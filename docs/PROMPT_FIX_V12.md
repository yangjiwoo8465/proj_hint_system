# V12 - 템플릿 기반 힌트 생성 (모델 포기)

## 최종 진단: 작은 모델의 근본적 한계

### V1-V11 모두 실패

**11번의 프롬프트 개선 시도:**

| 버전 | 전략 | 결과 |
|------|------|------|
| V1-V4 | 예시 제거 | 예시 복사 |
| V5 | 추상적 원칙 | 막연함 |
| V6 | 초간단 명령 | 영어 혼란 |
| V7 | 대조 학습 | 여전히 추상 |
| V8 | 개념 차단 | Logic Step 없음 |
| V9 | Logic Step 기반 | 코드 디버깅 |
| V10 | 코드 제거 | 함수명 언급 |
| V11 | Few-shot (13줄) | **막연한 질문** |

**V11 최종 실패:**
```
어떤 문제 해결 방안을 제안할까요?
```

→ Few-shot 예시도 따라하지 못함

---

## 근본 원인: 모델 크기 한계

### 1.5B-2B 모델의 현실

**능력:**
- 간단한 대화 가능
- 기본적인 질문 생성 가능

**한계:**
- **복잡한 지시 이해 어려움**
- **부정 명령 무시** ("~하지 마" 이해 못함)
- **패턴 학습 제한적** (Few-shot도 어려움)
- **일관성 없음** (같은 프롬프트, 다른 결과)

### 프롬프트 엔지니어링의 한계

**V1-V11이 증명한 것:**
- 프롬프트 길이 무관 (45줄 → 13줄, 모두 실패)
- 예시 개수 무관 (3개 → 6개, 효과 없음)
- 전략 무관 (규칙/예시/대조, 모두 실패)

**결론:**
> **1.5B-2B 모델로는 소크라테스식 질문 생성 불가능**

---

## V12 해결책: 모델 포기, 규칙 기반

### 새로운 접근

**이전 (V1-V11):**
```
프롬프트 → 모델 → 힌트
```

**V12:**
```
키워드 분석 → 템플릿 선택 → 힌트
```

→ **모델 완전 우회**

---

## 템플릿 기반 시스템

### 구조

```python
# next_step_goal에서 키워드 추출
goal_lower = next_step_goal.lower()

# 키워드별 템플릿 매칭
if "반복" in goal_lower:
    hints = [
        "같은 작업 10번 해야 하는데 매번 손으로 쓸 건가?",
        "비슷한 계산 100번 필요하면 어떻게 할 건데?",
        "입력이 2개가 아니라 1000개면 어떻게 처리?"
    ]
elif "함수" in goal_lower:
    hints = [
        "같은 계산을 10군데에서 해야 하는데 코드 10번 복사?",
        "나중에 계산 방법 바꾸면 10군데 다 찾아서 수정?",
        "이 작업을 다른 문제에서도 쓰려면 매번 복붙?"
    ]
# ...

# 랜덤 선택
import random
hint = random.choice(hints)
```

---

### 템플릿 카테고리

**1. 반복 (loop, 여러 번)**
```python
"같은 작업 10번 해야 하는데 매번 손으로 쓸 건가?"
"비슷한 계산 100번 필요하면 어떻게 할 건데?"
"입력이 2개가 아니라 1000개면 어떻게 처리?"
```

**2. 함수 (재사용, def)**
```python
"같은 계산을 10군데에서 해야 하는데 코드 10번 복사?"
"나중에 계산 방법 바꾸면 10군데 다 찾아서 수정?"
"이 작업을 다른 문제에서도 쓰려면 매번 복붙?"
```

**3. 조건 (if, 검사)**
```python
"다른 경우는 어떻게 처리할 건데?"
"예외 상황 10가지 나오면 다 손으로 확인?"
"입력이 이상하면 그냥 넘어갈 건가?"
```

**4. 입력 (받기, input)**
```python
"입력 형식이 바뀌면 어떻게 대응?"
"숫자가 아니라 문자 들어오면?"
"입력 10개를 한 번에 받으려면?"
```

**5. 출력 (print)**
```python
"결과를 보기 좋게 보여주려면?"
"출력 형식 바꾸라고 하면 어디를 고쳐?"
"여러 결과를 한 번에 출력하려면?"
```

**6. 기본 (매칭 실패 시)**
```python
f"{next_step_goal} 안 하면 어떤 문제 생기는데?"
f"{next_step_goal} 필요한 상황이 10번 나오면 어떻게 할 건데?"
f"지금 코드로는 {next_step_goal} 못하는데 괜찮아?"
```

---

## 장점

### 1. 100% 일관성

**모델 (V1-V11):**
- 같은 입력, 다른 출력
- 예측 불가능
- 품질 보장 없음

**템플릿 (V12):**
- 같은 키워드, 같은 템플릿 그룹
- 예측 가능
- 품질 보장

---

### 2. 즉시 반응

**모델:**
- 추론 시간: 1-5초
- GPU/메모리 필요

**템플릿:**
- 실행 시간: ~0.001초
- CPU만으로 충분

---

### 3. 소크라테스 학습법 보장

**모델:**
- 프롬프트 무시
- 개념 질문 생성
- 함수명 언급

**템플릿:**
- 모든 질문이 소크라테스식
- 구체적 숫자 포함 ("10개", "100번")
- 상황 기반 ("~하는데", "~할 건데?")

---

### 4. 확장 용이

**새 카테고리 추가:**
```python
elif "정렬" in goal_lower or "sort" in goal_lower:
    hints = [
        "순서가 뒤죽박죽이면 어떻게 찾을 건데?",
        "큰 거부터 보려면 매번 눈으로 확인?",
        "1000개를 손으로 정렬할 건가?"
    ]
```

**새 질문 추가:**
```python
"같은 작업 10번..." 에 추가
"비슷한 계산 100번..."
"이거 1000번 반복할 건가?"  # 신규
```

---

## 단점

### 1. 다양성 제한

**모델:**
- 무한한 변형 가능
- 창의적 질문 생성

**템플릿:**
- 사전 정의된 질문만
- 카테고리별 3-5개

**해결:**
- 각 카테고리마다 충분한 변형 제공
- random.choice()로 다양성 확보
- 지속적인 템플릿 추가

---

### 2. 키워드 의존

**문제:**
- next_step_goal이 애매하면?
- 예: "코드 개선" → 어떤 템플릿?

**해결:**
- 기본 템플릿 제공
- next_step_goal을 직접 포함

```python
else:
    hints = [
        f"{next_step_goal} 안 하면 어떤 문제 생기는데?",
        f"{next_step_goal} 필요한 상황이 10번 나오면?"
    ]
```

---

### 3. 컨텍스트 부족

**모델 (이론상):**
- user_code 분석 가능
- 상황에 맞춘 질문

**템플릿:**
- user_code 무시
- next_step_goal만 사용

**현실:**
- V9에서 user_code 제공해도 모델이 코드 디버깅만 함
- V10에서 user_code 제거해도 실패
- → **템플릿이 오히려 나음**

---

## V12 vs V11 비교

### 코드 길이

**V11 (Few-shot):**
```python
prompt = f"""질문 1개만 만들어.

학생이 "{next_step_goal}"를 못했음.

예시 1 - 반복:
질문: 같은 계산 10번 해야 하는데 매번 손으로?

예시 2 - 재사용:
질문: 나중에 숫자 바꾸면 10군데 다 고칠 건데?

예시 3 - 확장:
질문: 입력 100개면 어떻게 처리?

위처럼 "{next_step_goal}"에 대해 질문 1개. 물음표 필수.

질문:"""
```
→ 13줄, 모델에 전달, **실패**

**V12 (템플릿):**
```python
if "반복" in goal_lower:
    hints = ["...", "...", "..."]
elif "함수" in goal_lower:
    hints = ["...", "...", "..."]
# ...

hint = random.choice(hints)
```
→ ~50줄, 직접 반환, **성공 보장**

---

### 실행 흐름

**V11:**
```
user_code → prompt 생성 → 모델 추론 → 필터링 → (실패)
```

**V12:**
```
user_code → 키워드 추출 → 템플릿 선택 → 힌트 반환
```

---

### 품질

**V11 출력:**
```
"어떤 문제 해결 방안을 제안할까요?"
```
→ 막연함, 소크라테스식 아님

**V12 출력:**
```
"같은 작업 10번 해야 하는데 매번 손으로 쓸 건가?"
```
→ 구체적, 소크라테스식 완벽

---

## 시스템 변경사항

### 함수 역할 변경

**Before (V1-V11):**
```python
def _create_analysis_prompt(self, user_code: str) -> str:
    """프롬프트 생성"""
    prompt = f"""..."""
    return prompt  # 모델에 전달될 프롬프트
```

**After (V12):**
```python
def _create_analysis_prompt(self, user_code: str) -> str:
    """템플릿 기반 힌트 직접 생성"""
    # 키워드 추출
    goal_lower = next_step_goal.lower()

    # 템플릿 선택
    if "반복" in goal_lower:
        hints = [...]

    # 힌트 반환 (모델 우회)
    return random.choice(hints)
```

---

### 모델 우회

**Before:**
```python
prompt = self._create_analysis_prompt(user_code)
results = self.model_manager.generate_hints_from_selected(
    prompt, selected, temperature=temperature
)
```

**After:**
```python
hint = self._create_analysis_prompt(user_code)

# 모델 우회 - 모든 선택된 모델에 같은 템플릿 힌트 반환
results = {}
for model_name in selected:
    results[model_name] = {
        'hint': hint,
        'error': None
    }
```

---

## 사용자 경험 변화

### Before (V1-V11)

```
1. 모델 선택 (Qwen, Phi, etc.)
2. 코드 입력
3. 모델 로딩 (1-3초)
4. 추론 (1-5초)
5. 필터링
6. 결과: (막연한 질문 or 코드 or 에러)
```

**총 시간:** 2-8초
**품질:** ❌ 불안정

---

### After (V12)

```
1. 모델 선택 (의미 없음, UI 호환성만)
2. 코드 입력
3. 키워드 분석 (0.001초)
4. 템플릿 선택 (0.001초)
5. 결과: 소크라테스식 질문 보장
```

**총 시간:** ~0.002초
**품질:** ✅ 안정적

---

## V1 → V12 전체 여정

### 시도의 역사

| 버전 | 핵심 아이디어 | 희망 | 현실 |
|------|---------------|------|------|
| V1 | solution_code 제공 | 모델이 이해 | 함수명 복사 |
| V2-V4 | 예시 조정 | 모델이 학습 | 예시 복사 |
| V5 | 예시 제거 | 원칙 이해 | 막연함 |
| V6 | 초간단 | 단순 = 명확 | 영어 혼란 |
| V7 | 대조 학습 | 나쁜 거 회피 | 여전히 추상 |
| V8 | 개념 차단 | 금지 이해 | Logic 없음 |
| V9 | Logic Step | 컨텍스트 이해 | 코드 디버깅 |
| V10 | 코드 제거 | Coder 회피 | 함수명 언급 |
| V11 | Few-shot | 패턴 학습 | 막연한 질문 |
| **V12** | **모델 포기** | **포기 = 성공** | **✅ 해결** |

### 교훈

**"프롬프트가 아니라 모델이 문제였다"**

- 1.5B-2B 모델 < 복잡한 지시
- 프롬프트 개선 < 모델 크기
- 규칙 기반 > 작은 모델

---

## 향후 방향

### 1. 템플릿 확장

현재 6개 카테고리 → 20+ 카테고리:
- 리스트, 딕셔너리
- 예외 처리
- 파일 입출력
- 재귀
- 정렬, 탐색
- 등등

---

### 2. 동적 템플릿

현재: 고정 문자열
개선: 컨텍스트 기반 변수

```python
# next_step_goal = "반복문 사용"
# user_code에서 반복 횟수 추출
repeat_count = extract_repeat_count(user_code)

hint = f"같은 작업 {repeat_count}번 해야 하는데 매번 손으로?"
```

---

### 3. 큰 모델 실험 (선택적)

V12를 기본으로 유지하되:
- 7B+ 모델로 실험
- API 모델 (GPT-4, Claude) 옵션
- 비교 모드 제공

---

## 변경 위치

**파일:** [hint-system/app.py](../hint-system/app.py#L251-L264)
**함수:**
- `generate_hint()` (lines 251-264) - 모델 우회 로직
- `_create_analysis_prompt()` (lines 347-396) - 템플릿 기반 생성

---

## 사용 방법

### 실행

```bash
python app.py
```

### UI

- 모델 선택 (의미 없지만 UI 호환성)
- 코드 입력
- 힌트 생성 버튼 클릭
- **즉시 소크라테스식 질문 표시**

### 예시

**입력:**
- next_step_goal: "함수 정의"

**출력 (랜덤):**
```
"같은 계산을 10군데에서 해야 하는데 코드 10번 복사?"
```
또는
```
"나중에 계산 방법 바꾸면 10군데 다 찾아서 수정?"
```

---

## 결론

### V1-V11의 실패가 증명한 것

**작은 모델 (1.5B-2B):**
- ❌ 복잡한 지시 이해 못함
- ❌ Few-shot도 따라하기 어려움
- ❌ 일관성 없음

### V12가 보여주는 것

**규칙 기반 템플릿:**
- ✅ 100% 일관성
- ✅ 즉시 반응
- ✅ 소크라테스 학습법 보장
- ✅ 확장 용이

### 핵심 교훈

> **"좋은 프롬프트 < 적절한 도구 선택"**

- 프롬프트로 해결 안 되면 → 다른 방법
- 모델이 작으면 → 규칙 사용
- 일관성 필요하면 → 템플릿 사용

---

**작성일:** 2025-01-30
**버전:** V12 (최종)
**이전 버전:** [PROMPT_FIX_V11.md](PROMPT_FIX_V11.md)
**핵심:** 프롬프트 포기, 템플릿 기반 직접 생성
**철학:** "프롬프트가 아니라 모델이 문제였다"
