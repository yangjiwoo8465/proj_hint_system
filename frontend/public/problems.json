[
  {
    "problem_id": "1000",
    "step_title": "입출력과 사칙연산",
    "title": "A+B",
    "level": 1,
    "tags": [
      "구현",
      "사칙연산",
      "수학"
    ],
    "description": "두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 A와 B가 주어진다. (0 < A, B < 10)",
    "output_description": "첫째 줄에 A+B를 출력한다.",
    "examples": [
      {
        "input": "1 2",
        "output": "3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1000",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1: 각각 입력",
        "solution_code": "A = int(input())\nB = int(input())\nprint(A + B)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "첫 번째 정수 A 입력받기",
            "description": "input()으로 입력을 받고, int()로 정수로 변환하여 A 변수에 저장합니다.",
            "code_pattern": "A = int(input())",
            "socratic_hint": "첫 번째 숫자를 정수로 입력받아 변수에 저장하려면?",
            "hint": "A = int(input())을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "두 번째 정수 B 입력받기",
            "description": "같은 방법으로 두 번째 정수를 B 변수에 저장합니다.",
            "code_pattern": "B = int(input())",
            "socratic_hint": "두 번째 숫자도 같은 방법으로 입력받으면 되나요?",
            "hint": "B = int(input())을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "A + B 계산하여 출력",
            "description": "A와 B를 더한 결과를 print()로 출력합니다.",
            "code_pattern": "print(A + B)",
            "socratic_hint": "두 수를 더한 결과를 화면에 보여주려면?",
            "hint": "print(A + B)를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: split 활용",
        "solution_code": "A, B = map(int, input().split())\nprint(A + B)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "한 줄에서 두 정수 입력받기",
            "description": "input().split()으로 공백 기준 분리 후, map(int, ...)로 정수 변환하여 A, B에 언패킹합니다.",
            "code_pattern": "A, B = map(int, input().split())",
            "socratic_hint": "공백으로 구분된 두 정수를 한 번에 입력받으려면?",
            "hint": "input().split()과 map(int, ...)를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "A + B 출력",
            "description": "두 수의 합을 출력합니다.",
            "code_pattern": "print(A + B)",
            "socratic_hint": "합을 출력하려면?",
            "hint": "print(A + B)를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3: eval 활용 (간단)",
        "solution_code": "print(eval(input().replace(\" \", \"+\")))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력을 수식으로 변환하여 계산",
            "description": "공백을 +로 바꾸고 eval()로 계산합니다.",
            "code_pattern": "print(eval(input().replace(\" \", \"+\")))",
            "socratic_hint": "입력 문자열을 직접 계산식으로 변환할 수 있나요?",
            "hint": "eval()과 replace()를 조합합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4: 리스트 언패킹",
        "solution_code": "a, b = [int(x) for x in input().split()]\nprint(a + b)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "리스트 컴프리헨션으로 변환 후 언패킹",
            "description": "입력을 리스트로 만들고 언패킹하여 변수에 할당합니다.",
            "code_pattern": "a, b = [int(x) for x in input().split()]",
            "socratic_hint": "리스트를 만들고 동시에 변수에 할당할 수 있나요?",
            "hint": "리스트 컴프리헨션과 언패킹을 함께 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "두 수의 합을 출력합니다.",
            "code_pattern": "print(a + b)",
            "socratic_hint": "계산 결과를 출력하려면?",
            "hint": "print()를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 5,
        "solution_name": "풀이 5: sys.stdin 활용",
        "solution_code": "import sys\nA, B = map(int, sys.stdin.readline().split())\nprint(A + B)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "sys.stdin으로 입력",
            "description": "sys.stdin.readline()을 사용하여 빠르게 입력받습니다.",
            "code_pattern": "import sys\nA, B = map(int, sys.stdin.readline().split())",
            "socratic_hint": "더 빠른 입력 방법은?",
            "hint": "sys.stdin.readline()을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "두 수의 합을 출력합니다.",
            "code_pattern": "print(A + B)",
            "socratic_hint": "결과를 출력하려면?",
            "hint": "print()를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 6,
        "solution_name": "풀이 6: lambda 활용",
        "solution_code": "print(sum(map(int, input().split())))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "sum과 map 조합",
            "description": "입력을 바로 정수로 변환하고 합계를 구합니다.",
            "code_pattern": "print(sum(map(int, input().split())))",
            "socratic_hint": "한 줄로 입력과 합계를 동시에 처리하려면?",
            "hint": "sum(map(...))을 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1001",
    "step_title": "입출력과 사칙연산",
    "title": "A-B",
    "level": 1,
    "tags": [
      "구현",
      "사칙연산",
      "수학"
    ],
    "description": "두 정수 A와 B를 입력받은 다음, A-B를 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 A와 B가 주어진다. (0 < A, B < 10)",
    "output_description": "첫째 줄에 A-B를 출력한다.",
    "examples": [
      {
        "input": "3 2",
        "output": "1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1001",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1: 각각 입력",
        "solution_code": "A = int(input())\nB = int(input())\nprint(A - B)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "첫 번째 정수 A 입력",
            "description": "int(input())으로 첫 번째 정수를 A에 저장합니다.",
            "code_pattern": "A = int(input())",
            "socratic_hint": "첫 번째 정수를 입력받으려면?",
            "hint": "A = int(input())을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "두 번째 정수 B 입력",
            "description": "두 번째 정수를 B에 저장합니다.",
            "code_pattern": "B = int(input())",
            "socratic_hint": "두 번째 정수를 입력받으려면?",
            "hint": "B = int(input())을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "A - B 계산하여 출력",
            "description": "A에서 B를 뺀 결과를 출력합니다.",
            "code_pattern": "print(A - B)",
            "socratic_hint": "뺄셈 결과를 출력하려면?",
            "hint": "print(A - B)를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: split 활용",
        "solution_code": "A, B = map(int, input().split())\nprint(A - B)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "한 줄에서 두 정수 입력받기",
            "description": "input().split()으로 공백 기준 분리 후, map(int, ...)로 정수 변환합니다.",
            "code_pattern": "A, B = map(int, input().split())",
            "socratic_hint": "공백으로 구분된 두 정수를 한 번에 입력받으려면?",
            "hint": "A, B = map(int, input().split())을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "A - B 출력",
            "description": "A에서 B를 뺀 결과를 출력합니다.",
            "code_pattern": "print(A - B)",
            "socratic_hint": "뺄셈 결과를 출력하려면?",
            "hint": "print(A - B)를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3: 언패킹과 연산자",
        "solution_code": "print(*[a - b for a, b in [map(int, input().split())]])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "리스트 컴프리헨션 활용",
            "description": "입력과 계산을 한 줄로 처리합니다.",
            "code_pattern": "print(*[a - b for a, b in [map(int, input().split())]])",
            "socratic_hint": "한 줄로 모든 것을 처리하려면?",
            "hint": "리스트 컴프리헨션을 활용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4: operator 모듈",
        "solution_code": "import operator\nA, B = map(int, input().split())\nprint(operator.sub(A, B))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "operator 모듈 사용",
            "description": "operator.sub()를 사용하여 뺄셈을 수행합니다.",
            "code_pattern": "import operator\nprint(operator.sub(A, B))",
            "socratic_hint": "함수로 연산을 수행하려면?",
            "hint": "operator 모듈을 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1008",
    "step_title": "입출력과 사칙연산",
    "title": "A/B",
    "level": 1,
    "tags": [
      "구현",
      "사칙연산",
      "수학"
    ],
    "description": "두 정수 A와 B를 입력받은 다음, A/B를 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 A와 B가 주어진다. (0 < A, B < 10)",
    "output_description": "첫째 줄에 A/B를 출력한다. 실제 정답과 출력값의 절대오차 또는 상대오차가 10-9이하이면 정답이다.",
    "examples": [
      {
        "input": "1 3",
        "output": "0.33333333333333333333333333333333"
      },
      {
        "input": "4 5",
        "output": "0.8"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1008",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1: 각각 입력",
        "solution_code": "A = int(input())\nB = int(input())\nprint(A / B)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "A 입력",
            "description": "나누어질 수 A를 입력받습니다.",
            "code_pattern": "A = int(input())",
            "socratic_hint": "나누어질 수를 입력받으려면?",
            "hint": "A = int(input())"
          },
          {
            "step_id": 2,
            "goal": "B 입력",
            "description": "나눌 수 B를 입력받습니다.",
            "code_pattern": "B = int(input())",
            "socratic_hint": "나눌 수를 입력받으려면?",
            "hint": "B = int(input())"
          },
          {
            "step_id": 3,
            "goal": "A ÷ B 출력",
            "description": "A를 B로 나눈 결과를 출력합니다. /는 실수 나눗셈입니다.",
            "code_pattern": "print(A / B)",
            "socratic_hint": "나눗셈 결과를 출력하려면?",
            "hint": "print(A / B)를 사용합니다. /는 실수 나눗셈입니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: split 활용",
        "solution_code": "A, B = map(int, input().split())\nprint(A / B)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "한 줄에서 두 정수 입력받기",
            "description": "공백으로 구분된 두 정수를 한 번에 입력받습니다.",
            "code_pattern": "A, B = map(int, input().split())",
            "socratic_hint": "공백으로 구분된 두 정수를 한 번에 입력받으려면?",
            "hint": "A, B = map(int, input().split())을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "A ÷ B 출력",
            "description": "A를 B로 나눈 결과를 출력합니다. /는 실수 나눗셈입니다.",
            "code_pattern": "print(A / B)",
            "socratic_hint": "실수 나눗셈 결과를 출력하려면?",
            "hint": "print(A / B)를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3: 포맷 지정 (15자리)",
        "solution_code": "A, B = map(int, input().split())\nprint(f'{A/B:.15f}')",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "나눗셈과 포맷",
            "description": "나눗셈 결과를 소수점 15자리까지 출력합니다.",
            "code_pattern": "print(f'{A/B:.15f}')",
            "socratic_hint": "소수점 자리수를 지정하려면?",
            "hint": "f-string의 :.15f를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4: __truediv__ 활용",
        "solution_code": "A, B = map(int, input().split())\nprint(A.__truediv__(B))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "메서드 직접 호출",
            "description": "__truediv__ 메서드를 직접 호출합니다.",
            "code_pattern": "A.__truediv__(B)",
            "socratic_hint": "나눗셈 연산자의 내부 메서드는?",
            "hint": "__truediv__입니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1010",
    "step_title": "조합론",
    "title": "다리 놓기",
    "level": 6,
    "tags": [
      "수학",
      "다이나믹 프로그래밍",
      "조합론"
    ],
    "description": "재원이는 한 도시의 시장이 되었다. 이 도시에는 도시를 동쪽과 서쪽으로 나누는 큰 일직선 모양의 강이 흐르고 있다. 하지만 재원이는 다리가 없어서 시민들이 강을 건너는데 큰 불편을 겪고 있음을 알고 다리를 짓기로 결심하였다. 강 주변에서 다리를 짓기에 적합한 곳을 사이트라고 한다. 재원이는 강 주변을 면밀히 조사해 본 결과 강의 서쪽에는 N개의 사이트가 있고 동쪽에는 M개의 사이트가 있다는 것을 알았다. (N ≤ M)재원이는 서쪽의 사이트와 동쪽의 사이트를 다리로 연결하려고 한다. (이때 한 사이트에는 최대 한 개의 다리만 연결될 수 있다.) 재원이는 다리를 최대한 많이 지으려고 하기 때문에 서쪽의 사이트 개수만큼 (N개) 다리를 지으려고 한다. 다리끼리는 서로 겹쳐질 수 없다고 할 때 다리를 지을 수 있는 경우의 수를 구하는 프로그램을 작성하라.",
    "input_description": "입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트케이스에 대해 강의 서쪽과 동쪽에 있는 사이트의 개수 정수 N, M (0 < N ≤ M < 30)이 주어진다.",
    "output_description": "각 테스트 케이스에 대해 주어진 조건하에 다리를 지을 수 있는 경우의 수를 출력한다.",
    "examples": [
      {
        "input": "3\n2 2\n1 5\n13 29",
        "output": "1\n5\n67863915"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1010",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from math import comb\n\nT = int(input())\nfor _ in range(T):\n    N, M = map(int, input().split())\n    print(comb(M, N))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1012",
    "step_title": "그래프와 순회",
    "title": "유기농 배추",
    "level": 9,
    "tags": [
      "그래프 이론",
      "그래프 탐색",
      "너비 우선 탐색",
      "깊이 우선 탐색",
      "격자 그래프",
      "플러드 필"
    ],
    "description": "차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다. 한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있는 것이다.한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어 놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다. 예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다. 0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.110000000001000000000000100000000010000000110001110000100111",
    "input_description": "입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 첫째 줄에는 배추를 심은 배추밭의 가로길이 M(1 ≤ M ≤ 50)과 세로길이 N(1 ≤ N ≤ 50), 그리고 배추가 심어져 있는 위치의 개수 K(1 ≤ K ≤ 2500)이 주어진다. 그 다음 K줄에는 배추의 위치 X(0 ≤ X ≤ M-1), Y(0 ≤ Y ≤ N-1)가 주어진다. 두 배추의 위치가 같은 경우는 없다.",
    "output_description": "각 테스트 케이스에 대해 필요한 최소의 배추흰지렁이 마리 수를 출력한다.",
    "examples": [
      {
        "input": "2\n10 8 17\n0 0\n1 0\n1 1\n4 2\n4 3\n4 5\n2 4\n3 4\n7 4\n8 4\n9 4\n7 5\n8 5\n9 5\n7 6\n8 6\n9 6\n10 10 1\n5 5",
        "output": "5\n1"
      },
      {
        "input": "1\n5 3 6\n0 2\n1 2\n2 2\n3 2\n4 2\n4 0",
        "output": "2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1012",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def dfs(x, y):\n    if x < 0 or x >= M or y < 0 or y >= N:\n        return\n    if field[x][y] == 1:\n        field[x][y] = 0\n        dfs(x-1, y)\n        dfs(x+1, y)\n        dfs(x, y-1)\n        dfs(x, y+1)\n\nT = int(input())\nfor _ in range(T):\n    M, N, K = map(int, input().split())\n    field = [[0] * N for _ in range(M)]\n    \n    for _ in range(K):\n        x, y = map(int, input().split())\n        field[x][y] = 1\n    \n    count = 0\n    for i in range(M):\n        for j in range(N):\n            if field[i][j] == 1:\n                dfs(i, j)\n                count += 1\n    \n    print(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1017",
    "step_title": "이분 매칭",
    "title": "소수 쌍",
    "level": 18,
    "tags": [
      "수학",
      "정수론",
      "소수 판정",
      "에라토스테네스의 체",
      "이분 매칭"
    ],
    "description": "지민이는 수의 리스트가 있을 때, 이를 짝지어 각 쌍의 합이 소수가 되게 하려고 한다. 예를 들어, {1, 4, 7, 10, 11, 12}가 있다고 하자. 지민이는 다음과 같이 짝지을 수 있다.1 + 4 = 5, 7 + 10 = 17, 11 + 12 = 23또는1 + 10 = 11, 4 + 7 = 11, 11 + 12 = 23수의 리스트가 주어졌을 때, 지민이가 모든 수를 다 짝지었을 때, 첫 번째 수와 어떤 수를 짝지었는지 오름차순으로 출력하는 프로그램을 작성하시오. 위의 예제에서 1 + 12 = 13으로 소수이다. 그러나, 남은 4개의 수를 합이 소수가 되게 짝지을 수 있는 방법이 없다. 따라서 위의 경우 정답은 4, 10이다.",
    "input_description": "첫째 줄에 리스트의 크기 N이 주어진다. N은 50보다 작거나 같은 자연수이며, 짝수이다. 둘째 줄에 리스트에 들어있는 수가 주어진다. 리스트에 들어있는 수는 1,000보다 작거나 같은 자연수이며, 중복되지 않는다.",
    "output_description": "첫째 줄에 정답을 출력한다. 없으면 -1을 출력한다.",
    "examples": [
      {
        "input": "6\n1 4 7 10 11 12",
        "output": "4 10"
      },
      {
        "input": "6\n11 1 4 7 10 12",
        "output": "12"
      },
      {
        "input": "4\n8 9 1 14",
        "output": "-1"
      },
      {
        "input": "8\n34 39 32 4 9 35 14 17",
        "output": "9 39"
      },
      {
        "input": "20\n941 902 873 841 948 851 945 854 815 898 806 826 976 878 861 919 926 901 875 864",
        "output": "806 926"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1017",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 수학 문제 기본 구조\ndef solve():\n    # 입력 처리\n    N = int(input())\n    \n    # 계산\n    result = N\n    \n    return result\n\nprint(solve())",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1018",
    "step_title": "브루트 포스",
    "title": "체스판 다시 칠하기",
    "level": 8,
    "tags": [
      "구현",
      "브루트포스 알고리즘"
    ],
    "description": "지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M×N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 8×8 크기의 체스판으로 만들려고 한다.체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다.보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 8×8 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다. 당연히 8*8 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N과 M이 주어진다. N과 M은 8보다 크거나 같고, 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 보드의 각 행의 상태가 주어진다. B는 검은색이며, W는 흰색이다.",
    "output_description": "첫째 줄에 지민이가 다시 칠해야 하는 정사각형 개수의 최솟값을 출력한다.",
    "examples": [
      {
        "input": "8 8\nWBWBWBWB\nBWBWBWBW\nWBWBWBWB\nBWBBBWBW\nWBWBWBWB\nBWBWBWBW\nWBWBWBWB\nBWBWBWBW",
        "output": "1"
      },
      {
        "input": "10 13\nBBBBBBBBWBWBW\nBBBBBBBBBWBWB\nBBBBBBBBWBWBW\nBBBBBBBBBWBWB\nBBBBBBBBWBWBW\nBBBBBBBBBWBWB\nBBBBBBBBWBWBW\nBBBBBBBBBWBWB\nWWWWWWWWWWBWB\nWWWWWWWWWWBWB",
        "output": "12"
      },
      {
        "input": "8 8\nBWBWBWBW\nWBWBWBWB\nBWBWBWBW\nWBWBWBWB\nBWBWBWBW\nWBWBWBWB\nBWBWBWBW\nWBWBWBWB",
        "output": "0"
      },
      {
        "input": "9 23\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBW",
        "output": "31"
      },
      {
        "input": "10 10\nBBBBBBBBBB\nBBWBWBWBWB\nBWBWBWBWBB\nBBWBWBWBWB\nBWBWBWBWBB\nBBWBWBWBWB\nBWBWBWBWBB\nBBWBWBWBWB\nBWBWBWBWBB\nBBBBBBBBBB",
        "output": "0"
      },
      {
        "input": "8 8\nWBWBWBWB\nBWBWBWBW\nWBWBWBWB\nBWBBBWBW\nWBWBWBWB\nBWBWBWBW\nWBWBWWWB\nBWBWBWBW",
        "output": "2"
      },
      {
        "input": "11 12\nBWWBWWBWWBWW\nBWWBWBBWWBWW\nWBWWBWBBWWBW\nBWWBWBBWWBWW\nWBWWBWBBWWBW\nBWWBWBBWWBWW\nWBWWBWBBWWBW\nBWWBWBWWWBWW\nWBWWBWBBWWBW\nBWWBWBBWWBWW\nWBWWBWBBWWBW",
        "output": "15"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1018",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N, M = map(int, input().split())\nboard = []\nfor _ in range(N):\n    board.append(input())\n\ndef count_repaint(x, y, first):\n    count = 0\n    for i in range(8):\n        for j in range(8):\n            if (i + j) % 2 == 0:\n                if board[x+i][y+j] != first:\n                    count += 1\n            else:\n                if board[x+i][y+j] == first:\n                    count += 1\n    return count\n\nmin_count = 64\nfor i in range(N - 7):\n    for j in range(M - 7):\n        count_W = count_repaint(i, j, 'W')\n        count_B = count_repaint(i, j, 'B')\n        min_count = min(min_count, count_W, count_B)\n\nprint(min_count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1037",
    "step_title": "심화 2",
    "title": "약수",
    "level": 5,
    "tags": [
      "수학",
      "정수론"
    ],
    "description": "양수 A가 N의 진짜 약수가 되려면, N이 A의 배수이고, A가 1과 N이 아니어야 한다. 어떤 수 N의 진짜 약수가 모두 주어질 때, N을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N의 진짜 약수의 개수가 주어진다. 이 개수는 50보다 작거나 같은 자연수이다. 둘째 줄에는 N의 진짜 약수가 주어진다. 1,000,000보다 작거나 같고, 2보다 크거나 같은 자연수이고, 중복되지 않는다.",
    "output_description": "첫째 줄에 N을 출력한다. N은 항상 32비트 부호있는 정수로 표현할 수 있다.",
    "examples": [
      {
        "input": "2\n4 2",
        "output": "8"
      },
      {
        "input": "1\n2",
        "output": "4"
      },
      {
        "input": "6\n3 4 2 12 6 8",
        "output": "24"
      },
      {
        "input": "14\n14 26456 2 28 13228 3307 7 23149 8 6614 46298 56 4 92596",
        "output": "185192"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1037",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\ndivisors = list(map(int, input().split()))\nprint(min(divisors) * max(divisors))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1040",
    "step_title": "동적 계획법 4",
    "title": "정수",
    "level": 19,
    "tags": [
      "다이나믹 프로그래밍",
      "그리디 알고리즘",
      "비트마스킹",
      "자릿수를 이용한 다이나믹 프로그래밍"
    ],
    "description": "정수 N이 주어진다. N보다 크거나 같은 수 중에, K개의 서로 다른 숫자로 이루어진 수 중 가장 작은 수를 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N과 K가 주어진다. N은 1018보다 작거나 같은 자연수이다. K는 10보다 작거나 같은 자연수이다.",
    "output_description": "첫째 줄에 문제의 정답을 출력한다.",
    "examples": [
      {
        "input": "47 1",
        "output": "55"
      },
      {
        "input": "12364 3",
        "output": "12411"
      },
      {
        "input": "7 3",
        "output": "102"
      },
      {
        "input": "69 2",
        "output": "69"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1040",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1067",
    "step_title": "고속 푸리에 변환",
    "title": "이동",
    "level": 20,
    "tags": [
      "수학",
      "고속 푸리에 변환"
    ],
    "description": "N개의 수가 있는 X와 Y가 있다. 이때 X나 Y를 순환 이동시킬 수 있다. 순환 이동이란 마지막 원소를 제거하고 그 수를 맨 앞으로 다시 삽입하는 것을 말한다. 예를 들어, {1, 2, 3}을 순환 이동시키면 {3, 1, 2}가 될 것이고, {3, 1, 2}는 {2, 3, 1}이 된다. 순환 이동은 0번 또는 그 이상 할 수 있다. 이 모든 순환 이동을 한 후에 점수를 구하면 된다. 점수 S는 다음과 같이 구한다.S = X[0]×Y[0] + X[1]×Y[1] + ... + X[N-1]×Y[N-1]이때 S를 최대로 하면 된다.",
    "input_description": "첫째 줄에 N이 주어진다. 둘째 줄에는 X에 들어있는 N개의 수가 주어진다. 셋째 줄에는 Y에 있는 수가 모두 주어진다. N은 60,000보다 작거나 같은 자연수이고, X와 Y에 들어있는 모든 수는 100보다 작은 자연수 또는 0이다.",
    "output_description": "첫째 줄에 S의 최댓값을 출력한다.",
    "examples": [
      {
        "input": "4\n1 2 3 4\n6 7 8 5",
        "output": "70"
      },
      {
        "input": "5\n1 1 1 1 1\n1 1 1 1 1",
        "output": "5"
      },
      {
        "input": "10\n23 4 95 20 17 94 63 44 13 96\n87 54 13 18 61 24 17 94 53 2",
        "output": "28886"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1067",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 수학 문제 기본 구조\ndef solve():\n    # 입력 처리\n    N = int(input())\n    \n    # 계산\n    result = N\n    \n    return result\n\nprint(solve())",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1069",
    "step_title": "기하 2",
    "title": "집으로",
    "level": 13,
    "tags": [
      "애드 혹",
      "기하학",
      "많은 조건 분기"
    ],
    "description": "은진이는 지금 (X, Y)에 있고, (0, 0)에 있는 집으로 가능한 빨리 가려고 한다. 이동할 수 있는 방법은 다음 두 가지이다.첫 번째 방법은 걷는것이다. 걸을 때는 1초에 1만큼 움직인다. 두 번째 방법은 점프하는 것이다. 점프를 하게 되면, T초에 D만큼 움직인다. 점프는 일직선으로만 할 수 있고, 정확하게 D칸만 움직일 수 있다.위의 두 가지 방법을 이용해서 집에 돌아오는데 걸리는 시간의 최솟값을 구하는 프로그램을 작성하시오. 꼭 한 가지 방법만 사용해야 되는것이 아니고, 두 가지 방법을 적절히 조합해서 가장 빠른 시간을 구하는 것이다.",
    "input_description": "첫째 줄에 네 정수 X, Y, D, T가 주어진다.",
    "output_description": "첫째 줄에 집에 돌아오는데 걸리는 시간의 최솟값을 출력한다. 절대/상대 오차는 10-9까지 허용한다.",
    "examples": [
      {
        "input": "6 8 5 3",
        "output": "6.0"
      },
      {
        "input": "3 4 6 3",
        "output": "4.0"
      },
      {
        "input": "318 445 1200 800",
        "output": "546.9451526432975"
      },
      {
        "input": "400 300 150 10",
        "output": "40.0"
      },
      {
        "input": "6 8 3 2",
        "output": "7.0"
      },
      {
        "input": "10 10 1000 5",
        "output": "10.0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1069",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1085",
    "step_title": "기하 1: 직사각형과 삼각형",
    "title": "직사각형에서 탈출",
    "level": 3,
    "tags": [
      "수학",
      "기하학"
    ],
    "description": "한수는 지금 (x, y)에 있다. 직사각형은 각 변이 좌표축에 평행하고, 왼쪽 아래 꼭짓점은 (0, 0), 오른쪽 위 꼭짓점은 (w, h)에 있다. 직사각형의 경계선까지 가는 거리의 최솟값을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 x, y, w, h가 주어진다.",
    "output_description": "첫째 줄에 문제의 정답을 출력한다.",
    "examples": [
      {
        "input": "6 2 10 3",
        "output": "1"
      },
      {
        "input": "1 1 5 5",
        "output": "1"
      },
      {
        "input": "653 375 1000 1000",
        "output": "347"
      },
      {
        "input": "161 181 762 375",
        "output": "161"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1085",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "x, y, w, h = map(int, input().split())\nprint(min(x, y, w - x, h - y))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "x, y, w, h = map(int, input().split())\nprint(min(x, y, w - x, h - y))",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1086",
    "step_title": "동적 계획법 3",
    "title": "박성원",
    "level": 16,
    "tags": [
      "비트마스킹",
      "다이나믹 프로그래밍",
      "비트필드를 이용한 다이나믹 프로그래밍"
    ],
    "description": "박성원은 이 문제를 풀지 못했다.서로 다른 정수로 이루어진 집합이 있다. 이 집합의 순열을 합치면 큰 정수 하나를 만들 수 있다. 예를 들어, {5221,40,1,58,9}로 5221401589를 만들 수 있다. 합친수가 정수 K로 나누어 떨어지는 순열을 구하는 프로그램을 작성하시오.하지만, 박성원은 이 문제를 풀지 못했다.따라서 박성원은 그냥 랜덤하게 순열 하나를 정답이라고 출력하려고 한다. 이 문제에는 정답이 여러 개 있을 수도 있고, 박성원이 우연히 문제의 정답을 맞출 수도 있다.박성원이 우연히 정답을 맞출 확률을 분수로 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 집합의 수의 개수 N이 주어진다. N은 15보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 집합에 포함된 수가 주어진다. 각 수의 길이는 길어야 50인 자연수이다. 마지막 줄에는 K가 주어진다. K는 100보다 작거나 같은 자연수이다.",
    "output_description": "첫째 줄에 정답을 기약분수 형태로 출력한다. p/q꼴로 출력하며, p는 분자, q는 분모이다. 정답이 0인 경우는 0/1로, 1인 경우는 1/1로 출력한다.",
    "examples": [
      {
        "input": "3\n3\n2\n1\n2",
        "output": "1/3"
      },
      {
        "input": "5\n10\n100\n1000\n10000\n100000\n10",
        "output": "1/1"
      },
      {
        "input": "5\n11\n101\n1001\n10001\n100001\n10",
        "output": "0/1"
      },
      {
        "input": "9\n13\n10129414190271203\n102\n102666818896\n1216\n1217\n1218\n101278001\n1000021412678412681\n21",
        "output": "5183/36288"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1086",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1144",
    "step_title": "동적 계획법 5",
    "title": "싼 비용",
    "level": 23,
    "tags": [
      "다이나믹 프로그래밍",
      "커넥션 프로파일을 이용한 다이나믹 프로그래밍"
    ],
    "description": "1*1크기의 정사각형으로 나누어진 N*M크기의 직사각형 종이가 있다. 각 칸에는 정수가 하나씩 쓰여져 있다. 이 숫자를 비용이라고 하자.이때, 가장 싼 연결된 칸의 집합을 찾는 프로그램을 작성하시오. 연결된 칸의 집합의 비용은 각 칸에 쓰여 있는 비용의 합이다.칸이 연결되어 있다는 말은 그 집합의 한 칸에서 다른 칸으로 집합에 포함된 인접한 칸을 통해서 모두 이동할 수 있다는 의미이고, 두 칸이 인접해 있다는 소리는, 같은 변을 공유할 때이다. 크기가 0인 집합도 올바른 집합이다.",
    "input_description": "첫째 줄에 N과 M이 주어진다. N과 M은 9보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 숫자가 M개씩 주어진다. 각 숫자는 절댓값이 1000보다 작거나 같은 정수이다.",
    "output_description": "첫째 줄에 가장 싼 연결된 칸의 집합의 비용을 출력한다.",
    "examples": [
      {
        "input": "2 2\n-10 1\n2 -10",
        "output": "-19"
      },
      {
        "input": "3 3\n1 2 3\n4 5 6\n7 8 9",
        "output": "0"
      },
      {
        "input": "2 3\n-5 100 -5\n-5 100 -5",
        "output": "-10"
      },
      {
        "input": "6 5\n-1 -1 1 -1 -1\n-1 -1 1 -1 -1\n-1 -1 1 -1 -1\n99 99 99 99 99\n-1 -1 -1 -1 -1\n-1 -1 -1 -1 -1",
        "output": "-11"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1144",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1149",
    "step_title": "동적 계획법 1",
    "title": "RGB거리",
    "level": 10,
    "tags": [
      "다이나믹 프로그래밍"
    ],
    "description": "RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.1번 집의 색은 2번 집의 색과 같지 않아야 한다.N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.",
    "input_description": "첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다. 집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.",
    "output_description": "첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.",
    "examples": [
      {
        "input": "3\n26 40 83\n49 60 57\n13 89 99",
        "output": "96"
      },
      {
        "input": "3\n1 100 100\n100 1 100\n100 100 1",
        "output": "3"
      },
      {
        "input": "3\n1 100 100\n100 100 100\n1 100 100",
        "output": "102"
      },
      {
        "input": "6\n30 19 5\n64 77 64\n15 19 97\n4 71 57\n90 86 84\n93 32 91",
        "output": "208"
      },
      {
        "input": "8\n71 39 44\n32 83 55\n51 37 63\n89 29 100\n83 58 11\n65 13 15\n47 25 29\n60 66 19",
        "output": "253"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1149",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\ncost = []\nfor _ in range(N):\n    cost.append(list(map(int, input().split())))\n\ndp = [[0] * 3 for _ in range(N)]\ndp[0] = cost[0]\n\nfor i in range(1, N):\n    dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + cost[i][0]\n    dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + cost[i][1]\n    dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + cost[i][2]\n\nprint(min(dp[N-1]))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1152",
    "step_title": "문자열",
    "title": "단어의 개수",
    "level": 4,
    "tags": [
      "구현",
      "문자열"
    ],
    "description": "영어 대소문자와 공백으로 이루어진 문자열이 주어진다. 이 문자열에는 몇 개의 단어가 있을까? 이를 구하는 프로그램을 작성하시오. 단, 한 단어가 여러 번 등장하면 등장한 횟수만큼 모두 세어야 한다.",
    "input_description": "첫 줄에 영어 대소문자와 공백으로 이루어진 문자열이 주어진다. 이 문자열의 길이는 1,000,000을 넘지 않는다. 단어는 공백 한 개로 구분되며, 공백이 연속해서 나오는 경우는 없다. 또한 문자열은 공백으로 시작하거나 끝날 수 있다.",
    "output_description": "첫째 줄에 단어의 개수를 출력한다.",
    "examples": [
      {
        "input": "The Curious Case of Benjamin Button",
        "output": "6"
      },
      {
        "input": "The first character is a blank",
        "output": "6"
      },
      {
        "input": "The last character is a blank",
        "output": "6"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1152",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "print(len(input().split()))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(len(input().split()))",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: count 활용",
        "solution_code": "s = input().strip()\nif not s:\n    print(0)\nelse:\n    print(s.count(' ') + 1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "공백 개수로 계산",
            "description": "공백 개수 + 1 = 단어 개수입니다.",
            "code_pattern": "s.count(' ') + 1",
            "socratic_hint": "공백 개수로 단어를 세려면?",
            "hint": "count(' ') + 1을 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1157",
    "step_title": "심화 1",
    "title": "단어 공부",
    "level": 5,
    "tags": [
      "구현",
      "문자열"
    ],
    "description": "알파벳 대소문자로 된 단어가 주어지면, 이 단어에서 가장 많이 사용된 알파벳이 무엇인지 알아내는 프로그램을 작성하시오. 단, 대문자와 소문자를 구분하지 않는다.",
    "input_description": "첫째 줄에 알파벳 대소문자로 이루어진 단어가 주어진다. 주어지는 단어의 길이는 1,000,000을 넘지 않는다.",
    "output_description": "첫째 줄에 이 단어에서 가장 많이 사용된 알파벳을 대문자로 출력한다. 단, 가장 많이 사용된 알파벳이 여러 개 존재하는 경우에는 ?를 출력한다.",
    "examples": [
      {
        "input": "Mississipi",
        "output": "?"
      },
      {
        "input": "zZa",
        "output": "Z"
      },
      {
        "input": "z",
        "output": "Z"
      },
      {
        "input": "baaa",
        "output": "A"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1157",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "word = input().upper()\nfrom collections import Counter\ncount = Counter(word)\nmax_count = max(count.values())\nmost_common = [char for char, cnt in count.items() if cnt == max_count]\nprint('?' if len(most_common) > 1 else most_common[0])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "word = input().upper()\nfrom collections import Counter\ncount = Counter(word)\nmax_count = max(count.v",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1167",
    "step_title": "트리",
    "title": "트리의 지름",
    "level": 14,
    "tags": [
      "그래프 이론",
      "그래프 탐색",
      "트리",
      "깊이 우선 탐색",
      "트리의 지름"
    ],
    "description": "트리의 지름이란, 트리에서 임의의 두 점 사이의 거리 중 가장 긴 것을 말한다. 트리의 지름을 구하는 프로그램을 작성하시오.",
    "input_description": "트리가 입력으로 주어진다. 먼저 첫 번째 줄에서는 트리의 정점의 개수 V가 주어지고 (2 ≤ V ≤ 100,000)둘째 줄부터 V개의 줄에 걸쳐 간선의 정보가 다음과 같이 주어진다. 정점 번호는 1부터 V까지 매겨져 있다.먼저 정점 번호가 주어지고, 이어서 연결된 간선의 정보를 의미하는 정수가 두 개씩 주어지는데, 하나는 정점번호, 다른 하나는 그 정점까지의 거리이다. 예를 들어 네 번째 줄의 경우 정점 3은 정점 1과 거리가 2인 간선으로 연결되어 있고, 정점 4와는 거리가 3인 간선으로 연결되어 있는 것을 보여준다. 각 줄의 마지막에는 -1이 입력으로 주어진다. 주어지는 거리는 모두 10,000 이하의 자연수이다.",
    "output_description": "첫째 줄에 트리의 지름을 출력한다.",
    "examples": [
      {
        "input": "5\n1 3 2 -1\n2 4 4 -1\n3 1 2 4 3 -1\n4 2 4 3 3 5 6 -1\n5 4 6 -1",
        "output": "11"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1167",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\n\ndef dfs(node, dist):\n    visited[node] = True\n    \n    for next_node, weight in tree[node]:\n        if not visited[next_node]:\n            distance[next_node] = dist + weight\n            dfs(next_node, dist + weight)\n\nV = int(input())\ntree = [[] for _ in range(V + 1)]\n\nfor _ in range(V):\n    data = list(map(int, input().split()))\n    node = data[0]\n    for i in range(1, len(data) - 1, 2):\n        next_node, weight = data[i], data[i+1]\n        tree[node].append((next_node, weight))\n\nvisited = [False] * (V + 1)\ndistance = [0] * (V + 1)\ndfs(1, 0)\n\nfarthest = distance.index(max(distance))\n\nvisited = [False] * (V + 1)\ndistance = [0] * (V + 1)\ndfs(farthest, 0)\n\nprint(max(distance))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1168",
    "step_title": "세그먼트 트리 1",
    "title": "요세푸스 문제 2",
    "level": 18,
    "tags": [
      "자료 구조",
      "세그먼트 트리"
    ],
    "description": "요세푸스 문제는 다음과 같다.1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 <3, 6, 2, 7, 5, 1, 4>이다.N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N과 K가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 100,000)",
    "output_description": "예제와 같이 요세푸스 순열을 출력한다.",
    "examples": [
      {
        "input": "7 3",
        "output": "<3, 6, 2, 7, 5, 1, 4>"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1168",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1181",
    "step_title": "정렬",
    "title": "단어 정렬",
    "level": 6,
    "tags": [
      "문자열",
      "정렬"
    ],
    "description": "알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.길이가 짧은 것부터길이가 같으면 사전 순으로단, 중복된 단어는 하나만 남기고 제거해야 한다.",
    "input_description": "첫째 줄에 단어의 개수 N이 주어진다. (1 ≤ N ≤ 20,000) 둘째 줄부터 N개의 줄에 걸쳐 알파벳 소문자로 이루어진 단어가 한 줄에 하나씩 주어진다. 주어지는 문자열의 길이는 50을 넘지 않는다.",
    "output_description": "조건에 따라 정렬하여 단어들을 출력한다.",
    "examples": [
      {
        "input": "13\nbut\ni\nwont\nhesitate\nno\nmore\nno\nmore\nit\ncannot\nwait\nim\nyours",
        "output": "i\nim\nit\nno\nbut\nmore\nwait\nwont\nyours\ncannot\nhesitate"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1181",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nwords = set()\nfor _ in range(N):\n    words.add(input())\n\nwords = sorted(words, key=lambda x: (len(x), x))\nfor word in words:\n    print(word)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = int(input())\nwords = set()\nfor _ in range(n):\n    words.add(input().strip())\n\nwords = sorted(words, key=lambda x: (len(x), x))\nfor word in words:\n    print(word)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3",
        "solution_code": "n = int(input())\nwords = []\nfor _ in range(n):\n    words.append(input().strip())\nwords = list(set(words))\n\nfor i in range(len(words)-1):\n    for j in range(len(words)-1-i):\n        if (len(words[j]), words[j]) > (len(words[j+1]), words[j+1]):\n            words[j], words[j+1] = words[j+1], words[j]\n\nfor word in words:\n    print(word)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 패스 횟수 제어",
            "description": "n-1번 반복하며 각 패스를 수행합니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "버블 정렬에서 몇 번의 패스가 필요한가요?",
            "hint": "n-1번의 패스가 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "내부 반복문: 인접 원소 비교",
            "description": "각 패스에서 인접한 두 원소를 비교합니다. 이미 정렬된 뒤쪽 부분은 제외합니다.",
            "code_pattern": "for j in range(n-1-i):",
            "socratic_hint": "각 패스에서 비교해야 할 원소의 범위는?",
            "hint": "n-1-i까지 비교합니다 (이미 정렬된 부분 제외)."
          },
          {
            "step_id": 4,
            "goal": "원소 교환",
            "description": "왼쪽 원소가 오른쪽 원소보다 크면 위치를 교환합니다.",
            "code_pattern": "if arr[j] > arr[j+1]:\n    arr[j], arr[j+1] = arr[j+1], arr[j]",
            "socratic_hint": "인접한 두 원소의 순서가 잘못되었을 때 어떻게 하나요?",
            "hint": "두 원소의 위치를 swap합니다."
          },
          {
            "step_id": 5,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4",
        "solution_code": "n = int(input())\nwords = []\nfor _ in range(n):\n    words.append(input().strip())\nwords = list(set(words))\n\nfor i in range(len(words)-1):\n    min_idx = i\n    for j in range(i+1, len(words)):\n        if (len(words[j]), words[j]) < (len(words[min_idx]), words[min_idx]):\n            min_idx = j\n    words[i], words[min_idx] = words[min_idx], words[i]\n\nfor word in words:\n    print(word)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 정렬할 위치 선택",
            "description": "n-1번 반복하며 각 위치에 올 최솟값을 찾습니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "선택 정렬에서 몇 번의 선택이 필요한가요?",
            "hint": "n-1번의 선택이 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "최솟값 인덱스 초기화",
            "description": "현재 위치를 최솟값 인덱스로 가정합니다.",
            "code_pattern": "min_idx = i",
            "socratic_hint": "최솟값을 찾기 위한 초기값은?",
            "hint": "현재 위치 i를 초기값으로 설정합니다."
          },
          {
            "step_id": 4,
            "goal": "내부 반복문: 최솟값 찾기",
            "description": "현재 위치 이후의 원소들 중 최솟값의 인덱스를 찾습니다.",
            "code_pattern": "for j in range(i+1, n):\n    if arr[j] < arr[min_idx]:\n        min_idx = j",
            "socratic_hint": "정렬되지 않은 부분에서 최솟값을 어떻게 찾나요?",
            "hint": "i+1부터 끝까지 순회하며 최솟값 인덱스를 업데이트합니다."
          },
          {
            "step_id": 5,
            "goal": "원소 교환",
            "description": "찾은 최솟값을 현재 위치로 이동시킵니다.",
            "code_pattern": "arr[i], arr[min_idx] = arr[min_idx], arr[i]",
            "socratic_hint": "최솟값을 현재 위치로 가져오려면?",
            "hint": "현재 위치의 값과 최솟값을 swap합니다."
          },
          {
            "step_id": 6,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1193",
    "step_title": "수학 1",
    "title": "분수찾기",
    "level": 6,
    "tags": [
      "수학",
      "구현"
    ],
    "description": "무한히 큰 배열에 다음과 같이 분수들이 적혀있다.1/11/21/31/41/5…2/12/22/32/4……3/13/23/3………4/14/2…………5/1……………………………이와 같이 나열된 분수들을 1/1 → 1/2 → 2/1 → 3/1 → 2/2 → … 과 같은 지그재그 순서로 차례대로 1번, 2번, 3번, 4번, 5번, … 분수라고 하자.X가 주어졌을 때, X번째 분수를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 X(1 ≤ X ≤ 10,000,000)가 주어진다.",
    "output_description": "첫째 줄에 분수를 출력한다.",
    "examples": [
      {
        "input": "1",
        "output": "1/1"
      },
      {
        "input": "2",
        "output": "1/2"
      },
      {
        "input": "3",
        "output": "2/1"
      },
      {
        "input": "4",
        "output": "3/1"
      },
      {
        "input": "5",
        "output": "2/2"
      },
      {
        "input": "6",
        "output": "1/3"
      },
      {
        "input": "7",
        "output": "1/4"
      },
      {
        "input": "8",
        "output": "2/3"
      },
      {
        "input": "9",
        "output": "3/2"
      },
      {
        "input": "14",
        "output": "2/4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1193",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "X = int(input())\ndiagonal = 1\nwhile X > diagonal:\n    X -= diagonal\n    diagonal += 1\nif diagonal % 2 == 0:\n    print(f\"{X}/{diagonal - X + 1}\")\nelse:\n    print(f\"{diagonal - X + 1}/{X}\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "X = int(input())\ndiagonal = 1\nwhile X > diagonal:\n    X -= diagonal\n    diagonal += 1\nif diagonal % ",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1197",
    "step_title": "최소 신장 트리",
    "title": "최소 스패닝 트리",
    "level": 12,
    "tags": [
      "최소 스패닝 트리",
      "그래프 이론"
    ],
    "description": "그래프가 주어졌을 때, 그 그래프의 최소 스패닝 트리를 구하는 프로그램을 작성하시오.최소 스패닝 트리는, 주어진 그래프의 모든 정점들을 연결하는 부분 그래프 중에서 그 가중치의 합이 최소인 트리를 말한다.",
    "input_description": "첫째 줄에 정점의 개수 V(1 ≤ V ≤ 10,000)와 간선의 개수 E(1 ≤ E ≤ 100,000)가 주어진다. 다음 E개의 줄에는 각 간선에 대한 정보를 나타내는 세 정수 A, B, C가 주어진다. 이는 A번 정점과 B번 정점이 가중치 C인 간선으로 연결되어 있다는 의미이다. C는 음수일 수도 있으며, 절댓값이 1,000,000을 넘지 않는다.그래프의 정점은 1번부터 V번까지 번호가 매겨져 있고, 임의의 두 정점 사이에 경로가 있다. 최소 스패닝 트리의 가중치가 -2,147,483,648보다 크거나 같고, 2,147,483,647보다 작거나 같은 데이터만 입력으로 주어진다.",
    "output_description": "첫째 줄에 최소 스패닝 트리의 가중치를 출력한다.",
    "examples": [
      {
        "input": "3 3\n1 2 1\n2 3 2\n1 3 3",
        "output": "3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1197",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def find(x):\n    if parent[x] != x:\n        parent[x] = find(parent[x])\n    return parent[x]\n\ndef union(x, y):\n    x = find(x)\n    y = find(y)\n    if x != y:\n        parent[y] = x\n        return True\n    return False\n\nV, E = map(int, input().split())\nedges = []\nfor _ in range(E):\n    a, b, c = map(int, input().split())\n    edges.append((c, a, b))\n\nedges.sort()\nparent = list(range(V + 1))\n\ntotal = 0\nfor cost, a, b in edges:\n    if union(a, b):\n        total += cost\n\nprint(total)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1202",
    "step_title": "우선순위 큐",
    "title": "보석 도둑",
    "level": 14,
    "tags": [
      "자료 구조",
      "그리디 알고리즘",
      "정렬",
      "우선순위 큐"
    ],
    "description": "세계적인 도둑 상덕이는 보석점을 털기로 결심했다.상덕이가 털 보석점에는 보석이 총 N개 있다. 각 보석은 무게 Mi와 가격 Vi를 가지고 있다. 상덕이는 가방을 K개 가지고 있고, 각 가방에 담을 수 있는 최대 무게는 Ci이다. 가방에는 최대 한 개의 보석만 넣을 수 있다.상덕이가 훔칠 수 있는 보석의 최대 가격을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N과 K가 주어진다. (1 ≤ N, K ≤ 300,000)다음 N개 줄에는 각 보석의 정보 Mi와 Vi가 주어진다. (0 ≤ Mi, Vi≤ 1,000,000)다음 K개 줄에는 가방에 담을 수 있는 최대 무게 Ci가 주어진다. (1 ≤ Ci≤ 100,000,000)모든 숫자는 양의 정수이다.",
    "output_description": "첫째 줄에 상덕이가 훔칠 수 있는 보석 가격의 합의 최댓값을 출력한다.",
    "examples": [
      {
        "input": "2 1\n5 10\n100 100\n11",
        "output": "10"
      },
      {
        "input": "3 2\n1 65\n5 23\n2 99\n10\n2",
        "output": "164"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1202",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import heapq\n\nN, K = map(int, input().split())\njewels = []\nfor _ in range(N):\n    m, v = map(int, input().split())\n    jewels.append((m, v))\n\nbags = []\nfor _ in range(K):\n    bags.append(int(input()))\n\njewels.sort()\nbags.sort()\n\ntotal = 0\nheap = []\nj = 0\n\nfor bag in bags:\n    while j < N and jewels[j][0] <= bag:\n        heapq.heappush(heap, -jewels[j][1])\n        j += 1\n    \n    if heap:\n        total += -heapq.heappop(heap)\n\nprint(total)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "import heapq\nn, k = map(int, input().split())\njewels = []\nfor _ in range(n):\n    m, v = map(int, input().split())\n    jewels.append((m, v))\n\nbags = []\nfor _ in range(k):\n    bags.append(int(input()))\n\njewels.sort()\nbags.sort()\n\nresult = 0\navailable = []\nj = 0\n\nfor bag in bags:\n    while j < n and jewels[j][0] <= bag:\n        heapq.heappush(available, -jewels[j][1])\n        j += 1\n    \n    if available:\n        result += -heapq.heappop(available)\n\nprint(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1260",
    "step_title": "그래프와 순회",
    "title": "DFS와 BFS",
    "level": 9,
    "tags": [
      "그래프 이론",
      "그래프 탐색",
      "너비 우선 탐색",
      "깊이 우선 탐색"
    ],
    "description": "그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 정점 번호는 1번부터 N번까지이다.",
    "input_description": "첫째 줄에 정점의 개수 N(1 ≤ N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 10,000), 탐색을 시작할 정점의 번호 V가 주어진다. 다음 M개의 줄에는 간선이 연결하는 두 정점의 번호가 주어진다. 어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다. 입력으로 주어지는 간선은 양방향이다.",
    "output_description": "첫째 줄에 DFS를 수행한 결과를, 그 다음 줄에는 BFS를 수행한 결과를 출력한다. V부터 방문된 점을 순서대로 출력하면 된다.",
    "examples": [
      {
        "input": "4 5 1\r\n1 2\r\n1 3\r\n1 4\r\n2 4\r\n3 4",
        "output": "1 2 4 3\r\n1 2 3 4"
      },
      {
        "input": "5 5 3\r\n5 4\r\n5 2\r\n1 2\r\n3 4\r\n3 1",
        "output": "3 1 2 5 4\r\n3 1 4 2 5"
      },
      {
        "input": "1000 1 1000\r\n999 1000",
        "output": "1000 999\r\n1000 999"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1260",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import deque\n\ndef dfs(node):\n    visited_dfs[node] = True\n    dfs_result.append(node)\n    \n    for next_node in sorted(graph[node]):\n        if not visited_dfs[next_node]:\n            dfs(next_node)\n\ndef bfs(start):\n    queue = deque([start])\n    visited_bfs[start] = True\n    \n    while queue:\n        node = queue.popleft()\n        bfs_result.append(node)\n        \n        for next_node in sorted(graph[node]):\n            if not visited_bfs[next_node]:\n                visited_bfs[next_node] = True\n                queue.append(next_node)\n\nN, M, V = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\nvisited_dfs = [False] * (N + 1)\nvisited_bfs = [False] * (N + 1)\ndfs_result = []\nbfs_result = []\n\ndfs(V)\nbfs(V)\n\nprint(' '.join(map(str, dfs_result)))\nprint(' '.join(map(str, bfs_result)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1269",
    "step_title": "집합과 맵",
    "title": "대칭 차집합",
    "level": 7,
    "tags": [
      "자료 구조",
      "집합과 맵",
      "해시를 사용한 집합과 맵",
      "트리를 사용한 집합과 맵"
    ],
    "description": "자연수를 원소로 갖는 공집합이 아닌 두 집합 A와 B가 있다. 이때, 두 집합의 대칭 차집합의 원소의 개수를 출력하는 프로그램을 작성하시오. 두 집합 A와 B가 있을 때, (A-B)와 (B-A)의 합집합을 A와 B의 대칭 차집합이라고 한다.예를 들어, A = { 1, 2, 4 } 이고, B = { 2, 3, 4, 5, 6 } 라고 할 때,  A-B = { 1 } 이고, B-A = { 3, 5, 6 } 이므로, 대칭 차집합의 원소의 개수는 1 + 3 = 4개이다.",
    "input_description": "첫째 줄에 집합 A의 원소의 개수와 집합 B의 원소의 개수가 빈 칸을 사이에 두고 주어진다. 둘째 줄에는 집합 A의 모든 원소가, 셋째 줄에는 집합 B의 모든 원소가 빈 칸을 사이에 두고 각각 주어진다. 각 집합의 원소의 개수는 200,000을 넘지 않으며, 모든 원소의 값은 100,000,000을 넘지 않는다.",
    "output_description": "첫째 줄에 대칭 차집합의 원소의 개수를 출력한다.",
    "examples": [
      {
        "input": "3 5\r\n1 2 4\r\n2 3 4 5 6",
        "output": "4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1269",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "A_count, B_count = map(int, input().split())\nA = set(map(int, input().split()))\nB = set(map(int, input().split()))\n\nprint(len(A - B) + len(B - A))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1300",
    "step_title": "이분 탐색",
    "title": "K번째 수",
    "level": 15,
    "tags": [
      "이분 탐색",
      "매개 변수 탐색"
    ],
    "description": "세준이는 크기가 N×N인 배열 A를 만들었다. 배열에 들어있는 수 A[i][j] = i×j 이다. 이 수를 일차원 배열 B에 넣으면 B의 크기는 N×N이 된다. B를 오름차순 정렬했을 때, B[k]를 구해보자.배열 A와 B의 인덱스는 1부터 시작한다.",
    "input_description": "첫째 줄에 배열의 크기 N이 주어진다. N은 105보다 작거나 같은 자연수이다. 둘째 줄에 k가 주어진다. k는 min(109, N2)보다 작거나 같은 자연수이다.",
    "output_description": "B[k]를 출력한다.",
    "examples": [
      {
        "input": "3\n7",
        "output": "6"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1300",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nk = int(input())\n\nleft, right = 1, k\nresult = 0\n\nwhile left <= right:\n    mid = (left + right) // 2\n    \n    # mid 이하의 수가 몇 개인지 계산\n    count = 0\n    for i in range(1, N + 1):\n        count += min(mid // i, N)\n    \n    if count >= k:\n        result = mid\n        right = mid - 1\n    else:\n        left = mid + 1\n\nprint(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1305",
    "step_title": "문자열 알고리즘 1",
    "title": "광고",
    "level": 17,
    "tags": [
      "문자열",
      "KMP"
    ],
    "description": "세준이는 길 한가운데에서 전광판을 쳐다보고 있었다. 전광판에는 광고가 흘러나오고 있었다. 한참을 전광판을 쳐다본 세준이는 이 광고가 의미하는 것이 무엇인지 궁금해지기 시작했다.전광판에는 같은 내용의 문구가 무한히 반복되어 나온다. 또, 전광판의 크기는 전광판에서 한번에 보이는 최대 문자수를 나타낸다. 만약 전광판의 크기가 L이라면, 한번에 L개의 문자를 표시할 수 있는 것이다.광고업자는 최대한의 광고효과를 내기 위해서 길이가 N인 광고를 무한히 붙여서 광고한다.예를 들어, 광고 업자 백은진이 광고하고 싶은 내용이 aaba 이고, 전광판의 크기가 6이라면 맨 처음에 보이는 내용은 aabaaa 이다. 시간이 1초가 지날 때마다, 문자는 한 칸씩 옆으로 이동한다. 따라서 처음에 aabaaa가 보였으면 그 다음에는 abaaab가 보인다. 그 다음에는 baaaba가 보인다.세준이가 어느 순간 전광판을 쳐다봤을 때, 그 때 쓰여 있는 문자가 입력으로 주어졌을 때, 가능한 광고의 길이중 가장 짧은 것을 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 광고판의 크기 L이 주어지고, 둘째 줄에 현재 광고판에 보이는 문자열이 주어진다.",
    "output_description": "첫째 줄에 가능한 광고의 길이중 가장 짧은 것의 길이를 출력한다.",
    "examples": [
      {
        "input": "5\naaaaa",
        "output": "1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1305",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def failure_function(pattern):\n    m = len(pattern)\n    pi = [0] * m\n    j = 0\n    \n    for i in range(1, m):\n        while j > 0 and pattern[i] != pattern[j]:\n            j = pi[j-1]\n        if pattern[i] == pattern[j]:\n            j += 1\n            pi[i] = j\n    \n    return pi\n\nL = int(input())\nad = input()\n\npi = failure_function(ad)\nprint(L - pi[L-1])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1311",
    "step_title": "동적 계획법 3",
    "title": "할 일 정하기 1",
    "level": 15,
    "tags": [
      "다이나믹 프로그래밍",
      "비트마스킹",
      "비트필드를 이용한 다이나믹 프로그래밍"
    ],
    "description": "N명의 사람과 N개의 일이 있다. 각 사람은 일을 하나 담당해야 하고, 각 일을 담당하는 사람은 한 명 이어야 한다. 또한, 모든 사람은 모든 일을 할 능력이 있다.사람은 1번부터 N번까지 번호가 매겨져 있으며, 일도 1번부터 N번까지 번호가 매겨져 있다.Dij를 i번 사람이 j번 일을 할 때 필요한 비용이라고 했을 때, 모든 일을 하는데 필요한 비용의 최솟값을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 사람과 일의 수 N (1 ≤ N ≤ 20)이 주어진다. 둘째 줄부터 N개의 줄에는 D의 내용이 주어진다. 비용은 10,000보다 작거나 같은 자연수이다.",
    "output_description": "모든 일을 하는데 필요한 비용의 최솟값을 출력한다.",
    "examples": [
      {
        "input": "3\n2 3 3\n3 2 3\n3 3 2",
        "output": "6"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1311",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1316",
    "step_title": "심화 1",
    "title": "그룹 단어 체커",
    "level": 6,
    "tags": [
      "구현",
      "문자열"
    ],
    "description": "그룹 단어란 단어에 존재하는 모든 문자에 대해서, 각 문자가 연속해서 나타나는 경우만을 말한다. 예를 들면, ccazzzzbb는 c, a, z, b가 모두 연속해서 나타나고, kin도 k, i, n이 연속해서 나타나기 때문에 그룹 단어이지만, aabbbccb는 b가 떨어져서 나타나기 때문에 그룹 단어가 아니다.단어 N개를 입력으로 받아 그룹 단어의 개수를 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 단어의 개수 N이 들어온다. N은 100보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 단어가 들어온다. 단어는 알파벳 소문자로만 되어있고 중복되지 않으며, 길이는 최대 100이다.",
    "output_description": "첫째 줄에 그룹 단어의 개수를 출력한다.",
    "examples": [
      {
        "input": "3\nhappy\nnew\nyear",
        "output": "3"
      },
      {
        "input": "4\naba\nabab\nabcabc\na",
        "output": "1"
      },
      {
        "input": "5\nab\naa\naca\nba\nbb",
        "output": "4"
      },
      {
        "input": "2\nyzyzy\nzyzyz",
        "output": "0"
      },
      {
        "input": "1\nz",
        "output": "1"
      },
      {
        "input": "9\naaa\naaazbz\nbabb\naazz\nazbz\naabbaa\nabacc\naba\nzzaz",
        "output": "2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1316",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\ncount = 0\nfor _ in range(N):\n    word = input()\n    is_group = True\n    prev = ''\n    seen = set()\n    for char in word:\n        if char != prev:\n            if char in seen:\n                is_group = False\n                break\n            seen.add(char)\n        prev = char\n    if is_group:\n        count += 1\nprint(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "word = input()로 입력을 처리합니다.",
            "code_pattern": "word = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "조건 판단",
            "description": "조건문을 사용하여 상황에 따라 다르게 처리합니다.",
            "code_pattern": "if char != prev:",
            "socratic_hint": "조건에 따라 다르게 처리하려면?",
            "hint": "if-else 문을 사용합니다."
          },
          {
            "step_id": 5,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(count)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1330",
    "step_title": "조건문",
    "title": "두 수 비교하기",
    "level": 1,
    "tags": [
      "구현"
    ],
    "description": "두 정수 A와 B가 주어졌을 때, A와 B를 비교하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 A와 B가 주어진다. A와 B는 공백 한 칸으로 구분되어져 있다.",
    "output_description": "첫째 줄에 다음 세 가지 중 하나를 출력한다.A가 B보다 큰 경우에는 '>'를 출력한다.A가 B보다 작은 경우에는 '<'를 출력한다.A와 B가 같은 경우에는 '=='를 출력한다.",
    "examples": [
      {
        "input": "1 2",
        "output": "<"
      },
      {
        "input": "10 2",
        "output": ">"
      },
      {
        "input": "5 5",
        "output": "=="
      }
    ],
    "url": "https://www.acmicpc.net/problem/1330",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "A, B = map(int, input().split())\nif A > B:\n    print(\">\")\nelif A < B:\n    print(\"<\")\nelse:\n    print(\"==\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "A 입력",
            "description": "첫 번째 정수 A를 입력받습니다.",
            "code_pattern": "A = int(input())",
            "socratic_hint": "첫 번째 수를 입력받으려면?",
            "hint": "A = int(input())"
          },
          {
            "step_id": 2,
            "goal": "B 입력",
            "description": "두 번째 정수 B를 입력받습니다.",
            "code_pattern": "B = int(input())",
            "socratic_hint": "두 번째 수를 입력받으려면?",
            "hint": "B = int(input())"
          },
          {
            "step_id": 3,
            "goal": "A와 B 비교",
            "description": "if-elif-else로 A > B, A < B, A == B 세 가지 경우를 비교합니다.",
            "code_pattern": "if A > B:\nelif A < B:\nelse:",
            "socratic_hint": "세 가지 경우(크다, 작다, 같다)를 어떻게 구분하나요?",
            "hint": "if, elif, else를 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "비교 결과 출력",
            "description": "각 경우에 맞는 기호(>, <, ==)를 출력합니다.",
            "code_pattern": "if A > B:\n    print(\">\")\nelif A < B:\n    print(\"<\")\nelse:\n    print(\"==\")",
            "socratic_hint": "각 경우에 어떤 기호를 출력해야 하나요?",
            "hint": "A가 크면 >, 작으면 <, 같으면 ==를 출력합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: 삼항 연산자 활용",
        "solution_code": "A, B = map(int, input().split())\nprint('>' if A > B else '<' if A < B else '==')",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "필요한 값을 입력받습니다.",
            "code_pattern": "A, B = map(int, input().split())",
            "socratic_hint": "입력을 받으려면?",
            "hint": "input()과 split()을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "삼항 연산자로 조건 판단",
            "description": "삼항 연산자를 연쇄적으로 사용하여 조건을 판단합니다.",
            "code_pattern": "결과 = 값1 if 조건1 else 값2 if 조건2 else 값3",
            "socratic_hint": "여러 조건을 간결하게 표현하려면?",
            "hint": "삼항 연산자를 연쇄적으로 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3: 딕셔너리 활용",
        "solution_code": "A, B = map(int, input().split())\nresult = {True: '>', False: '<', None: '=='}\nprint(result[None if A == B else A > B])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "조건을 딕셔너리로",
            "description": "비교 결과를 키로 사용하는 딕셔너리를 만듭니다.",
            "code_pattern": "result = {True: '>', False: '<', None: '=='}",
            "socratic_hint": "조건 결과를 딕셔너리로 매핑하려면?",
            "hint": "조건을 키로 하는 딕셔너리를 만듭니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4: 비교 연산자 조합",
        "solution_code": "A, B = map(int, input().split())\nprint(['<', '==', '>'][(A > B) - (A < B) + 1])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "비교 연산자 차이",
            "description": "(A > B) - (A < B)의 결과로 인덱스를 결정합니다.",
            "code_pattern": "print(['<', '==', '>'][(A > B) - (A < B) + 1])",
            "socratic_hint": "비교 결과를 수치화하려면?",
            "hint": "불린 연산의 차이를 이용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1395",
    "step_title": "세그먼트 트리 2",
    "title": "스위치",
    "level": 18,
    "tags": [
      "자료 구조",
      "세그먼트 트리",
      "느리게 갱신되는 세그먼트 트리"
    ],
    "description": "준규네 집에는 총 N개의 스위치가 있고 이를 편하게 1번부터 N번까지 차례대로 번호를 매겼다. 그리고 준규의 취미는 이 스위치들을 켜고 끄는 것이다.준규가 하는 스위치를 갖고 노는 일은 크게 두 가지이다. 하나는 A번부터 B번 사이의 스위치 상태를 반전시키는 것이고 다른 하나는 C번부터 D번 사이의 스위치 중 켜져 있는 상태의 스위치의 개수를 세는 것이다.하지만 준규가 싫증을 느껴 우리가 이 귀찮은 일을 떠맡게 되었고 프로그래밍을 통해 일을 처리하도록 결정하였다.",
    "input_description": "첫 줄에는 스위치의 개수 N(2 ≤ N ≤ 100,000)과 처리할 일의 개수 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 M개의 줄에 대해 각 줄에 처리할 일에 대한 정보가 담겨진 세 개의 정수 O, Si, Ti가 입력된다. O가 0이면 Si번 스위치부터 Ti번 스위치까지 스위치 상태를 반전시키는 일이고 1이면 Si번 스위치부터 Ti번 스위치까지 중 켜져 있는 상태의 스위치 개수를 묻는 일이다. 단, 초기에는 모든 스위치의 상태는 꺼져있는 상태로 되어있다.",
    "output_description": "입력에서 켜진 스위치 개수에 대한 답을 한 줄에 하나씩 출력한다.",
    "examples": [
      {
        "input": "4 5\r\n0 1 2\r\n0 2 4\r\n1 2 3\r\n0 2 4\r\n1 1 4",
        "output": "1\r\n2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1395",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1420",
    "step_title": "네트워크 플로우 1",
    "title": "학교 가지마!",
    "level": 19,
    "tags": [
      "그래프 이론",
      "최대 유량",
      "격자 그래프",
      "최대 유량 최소 컷 정리"
    ],
    "description": "도현이가 사는 도시는 N×M 크기의 모양이며, 1×1칸으로 나누어져 있다. 각 칸은 빈 칸 또는 벽이다.도현이는 학교에 가려고 한다. 도현이가 있는 곳은 항상 빈 칸이고, 학교도 빈 칸에 있다. 도현이는 현재 있는 칸과 상하좌우로 인접한 칸으로 이동할 수 있다. 이때, 벽이 있는 칸으로는 이동할 수 없다. 또, 도시를 벗어날 수는 없다.준규는 도현이가 학교에 가지 못하게 빈 칸을 적절히 벽으로 바꾸려고 한다. 이미 벽인 곳은 벽으로 바꿀 수 없고, 빈 칸만 벽으로 바꿀 수 있다. 도현이와 학교가 있는 곳은 벽으로 바꿀 수 없다.도현이가 학교에 가지 못하게 하기 위해서 빈 칸을 벽으로 바꿔야하는 횟수의 최솟값을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 도시의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 100) 둘째 줄부터 N개의 줄에 도시의 모양이 주어진다. 비어있으면 점('.'), 벽은 '#', 도현이의 위치는 K, 학교의 위치는 H이다. K와 H는 하나만 주어진다.",
    "output_description": "첫째 줄에 도현이가 학교를 가지 못하게 하기 위해서 바꿔야 하는 벽의 최소 개수를 출력한다. 만약, 벽을 아무리 세워도 학교에 가는 것을 막을 수 없다면 -1을 출력한다.",
    "examples": [
      {
        "input": "4 5\nK....\n...##\n##...\n....H",
        "output": "1"
      },
      {
        "input": "3 5\n.....\n.K.H.\n.....",
        "output": "3"
      },
      {
        "input": "2 4\n.#K.\n.H#.",
        "output": "0"
      },
      {
        "input": "3 4\n####\n#KH#\n####",
        "output": "-1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1420",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1427",
    "step_title": "정렬",
    "title": "소트인사이드",
    "level": 6,
    "tags": [
      "문자열",
      "정렬"
    ],
    "description": "배열을 정렬하는 것은 쉽다. 수가 주어지면, 그 수의 각 자리수를 내림차순으로 정렬해보자.",
    "input_description": "첫째 줄에 정렬하려고 하는 수 N이 주어진다. N은 1,000,000,000보다 작거나 같은 자연수이다.",
    "output_description": "첫째 줄에 자리수를 내림차순으로 정렬한 수를 출력한다.",
    "examples": [
      {
        "input": "2143",
        "output": "4321"
      },
      {
        "input": "999998999",
        "output": "999999998"
      },
      {
        "input": "61423",
        "output": "64321"
      },
      {
        "input": "500613009",
        "output": "965310000"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1427",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = input()\ndigits = sorted(N, reverse=True)\nprint(''.join(digits))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = input()\ndigits = sorted(n, reverse=True)\nprint(''.join(digits))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3",
        "solution_code": "n = input()\ndigits = list(n)\ndigits.sort(reverse=True)\nprint(''.join(digits))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sort() 메서드로 정렬",
            "description": "arr.sort()로 리스트를 제자리에서 정렬합니다.",
            "code_pattern": "arr.sort()",
            "socratic_hint": "리스트를 제자리에서 정렬하는 메서드는?",
            "hint": ".sort() 메서드를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문을 사용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4",
        "solution_code": "n = input()\ndigits = list(n)\nfor i in range(len(digits)-1):\n    for j in range(len(digits)-1-i):\n        if digits[j] < digits[j+1]:\n            digits[j], digits[j+1] = digits[j+1], digits[j]\nprint(''.join(digits))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 패스 횟수 제어",
            "description": "n-1번 반복하며 각 패스를 수행합니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "버블 정렬에서 몇 번의 패스가 필요한가요?",
            "hint": "n-1번의 패스가 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "내부 반복문: 인접 원소 비교",
            "description": "각 패스에서 인접한 두 원소를 비교합니다. 이미 정렬된 뒤쪽 부분은 제외합니다.",
            "code_pattern": "for j in range(n-1-i):",
            "socratic_hint": "각 패스에서 비교해야 할 원소의 범위는?",
            "hint": "n-1-i까지 비교합니다 (이미 정렬된 부분 제외)."
          },
          {
            "step_id": 4,
            "goal": "원소 교환",
            "description": "왼쪽 원소가 오른쪽 원소보다 크면 위치를 교환합니다.",
            "code_pattern": "if arr[j] > arr[j+1]:\n    arr[j], arr[j+1] = arr[j+1], arr[j]",
            "socratic_hint": "인접한 두 원소의 순서가 잘못되었을 때 어떻게 하나요?",
            "hint": "두 원소의 위치를 swap합니다."
          },
          {
            "step_id": 5,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      },
      {
        "solution_id": 5,
        "solution_name": "풀이 5",
        "solution_code": "n = input()\ndigits = list(n)\nfor i in range(len(digits)-1):\n    max_idx = i\n    for j in range(i+1, len(digits)):\n        if digits[j] > digits[max_idx]:\n            max_idx = j\n    digits[i], digits[max_idx] = digits[max_idx], digits[i]\nprint(''.join(digits))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 정렬할 위치 선택",
            "description": "n-1번 반복하며 각 위치에 올 최솟값을 찾습니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "선택 정렬에서 몇 번의 선택이 필요한가요?",
            "hint": "n-1번의 선택이 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "최솟값 인덱스 초기화",
            "description": "현재 위치를 최솟값 인덱스로 가정합니다.",
            "code_pattern": "min_idx = i",
            "socratic_hint": "최솟값을 찾기 위한 초기값은?",
            "hint": "현재 위치 i를 초기값으로 설정합니다."
          },
          {
            "step_id": 4,
            "goal": "내부 반복문: 최솟값 찾기",
            "description": "현재 위치 이후의 원소들 중 최솟값의 인덱스를 찾습니다.",
            "code_pattern": "for j in range(i+1, n):\n    if arr[j] < arr[min_idx]:\n        min_idx = j",
            "socratic_hint": "정렬되지 않은 부분에서 최솟값을 어떻게 찾나요?",
            "hint": "i+1부터 끝까지 순회하며 최솟값 인덱스를 업데이트합니다."
          },
          {
            "step_id": 5,
            "goal": "원소 교환",
            "description": "찾은 최솟값을 현재 위치로 이동시킵니다.",
            "code_pattern": "arr[i], arr[min_idx] = arr[min_idx], arr[i]",
            "socratic_hint": "최솟값을 현재 위치로 가져오려면?",
            "hint": "현재 위치의 값과 최솟값을 swap합니다."
          },
          {
            "step_id": 6,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1436",
    "step_title": "브루트 포스",
    "title": "영화감독 숌",
    "level": 6,
    "tags": [
      "브루트포스 알고리즘"
    ],
    "description": "666은 종말을 나타내는 수라고 한다. 따라서, 많은 블록버스터 영화에서는 666이 들어간 제목을 많이 사용한다. 영화감독 숌은 세상의 종말 이라는 시리즈 영화의 감독이다. 조지 루카스는 스타워즈를 만들 때, 스타워즈 1, 스타워즈 2, 스타워즈 3, 스타워즈 4, 스타워즈 5, 스타워즈 6과 같이 이름을 지었고, 피터 잭슨은 반지의 제왕을 만들 때, 반지의 제왕 1, 반지의 제왕 2, 반지의 제왕 3과 같이 영화 제목을 지었다. 하지만 숌은 자신이 조지 루카스와 피터 잭슨을 뛰어넘는다는 것을 보여주기 위해서 영화 제목을 좀 다르게 만들기로 했다.종말의 수란 어떤 수에 6이 적어도 3개 이상 연속으로 들어가는 수를 말한다. 제일 작은 종말의 수는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, .... 이다. 따라서, 숌은 첫 번째 영화의 제목은 \"세상의 종말 666\", 두 번째 영화의 제목은 \"세상의 종말 1666\"와 같이 이름을 지을 것이다. 일반화해서 생각하면, N번째 영화의 제목은 세상의 종말 (N번째로 작은 종말의 수) 와 같다.숌이 만든 N번째 영화의 제목에 들어간 수를 출력하는 프로그램을 작성하시오. 숌은 이 시리즈를 항상 차례대로 만들고, 다른 영화는 만들지 않는다.",
    "input_description": "첫째 줄에 N이 주어진다. N은 10,000보다 작거나 같은 자연수이다.",
    "output_description": "첫째 줄에 N번째 영화의 제목에 들어간 수를 출력한다.",
    "examples": [
      {
        "input": "2",
        "output": "1666"
      },
      {
        "input": "3",
        "output": "2666"
      },
      {
        "input": "6",
        "output": "5666"
      },
      {
        "input": "187",
        "output": "66666"
      },
      {
        "input": "500",
        "output": "166699"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1436",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\ncount = 0\nnum = 665\n\nwhile count < N:\n    num += 1\n    if '666' in str(num):\n        count += 1\n\nprint(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1450",
    "step_title": "투 포인터",
    "title": "냅색문제",
    "level": 15,
    "tags": [
      "이분 탐색",
      "중간에서 만나기"
    ],
    "description": "세준이는 N개의 물건을 가지고 있고, 최대 C만큼의 무게를 넣을 수 있는 가방을 하나 가지고 있다.N개의 물건을 가방에 넣는 방법의 수를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N과 C가 주어진다. N은 30보다 작거나 같은 자연수, C는 109보다 작거나 같은 음이 아닌 정수이다. 둘째 줄에 물건의 무게가 주어진다. 무게도 109보다 작거나 같은 자연수이다.",
    "output_description": "첫째 줄에 가방에 넣는 방법의 수를 출력한다.",
    "examples": [
      {
        "input": "2 1\n1 1",
        "output": "3"
      },
      {
        "input": "1 1\n1",
        "output": "2"
      },
      {
        "input": "1 2\n1",
        "output": "2"
      },
      {
        "input": "2 1\n2 2",
        "output": "1"
      },
      {
        "input": "2 2\n1 1",
        "output": "4"
      },
      {
        "input": "30 30\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1",
        "output": "1073741824"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1450",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from itertools import combinations\n\ndef get_sums(items):\n    result = []\n    for i in range(len(items) + 1):\n        for comb in combinations(items, i):\n            result.append(sum(comb))\n    return sorted(result)\n\nN, C = map(int, input().split())\nitems = list(map(int, input().split()))\n\nmid = N // 2\nleft = items[:mid]\nright = items[mid:]\n\nleft_sums = get_sums(left)\nright_sums = get_sums(right)\n\ncount = 0\nfor left_sum in left_sums:\n    remain = C - left_sum\n    lo, hi = 0, len(right_sums)\n    while lo < hi:\n        mid_idx = (lo + hi) // 2\n        if right_sums[mid_idx] <= remain:\n            lo = mid_idx + 1\n        else:\n            hi = mid_idx\n    count += lo\n\nprint(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1463",
    "step_title": "동적 계획법 1",
    "title": "1로 만들기",
    "level": 8,
    "tags": [
      "다이나믹 프로그래밍"
    ],
    "description": "정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.X가 3으로 나누어 떨어지면, 3으로 나눈다.X가 2로 나누어 떨어지면, 2로 나눈다.1을 뺀다.정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.",
    "input_description": "첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.",
    "output_description": "첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.",
    "examples": [
      {
        "input": "2",
        "output": "1"
      },
      {
        "input": "10",
        "output": "3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1463",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\ndp = [0] * (N + 1)\n\nfor i in range(2, N + 1):\n    dp[i] = dp[i-1] + 1\n    \n    if i % 2 == 0:\n        dp[i] = min(dp[i], dp[i//2] + 1)\n    \n    if i % 3 == 0:\n        dp[i] = min(dp[i], dp[i//3] + 1)\n\nprint(dp[N])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1504",
    "step_title": "최단 경로",
    "title": "특정한 최단 경로",
    "level": 12,
    "tags": [
      "그래프 이론",
      "최단 경로",
      "데이크스트라"
    ],
    "description": "방향성이 없는 그래프가 주어진다. 세준이는 1번 정점에서 N번 정점으로 최단 거리로 이동하려고 한다. 또한 세준이는 두 가지 조건을 만족하면서 이동하는 특정한 최단 경로를 구하고 싶은데, 그것은 바로 임의로 주어진 두 정점은 반드시 통과해야 한다는 것이다.세준이는 한번 이동했던 정점은 물론, 한번 이동했던 간선도 다시 이동할 수 있다. 하지만 반드시 최단 경로로 이동해야 한다는 사실에 주의하라. 1번 정점에서 N번 정점으로 이동할 때, 주어진 두 정점을 반드시 거치면서 최단 경로로 이동하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 정점의 개수 N과 간선의 개수 E가 주어진다. (2 ≤ N ≤ 800, 0 ≤ E ≤ 200,000) 둘째 줄부터 E개의 줄에 걸쳐서 세 개의 정수 a, b, c가 주어지는데, a번 정점에서 b번 정점까지 양방향 길이 존재하며, 그 거리가 c라는 뜻이다. (1 ≤ c ≤ 1,000) 다음 줄에는 반드시 거쳐야 하는 두 개의 서로 다른 정점 번호 v1과 v2가 주어진다. (v1≠ v2, v1≠ N, v2≠ 1) 임의의 두 정점 u와 v사이에는 간선이 최대 1개 존재한다.",
    "output_description": "첫째 줄에 두 개의 정점을 지나는 최단 경로의 길이를 출력한다. 그러한 경로가 없을 때에는 -1을 출력한다.",
    "examples": [
      {
        "input": "4 6\n1 2 3\n2 3 3\n3 4 1\n1 3 5\n2 4 5\n1 4 4\n2 3",
        "output": "7"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1504",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import heapq\nimport sys\ninput = sys.stdin.readline\n\ndef dijkstra(start):\n    dist = [float('inf')] * (N + 1)\n    dist[start] = 0\n    heap = [(0, start)]\n    \n    while heap:\n        d, node = heapq.heappop(heap)\n        \n        if d > dist[node]:\n            continue\n        \n        for next_node, weight in graph[node]:\n            if dist[node] + weight < dist[next_node]:\n                dist[next_node] = dist[node] + weight\n                heapq.heappush(heap, (dist[next_node], next_node))\n    \n    return dist\n\nN, E = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor _ in range(E):\n    a, b, c = map(int, input().split())\n    graph[a].append((b, c))\n    graph[b].append((a, c))\n\nv1, v2 = map(int, input().split())\n\ndist_1 = dijkstra(1)\ndist_v1 = dijkstra(v1)\ndist_v2 = dijkstra(v2)\n\npath1 = dist_1[v1] + dist_v1[v2] + dist_v2[N]\npath2 = dist_1[v2] + dist_v2[v1] + dist_v1[N]\n\nresult = min(path1, path2)\nprint(result if result < float('inf') else -1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1509",
    "step_title": "동적 계획법 4",
    "title": "팰린드롬 분할",
    "level": 15,
    "tags": [
      "다이나믹 프로그래밍"
    ],
    "description": "세준이는 어떤 문자열을 팰린드롬으로 분할하려고 한다. 예를 들어, ABACABA를 팰린드롬으로 분할하면, {A, B, A, C, A, B, A}, {A, BACAB, A}, {ABA, C, ABA}, {ABACABA}등이 있다.분할의 개수의 최솟값을 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 문자열이 주어진다. 이 문자열은 알파벳 대문자로만 이루어져 있고, 최대 길이는 2,500이다.",
    "output_description": "첫째 줄에 팰린드롬 분할의 개수의 최솟값을 출력한다.",
    "examples": [
      {
        "input": "BBCDDECAECBDABADDCEBACCCBDCAABDBADD",
        "output": "22"
      },
      {
        "input": "AAAA",
        "output": "1"
      },
      {
        "input": "ABCDEFGH",
        "output": "8"
      },
      {
        "input": "QWERTYTREWQWERT",
        "output": "5"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1509",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "word = input()로 입력을 처리합니다.",
            "code_pattern": "word = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "조건 판단",
            "description": "조건문을 사용하여 상황에 따라 다르게 처리합니다.",
            "code_pattern": "print(1 if word == word[::-1] else 0)",
            "socratic_hint": "조건에 따라 다르게 처리하려면?",
            "hint": "if-else 문을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(1 if word == word[::-1] else 0)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1517",
    "step_title": "세그먼트 트리 1",
    "title": "버블 소트",
    "level": 16,
    "tags": [
      "자료 구조",
      "정렬",
      "세그먼트 트리",
      "분할 정복"
    ],
    "description": "N개의 수로 이루어진 수열 A[1], A[2], …, A[N]이 있다. 이 수열에 대해서 버블 소트를 수행할 때, Swap이 총 몇 번 발생하는지 알아내는 프로그램을 작성하시오.버블 소트는 서로 인접해 있는 두 수를 바꿔가며 정렬하는 방법이다. 예를 들어 수열이 3 2 1 이었다고 하자. 이 경우에는 인접해 있는 3, 2가 바뀌어야 하므로 2 3 1 이 된다. 다음으로는 3, 1이 바뀌어야 하므로 2 1 3 이 된다. 다음에는 2, 1이 바뀌어야 하므로 1 2 3 이 된다. 그러면 더 이상 바꿔야 할 경우가 없으므로 정렬이 완료된다.",
    "input_description": "첫째 줄에 N(1 ≤ N ≤ 500,000)이 주어진다. 다음 줄에는 N개의 정수로 A[1], A[2], …, A[N]이 주어진다. 각각의 A[i]는 0 ≤ |A[i]| ≤ 1,000,000,000의 범위에 들어있다.",
    "output_description": "첫째 줄에 Swap 횟수를 출력한다",
    "examples": [
      {
        "input": "3\n3 2 1",
        "output": "3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1517",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "n = int(input())\narr = list(map(int, input().split()))\n\ncount = 0\n\ndef merge_sort(arr):\n    global count\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    merged = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            count += len(left) - i\n            j += 1\n    \n    merged.extend(left[i:])\n    merged.extend(right[j:])\n    \n    return merged\n\nmerge_sort(arr)\nprint(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor num in sorted(arr):\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1520",
    "step_title": "동적 계획법 2",
    "title": "내리막 길",
    "level": 13,
    "tags": [
      "다이나믹 프로그래밍",
      "그래프 이론",
      "그래프 탐색",
      "깊이 우선 탐색"
    ],
    "description": "여행을 떠난 세준이는 지도를 하나 구하였다. 이 지도는 아래 그림과 같이 직사각형 모양이며 여러 칸으로 나뉘어져 있다. 한 칸은 한 지점을 나타내는데 각 칸에는 그 지점의 높이가 쓰여 있으며, 각 지점 사이의 이동은 지도에서 상하좌우 이웃한 곳끼리만 가능하다.현재 제일 왼쪽 위 칸이 나타내는 지점에 있는 세준이는 제일 오른쪽 아래 칸이 나타내는 지점으로 가려고 한다. 그런데 가능한 힘을 적게 들이고 싶어 항상 높이가 더 낮은 지점으로만 이동하여 목표 지점까지 가고자 한다. 위와 같은 지도에서는 다음과 같은 세 가지 경로가 가능하다.지도가 주어질 때 이와 같이 제일 왼쪽 위 지점에서 출발하여 제일 오른쪽 아래 지점까지 항상 내리막길로만 이동하는 경로의 개수를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에는 지도의 세로의 크기 M과 가로의 크기 N이 빈칸을 사이에 두고 주어진다. 이어 다음 M개 줄에 걸쳐 한 줄에 N개씩 위에서부터 차례로 각 지점의 높이가 빈 칸을 사이에 두고 주어진다. M과 N은 각각 500이하의 자연수이고, 각 지점의 높이는 10000이하의 자연수이다.",
    "output_description": "첫째 줄에 이동 가능한 경로의 수 H를 출력한다. 모든 입력에 대하여 H는 10억 이하의 음이 아닌 정수이다.",
    "examples": [
      {
        "input": "4 5\n50 45 37 32 30\n35 50 40 20 25\n30 30 25 17 28\n27 24 22 15 10",
        "output": "3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1520",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(x, y):\n    if x == M - 1 and y == N - 1:\n        return 1\n    \n    if dp[x][y] != -1:\n        return dp[x][y]\n    \n    dp[x][y] = 0\n    for i in range(4):\n        nx, ny = x + dx[i], y + dy[i]\n        if 0 <= nx < M and 0 <= ny < N and grid[nx][ny] < grid[x][y]:\n            dp[x][y] += dfs(nx, ny)\n    \n    return dp[x][y]\n\nM, N = map(int, input().split())\ngrid = []\nfor _ in range(M):\n    grid.append(list(map(int, input().split())))\n\ndp = [[-1] * N for _ in range(M)]\ndx = [-1, 1, 0, 0]\ndy = [0, 0, -1, 1]\n\nprint(dfs(0, 0))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1541",
    "step_title": "그리디 알고리즘 1",
    "title": "잃어버린 괄호",
    "level": 9,
    "tags": [
      "수학",
      "그리디 알고리즘",
      "문자열",
      "파싱"
    ],
    "description": "세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다.그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다.괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다. 수는 0으로 시작할 수 있다. 입력으로 주어지는 식의 길이는 50보다 작거나 같다.",
    "output_description": "첫째 줄에 정답을 출력한다.",
    "examples": [
      {
        "input": "55-50+40",
        "output": "-35"
      },
      {
        "input": "10+20+30+40",
        "output": "100"
      },
      {
        "input": "00009-00009",
        "output": "0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1541",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "expression = input().split('-')\nresult = sum(map(int, expression[0].split('+')))\n\nfor part in expression[1:]:\n    result -= sum(map(int, part.split('+')))\n\nprint(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1546",
    "step_title": "1차원 배열",
    "title": "평균",
    "level": 5,
    "tags": [
      "수학",
      "사칙연산"
    ],
    "description": "세준이는 기말고사를 망쳤다. 세준이는 점수를 조작해서 집에 가져가기로 했다. 일단 세준이는 자기 점수 중에 최댓값을 골랐다. 이 값을 M이라고 한다. 그리고 나서 모든 점수를 점수/M*100으로 고쳤다.예를 들어, 세준이의 최고점이 70이고, 수학점수가 50이었으면 수학점수는 50/70*100이 되어 71.43점이 된다.세준이의 성적을 위의 방법대로 새로 계산했을 때, 새로운 평균을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 시험 본 과목의 개수 N이 주어진다. 이 값은 1000보다 작거나 같다. 둘째 줄에 세준이의 현재 성적이 주어진다. 이 값은 100보다 작거나 같은 음이 아닌 정수이고, 적어도 하나의 값은 0보다 크다.",
    "output_description": "첫째 줄에 새로운 평균을 출력한다. 실제 정답과 출력값의 절대오차 또는 상대오차가 10-2이하이면 정답이다.",
    "examples": [
      {
        "input": "3\n40 80 60",
        "output": "75.0"
      },
      {
        "input": "3\n10 20 30",
        "output": "66.666667"
      },
      {
        "input": "4\n1 100 100 100",
        "output": "75.25"
      },
      {
        "input": "5\n1 2 4 8 16",
        "output": "38.75"
      },
      {
        "input": "2\n3 10",
        "output": "65.0"
      },
      {
        "input": "4\n10 20 0 100",
        "output": "32.5"
      },
      {
        "input": "1\n50",
        "output": "100.0"
      },
      {
        "input": "9\n10 20 30 40 50 60 70 80 90",
        "output": "55.55555555555556"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1546",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nscores = list(map(int, input().split()))\nM = max(scores)\nnew_scores = [score / M * 100 for score in scores]\nprint(sum(new_scores) / N)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "과목 수 입력",
            "description": "과목 개수 N을 입력받습니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "과목이 몇 개인지 입력받으려면?",
            "hint": "N = int(input())"
          },
          {
            "step_id": 2,
            "goal": "빈 리스트 생성 및 점수 입력",
            "description": "점수를 저장할 리스트를 만들고, N번 반복하여 점수를 입력받습니다.",
            "code_pattern": "scores = []\nfor i in range(N):\n    score = int(input())\n    scores.append(score)",
            "socratic_hint": "N개의 점수를 리스트에 저장하려면?",
            "hint": "빈 리스트를 만들고 for 반복문으로 append()"
          },
          {
            "step_id": 3,
            "goal": "최고 점수 찾기",
            "description": "max() 함수로 점수 중 최댓값 M을 구합니다.",
            "code_pattern": "M = max(scores)",
            "socratic_hint": "점수 중 가장 높은 점수를 찾으려면?",
            "hint": "M = max(scores)"
          },
          {
            "step_id": 4,
            "goal": "점수 조작하기",
            "description": "빈 리스트를 만들고, 각 점수를 '점수/M*100'으로 변환하여 저장합니다.",
            "code_pattern": "new_scores = []\nfor score in scores:\n    new_score = score / M * 100\n    new_scores.append(new_score)",
            "socratic_hint": "모든 점수에 같은 계산(점수/M*100)을 적용하려면?",
            "hint": "for 반복문으로 각 점수를 변환"
          },
          {
            "step_id": 5,
            "goal": "합계 계산",
            "description": "변환된 점수들의 합을 계산합니다.",
            "code_pattern": "total = 0\nfor score in new_scores:\n    total = total + score",
            "socratic_hint": "리스트의 모든 값을 더하려면?",
            "hint": "반복문으로 total에 계속 더하기"
          },
          {
            "step_id": 6,
            "goal": "평균 계산",
            "description": "합계를 과목 수로 나누어 평균을 구합니다.",
            "code_pattern": "average = total / N",
            "socratic_hint": "평균을 구하려면?",
            "hint": "합계 / 개수"
          },
          {
            "step_id": 7,
            "goal": "평균 출력",
            "description": "계산된 평균을 출력합니다.",
            "code_pattern": "print(average)",
            "socratic_hint": "평균을 출력하려면?",
            "hint": "print(average)"
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1605",
    "step_title": "문자열 알고리즘 2",
    "title": "반복 부분문자열",
    "level": 18,
    "tags": [
      "문자열",
      "해싱",
      "접미사 배열과 LCP 배열",
      "라빈–카프"
    ],
    "description": "알파벳 소문자로 이루어진 길이 L인 문자열이 있다. 이 문자열의 부분문자열 중, 적어도 한 번은 반복되는 (다시 말해서, 전체 문자열에서 두 번 이상 나타나는) 부분문자열을 '반복 부분문자열'이라고 부르자.문자열이 주어지면, 가장 긴 '반복 부분문자열'의 길이를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 문자열의 길이 L(1 ≤ L ≤ 200,000)이 주어진다. 둘째 줄에는 문자열을 이루는 L개의 알파벳 소문자들이 띄어쓰기 없이 주어진다.",
    "output_description": "첫째 줄에 가장 긴 '반복 부분문자열'의 길이를 출력한다. 만일 '반복 부분문자열'이 하나도 존재하지 않는다면 0을 출력한다.",
    "examples": [
      {
        "input": "28\ntellmetellmetetetetetetellme",
        "output": "11"
      },
      {
        "input": "5\njykim",
        "output": "0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1605",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1620",
    "step_title": "집합과 맵",
    "title": "나는야 포켓몬 마스터 이다솜",
    "level": 7,
    "tags": [
      "자료 구조",
      "집합과 맵",
      "해시를 사용한 집합과 맵"
    ],
    "description": "안녕? 내 이름은 이다솜. 나의 꿈은 포켓몬 마스터야. 일단 포켓몬 마스터가 되기 위해선 포켓몬을 한 마리 잡아야겠지? 근처 숲으로 가야겠어.(뚜벅 뚜벅)얏! 꼬렛이다. 꼬렛? 귀여운데, 나의 첫 포켓몬으로 딱 어울린데? 내가 잡고 말겠어. 가라! 몬스터볼~(펑!) 헐랭... 왜 안 잡히지?ㅜㅜ 몬스터 볼만 던지면 되는 게 아닌가...ㅜㅠ(터벅터벅)어? 누구지?오박사 : 나는 태초마을의 포켓몬 박사 오민식 박사라네. 다솜아, 포켓몬을 잡을 때는, 일단 상대 포켓몬의 체력을 적당히 바닥으로 만들어놓고 몬스터 볼을 던져야 한단다. 자, 내 포켓몬 이상해꽃으로 한번 잡아보렴. 포켓몬의 기술을 쓰는 것을 보고 포켓몬을 줄지 안줄지 결정을 하겠네. 자 한번 해보아라. 다솜아.이다솜 : 이상해꽃이라...음.. 꽃이니깐 왠지 햇빛을 받아서 공격을 할 것 같은데... 음... 이상해꽃! 햇빛공격!!!(꼬렛이 이상해꽃에게 공격을 받아 체력이 25 감소했다.)    가라! 몬스터 볼!!!    (꼬렛을 잡았습니다.)    야호! 신난다. 꼬렛을 잡았다.오박사 : 오우!! 방금 쓴 공격은 솔라빔이라고 하네.. 어떻게 공격을 한 건가? 솔라빔이란 공격에 대해서 공부를 한 건가?이다솜 : 꽃이니깐 왠지 햇빛을 제대로 받으면 광합성을 해서 음.. 그냥 그럴 것 같아서요 ☞☜오박사 : 다른 아이들은 넝쿨채찍이나, 나뭇잎 공격을 하는데, 다솜이는 역시 뭔가 다르구나. 그럼 나와 함께 연구소로 가자꾸나. 내가 포켓몬을 한 마리 줄 테니, 너의 꿈을 펼쳐보아라. 꿈은 이루어진단다.이다솜 : 네! 오박사님, 고마워요.ㅜㅜ오박사 : 가자. 나의 연구소는 너의 옆집의 아랫집이란다. 같이 가도록하자. 지금 포켓몬을 주마.이다솜 : 네. 야호!!'오영식 : 어? 오박사님 얘는 누구인가요?오박사 : 얘는 너의 라이벌이 될 친구 이다솜이라고 하네. 자, 포켓몬을 한 마리 골라보도록 해봐라 다솜아. 레이디퍼스트 네가 먼저 골라봐라.이다솜 : 저는 생각해둔 포켓몬이 있어요. 피카츄 골라도 될까요?오박사 : 그래 여기 피카츄가 한 마리 있단다. 피카츄를 가져가거라.오영식 : 그럼 저는 이브이를 가져가겠어요. 그럼 나중에 보자 이다솜.이다솜 : 그럼 꼬렛을 다시 잡으러 가야겠다. 영식아, 그리고 민식박사님 빠잉!이다솜 : 피카츄 공격!가라 몬스터 볼!이다솜 : 야호! 신난다. 꼬렛을 잡았다!!!!!이다솜 : 그럼! 일단 사천왕을 이기고 오겠어!이다솜 : 여기가 사천왕과 대결하려면 가야하는 곳인가..경비원 : 사천왕과 대결을 하려면, 마을의 체육관 리더를 이겨서 배지를 8개를 모아야 한다네... 배지를 모아서 오도록 하게이다솜 : 잉ㅠㅜ... 그럼 배지부터 모아야 하는구나ㅠㅜㅠㅜ 나쁘당 그냥 좀 봐주지..<1 년 후>그동안의 줄거리 : 이다솜은 일단 상록 숲의 체육관 리더에게 도전을 했다. 하지만 상록숲 체육관의 리더는 실종된 상태. 따라서 회색마을부터 도전하기로 했다. 체육관의 리더를 이기면서, 로켓단을 해체시키기도 하고, 여러 가지 사건도 있었다. 결국 전설의 포켓몬도 잡고, 이제 사천왕을 이기려고 도전하기로 했다. 사천왕은 모두 가볍게 이기고, 이제 마지막 라이벌 오!영!식! 이다.오영식 : 훗. 1년 전의 그 이다솜이 사천왕을 이기고 현재 포켓몬 마스터인 나에게 덤벼? 어디 한번 덤벼보시지.이다솜 : 헐랭... 나를 우습게보네.... 한번 두고 보시지! 그럼 대결이닷!이다솜 : 휴... 이겼다.오영식 : 내가 지다니 분하다. ㅜㅜ오박사 : 그럼 다솜아 이제 진정한 포켓몬 마스터가 되기 위해 도감을 완성시키도록 하여라. 일단 네가 현재 가지고 있는 포켓몬 도감에서 포켓몬의 이름을 보면 포켓몬의 번호를 말하거나, 포켓몬의 번호를 보면 포켓몬의 이름을 말하는 연습을 하도록 하여라. 나의 시험을 통과하면, 내가 새로 만든 도감을 주도록 하겠네.",
    "input_description": "첫째 줄에는 도감에 수록되어 있는 포켓몬의 개수 N이랑 내가 맞춰야 하는 문제의 개수 M이 주어져. N과 M은 1보다 크거나 같고, 100,000보다 작거나 같은 자연수인데, 자연수가 뭔지는 알지? 모르면 물어봐도 괜찮아. 나는 언제든지 질문에 답해줄 준비가 되어있어.둘째 줄부터 N개의 줄에 포켓몬의 번호가 1번인 포켓몬부터 N번에 해당하는 포켓몬까지 한 줄에 하나씩 입력으로 들어와. 포켓몬의 이름은 모두 영어로만 이루어져있고, 또, 음... 첫 글자만 대문자이고, 나머지 문자는 소문자로만 이루어져 있어. 아참! 일부 포켓몬은 마지막 문자만 대문자일 수도 있어. 포켓몬 이름의 최대 길이는 20, 최소 길이는 2야. 그 다음 줄부터 총 M개의 줄에 내가 맞춰야하는 문제가 입력으로 들어와. 문제가 알파벳으로만 들어오면 포켓몬 번호를 말해야 하고, 숫자로만 들어오면, 포켓몬 번호에 해당하는 문자를 출력해야해. 입력으로 들어오는 숫자는 반드시 1보다 크거나 같고, N보다 작거나 같고, 입력으로 들어오는 문자는 반드시 도감에 있는 포켓몬의 이름만 주어져. 그럼 화이팅!!!",
    "output_description": "첫째 줄부터 차례대로 M개의 줄에 각각의 문제에 대한 답을 말해줬으면 좋겠어!!!. 입력으로 숫자가 들어왔다면 그 숫자에 해당하는 포켓몬의 이름을, 문자가 들어왔으면 그 포켓몬의 이름에 해당하는 번호를 출력하면 돼. 그럼 땡큐~이게 오박사님이 나에게 새로 주시려고 하는 도감이야. 너무 가지고 싶다ㅠㅜ. 꼭 만점을 받아줬으면 좋겠어!! 파이팅!!!",
    "examples": [
      {
        "input": "26 5\nBulbasaur\nIvysaur\nVenusaur\nCharmander\nCharmeleon\nCharizard\nSquirtle\nWartortle\nBlastoise\nCaterpie\nMetapod\nButterfree\nWeedle\nKakuna\nBeedrill\nPidgey\nPidgeotto\nPidgeot\nRattata\nRaticate\nSpearow\nFearow\nEkans\nArbok\nPikachu\nRaichu\n25\nRaichu\n3\nPidgey\nKakuna",
        "output": "Pikachu\n26\nVenusaur\n16\n14"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1620",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N, M = map(int, input().split())\n\nname_to_num = {}\nnum_to_name = {}\n\nfor i in range(1, N+1):\n    name = input()\n    name_to_num[name] = i\n    num_to_name[i] = name\n\nfor _ in range(M):\n    query = input()\n    if query.isdigit():\n        print(num_to_name[int(query)])\n    else:\n        print(name_to_num[query])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: 양방향 딕셔너리",
        "solution_code": "import sys\ninput = sys.stdin.readline\nN, M = map(int, input().split())\nname_to_num = {}\nnum_to_name = {}\nfor i in range(1, N+1):\n    name = input().strip()\n    name_to_num[name] = i\n    num_to_name[i] = name\nfor _ in range(M):\n    query = input().strip()\n    if query.isdigit():\n        print(num_to_name[int(query)])\n    else:\n        print(name_to_num[query])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "두 방향 매핑",
            "description": "이름→번호, 번호→이름 두 딕셔너리를 만듭니다.",
            "code_pattern": "name_to_num = {}\nnum_to_name = {}",
            "socratic_hint": "양방향 검색을 위해서는?",
            "hint": "두 개의 딕셔너리를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1629",
    "step_title": "분할 정복",
    "title": "곱셈",
    "level": 10,
    "tags": [
      "수학",
      "분할 정복을 이용한 거듭제곱"
    ],
    "description": "자연수 A를 B번 곱한 수를 알고 싶다. 단 구하려는 수가 매우 커질 수 있으므로 이를 C로 나눈 나머지를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 모두 2,147,483,647 이하의 자연수이다.",
    "output_description": "첫째 줄에 A를 B번 곱한 수를 C로 나눈 나머지를 출력한다.",
    "examples": [
      {
        "input": "10 11 12",
        "output": "4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1629",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def power(a, b, c):\n    if b == 0:\n        return 1\n    if b == 1:\n        return a % c\n    \n    half = power(a, b // 2, c)\n    if b % 2 == 0:\n        return (half * half) % c\n    else:\n        return (half * half * a) % c\n\nA, B, C = map(int, input().split())\nprint(power(A, B, C))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1644",
    "step_title": "투 포인터",
    "title": "소수의 연속합",
    "level": 13,
    "tags": [
      "수학",
      "정수론",
      "두 포인터",
      "소수 판정",
      "에라토스테네스의 체"
    ],
    "description": "하나 이상의 연속된 소수의 합으로 나타낼 수 있는 자연수들이 있다. 몇 가지 자연수의 예를 들어 보면 다음과 같다.3 : 3 (한 가지)41 : 2+3+5+7+11+13 = 11+13+17 = 41 (세 가지)53 : 5+7+11+13+17 = 53 (두 가지)하지만 연속된 소수의 합으로 나타낼 수 없는 자연수들도 있는데, 20이 그 예이다. 7+13을 계산하면 20이 되기는 하나 7과 13이 연속이 아니기에 적합한 표현이 아니다. 또한 한 소수는 반드시 한 번만 덧셈에 사용될 수 있기 때문에, 3+5+5+7과 같은 표현도 적합하지 않다.자연수가 주어졌을 때, 이 자연수를 연속된 소수의 합으로 나타낼 수 있는 경우의 수를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 4,000,000)",
    "output_description": "첫째 줄에 자연수 N을 연속된 소수의 합으로 나타낼 수 있는 경우의 수를 출력한다.",
    "examples": [
      {
        "input": "20",
        "output": "0"
      },
      {
        "input": "3",
        "output": "1"
      },
      {
        "input": "41",
        "output": "3"
      },
      {
        "input": "53",
        "output": "2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1644",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def sieve(n):\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n + 1, i):\n                is_prime[j] = False\n    \n    return [i for i in range(n + 1) if is_prime[i]]\n\nN = int(input())\nprimes = sieve(N)\n\nif not primes:\n    print(0)\nelse:\n    left = 0\n    current_sum = 0\n    count = 0\n    \n    for right in range(len(primes)):\n        current_sum += primes[right]\n        \n        while current_sum > N and left <= right:\n            current_sum -= primes[left]\n            left += 1\n        \n        if current_sum == N:\n            count += 1\n    \n    print(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1648",
    "step_title": "동적 계획법 4",
    "title": "격자판 채우기",
    "level": 18,
    "tags": [
      "다이나믹 프로그래밍",
      "비트마스킹",
      "비트필드를 이용한 다이나믹 프로그래밍"
    ],
    "description": "준규는 침대에 누워서 천장을 바라보고 있었다. 천장은 격자판 모양이었고, 계속해서 천장을 바라보다 보니 이런 생각이 들었다.세로 크기가 N이고, 가로 크기가 M인 격자판을 2x1 크기의 도미노를 이용해서 빈 공간이 없도록 채우는 방법의 수는 몇일까?아래 그림은 N = 3, M = 6인 예이다.N과 M이 주어졌을 때, 격자판을 2x1크기의 도미노로 채우는 방법의 수를 구하는 방법을 작성하시오. 도미노는 회전시켜 1x2크기로 채울 수 있다. 도미노로 모두 채웠을 때, 빈 칸이 존재하면 안 된다.",
    "input_description": "첫째 줄에 격자판의 세로 크기 N과 가로 크기 M이 주어진다.",
    "output_description": "첫째 줄에 주어진 격자판을 2x1크기의 도미노로 빈 공간이 없도록 채우는 방법의 수를 9901로 나눈 나머지를 출력한다.",
    "examples": [
      {
        "input": "3 6",
        "output": "41"
      },
      {
        "input": "5 5",
        "output": "0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1648",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1654",
    "step_title": "이분 탐색",
    "title": "랜선 자르기",
    "level": 9,
    "tags": [
      "이분 탐색",
      "매개 변수 탐색"
    ],
    "description": "집에서 시간을 보내던 오영식은 박성원의 부름을 받고 급히 달려왔다. 박성원이 캠프 때 쓸 N개의 랜선을 만들어야 하는데 너무 바빠서 영식이에게 도움을 청했다.이미 오영식은 자체적으로 K개의 랜선을 가지고 있다. 그러나 K개의 랜선은 길이가 제각각이다. 박성원은 랜선을 모두 N개의 같은 길이의 랜선으로 만들고 싶었기 때문에 K개의 랜선을 잘라서 만들어야 한다. 예를 들어 300cm 짜리 랜선에서 140cm 짜리 랜선을 두 개 잘라내면 20cm는 버려야 한다. (이미 자른 랜선은 붙일 수 없다.)편의를 위해 랜선을 자르거나 만들 때 손실되는 길이는 없다고 가정하며, 기존의 K개의 랜선으로 N개의 랜선을 만들 수 없는 경우는 없다고 가정하자. 그리고 자를 때는 항상 센티미터 단위로 정수길이만큼 자른다고 가정하자. N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다. 이때 만들 수 있는 최대 랜선의 길이를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에는 오영식이 이미 가지고 있는 랜선의 개수 K, 그리고 필요한 랜선의 개수 N이 입력된다. K는 1이상 10,000이하의 정수이고, N은 1이상 1,000,000이하의 정수이다. 그리고 항상 K ≦ N 이다. 그 후 K줄에 걸쳐 이미 가지고 있는 각 랜선의 길이가 센티미터 단위의 정수로 입력된다. 랜선의 길이는 231-1보다 작거나 같은 자연수이다.",
    "output_description": "첫째 줄에 N개를 만들 수 있는 랜선의 최대 길이를 센티미터 단위의 정수로 출력한다.",
    "examples": [
      {
        "input": "4 11\n802\n743\n457\n539",
        "output": "200"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1654",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def can_cut(length):\n    count = 0\n    for cable in cables:\n        count += cable // length\n    return count >= N\n\nK, N = map(int, input().split())\ncables = []\nfor _ in range(K):\n    cables.append(int(input()))\n\nleft, right = 1, max(cables)\nresult = 0\n\nwhile left <= right:\n    mid = (left + right) // 2\n    if can_cut(mid):\n        result = mid\n        left = mid + 1\n    else:\n        right = mid - 1\n\nprint(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1657",
    "step_title": "동적 계획법 4",
    "title": "두부장수 장홍준",
    "level": 18,
    "tags": [
      "다이나믹 프로그래밍",
      "비트마스킹",
      "비트필드를 이용한 다이나믹 프로그래밍"
    ],
    "description": "장홍준은 참 특이한 두부장수이다. 세로크기 N, 가로크기 M인 두부판을 가지고 2x1짜리 두부로 잘라서 판다. 그런데, 두부판의 위치마다 등급이 다르다. 그리고 2x1짜리에 등급이 어떻게 매겨지느냐에 따라 두부의 값도 천차만별이 된다. 다음 등급표를 보자.위의 표는 2x1짜리 두부의 등급에 따라 매겨지는 두부의 가격표다. 예를 들어 “AC\" 두부의 가격은 7이고, ”DB\" 두부의 가격은 3이다.세로크기 N, 가로크기 M의 두부판이 주어진다. 각 칸마다 두부의 등급이 A, B, C, D, F로 매겨져 있다. 홍준이는 전체 두부가격의 합을 최대가 되게 두부를 자르려고 한다. 2x1짜리 두부로 잘라내고 남은 한 칸짜리 두부는 가격이 0이기 때문에 버린다. 홍준이를 도와 가격이 최대가 되게 두부판을 자르는 프로그램을 작성하시오.위 그림은 N=4, M=4 인 두부판의 한 예이다. 오른쪽 그림이 잘라낸 두부가격의 합을 최대로 한 것이다. 한 칸짜리는 쓸모없으므로 버린다.",
    "input_description": "첫째 줄에는 두부판의 세로크기 N, 가로크기 M이 주어진다. N, M은 1이상 14이하의 정수이다. 그 다음 N줄에 걸쳐 M개의 문자가 주어진다. 각 문자는 그 칸의 두부의 등급을 나타내며 A, B, C, D, F 중 하나로 주어진다.",
    "output_description": "첫째 줄에 잘라낸 두부가격 합의 최댓값을 출력한다.",
    "examples": [
      {
        "input": "4 4\nACFC\nFDAB\nBACF\nDBAC",
        "output": "37"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1657",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1671",
    "step_title": "이분 매칭",
    "title": "상어의 저녁식사",
    "level": 18,
    "tags": [
      "이분 매칭"
    ],
    "description": "어떤 상어는 저녁식사로 서로를 먹는다. 모든 상어는 자신과 다른 상어의 크기, 속도, 지능을 수치로 나타낸 것을 알고 있다. 만약, 상어 A의 크기, 속도, 지능이 상어 B의 크기, 속도, 지능보다 크거나 같다면 상어 A는 상어 B를 먹을 수 있다. 그러나, 상어들의 왕 김재홍은 상어들이 많이 없어지는 것을 방지하기 위해서 한 상어가 최대 두 개의 상어만 먹을 수 있게 했다. 상어들은 김재홍의 말을 모두 듣는다.한 상어가 다른 상어를 잡아먹는 동안 나머지 상어들은 상어를 잡아먹을 수 없으며, 이미 잡아먹힌 상어는 다른 상어들을 잡아먹을 수 없다.N마리 상어의 크기, 속도, 지능이 주어졌을 때, 살아남을 수 있는 상어 수의 최솟값을 구하시오.",
    "input_description": "첫째 줄에 상어의 마리 수 N이 주어진다. 이 값은 50보다 작거나 같은 자연수이다. 둘째 줄부터 각 상어의 크기, 속도, 지능의 정보가 주어진다. 이 값은 2,000,000,000보다 작거나 같은 자연수이다.",
    "output_description": "첫째 줄에 살아남을 수 있는 상어 수의 최솟값을 출력한다.",
    "examples": [
      {
        "input": "5\n4 5 5\n10 10 8\n5 7 10\n8 7 7\n8 10 3",
        "output": "2"
      },
      {
        "input": "3\n1 2 1\n4 3 5\n3 1 2",
        "output": "1"
      },
      {
        "input": "5\n1 4 2\n2 3 4\n3 2 1\n4 1 3\n100 100 100",
        "output": "3"
      },
      {
        "input": "4\n4 3 8\n4 3 8\n4 3 8\n4 3 8",
        "output": "1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1671",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1688",
    "step_title": "기하 2",
    "title": "지민이의 테러",
    "level": 17,
    "tags": [
      "기하학",
      "선분 교차 판정",
      "오목 다각형 내부의 점 판정"
    ],
    "description": "지민이는 유명한 테러리스트이다. 지민이는 대연이, 영훈이, 범진이를 테러하려고 한다. 우석이는 대연이, 영훈이, 범진이를 테러에서 막아주려고 한다. 우석이는 지민이가 통과할 수 없는 방어막을 치려고 한다.대연이와, 영훈이와, 범진이의 현재 위치가 좌표로 주어질 때, 우석이가 얘네들을 테러에서 막아줄 수 있는지 없는지 구하는 프로그램을 작성하시오. 다각형 경계위에 있는 경우에는 보호되는 것이다.",
    "input_description": "첫째 줄에 방어막의 꼭짓점의 개수 N(3 ≤ N ≤ 10,000)이 주어진다. 이어서 N개의 줄에는 꼭짓점들의 좌표가 순서대로 주어진다. 시계방향으로 주어질 수도 있고, 반시계방향으로 주어질 수도 있다. 이어서 세 개의 줄에는 대연이, 영훈이, 범진이의 좌표가 주어진다. 모든 좌표를 이루는 수는 0 이상 1,000,000,000 이하의 정수이다.",
    "output_description": "세 줄에 입력된 순서대로 테러에서 막아줄 수 있으면 1, 없으면 0을 출력한다.",
    "examples": [
      {
        "input": "3\n1 0\n5 0\n3 3\n2 2\n3 2\n4 3",
        "output": "0\n1\n0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1688",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1697",
    "step_title": "그래프와 순회",
    "title": "숨바꼭질",
    "level": 10,
    "tags": [
      "그래프 이론",
      "그래프 탐색",
      "너비 우선 탐색"
    ],
    "description": "수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.",
    "input_description": "첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.",
    "output_description": "수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.",
    "examples": [
      {
        "input": "5 17",
        "output": "4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1697",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import deque\n\nN, K = map(int, input().split())\n\nif N == K:\n    print(0)\nelse:\n    visited = [False] * 100001\n    queue = deque([(N, 0)])\n    visited[N] = True\n    \n    while queue:\n        pos, time = queue.popleft()\n        \n        for next_pos in [pos - 1, pos + 1, pos * 2]:\n            if 0 <= next_pos <= 100000 and not visited[next_pos]:\n                if next_pos == K:\n                    print(time + 1)\n                    exit()\n                visited[next_pos] = True\n                queue.append((next_pos, time + 1))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1707",
    "step_title": "그래프와 순회",
    "title": "이분 그래프",
    "level": 12,
    "tags": [
      "그래프 이론",
      "그래프 탐색",
      "너비 우선 탐색",
      "깊이 우선 탐색",
      "이분 그래프"
    ],
    "description": "그래프의 정점의 집합을 둘로 분할하여, 각 집합에 속한 정점끼리는 서로 인접하지 않도록 분할할 수 있을 때, 그러한 그래프를 특별히 이분 그래프 (Bipartite Graph) 라 부른다.그래프가 입력으로 주어졌을 때, 이 그래프가 이분 그래프인지 아닌지 판별하는 프로그램을 작성하시오.",
    "input_description": "입력은 여러 개의 테스트 케이스로 구성되어 있는데, 첫째 줄에 테스트 케이스의 개수 K가 주어진다. 각 테스트 케이스의 첫째 줄에는 그래프의 정점의 개수 V와 간선의 개수 E가 빈 칸을 사이에 두고 순서대로 주어진다. 각 정점에는 1부터 V까지 차례로 번호가 붙어 있다. 이어서 둘째 줄부터 E개의 줄에 걸쳐 간선에 대한 정보가 주어지는데, 각 줄에 인접한 두 정점의 번호 u, v (u ≠ v)가 빈 칸을 사이에 두고 주어진다.",
    "output_description": "K개의 줄에 걸쳐 입력으로 주어진 그래프가 이분 그래프이면 YES, 아니면 NO를 순서대로 출력한다.",
    "examples": [
      {
        "input": "2\n3 2\n1 3\n2 3\n4 4\n1 2\n2 3\n3 4\n4 2",
        "output": "YES\nNO"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1707",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\ndef dfs(node, color):\n    visited[node] = color\n    \n    for next_node in graph[node]:\n        if visited[next_node] == 0:\n            if not dfs(next_node, 3 - color):\n                return False\n        elif visited[next_node] == color:\n            return False\n    \n    return True\n\nK = int(input())\nfor _ in range(K):\n    V, E = map(int, input().split())\n    graph = [[] for _ in range(V + 1)]\n    visited = [0] * (V + 1)\n    \n    for _ in range(E):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    is_bipartite = True\n    for i in range(1, V + 1):\n        if visited[i] == 0:\n            if not dfs(i, 1):\n                is_bipartite = False\n                break\n    \n    print(\"YES\" if is_bipartite else \"NO\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1708",
    "step_title": "기하 3",
    "title": "볼록 껍질",
    "level": 16,
    "tags": [
      "기하학",
      "볼록 껍질",
      "각도 정렬"
    ],
    "description": "다각형의 임의의 두 꼭짓점을 연결하는 선분이 항상 다각형 내부에 존재하는 다각형을 볼록 다각형이라고 한다. 아래 그림에서 (a)는 볼록 다각형이며, (b)는 볼록 다각형이 아니다.조금만 생각해 보면 다각형의 모든 내각이 180도 이하일 때 볼록 다각형이 된다는 것을 알 수 있다. 편의상 이 문제에서는 180도 미만인 경우만을 볼록 다각형으로 한정하도록 한다.2차원 평면에 N개의 점이 주어졌을 때, 이들 중 몇 개의 점을 골라 볼록 다각형을 만드는데, 나머지 모든 점을 내부에 포함하도록 할 수 있다. 이를 볼록 껍질 (CONVEX HULL) 이라 한다. 아래 그림은 N=10인 경우의 한 예이다.점의 집합이 주어졌을 때, 볼록 껍질을 이루는 점의 개수를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 점의 개수 N(3 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에 걸쳐 각 점의 x좌표와 y좌표가 빈 칸을 사이에 두고 주어진다. 주어지는 모든 점의 좌표는 다르다. x좌표와 y좌표의 범위는 절댓값 40,000을 넘지 않는다. 입력으로 주어지는 다각형의 모든 점이 일직선을 이루는 경우는 없다.",
    "output_description": "첫째 줄에 볼록 껍질을 이루는 점의 개수를 출력한다.볼록 껍질의 변에 점이 여러 개 있는 경우에는 가장 양 끝 점만 개수에 포함한다.",
    "examples": [
      {
        "input": "8\n1 1\n1 2\n1 3\n2 1\n2 2\n2 3\n3 1\n3 2",
        "output": "5"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1708",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1717",
    "step_title": "유니온 파인드 1",
    "title": "집합의 표현",
    "level": 11,
    "tags": [
      "자료 구조",
      "분리 집합"
    ],
    "description": "초기에 $n+1$개의 집합 $\\{0\\}, \\{1\\}, \\{2\\}, \\dots , \\{n\\}$이 있다. 여기에 합집합 연산과, 두 원소가 같은 집합에 포함되어 있는지를 확인하는 연산을 수행하려고 한다.집합을 표현하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 $n$, $m$이 주어진다. $m$은 입력으로 주어지는 연산의 개수이다. 다음 $m$개의 줄에는 각각의 연산이 주어진다. 합집합은 $0$ $a$ $b$의 형태로 입력이 주어진다. 이는 $a$가 포함되어 있는 집합과, $b$가 포함되어 있는 집합을 합친다는 의미이다. 두 원소가 같은 집합에 포함되어 있는지를 확인하는 연산은 $1$ $a$ $b$의 형태로 입력이 주어진다. 이는 $a$와 $b$가 같은 집합에 포함되어 있는지를 확인하는 연산이다.",
    "output_description": "1로 시작하는 입력에 대해서 $a$와 $b$가 같은 집합에 포함되어 있으면 \"YES\" 또는 \"yes\"를, 그렇지 않다면 \"NO\" 또는 \"no\"를 한 줄에 하나씩 출력한다.",
    "examples": [
      {
        "input": "7 8\n0 1 3\n1 1 7\n0 7 6\n1 7 1\n0 3 7\n0 4 2\n0 1 1\n1 1 1",
        "output": "NO\nNO\nYES"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1717",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\ndef find(x):\n    if parent[x] != x:\n        parent[x] = find(parent[x])\n    return parent[x]\n\ndef union(x, y):\n    x = find(x)\n    y = find(y)\n    if x != y:\n        parent[y] = x\n\nn, m = map(int, input().split())\nparent = list(range(n + 1))\n\nfor _ in range(m):\n    op, a, b = map(int, input().split())\n    if op == 0:\n        union(a, b)\n    else:\n        if find(a) == find(b):\n            print(\"YES\")\n        else:\n            print(\"NO\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1725",
    "step_title": "스택, 큐, 덱 2",
    "title": "히스토그램",
    "level": 16,
    "tags": [
      "자료 구조",
      "세그먼트 트리",
      "분할 정복",
      "스택"
    ],
    "description": "히스토그램에 대해서 알고 있는가? 히스토그램은 아래와 같은 막대그래프를 말한다.각 칸의 간격은 일정하고, 높이는 어떤 정수로 주어진다. 위 그림의 경우 높이가 각각 2 1 4 5 1 3 3이다.이러한 히스토그램의 내부에 가장 넓이가 큰 직사각형을 그리려고 한다. 아래 그림의 빗금 친 부분이 그 예이다. 이 직사각형의 밑변은 항상 히스토그램의 아랫변에 평행하게 그려져야 한다.주어진 히스토그램에 대해, 가장 큰 직사각형의 넓이를 구하는 프로그램을 작성하시오.",
    "input_description": "첫 행에는 N (1 ≤ N ≤ 100,000) 이 주어진다. N은 히스토그램의 가로 칸의 수이다. 다음 N 행에 걸쳐 각 칸의 높이가 왼쪽에서부터 차례대로 주어진다. 각 칸의 높이는 1,000,000,000보다 작거나 같은 자연수 또는 0이다.",
    "output_description": "첫째 줄에 가장 큰 직사각형의 넓이를 출력한다. 이 값은 20억을 넘지 않는다.",
    "examples": [
      {
        "input": "7\n2\n1\n4\n5\n1\n3\n3",
        "output": "8"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1725",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nheights = []\nfor _ in range(N):\n    heights.append(int(input()))\n\nstack = []\nmax_area = 0\n\nfor i, h in enumerate(heights):\n    while stack and heights[stack[-1]] > h:\n        height = heights[stack.pop()]\n        width = i if not stack else i - stack[-1] - 1\n        max_area = max(max_area, height * width)\n    stack.append(i)\n\nwhile stack:\n    height = heights[stack.pop()]\n    width = N if not stack else N - stack[-1] - 1\n    max_area = max(max_area, height * width)\n\nprint(max_area)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1735",
    "step_title": "약수, 배수와 소수 2",
    "title": "분수 합",
    "level": 8,
    "tags": [
      "수학",
      "정수론",
      "유클리드 호제법"
    ],
    "description": "분수 A/B는 분자가 A, 분모가 B인 분수를 의미한다. A와 B는 모두 자연수라고 하자.두 분수의 합 또한 분수로 표현할 수 있다. 두 분수가 주어졌을 때, 그 합을 기약분수의 형태로 구하는 프로그램을 작성하시오. 기약분수란 더 이상 약분되지 않는 분수를 의미한다.",
    "input_description": "첫째 줄과 둘째 줄에, 각 분수의 분자와 분모를 뜻하는 두 개의 자연수가 순서대로 주어진다. 입력되는 네 자연수는 모두 30,000 이하이다.",
    "output_description": "첫째 줄에 구하고자 하는 기약분수의 분자와 분모를 뜻하는 두 개의 자연수를 빈 칸을 사이에 두고 순서대로 출력한다.",
    "examples": [
      {
        "input": "2 7\r\n3 5",
        "output": "31 35"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1735",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import math\n\nA, B = map(int, input().split())\nC, D = map(int, input().split())\n\nnumerator = A * D + C * B\ndenominator = B * D\n\ngcd = math.gcd(numerator, denominator)\nprint(numerator // gcd, denominator // gcd)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1753",
    "step_title": "최단 경로",
    "title": "최단경로",
    "level": 12,
    "tags": [
      "그래프 이론",
      "최단 경로",
      "데이크스트라"
    ],
    "description": "방향그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하는 프로그램을 작성하시오. 단, 모든 간선의 가중치는 10 이하의 자연수이다.",
    "input_description": "첫째 줄에 정점의 개수 V와 간선의 개수 E가 주어진다. (1 ≤ V ≤ 20,000, 1 ≤ E ≤ 300,000) 모든 정점에는 1부터 V까지 번호가 매겨져 있다고 가정한다. 둘째 줄에는 시작 정점의 번호 K(1 ≤ K ≤ V)가 주어진다. 셋째 줄부터 E개의 줄에 걸쳐 각 간선을 나타내는 세 개의 정수 (u, v, w)가 순서대로 주어진다. 이는 u에서 v로 가는 가중치 w인 간선이 존재한다는 뜻이다. u와 v는 서로 다르며 w는 10 이하의 자연수이다. 서로 다른 두 정점 사이에 여러 개의 간선이 존재할 수도 있음에 유의한다.",
    "output_description": "첫째 줄부터 V개의 줄에 걸쳐, i번째 줄에 i번 정점으로의 최단 경로의 경로값을 출력한다. 시작점 자신은 0으로 출력하고, 경로가 존재하지 않는 경우에는 INF를 출력하면 된다.",
    "examples": [
      {
        "input": "5 6\n1\n5 1 1\n1 2 2\n1 3 3\n2 3 4\n2 4 5\n3 4 6",
        "output": "0\n2\n3\n7\nINF"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1753",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import heapq\nimport sys\ninput = sys.stdin.readline\n\nV, E = map(int, input().split())\nK = int(input())\n\ngraph = [[] for _ in range(V + 1)]\nfor _ in range(E):\n    u, v, w = map(int, input().split())\n    graph[u].append((v, w))\n\ndist = [float('inf')] * (V + 1)\ndist[K] = 0\n\nheap = [(0, K)]\n\nwhile heap:\n    d, node = heapq.heappop(heap)\n    \n    if d > dist[node]:\n        continue\n    \n    for next_node, weight in graph[node]:\n        if dist[node] + weight < dist[next_node]:\n            dist[next_node] = dist[node] + weight\n            heapq.heappush(heap, (dist[next_node], next_node))\n\nfor i in range(1, V + 1):\n    print(dist[i] if dist[i] != float('inf') else \"INF\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1762",
    "step_title": "평방 분할",
    "title": "평면그래프와 삼각형",
    "level": 18,
    "tags": [
      "그래프 이론",
      "이분 탐색",
      "집합과 맵",
      "평면 그래프"
    ],
    "description": "N(1 ≤ N ≤ 100,000)개의 정점으로 이루어진 평면그래프가 있다. 이 평면그래프에 삼각형, 즉 길이가 3인 사이클이 몇 개나 존재하는지 알아내는 프로그램을 작성하시오.평면그래프란, 열심히 노력하면 간선들이 서로 겹치지 않도록 평면상에 그릴 수 있는 그래프를 말한다.서로 다른 세 정점 x, y, z가 있을 때, x-y, y-z, z-x의 세 간선이 존재하면 세 정점 x, y, z는 삼각형을 이루고 있다고 한다.정점은 1번부터 N번까지 번호가 매겨져 있다.",
    "input_description": "첫째 줄에 두 정수 N, M이 주어진다. M은 간선의 개수를 나타내는 0 이상 300,000 이하의 정수이다. 다음 M개의 줄에는 각 간선이 연결하는 서로 다른 두 정점의 번호가 주어진다. 같은 간선이 중복되어 입력으로 주어지지 않으며, 간선들에는 방향성이 없다.",
    "output_description": "첫째 줄에 삼각형의 개수를 출력한다.",
    "examples": [
      {
        "input": "4 6\n1 2\n3 1\n2 3\n4 2\n4 1\n3 4",
        "output": "4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1762",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1764",
    "step_title": "집합과 맵",
    "title": "듣보잡",
    "level": 7,
    "tags": [
      "자료 구조",
      "문자열",
      "정렬",
      "집합과 맵",
      "해시를 사용한 집합과 맵"
    ],
    "description": "김진영이 듣도 못한 사람의 명단과, 보도 못한 사람의 명단이 주어질 때, 듣도 보도 못한 사람의 명단을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 듣도 못한 사람의 수 N, 보도 못한 사람의 수 M이 주어진다. 이어서 둘째 줄부터 N개의 줄에 걸쳐 듣도 못한 사람의 이름과, N+2째 줄부터 보도 못한 사람의 이름이 순서대로 주어진다. 이름은 띄어쓰기 없이 알파벳 소문자로만 이루어지며, 그 길이는 20 이하이다. N, M은 500,000 이하의 자연수이다.듣도 못한 사람의 명단에는 중복되는 이름이 없으며, 보도 못한 사람의 명단도 마찬가지이다.",
    "output_description": "듣보잡의 수와 그 명단을 사전순으로 출력한다.",
    "examples": [
      {
        "input": "3 4\nohhenrie\ncharlie\nbaesangwook\nobama\nbaesangwook\nohhenrie\nclinton",
        "output": "2\nbaesangwook\nohhenrie"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1764",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N, M = map(int, input().split())\nnot_heard = set()\nfor _ in range(N):\n    not_heard.add(input())\n\nnot_seen = set()\nfor _ in range(M):\n    not_seen.add(input())\n\nresult = sorted(not_heard & not_seen)\nprint(len(result))\nfor name in result:\n    print(name)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n, m = map(int, input().split())\nnot_heard = set()\nfor _ in range(n):\n    not_heard.add(input().strip())\nnot_seen = set()\nfor _ in range(m):\n    not_seen.add(input().strip())\nresult = sorted(not_heard & not_seen)\nprint(len(result))\nfor name in result:\n    print(name)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3",
        "solution_code": "n, m = map(int, input().split())\nnot_heard = set()\nfor _ in range(n):\n    not_heard.add(input().strip())\nnot_seen = set()\nfor _ in range(m):\n    not_seen.add(input().strip())\nresult = list(not_heard & not_seen)\n\nfor i in range(len(result)-1):\n    for j in range(len(result)-1-i):\n        if result[j] > result[j+1]:\n            result[j], result[j+1] = result[j+1], result[j]\n\nprint(len(result))\nfor name in result:\n    print(name)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 패스 횟수 제어",
            "description": "n-1번 반복하며 각 패스를 수행합니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "버블 정렬에서 몇 번의 패스가 필요한가요?",
            "hint": "n-1번의 패스가 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "내부 반복문: 인접 원소 비교",
            "description": "각 패스에서 인접한 두 원소를 비교합니다. 이미 정렬된 뒤쪽 부분은 제외합니다.",
            "code_pattern": "for j in range(n-1-i):",
            "socratic_hint": "각 패스에서 비교해야 할 원소의 범위는?",
            "hint": "n-1-i까지 비교합니다 (이미 정렬된 부분 제외)."
          },
          {
            "step_id": 4,
            "goal": "원소 교환",
            "description": "왼쪽 원소가 오른쪽 원소보다 크면 위치를 교환합니다.",
            "code_pattern": "if arr[j] > arr[j+1]:\n    arr[j], arr[j+1] = arr[j+1], arr[j]",
            "socratic_hint": "인접한 두 원소의 순서가 잘못되었을 때 어떻게 하나요?",
            "hint": "두 원소의 위치를 swap합니다."
          },
          {
            "step_id": 5,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4",
        "solution_code": "n, m = map(int, input().split())\nnot_heard = set()\nfor _ in range(n):\n    not_heard.add(input().strip())\nnot_seen = set()\nfor _ in range(m):\n    not_seen.add(input().strip())\nresult = list(not_heard & not_seen)\n\nfor i in range(len(result)-1):\n    min_idx = i\n    for j in range(i+1, len(result)):\n        if result[j] < result[min_idx]:\n            min_idx = j\n    result[i], result[min_idx] = result[min_idx], result[i]\n\nprint(len(result))\nfor name in result:\n    print(name)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 정렬할 위치 선택",
            "description": "n-1번 반복하며 각 위치에 올 최솟값을 찾습니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "선택 정렬에서 몇 번의 선택이 필요한가요?",
            "hint": "n-1번의 선택이 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "최솟값 인덱스 초기화",
            "description": "현재 위치를 최솟값 인덱스로 가정합니다.",
            "code_pattern": "min_idx = i",
            "socratic_hint": "최솟값을 찾기 위한 초기값은?",
            "hint": "현재 위치 i를 초기값으로 설정합니다."
          },
          {
            "step_id": 4,
            "goal": "내부 반복문: 최솟값 찾기",
            "description": "현재 위치 이후의 원소들 중 최솟값의 인덱스를 찾습니다.",
            "code_pattern": "for j in range(i+1, n):\n    if arr[j] < arr[min_idx]:\n        min_idx = j",
            "socratic_hint": "정렬되지 않은 부분에서 최솟값을 어떻게 찾나요?",
            "hint": "i+1부터 끝까지 순회하며 최솟값 인덱스를 업데이트합니다."
          },
          {
            "step_id": 5,
            "goal": "원소 교환",
            "description": "찾은 최솟값을 현재 위치로 이동시킵니다.",
            "code_pattern": "arr[i], arr[min_idx] = arr[min_idx], arr[i]",
            "socratic_hint": "최솟값을 현재 위치로 가져오려면?",
            "hint": "현재 위치의 값과 최솟값을 swap합니다."
          },
          {
            "step_id": 6,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1765",
    "step_title": "유니온 파인드 2",
    "title": "닭싸움 팀 정하기",
    "level": 14,
    "tags": [
      "그래프 이론",
      "자료 구조",
      "그래프 탐색",
      "분리 집합"
    ],
    "description": "닭싸움은 월드의 전통이다. 이번 캠프에서도 어김없이 닭싸움 대회가 열렸다. 그런데, 닭싸움을 하기 위해서는 반드시 누가 우리 편이고, 누가 우리 편이 아닌지를 알아야 할 것이다. 닭싸움의 팀을 정하는 원칙은, 평소 학생들의 인간관계에 따라 다음과 같이 정리할 수 있다.내 친구의 친구는 내 친구이다.내 원수의 원수도 내 친구이다.이 때 두 학생이 친구이면 같은 팀에 속해있어야 하며, 같은 팀에 속해 있는 사람들끼리는 전부 친구여야 한다.학생들의 인간관계가 주어지면, 닭싸움을 위한 팀 정하기를 할 때, 최대 얼마나 많은 팀이 만들어질 수 있는지 알아내는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 학생의 수 n이 주어진다. 각 학생들은 1부터 n까지 번호가 매겨져 있다. (2 ≤ n ≤ 1000)둘째 줄에 학생 간의 인간관계 중 알려진 것의 개수 m이 주어진다. (1 ≤ m ≤ 5000)다음 m개의 줄에는 한 줄에 한 개씩, 학생 간의 인간관계가 F p q 혹은 E p q의 형태로 공백으로 구분되어 주어진다. (1 ≤ p < q ≤ n)첫 번째 글자가 F인 경우에는 p와 q가 친구인 것이고, E인 경우는 p와 q가 원수인 경우이다.입력은 모순이 없음이 보장된다. 즉, 두 학생이 동시에 친구이면서 원수인 경우는 없다.",
    "output_description": "첫째 줄에, 가능한 최대 팀 개수를 출력한다.",
    "examples": [
      {
        "input": "6\n4\nE 1 4\nF 3 5\nF 4 6\nE 1 2",
        "output": "3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1765",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1766",
    "step_title": "위상 정렬",
    "title": "문제집",
    "level": 14,
    "tags": [
      "그래프 이론",
      "자료 구조",
      "우선순위 큐",
      "방향 비순환 그래프",
      "위상 정렬"
    ],
    "description": "민오는 1번부터 N번까지 총 N개의 문제로 되어 있는 문제집을 풀려고 한다. 문제는 난이도 순서로 출제되어 있다. 즉 1번 문제가 가장 쉬운 문제이고 N번 문제가 가장 어려운 문제가 된다.어떤 문제부터 풀까 고민하면서 문제를 훑어보던 민오는, 몇몇 문제들 사이에는 '먼저 푸는 것이 좋은 문제'가 있다는 것을 알게 되었다. 예를 들어 1번 문제를 풀고 나면 4번 문제가 쉽게 풀린다거나 하는 식이다. 민오는 다음의 세 가지 조건에 따라 문제를 풀 순서를 정하기로 하였다.N개의 문제는 모두 풀어야 한다.먼저 푸는 것이 좋은 문제가 있는 문제는, 먼저 푸는 것이 좋은 문제를 반드시 먼저 풀어야 한다.가능하면 쉬운 문제부터 풀어야 한다.예를 들어서 네 개의 문제가 있다고 하자. 4번 문제는 2번 문제보다 먼저 푸는 것이 좋고, 3번 문제는 1번 문제보다 먼저 푸는 것이 좋다고 하자. 만일 4-3-2-1의 순서로 문제를 풀게 되면 조건 1과 조건 2를 만족한다. 하지만 조건 3을 만족하지 않는다. 4보다 3을 충분히 먼저 풀 수 있기 때문이다. 따라서 조건 3을 만족하는 문제를 풀 순서는 3-1-4-2가 된다.문제의 개수와 먼저 푸는 것이 좋은 문제에 대한 정보가 주어졌을 때, 주어진 조건을 만족하면서 민오가 풀 문제의 순서를 결정해 주는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 문제의 수 N(1 ≤ N ≤ 32,000)과 먼저 푸는 것이 좋은 문제에 대한 정보의 개수 M(1 ≤ M ≤ 100,000)이 주어진다. 둘째 줄부터 M개의 줄에 걸쳐 두 정수의 순서쌍 A,B가 빈칸을 사이에 두고 주어진다. 이는 A번 문제는 B번 문제보다 먼저 푸는 것이 좋다는 의미이다.항상 문제를 모두 풀 수 있는 경우만 입력으로 주어진다.",
    "output_description": "첫째 줄에 문제 번호를 나타내는 1 이상 N 이하의 정수들을 민오가 풀어야 하는 순서대로 빈칸을 사이에 두고 출력한다.",
    "examples": [
      {
        "input": "4 2\r\n4 2\r\n3 1",
        "output": "3 1 4 2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1766",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import heapq\nimport sys\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\nindegree = [0] * (N + 1)\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    indegree[b] += 1\n\nheap = []\nfor i in range(1, N + 1):\n    if indegree[i] == 0:\n        heapq.heappush(heap, i)\n\nresult = []\nwhile heap:\n    node = heapq.heappop(heap)\n    result.append(node)\n    \n    for next_node in graph[node]:\n        indegree[next_node] -= 1\n        if indegree[next_node] == 0:\n            heapq.heappush(heap, next_node)\n\nprint(' '.join(map(str, result)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1774",
    "step_title": "최소 신장 트리",
    "title": "우주신과의 교감",
    "level": 13,
    "tags": [
      "그래프 이론",
      "최소 스패닝 트리"
    ],
    "description": "황선자씨는 우주신과 교감을 할수 있는 채널러 이다. 하지만 우주신은 하나만 있는 것이 아니기때문에 황선자 씨는 매번 여럿의 우주신과 교감하느라 힘이 든다. 이러던 와중에 새로운 우주신들이 황선자씨를 이용하게 되었다.하지만 위대한 우주신들은 바로 황선자씨와 연결될 필요가 없다. 이미 황선자씨와 혹은 이미 우주신끼리 교감할 수 있는 우주신들이 있기 때문에 새로운 우주신들은 그 우주신들을 거쳐서 황선자 씨와 교감을 할 수 있다.우주신들과의 교감은 우주신들과 황선자씨 혹은 우주신들 끼리 이어진 정신적인 통로를 통해 이루어 진다. 하지만 우주신들과 교감하는 것은 힘든 일이기 때문에 황선자씨는 이런 통로들이 긴 것을 좋아하지 않는다. 왜냐하면 통로들이 길 수록 더 힘이 들기 때문이다.또한 우리들은 3차원 좌표계로 나타낼 수 있는 세상에 살고 있지만 우주신들과 황선자씨는 2차원 좌표계로 나타낼 수 있는 세상에 살고 있다. 통로들의 길이는 2차원 좌표계상의 거리와 같다.이미 황선자씨와 연결된, 혹은 우주신들과 연결된 통로들이 존재한다. 우리는 황선자 씨를 도와 아직 연결이 되지 않은 우주신들을 연결해 드려야 한다. 새로 만들어야 할 정신적인 통로의 길이들이 합이 최소가 되게 통로를 만들어 “빵상”을 외칠수 있게 도와주자.",
    "input_description": "첫째 줄에 우주신들의 개수 $N$ ($1 \\le 1\\,000$) 이미 연결된 신들과의 통로의 개수$M$ ($1 \\le M \\le 1\\,000$)가 주어진다.두 번째 줄부터 $N$개의 줄에는 황선자를 포함하여 우주신들의 좌표가 $X$, $Y$ ($0 \\le X, Y \\le 1\\,000\\,000$)가 주어진다. 그 밑으로 $M$개의 줄에는 이미 연결된 통로가 주어진다. 번호는 위의 입력받은 좌표들의 순서라고 생각하면 된다. 좌표는 정수이다.",
    "output_description": "첫째 줄에 만들어야 할 최소의 통로 길이를 소수점 둘째 자리까지 반올림하여 출력하라.",
    "examples": [
      {
        "input": "4 1\n1 1\n3 1\n2 3\n4 3\n1 4",
        "output": "4.00"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1774",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nimport math\ninput = sys.stdin.readline\n\ndef find(x):\n    if parent[x] != x:\n        parent[x] = find(parent[x])\n    return parent[x]\n\ndef union(a, b):\n    a = find(a)\n    b = find(b)\n    if a < b:\n        parent[b] = a\n    else:\n        parent[a] = b\n\nN, M = map(int, input().split())\ngods = [tuple(map(int, input().split())) for _ in range(N)]\n\nparent = list(range(N + 1))\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    union(a, b)\n\nedges = []\nfor i in range(N):\n    for j in range(i + 1, N):\n        dist = math.sqrt((gods[i][0] - gods[j][0])**2 + (gods[i][1] - gods[j][1])**2)\n        edges.append((dist, i + 1, j + 1))\n\nedges.sort()\n\ntotal = 0\nfor dist, a, b in edges:\n    if find(a) != find(b):\n        union(a, b)\n        total += dist\n\nprint(f\"{total:.2f}\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1780",
    "step_title": "분할 정복",
    "title": "종이의 개수",
    "level": 9,
    "tags": [
      "분할 정복",
      "재귀"
    ],
    "description": "N×N크기의 행렬로 표현되는 종이가 있다. 종이의 각 칸에는 -1, 0, 1 중 하나가 저장되어 있다. 우리는 이 행렬을 다음과 같은 규칙에 따라 적절한 크기로 자르려고 한다.만약 종이가 모두 같은 수로 되어 있다면 이 종이를 그대로 사용한다.(1)이 아닌 경우에는 종이를 같은 크기의 종이 9개로 자르고, 각각의 잘린 종이에 대해서 (1)의 과정을 반복한다.이와 같이 종이를 잘랐을 때, -1로만 채워진 종이의 개수, 0으로만 채워진 종이의 개수, 1로만 채워진 종이의 개수를 구해내는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N(1 ≤ N ≤ 37, N은 3k꼴)이 주어진다. 다음 N개의 줄에는 N개의 정수로 행렬이 주어진다.",
    "output_description": "첫째 줄에 -1로만 채워진 종이의 개수를, 둘째 줄에 0으로만 채워진 종이의 개수를, 셋째 줄에 1로만 채워진 종이의 개수를 출력한다.",
    "examples": [
      {
        "input": "9\n0 0 0 1 1 1 -1 -1 -1\n0 0 0 1 1 1 -1 -1 -1\n0 0 0 1 1 1 -1 -1 -1\n1 1 1 0 0 0 0 0 0\n1 1 1 0 0 0 0 0 0\n1 1 1 0 0 0 0 0 0\n0 1 -1 0 1 -1 0 1 -1\n0 -1 1 0 1 -1 0 1 -1\n0 1 -1 1 0 -1 0 1 -1",
        "output": "10\n12\n11"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1780",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def count_paper(x, y, n):\n    global minus, zero, plus\n    \n    first = paper[x][y]\n    same = True\n    \n    for i in range(x, x + n):\n        for j in range(y, y + n):\n            if paper[i][j] != first:\n                same = False\n                break\n        if not same:\n            break\n    \n    if same:\n        if first == -1:\n            minus += 1\n        elif first == 0:\n            zero += 1\n        else:\n            plus += 1\n    else:\n        third = n // 3\n        for i in range(3):\n            for j in range(3):\n                count_paper(x + i * third, y + j * third, third)\n\nN = int(input())\npaper = []\nfor _ in range(N):\n    paper.append(list(map(int, input().split())))\n\nminus = 0\nzero = 0\nplus = 0\n\ncount_paper(0, 0, N)\n\nprint(minus)\nprint(zero)\nprint(plus)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1786",
    "step_title": "문자열 알고리즘 1",
    "title": "찾기",
    "level": 16,
    "tags": [
      "문자열",
      "KMP"
    ],
    "description": "워드프로세서 등을 사용하는 도중에 찾기 기능을 이용해 본 일이 있을 것이다. 이 기능을 여러분이 실제로 구현해 보도록 하자.두 개의 문자열 P와 T에 대해, 문자열 P가 문자열 T 중간에 몇 번, 어느 위치에서 나타나는지 알아내는 문제를 '문자열 매칭'이라고 한다. 워드프로세서의 찾기 기능은 이 문자열 매칭 문제를 풀어주는 기능이라고 할 수 있다. 이때의 P는 패턴이라고 부르고 T는 텍스트라고 부른다.편의상 T의 길이를 n, P의 길이를 m이라고 하자. 일반적으로, n ≥ m이라고 가정해도 무리가 없다.  n<m이면 어차피 P는 T중간에 나타날 수 없기 때문이다. 또, T의 i번째 문자를 T[i]라고 표현하도록 하자. 그러면 물론, P의 i번째 문자는 P[i]라고 표현된다.1 2 3 4 5 6 7 8 9 …\r\nT : [ A B C D A B C D A B D E ]\r\n      | | | | | | X\r\nP : [ A B C D A B D ]\r\n      1 2 3 4 5 6 7문자열 P가 문자열 T 중간에 나타난다는 것, 즉 문자열 P가 문자열 T와 매칭을 이룬다는 것이 어떤 것인지 위와 아래의 두 예를 통해 알아보자. 위의 예에서 P는, T의 1번 문자에서 시작하는 매칭에 실패했다. T의 7번 문자 T[7]과, P의 7번 문자 P[7]이 서로 다르기 때문이다.그러나 아래의 예에서 P는, T의 5번 문자에서 시작하는 매칭에 성공했다. T의 5～11번 문자와 P의 1～7번 문자가 서로 하나씩 대응되기 때문이다.1 2 3 4 5 6 7 8 9 …\r\nT : [ A B C D A B C D A B D E ]\r\n              | | | | | | |\r\nP :         [ A B C D A B D ]\r\n              1 2 3 4 5 6 7가장 단순한 방법으로, 존재하는 모든 매칭을 확인한다면, 시간복잡도가 어떻게 될까? T의 1번 문자에서 시작하는 매칭이 가능한지 알아보기 위해서, T의 1～m번 문자와 P의 1～m번 문자를 비교한다면 최대 m번의 연산이 필요하다. 이 비교들이 끝난 후, T의 2번 문자에서 시작하는 매칭이 가능한지 알아보기 위해서, T의 2～m+1번 문자와 P의 1～m번 문자를 비교한다면 다시 최대 m번의 연산이 수행된다. 매칭은 T의 n-m+1번 문자에서까지 시작할 수 있으므로, 이러한 방식으로 진행한다면 O( (n-m+1) × m ) = O(nm) 의 시간복잡도를 갖는 알고리즘이 된다.더 좋은 방법은 없을까? 물론 있다. 위에 제시된 예에서, T[7] ≠ P[7] 이므로 T의 1번 문자에서 시작하는 매칭이 실패임을 알게 된 순간으로 돌아가자. 이때 우리는 매칭이 실패라는 사실에서, T[7] ≠ P[7] 라는 정보만을 얻은 것이 아니다. 오히려 i=1…6에 대해 T[i] = P[i] 라고 하는 귀중한 정보를 얻지 않았는가? 이 정보를 십분 활용하면, O(n)의 시간복잡도 내에 문자열 매칭 문제를 풀어내는 알고리즘을 설계할 수 있다.P 내부에 존재하는 문자열의 반복에 주목하자. P에서 1, 2번 문자 A, B는 5, 6번 문자로 반복되어 나타난다. 또, T의 1번 문자에서 시작하는 매칭이 7번 문자에서야 실패했으므로 T의 5, 6번 문자도 A, B이다.따라서 T의 1번 문자에서 시작하는 매칭이 실패한 이후, 그 다음으로 가능한 매칭은 T의 5번 문자에서 시작하는 매칭임을 알 수 있다! 더불어, T의 5～6번 문자는 P의 1～2번 문자와 비교하지 않아도, 서로 같다는 것을 이미 알고 있다! 그러므로 이제는 T의 7번 문자와 P의 3번 문자부터 비교해 나가면 된다.이제 이 방법을 일반화 해 보자. T의 i번 문자에서 시작하는 매칭을 검사하던 중 T[i+j-1] ≠ P[j]임을 발견했다고 하자. 이렇게 P의 j번 문자에서 매칭이 실패한 경우, P[1…k] = P[j-k…j-1]을 만족하는 최대의 k(≠j-1)에 대해 T의 i+j-1번 문자와 P의 k+1번 문자부터 비교를 계속해 나가면 된다.이 최대의 k를 j에 대한 함수라고 생각하고, 1～m까지의 각 j값에 대해 최대의 k를 미리 계산해 놓으면 편리할 것이다. 이를 전처리 과정이라고 부르며, O(m)에 완료할 수 있다.이러한 원리를 이용하여, T와 P가 주어졌을 때, 문자열 매칭 문제를 해결하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 문자열 T가, 둘째 줄에 문자열 P가 주어진다. T와 P의 길이 n, m은 1이상 100만 이하이고, 알파벳 대소문자와 공백으로만 이루어져 있다.",
    "output_description": "첫째 줄에, T 중간에 P가 몇 번 나타나는지를 나타내는 음이 아닌 정수를 출력한다. 둘째 줄에는 P가 나타나는 위치를 차례대로 공백으로 구분해 출력한다. 예컨대, T의 i～i+m-1번 문자와 P의 1～m번 문자가 차례로 일치한다면, i를 출력하는 식이다.",
    "examples": [
      {
        "input": "ABC ABCDAB ABCDABCDABDE\nABCDABD",
        "output": "1\n16"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1786",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def kmp(text, pattern):\n    n, m = len(text), len(pattern)\n    \n    # failure function\n    pi = [0] * m\n    j = 0\n    for i in range(1, m):\n        while j > 0 and pattern[i] != pattern[j]:\n            j = pi[j-1]\n        if pattern[i] == pattern[j]:\n            j += 1\n            pi[i] = j\n    \n    # search\n    result = []\n    j = 0\n    for i in range(n):\n        while j > 0 and text[i] != pattern[j]:\n            j = pi[j-1]\n        if text[i] == pattern[j]:\n            if j == m - 1:\n                result.append(i - m + 2)\n                j = pi[j]\n            else:\n                j += 1\n    \n    return result\n\nT = input()\nP = input()\n\nresult = kmp(T, P)\nprint(len(result))\nfor pos in result:\n    print(pos)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1806",
    "step_title": "투 포인터",
    "title": "부분합",
    "level": 12,
    "tags": [
      "누적 합",
      "두 포인터"
    ],
    "description": "10,000 이하의 자연수로 이루어진 길이 N짜리 수열이 주어진다. 이 수열에서 연속된 수들의 부분합 중에 그 합이 S 이상이 되는 것 중, 가장 짧은 것의 길이를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N (10 ≤ N < 100,000)과 S (0 < S ≤ 100,000,000)가 주어진다. 둘째 줄에는 수열이 주어진다. 수열의 각 원소는 공백으로 구분되어져 있으며, 10,000이하의 자연수이다.",
    "output_description": "첫째 줄에 구하고자 하는 최소의 길이를 출력한다. 만일 그러한 합을 만드는 것이 불가능하다면 0을 출력하면 된다.",
    "examples": [
      {
        "input": "10 15\n5 1 3 5 10 7 4 9 2 8",
        "output": "2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1806",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N, S = map(int, input().split())\nnumbers = list(map(int, input().split()))\n\nleft = 0\ncurrent_sum = 0\nmin_length = float('inf')\n\nfor right in range(N):\n    current_sum += numbers[right]\n    \n    while current_sum >= S:\n        min_length = min(min_length, right - left + 1)\n        current_sum -= numbers[left]\n        left += 1\n\nprint(min_length if min_length != float('inf') else 0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1867",
    "step_title": "이분 매칭",
    "title": "돌멩이 제거",
    "level": 18,
    "tags": [
      "이분 매칭"
    ],
    "description": "n행 n열의 격자로 나뉜 운동장이 있다. 이 위에 k개의 돌멩이가 있는데, 하나의 돌멩이는 격자 한 칸에 정확히 들어가 있으며, 두 개 이상의 돌멩이가 한 칸에 들어가 있는 경우는 없다.사고의 위험을 없애기 위해 이 돌멩이를 모두 제거하고 깨끗한 운동장을 만들려고 한다. 돌멩이를 제거할 때에는, 한 행이나 한 열을 따라 직선으로 달려가면서 그 행이나 열에 놓인 돌멩이를 모두 줍는 방식을 쓴다.여러분이 할 일은 운동장의 상태가 주어졌을 때 최소 몇 번이나 달려가야 돌멩이 줍기를 끝낼 수 있는지 계산하는 것이다.",
    "input_description": "첫째 줄에 n과 k가 주어진다. (1 ≤ n ≤ 500, 1 ≤ k ≤ 10,000) 이후 k개의 줄에는 돌멩이의 위치가 한 줄에 하나씩 주어진다. 줄마다 첫 번째 숫자는 행 번호, 두 번째 숫자는 열 번호를 나타낸다. 입력으로 주어지는 돌멩이의 위치는 중복되지 않는다.",
    "output_description": "첫 줄에 몇 번의 달리기를 통해 돌멩이를 주울 수 있는지 출력한다.",
    "examples": [
      {
        "input": "3 4\n1 1\n1 3\n2 2\n3 2",
        "output": "2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1867",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1904",
    "step_title": "동적 계획법 1",
    "title": "01타일",
    "level": 8,
    "tags": [
      "다이나믹 프로그래밍"
    ],
    "description": "지원이에게 2진 수열을 가르쳐 주기 위해, 지원이 아버지는 그에게 타일들을 선물해주셨다. 그리고 이 각각의 타일들은 0 또는 1이 쓰여 있는 낱장의 타일들이다.어느 날 짓궂은 동주가 지원이의 공부를 방해하기 위해 0이 쓰여진 낱장의 타일들을 붙여서 한 쌍으로 이루어진 00 타일들을 만들었다. 결국 현재 1 하나만으로 이루어진 타일 또는 0타일을 두 개 붙인 한 쌍의 00타일들만이 남게 되었다.그러므로 지원이는 타일로 더 이상 크기가 N인 모든 2진 수열을 만들 수 없게 되었다. 예를 들어, N=1일 때 1만 만들 수 있고, N=2일 때는 00, 11을 만들 수 있다. (01, 10은 만들 수 없게 되었다.) 또한 N=4일 때는 0011, 0000, 1001, 1100, 1111 등 총 5개의 2진 수열을 만들 수 있다.우리의 목표는 N이 주어졌을 때 지원이가 만들 수 있는 모든 가짓수를 세는 것이다. 단 타일들은 무한히 많은 것으로 가정하자.",
    "input_description": "첫 번째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 1,000,000)",
    "output_description": "첫 번째 줄에 지원이가 만들 수 있는 길이가 N인 모든 2진 수열의 개수를 15746으로 나눈 나머지를 출력한다.",
    "examples": [
      {
        "input": "4",
        "output": "5"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1904",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\ndp = [0] * (N + 1)\n\nif N >= 1:\n    dp[1] = 1\nif N >= 2:\n    dp[2] = 2\n\nfor i in range(3, N + 1):\n    dp[i] = (dp[i-1] + dp[i-2]) % 15746\n\nprint(dp[N])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1912",
    "step_title": "동적 계획법 1",
    "title": "연속합",
    "level": 9,
    "tags": [
      "다이나믹 프로그래밍",
      "최대 부분 배열 문제"
    ],
    "description": "n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다.",
    "input_description": "첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다. 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.",
    "output_description": "첫째 줄에 답을 출력한다.",
    "examples": [
      {
        "input": "10\n10 -4 3 1 5 6 -35 12 21 -1",
        "output": "33"
      },
      {
        "input": "10\n2 1 -4 3 4 -4 6 5 -5 1",
        "output": "14"
      },
      {
        "input": "5\n-1 -2 -3 -4 -5",
        "output": "-1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1912",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nnumbers = list(map(int, input().split()))\n\ndp = [0] * N\ndp[0] = numbers[0]\n\nfor i in range(1, N):\n    dp[i] = max(numbers[i], dp[i-1] + numbers[i])\n\nprint(max(dp))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1920",
    "step_title": "이분 탐색",
    "title": "수 찾기",
    "level": 7,
    "tags": [
      "자료 구조",
      "정렬",
      "이분 탐색",
      "집합과 맵",
      "해시를 사용한 집합과 맵"
    ],
    "description": "N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 자연수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 N개의 정수 A[1], A[2], …, A[N]이 주어진다. 다음 줄에는 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 줄에는 M개의 수들이 주어지는데, 이 수들이 A안에 존재하는지 알아내면 된다. 모든 정수의 범위는 -231보다 크거나 같고 231보다 작다.",
    "output_description": "M개의 줄에 답을 출력한다. 존재하면 1을, 존재하지 않으면 0을 출력한다.",
    "examples": [
      {
        "input": "5\n4 1 5 2 3\n5\n1 3 7 9 5",
        "output": "1\n1\n0\n0\n1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1920",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nA = set(map(int, input().split()))\nM = int(input())\nqueries = list(map(int, input().split()))\n\nfor q in queries:\n    print(1 if q in A else 0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = int(input())\nA = set(map(int, input().split()))\nm = int(input())\nqueries = list(map(int, input().split()))\n\nfor q in queries:\n    print(1 if q in A else 0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1927",
    "step_title": "우선순위 큐",
    "title": "최소 힙",
    "level": 9,
    "tags": [
      "자료 구조",
      "우선순위 큐"
    ],
    "description": "널리 잘 알려진 자료구조 중 최소 힙이 있다. 최소 힙을 이용하여 다음과 같은 연산을 지원하는 프로그램을 작성하시오.배열에 자연수 x를 넣는다.배열에서 가장 작은 값을 출력하고, 그 값을 배열에서 제거한다.프로그램은 처음에 비어있는 배열에서 시작하게 된다.",
    "input_description": "첫째 줄에 연산의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 만약 x가 자연수라면 배열에 x라는 값을 넣는(추가하는) 연산이고, x가 0이라면 배열에서 가장 작은 값을 출력하고 그 값을 배열에서 제거하는 경우이다. x는 231보다 작은 자연수 또는 0이고, 음의 정수는 입력으로 주어지지 않는다.",
    "output_description": "입력에서 0이 주어진 횟수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 가장 작은 값을 출력하라고 한 경우에는 0을 출력하면 된다.",
    "examples": [
      {
        "input": "9\n0\n12345678\n1\n2\n0\n0\n0\n0\n32",
        "output": "0\n1\n2\n12345678\n0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1927",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nimport heapq\ninput = sys.stdin.readline\n\nN = int(input())\nheap = []\n\nfor _ in range(N):\n    x = int(input())\n    if x == 0:\n        if heap:\n            print(heapq.heappop(heap))\n        else:\n            print(0)\n    else:\n        heapq.heappush(heap, x)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1929",
    "step_title": "약수, 배수와 소수 2",
    "title": "소수 구하기",
    "level": 8,
    "tags": [
      "수학",
      "정수론",
      "소수 판정",
      "에라토스테네스의 체"
    ],
    "description": "M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000) M이상 N이하의 소수가 하나 이상 있는 입력만 주어진다.",
    "output_description": "한 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.",
    "examples": [
      {
        "input": "3 16",
        "output": "3\r\n5\r\n7\r\n11\r\n13"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1929",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def sieve(n):\n    if n < 2:\n        return []\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n + 1, i):\n                is_prime[j] = False\n    \n    return [i for i in range(n + 1) if is_prime[i]]\n\nM, N = map(int, input().split())\nprimes = sieve(N)\n\nfor p in primes:\n    if p >= M:\n        print(p)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1931",
    "step_title": "그리디 알고리즘 1",
    "title": "회의실 배정",
    "level": 11,
    "tags": [
      "그리디 알고리즘",
      "정렬"
    ],
    "description": "한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.",
    "input_description": "첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.",
    "output_description": "첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.",
    "examples": [
      {
        "input": "11\n1 4\n3 5\n0 6\n5 7\n3 8\n5 9\n6 10\n8 11\n8 12\n2 13\n12 14",
        "output": "4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1931",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nmeetings = []\nfor _ in range(N):\n    start, end = map(int, input().split())\n    meetings.append((start, end))\n\nmeetings.sort(key=lambda x: (x[1], x[0]))\n\ncount = 0\nlast_end = 0\n\nfor start, end in meetings:\n    if start >= last_end:\n        count += 1\n        last_end = end\n\nprint(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = int(input())\nmeetings = []\nfor _ in range(n):\n    start, end = map(int, input().split())\n    meetings.append((start, end))\n\nmeetings.sort(key=lambda x: (x[1], x[0]))\n\ncount = 0\nlast_end = 0\nfor start, end in meetings:\n    if start >= last_end:\n        count += 1\n        last_end = end\n\nprint(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3",
        "solution_code": "n = int(input())\nmeetings = []\nfor _ in range(n):\n    start, end = map(int, input().split())\n    meetings.append((start, end))\n\nfor i in range(n-1):\n    for j in range(n-1-i):\n        if (meetings[j][1], meetings[j][0]) > (meetings[j+1][1], meetings[j+1][0]):\n            meetings[j], meetings[j+1] = meetings[j+1], meetings[j]\n\ncount = 0\nlast_end = 0\nfor start, end in meetings:\n    if start >= last_end:\n        count += 1\n        last_end = end\n\nprint(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 패스 횟수 제어",
            "description": "n-1번 반복하며 각 패스를 수행합니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "버블 정렬에서 몇 번의 패스가 필요한가요?",
            "hint": "n-1번의 패스가 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "내부 반복문: 인접 원소 비교",
            "description": "각 패스에서 인접한 두 원소를 비교합니다. 이미 정렬된 뒤쪽 부분은 제외합니다.",
            "code_pattern": "for j in range(n-1-i):",
            "socratic_hint": "각 패스에서 비교해야 할 원소의 범위는?",
            "hint": "n-1-i까지 비교합니다 (이미 정렬된 부분 제외)."
          },
          {
            "step_id": 4,
            "goal": "원소 교환",
            "description": "왼쪽 원소가 오른쪽 원소보다 크면 위치를 교환합니다.",
            "code_pattern": "if arr[j] > arr[j+1]:\n    arr[j], arr[j+1] = arr[j+1], arr[j]",
            "socratic_hint": "인접한 두 원소의 순서가 잘못되었을 때 어떻게 하나요?",
            "hint": "두 원소의 위치를 swap합니다."
          },
          {
            "step_id": 5,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4",
        "solution_code": "n = int(input())\nmeetings = []\nfor _ in range(n):\n    start, end = map(int, input().split())\n    meetings.append((start, end))\n\nfor i in range(n-1):\n    min_idx = i\n    for j in range(i+1, n):\n        if (meetings[j][1], meetings[j][0]) < (meetings[min_idx][1], meetings[min_idx][0]):\n            min_idx = j\n    meetings[i], meetings[min_idx] = meetings[min_idx], meetings[i]\n\ncount = 0\nlast_end = 0\nfor start, end in meetings:\n    if start >= last_end:\n        count += 1\n        last_end = end\n\nprint(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 정렬할 위치 선택",
            "description": "n-1번 반복하며 각 위치에 올 최솟값을 찾습니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "선택 정렬에서 몇 번의 선택이 필요한가요?",
            "hint": "n-1번의 선택이 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "최솟값 인덱스 초기화",
            "description": "현재 위치를 최솟값 인덱스로 가정합니다.",
            "code_pattern": "min_idx = i",
            "socratic_hint": "최솟값을 찾기 위한 초기값은?",
            "hint": "현재 위치 i를 초기값으로 설정합니다."
          },
          {
            "step_id": 4,
            "goal": "내부 반복문: 최솟값 찾기",
            "description": "현재 위치 이후의 원소들 중 최솟값의 인덱스를 찾습니다.",
            "code_pattern": "for j in range(i+1, n):\n    if arr[j] < arr[min_idx]:\n        min_idx = j",
            "socratic_hint": "정렬되지 않은 부분에서 최솟값을 어떻게 찾나요?",
            "hint": "i+1부터 끝까지 순회하며 최솟값 인덱스를 업데이트합니다."
          },
          {
            "step_id": 5,
            "goal": "원소 교환",
            "description": "찾은 최솟값을 현재 위치로 이동시킵니다.",
            "code_pattern": "arr[i], arr[min_idx] = arr[min_idx], arr[i]",
            "socratic_hint": "최솟값을 현재 위치로 가져오려면?",
            "hint": "현재 위치의 값과 최솟값을 swap합니다."
          },
          {
            "step_id": 6,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1932",
    "step_title": "동적 계획법 1",
    "title": "정수 삼각형",
    "level": 10,
    "tags": [
      "다이나믹 프로그래밍"
    ],
    "description": "7\r\n      3   8\r\n    8   1   0\r\n  2   7   4   4\r\n4   5   2   6   5위 그림은 크기가 5인 정수 삼각형의 한 모습이다.맨 위층 7부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때, 이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램을 작성하라. 아래층에 있는 수는 현재 층에서 선택된 수의 대각선 왼쪽 또는 대각선 오른쪽에 있는 것 중에서만 선택할 수 있다.삼각형의 크기는 1 이상 500 이하이다. 삼각형을 이루고 있는 각 수는 모두 정수이며, 범위는 0 이상 9999 이하이다.",
    "input_description": "첫째 줄에 삼각형의 크기 n(1 ≤ n ≤ 500)이 주어지고, 둘째 줄부터 n+1번째 줄까지 정수 삼각형이 주어진다.",
    "output_description": "첫째 줄에 합이 최대가 되는 경로에 있는 수의 합을 출력한다.",
    "examples": [
      {
        "input": "5\r\n7\r\n3 8\r\n8 1 0\r\n2 7 4 4\r\n4 5 2 6 5",
        "output": "30"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1932",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\ntriangle = []\nfor _ in range(N):\n    triangle.append(list(map(int, input().split())))\n\ndp = [[0] * (i + 1) for i in range(N)]\ndp[0][0] = triangle[0][0]\n\nfor i in range(1, N):\n    for j in range(i + 1):\n        if j == 0:\n            dp[i][j] = dp[i-1][j] + triangle[i][j]\n        elif j == i:\n            dp[i][j] = dp[i-1][j-1] + triangle[i][j]\n        else:\n            dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j]\n\nprint(max(dp[N-1]))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1934",
    "step_title": "약수, 배수와 소수 2",
    "title": "최소공배수",
    "level": 5,
    "tags": [
      "수학",
      "정수론",
      "유클리드 호제법"
    ],
    "description": "두 자연수 A와 B에 대해서, A의 배수이면서 B의 배수인 자연수를 A와 B의 공배수라고 한다. 이런 공배수 중에서 가장 작은 수를 최소공배수라고 한다. 예를 들어, 6과 15의 공배수는 30, 60, 90등이 있으며, 최소 공배수는 30이다.두 자연수 A와 B가 주어졌을 때, A와 B의 최소공배수를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다. 둘째 줄부터 T개의 줄에 걸쳐서 A와 B가 주어진다. (1 ≤ A, B ≤ 45,000)",
    "output_description": "첫째 줄부터 T개의 줄에 A와 B의 최소공배수를 입력받은 순서대로 한 줄에 하나씩 출력한다.",
    "examples": [
      {
        "input": "3\r\n1 45000\r\n6 10\r\n13 17",
        "output": "45000\r\n30\r\n221"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1934",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import math\n\nT = int(input())\nfor _ in range(T):\n    A, B = map(int, input().split())\n    print(A * B // math.gcd(A, B))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1949",
    "step_title": "트리에서의 동적 계획법",
    "title": "우수 마을",
    "level": 14,
    "tags": [
      "다이나믹 프로그래밍",
      "트리",
      "트리에서의 다이나믹 프로그래밍"
    ],
    "description": "N개의 마을로 이루어진 나라가 있다. 편의상 마을에는 1부터 N까지 번호가 붙어 있다고 하자. 이 나라는 트리(Tree) 구조로 이루어져 있다. 즉 마을과 마을 사이를 직접 잇는 N-1개의 길이 있으며, 각 길은 방향성이 없어서 A번 마을에서 B번 마을로 갈 수 있다면 B번 마을에서 A번 마을로 갈 수 있다. 또, 모든 마을은 연결되어 있다. 두 마을 사이에 직접 잇는 길이 있을 때, 두 마을이 인접해 있다고 한다.이 나라의 주민들에게 성취감을 높여 주기 위해, 다음 세 가지 조건을 만족하면서 N개의 마을 중 몇 개의 마을을 '우수 마을'로 선정하려고 한다.'우수 마을'로 선정된 마을 주민 수의 총 합을 최대로 해야 한다.마을 사이의 충돌을 방지하기 위해서, 만일 두 마을이 인접해 있으면 두 마을을 모두 '우수 마을'로 선정할 수는 없다. 즉 '우수 마을'끼리는 서로 인접해 있을 수 없다.선정되지 못한 마을에 경각심을 불러일으키기 위해서, '우수 마을'로 선정되지 못한 마을은 적어도 하나의 '우수 마을'과는 인접해 있어야 한다.각 마을 주민 수와 마을 사이의 길에 대한 정보가 주어졌을 때, 주어진 조건을 만족하도록 '우수 마을'을 선정하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 정수 N이 주어진다. (1 ≤ N ≤ 10,000) 둘째 줄에는 마을 주민 수를 나타내는 N개의 자연수가 빈칸을 사이에 두고 주어진다. 1번 마을부터 N번 마을까지 순서대로 주어지며, 주민 수는 10,000 이하이다. 셋째 줄부터 N-1개 줄에 걸쳐서 인접한 두 마을의 번호가 빈칸을 사이에 두고 주어진다.",
    "output_description": "첫째 줄에 '우수 마을'의 주민 수의 총 합을 출력한다.",
    "examples": [
      {
        "input": "7\n1000 3000 4000 1000 2000 2000 7000\n1 2\n2 3\n4 3\n4 5\n6 2\n6 7",
        "output": "14000"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1949",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(node):\n    visited[node] = True\n    dp[node][0] = 0\n    dp[node][1] = population[node]\n    \n    for child in tree[node]:\n        if not visited[child]:\n            dfs(child)\n            dp[node][0] += max(dp[child][0], dp[child][1])\n            dp[node][1] += dp[child][0]\n\nN = int(input())\npopulation = [0] + list(map(int, input().split()))\ntree = [[] for _ in range(N + 1)]\ndp = [[0, 0] for _ in range(N + 1)]\nvisited = [False] * (N + 1)\n\nfor _ in range(N - 1):\n    a, b = map(int, input().split())\n    tree[a].append(b)\n    tree[b].append(a)\n\ndfs(1)\nprint(max(dp[1][0], dp[1][1]))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1956",
    "step_title": "최단 경로",
    "title": "운동",
    "level": 12,
    "tags": [
      "그래프 이론",
      "최단 경로",
      "플로이드–워셜"
    ],
    "description": "V개의 마을와 E개의 도로로 구성되어 있는 도시가 있다. 도로는 마을과 마을 사이에 놓여 있으며, 일방 통행 도로이다. 마을에는 편의상 1번부터 V번까지 번호가 매겨져 있다고 하자.당신은 도로를 따라 운동을 하기 위한 경로를 찾으려고 한다. 운동을 한 후에는 다시 시작점으로 돌아오는 것이 좋기 때문에, 우리는 사이클을 찾기를 원한다. 단, 당신은 운동을 매우 귀찮아하므로, 사이클을 이루는 도로의 길이의 합이 최소가 되도록 찾으려고 한다.도로의 정보가 주어졌을 때, 도로의 길이의 합이 가장 작은 사이클을 찾는 프로그램을 작성하시오. 두 마을을 왕복하는 경우도 사이클에 포함됨에 주의한다.",
    "input_description": "첫째 줄에 V와 E가 빈칸을 사이에 두고 주어진다. (2 ≤ V ≤ 400, 0 ≤ E ≤ V(V-1)) 다음 E개의 줄에는 각각 세 개의 정수 a, b, c가 주어진다. a번 마을에서 b번 마을로 가는 거리가 c인 도로가 있다는 의미이다. (a → b임에 주의) 거리는 10,000 이하의 자연수이다. (a, b) 쌍이 같은 도로가 여러 번 주어지지 않는다.",
    "output_description": "첫째 줄에 최소 사이클의 도로 길이의 합을 출력한다. 운동 경로를 찾는 것이 불가능한 경우에는 -1을 출력한다.",
    "examples": [
      {
        "input": "3 4\n1 2 1\n3 2 1\n1 3 5\n2 3 2",
        "output": "3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1956",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N, E = map(int, input().split())\n\ndist = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n\nfor _ in range(E):\n    a, b, c = map(int, input().split())\n    dist[a][b] = c\n\nfor k in range(1, N + 1):\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\nresult = float('inf')\nfor i in range(1, N + 1):\n    result = min(result, dist[i][i])\n\nprint(result if result != float('inf') else -1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1967",
    "step_title": "트리",
    "title": "트리의 지름",
    "level": 12,
    "tags": [
      "그래프 이론",
      "그래프 탐색",
      "트리",
      "깊이 우선 탐색",
      "트리의 지름"
    ],
    "description": "트리(tree)는 사이클이 없는 무방향 그래프이다. 트리에서는 어떤 두 노드를 선택해도 둘 사이에 경로가 항상 하나만 존재하게 된다. 트리에서 어떤 두 노드를 선택해서 양쪽으로 쫙 당길 때, 가장 길게 늘어나는 경우가 있을 것이다. 이럴 때 트리의 모든 노드들은 이 두 노드를 지름의 끝 점으로 하는 원 안에 들어가게 된다.이런 두 노드 사이의 경로의 길이를 트리의 지름이라고 한다. 정확히 정의하자면 트리에 존재하는 모든 경로들 중에서 가장 긴 것의 길이를 말한다.입력으로 루트가 있는 트리를 가중치가 있는 간선들로 줄 때, 트리의 지름을 구해서 출력하는 프로그램을 작성하시오. 아래와 같은 트리가 주어진다면 트리의 지름은 45가 된다.트리의 노드는 1부터 n까지 번호가 매겨져 있다.",
    "input_description": "파일의 첫 번째 줄은 노드의 개수 n(1 ≤ n ≤ 10,000)이다. 둘째 줄부터 n-1개의 줄에 각 간선에 대한 정보가 들어온다. 간선에 대한 정보는 세 개의 정수로 이루어져 있다. 첫 번째 정수는 간선이 연결하는 두 노드 중 부모 노드의 번호를 나타내고, 두 번째 정수는 자식 노드를, 세 번째 정수는 간선의 가중치를 나타낸다. 간선에 대한 정보는 부모 노드의 번호가 작은 것이 먼저 입력되고, 부모 노드의 번호가 같으면 자식 노드의 번호가 작은 것이 먼저 입력된다. 루트 노드의 번호는 항상 1이라고 가정하며, 간선의 가중치는 100보다 크지 않은 양의 정수이다.",
    "output_description": "첫째 줄에 트리의 지름을 출력한다.",
    "examples": [
      {
        "input": "12\n1 2 3\n1 3 2\n2 4 5\n3 5 11\n3 6 9\n4 7 1\n4 8 7\n5 9 15\n5 10 4\n6 11 6\n6 12 10",
        "output": "45"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1967",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\n\ndef dfs(node, dist):\n    visited[node] = True\n    distance[node] = dist\n    \n    for next_node, weight in tree[node]:\n        if not visited[next_node]:\n            dfs(next_node, dist + weight)\n\nn = int(input())\nif n == 1:\n    print(0)\nelse:\n    tree = [[] for _ in range(n + 1)]\n    \n    for _ in range(n - 1):\n        parent, child, weight = map(int, input().split())\n        tree[parent].append((child, weight))\n        tree[child].append((parent, weight))\n    \n    visited = [False] * (n + 1)\n    distance = [0] * (n + 1)\n    dfs(1, 0)\n    \n    farthest = distance.index(max(distance))\n    \n    visited = [False] * (n + 1)\n    distance = [0] * (n + 1)\n    dfs(farthest, 0)\n    \n    print(max(distance))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1976",
    "step_title": "유니온 파인드 1",
    "title": "여행 가자",
    "level": 12,
    "tags": [
      "그래프 이론",
      "자료 구조",
      "그래프 탐색",
      "분리 집합"
    ],
    "description": "동혁이는 친구들과 함께 여행을 가려고 한다. 한국에는 도시가 N개 있고 임의의 두 도시 사이에 길이 있을 수도, 없을 수도 있다. 동혁이의 여행 일정이 주어졌을 때, 이 여행 경로가 가능한 것인지 알아보자. 물론 중간에 다른 도시를 경유해서 여행을 할 수도 있다. 예를 들어 도시가 5개 있고, A-B, B-C, A-D, B-D, E-A의 길이 있고, 동혁이의 여행 계획이 E C B C D 라면 E-A-B-C-B-C-B-D라는 여행경로를 통해 목적을 달성할 수 있다.도시들의 개수와 도시들 간의 연결 여부가 주어져 있고, 동혁이의 여행 계획에 속한 도시들이 순서대로 주어졌을 때 가능한지 여부를 판별하는 프로그램을 작성하시오. 같은 도시를 여러 번 방문하는 것도 가능하다.",
    "input_description": "첫 줄에 도시의 수 N이 주어진다. N은 200이하이다. 둘째 줄에 여행 계획에 속한 도시들의 수 M이 주어진다. M은 1000이하이다. 다음 N개의 줄에는 N개의 정수가 주어진다. i번째 줄의 j번째 수는 i번 도시와 j번 도시의 연결 정보를 의미한다. 1이면 연결된 것이고 0이면 연결이 되지 않은 것이다. A와 B가 연결되었으면 B와 A도 연결되어 있다. 마지막 줄에는 여행 계획이 주어진다. 도시의 번호는 1부터 N까지 차례대로 매겨져 있다.",
    "output_description": "첫 줄에 가능하면 YES 불가능하면 NO를 출력한다.",
    "examples": [
      {
        "input": "3\n3\n0 1 0\n1 0 1\n0 1 0\n1 2 3",
        "output": "YES"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1976",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def find(x):\n    if parent[x] != x:\n        parent[x] = find(parent[x])\n    return parent[x]\n\ndef union(x, y):\n    x = find(x)\n    y = find(y)\n    if x != y:\n        parent[y] = x\n\nN = int(input())\nM = int(input())\n\nparent = list(range(N + 1))\n\nfor i in range(1, N + 1):\n    connected = list(map(int, input().split()))\n    for j in range(1, N + 1):\n        if connected[j-1] == 1:\n            union(i, j)\n\nplan = list(map(int, input().split()))\n\nroot = find(plan[0])\npossible = True\nfor city in plan[1:]:\n    if find(city) != root:\n        possible = False\n        break\n\nprint(\"YES\" if possible else \"NO\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1978",
    "step_title": "약수, 배수와 소수 1",
    "title": "소수 찾기",
    "level": 4,
    "tags": [
      "소수 판정",
      "정수론",
      "수학"
    ],
    "description": "주어진 수 N개 중에서 소수가 몇 개인지 찾아서 출력하는 프로그램을 작성하시오.",
    "input_description": "첫 줄에 수의 개수 N이 주어진다. N은 100이하이다. 다음으로 N개의 수가 주어지는데 수는 1,000 이하의 자연수이다.",
    "output_description": "주어진 수들 중 소수의 개수를 출력한다.",
    "examples": [
      {
        "input": "4\n1 3 5 7",
        "output": "3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1978",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\nN = int(input())\nnumbers = list(map(int, input().split()))\ncount = sum(1 for num in numbers if is_prime(num))\nprint(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1991",
    "step_title": "트리",
    "title": "트리 순회",
    "level": 10,
    "tags": [
      "트리",
      "재귀"
    ],
    "description": "이진 트리를 입력받아 전위 순회(preorder traversal), 중위 순회(inorder traversal), 후위 순회(postorder traversal)한 결과를 출력하는 프로그램을 작성하시오.예를 들어 위와 같은 이진 트리가 입력되면,전위 순회한 결과 : ABDCEFG // (루트) (왼쪽 자식) (오른쪽 자식)중위 순회한 결과 : DBAECFG // (왼쪽 자식) (루트) (오른쪽 자식)후위 순회한 결과 : DBEGFCA // (왼쪽 자식) (오른쪽 자식) (루트)가 된다.",
    "input_description": "첫째 줄에는 이진 트리의 노드의 개수 N(1 ≤ N ≤ 26)이 주어진다. 둘째 줄부터 N개의 줄에 걸쳐 각 노드와 그의 왼쪽 자식 노드, 오른쪽 자식 노드가 주어진다. 노드의 이름은 A부터 차례대로 알파벳 대문자로 매겨지며, 항상 A가 루트 노드가 된다. 자식 노드가 없는 경우에는 .으로 표현한다.",
    "output_description": "첫째 줄에 전위 순회, 둘째 줄에 중위 순회, 셋째 줄에 후위 순회한 결과를 출력한다. 각 줄에 N개의 알파벳을 공백 없이 출력하면 된다.",
    "examples": [
      {
        "input": "7\nA B C\nB D .\nC E F\nE . .\nF . G\nD . .\nG . .",
        "output": "ABDCEFG\nDBAECFG\nDBEGFCA"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1991",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\ntree = {}\n\nfor _ in range(N):\n    root, left, right = input().split()\n    tree[root] = (left, right)\n\ndef preorder(node):\n    if node == '.':\n        return ''\n    left, right = tree[node]\n    return node + preorder(left) + preorder(right)\n\ndef inorder(node):\n    if node == '.':\n        return ''\n    left, right = tree[node]\n    return inorder(left) + node + inorder(right)\n\ndef postorder(node):\n    if node == '.':\n        return ''\n    left, right = tree[node]\n    return postorder(left) + postorder(right) + node\n\nprint(preorder('A'))\nprint(inorder('A'))\nprint(postorder('A'))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "1992",
    "step_title": "분할 정복",
    "title": "쿼드트리",
    "level": 10,
    "tags": [
      "분할 정복",
      "재귀"
    ],
    "description": "흑백 영상을 압축하여 표현하는 데이터 구조로 쿼드 트리(Quad Tree)라는 방법이 있다. 흰 점을 나타내는 0과 검은 점을 나타내는 1로만 이루어진 영상(2차원 배열)에서 같은 숫자의 점들이 한 곳에 많이 몰려있으면, 쿼드 트리에서는 이를 압축하여 간단히 표현할 수 있다.주어진 영상이 모두 0으로만 되어 있으면 압축 결과는 \"0\"이 되고, 모두 1로만 되어 있으면 압축 결과는 \"1\"이 된다. 만약 0과 1이 섞여 있으면 전체를 한 번에 나타내지를 못하고, 왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래, 이렇게 4개의 영상으로 나누어 압축하게 되며, 이 4개의 영역을 압축한 결과를 차례대로 괄호 안에 묶어서 표현한다위 그림에서 왼쪽의 영상은 오른쪽의 배열과 같이 숫자로 주어지며, 이 영상을 쿼드 트리 구조를 이용하여 압축하면 \"(0(0011)(0(0111)01)1)\"로 표현된다.  N ×N 크기의 영상이 주어질 때, 이 영상을 압축한 결과를 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에는 영상의 크기를 나타내는 숫자 N 이 주어진다. N 은 언제나 2의 제곱수로 주어지며, 1 ≤ N ≤ 64의 범위를 가진다. 두 번째 줄부터는 길이 N의 문자열이 N개 들어온다. 각 문자열은 0 또는 1의 숫자로 이루어져 있으며, 영상의 각 점들을 나타낸다.",
    "output_description": "영상을 압축한 결과를 출력한다.",
    "examples": [
      {
        "input": "8\n11110000\n11110000\n00011100\n00011100\n11110000\n11110000\n11110011\n11110011",
        "output": "((110(0101))(0010)1(0001))"
      }
    ],
    "url": "https://www.acmicpc.net/problem/1992",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def quad_tree(x, y, n):\n    if n == 1:\n        return str(video[x][y])\n    \n    # 모두 같은지 확인\n    first = video[x][y]\n    same = True\n    for i in range(x, x + n):\n        for j in range(y, y + n):\n            if video[i][j] != first:\n                same = False\n                break\n        if not same:\n            break\n    \n    if same:\n        return str(first)\n    \n    half = n // 2\n    result = '('\n    result += quad_tree(x, y, half)\n    result += quad_tree(x, y + half, half)\n    result += quad_tree(x + half, y, half)\n    result += quad_tree(x + half, y + half, half)\n    result += ')'\n    return result\n\nN = int(input())\nvideo = []\nfor _ in range(N):\n    video.append(list(map(int, input())))\n\nprint(quad_tree(0, 0, N))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2042",
    "step_title": "세그먼트 트리 1",
    "title": "구간 합 구하기",
    "level": 15,
    "tags": [
      "세그먼트 트리",
      "자료 구조"
    ],
    "description": "어떤 N개의 수가 주어져 있다. 그런데 중간에 수의 변경이 빈번히 일어나고 그 중간에 어떤 부분의 합을 구하려 한다. 만약에 1,2,3,4,5 라는 수가 있고, 3번째 수를 6으로 바꾸고 2번째부터 5번째까지 합을 구하라고 한다면 17을 출력하면 되는 것이다. 그리고 그 상태에서 다섯 번째 수를 2로 바꾸고 3번째부터 5번째까지 합을 구하라고 한다면 12가 될 것이다.",
    "input_description": "첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)과 M(1 ≤ M ≤ 10,000), K(1 ≤ K ≤ 10,000) 가 주어진다. M은 수의 변경이 일어나는 횟수이고, K는 구간의 합을 구하는 횟수이다. 그리고 둘째 줄부터 N+1번째 줄까지 N개의 수가 주어진다. 그리고 N+2번째 줄부터 N+M+K+1번째 줄까지 세 개의 정수 a, b, c가 주어지는데, a가 1인 경우 b(1 ≤ b ≤ N)번째 수를 c로 바꾸고 a가 2인 경우에는 b(1 ≤ b ≤ N)번째 수부터 c(b ≤ c ≤ N)번째 수까지의 합을 구하여 출력하면 된다.입력으로 주어지는 모든 수는 -263보다 크거나 같고, 263-1보다 작거나 같은 정수이다.",
    "output_description": "첫째 줄부터 K줄에 걸쳐 구한 구간의 합을 출력한다. 단, 정답은 -263보다 크거나 같고, 263-1보다 작거나 같은 정수이다.",
    "examples": [
      {
        "input": "5 2 2\n1\n2\n3\n4\n5\n1 3 6\n2 2 5\n1 5 2\n2 3 5",
        "output": "17\n12"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2042",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\ninput = sys.stdin.readline\n\nclass SegmentTree:\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.build(arr, 1, 0, self.n - 1)\n    \n    def build(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build(arr, node * 2, start, mid)\n            self.build(arr, node * 2 + 1, mid + 1, end)\n            self.tree[node] = self.tree[node * 2] + self.tree[node * 2 + 1]\n    \n    def update(self, node, start, end, idx, val):\n        if start == end:\n            self.tree[node] = val\n        else:\n            mid = (start + end) // 2\n            if idx <= mid:\n                self.update(node * 2, start, mid, idx, val)\n            else:\n                self.update(node * 2 + 1, mid + 1, end, idx, val)\n            self.tree[node] = self.tree[node * 2] + self.tree[node * 2 + 1]\n    \n    def query(self, node, start, end, left, right):\n        if left > end or right < start:\n            return 0\n        if left <= start and end <= right:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(node * 2, start, mid, left, right) + \\\n               self.query(node * 2 + 1, mid + 1, end, left, right)\n\nN, M, K = map(int, input().split())\narr = [int(input()) for _ in range(N)]\n\nseg = SegmentTree(arr)\n\nfor _ in range(M + K):\n    a, b, c = map(int, input().split())\n    if a == 1:\n        seg.update(1, 0, N - 1, b - 1, c)\n    else:\n        print(seg.query(1, 0, N - 1, b - 1, c - 1))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2075",
    "step_title": "우선순위 큐",
    "title": "N번째 큰 수",
    "level": 8,
    "tags": [
      "자료 구조",
      "정렬",
      "우선순위 큐"
    ],
    "description": "N×N의 표에 수 N2개 채워져 있다. 채워진 수에는 한 가지 특징이 있는데, 모든 수는 자신의 한 칸 위에 있는 수보다 크다는 것이다. N=5일 때의 예를 보자.127915513811196211026311648142835255220324149이러한 표가 주어졌을 때, N번째 큰 수를 찾는 프로그램을 작성하시오. 표에 채워진 수는 모두 다르다.",
    "input_description": "첫째 줄에 N(1 ≤ N ≤ 1,500)이 주어진다. 다음 N개의 줄에는 각 줄마다 N개의 수가 주어진다. 표에 적힌 수는 -10억보다 크거나 같고, 10억보다 작거나 같은 정수이다.",
    "output_description": "첫째 줄에 N번째 큰 수를 출력한다.",
    "examples": [
      {
        "input": "5\n12 7 9 15 5\n13 8 11 19 6\n21 10 26 31 16\n48 14 28 35 25\n52 20 32 41 49",
        "output": "35"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2075",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import heapq\n\nN = int(input())\nheap = []\n\nfor i in range(N):\n    numbers = list(map(int, input().split()))\n    for num in numbers:\n        if len(heap) < N:\n            heapq.heappush(heap, num)\n        elif num > heap[0]:\n            heapq.heapreplace(heap, num)\n\nprint(heap[0])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "import heapq\nn = int(input())\nheap = []\n\nfor _ in range(n):\n    nums = list(map(int, input().split()))\n    for num in nums:\n        if len(heap) < n:\n            heapq.heappush(heap, num)\n        else:\n            if num > heap[0]:\n                heapq.heappushpop(heap, num)\n\nprint(heap[0])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2098",
    "step_title": "동적 계획법 3",
    "title": "외판원 순회",
    "level": 15,
    "tags": [
      "비트마스킹",
      "다이나믹 프로그래밍",
      "비트필드를 이용한 다이나믹 프로그래밍",
      "외판원 순회 문제"
    ],
    "description": "외판원 순회 문제는 영어로 Traveling Salesman problem (TSP) 라고 불리는 문제로 computer science 분야에서 가장 중요하게 취급되는 문제 중 하나이다. 여러 가지 변종 문제가 있으나, 여기서는 가장 일반적인 형태의 문제를 살펴보자.1번부터 N번까지 번호가 매겨져 있는 도시들이 있고, 도시들 사이에는 길이 있다. (길이 없을 수도 있다) 이제 한 외판원이 어느 한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는 순회 여행 경로를 계획하려고 한다. 단, 한 번 갔던 도시로는 다시 갈 수 없다. (맨 마지막에 여행을 출발했던 도시로 돌아오는 것은 예외) 이런 여행 경로는 여러 가지가 있을 수 있는데, 가장 적은 비용을 들이는 여행 계획을 세우고자 한다.각 도시간에 이동하는데 드는 비용은 행렬 W[i][j]형태로 주어진다. W[i][j]는 도시 i에서 도시 j로 가기 위한 비용을 나타낸다. 비용은 대칭적이지 않다. 즉, W[i][j] 는 W[j][i]와 다를 수 있다. 모든 도시간의 비용은 양의 정수이다. W[i][i]는 항상 0이다. 경우에 따라서 도시 i에서 도시 j로 갈 수 없는 경우도 있으며 이럴 경우 W[i][j]=0이라고 하자.N과 비용 행렬이 주어졌을 때, 가장 적은 비용을 들이는 외판원의 순회 여행 경로를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 도시의 수 N이 주어진다. (2 ≤ N ≤ 16) 다음 N개의 줄에는 비용 행렬이 주어진다. 각 행렬의 성분은 1,000,000 이하의 양의 정수이며, 갈 수 없는 경우는 0이 주어진다. W[i][j]는 도시 i에서 j로 가기 위한 비용을 나타낸다.항상 순회할 수 있는 경우만 입력으로 주어진다.",
    "output_description": "첫째 줄에 외판원의 순회에 필요한 최소 비용을 출력한다.",
    "examples": [
      {
        "input": "4\n0 10 15 20\n5 0 9 10\n6 13 0 12\n8 8 9 0",
        "output": "35"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2098",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nW = []\nfor _ in range(N):\n    W.append(list(map(int, input().split())))\n\nINF = float('inf')\ndp = [[INF] * (1 << N) for _ in range(N)]\n\ndef tsp(curr, visited):\n    if visited == (1 << N) - 1:\n        return W[curr][0] if W[curr][0] > 0 else INF\n    \n    if dp[curr][visited] != INF:\n        return dp[curr][visited]\n    \n    for next_city in range(N):\n        if visited & (1 << next_city) or W[curr][next_city] == 0:\n            continue\n        \n        cost = W[curr][next_city] + tsp(next_city, visited | (1 << next_city))\n        dp[curr][visited] = min(dp[curr][visited], cost)\n    \n    return dp[curr][visited]\n\nprint(tsp(0, 1))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2108",
    "step_title": "심화 2",
    "title": "통계학",
    "level": 9,
    "tags": [
      "수학",
      "구현",
      "정렬"
    ],
    "description": "수를 처리하는 것은 통계학에서 상당히 중요한 일이다. 통계학에서 N개의 수를 대표하는 기본 통계값에는 다음과 같은 것들이 있다. 단, N은 홀수라고 가정하자.산술평균 : N개의 수들의 합을 N으로 나눈 값중앙값 : N개의 수들을 증가하는 순서로 나열했을 경우 그 중앙에 위치하는 값최빈값 : N개의 수들 중 가장 많이 나타나는 값범위 : N개의 수들 중 최댓값과 최솟값의 차이N개의 수가 주어졌을 때, 네 가지 기본 통계값을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 수의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 단, N은 홀수이다. 그 다음 N개의 줄에는 정수들이 주어진다. 입력되는 정수의 절댓값은 4,000을 넘지 않는다.",
    "output_description": "첫째 줄에는 산술평균을 출력한다. 소수점 이하 첫째 자리에서 반올림한 값을 출력한다.둘째 줄에는 중앙값을 출력한다.셋째 줄에는 최빈값을 출력한다. 여러 개 있을 때에는 최빈값 중 두 번째로 작은 값을 출력한다.넷째 줄에는 범위를 출력한다.",
    "examples": [
      {
        "input": "5\n1\n3\n8\n-2\n2",
        "output": "2\n2\n1\n10"
      },
      {
        "input": "1\n4000",
        "output": "4000\n4000\n4000\n0"
      },
      {
        "input": "5\n-1\n-2\n-3\n-1\n-2",
        "output": "-2\n-2\n-1\n2"
      },
      {
        "input": "3\n0\n0\n-1",
        "output": "0\n0\n0\n1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2108",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nfrom collections import Counter\ninput = sys.stdin.readline\n\nN = int(input())\nnumbers = []\nfor _ in range(N):\n    numbers.append(int(input()))\n\n# 산술평균\nmean = round(sum(numbers) / N)\nprint(mean)\n\n# 중앙값\nnumbers.sort()\nprint(numbers[N // 2])\n\n# 최빈값\ncounter = Counter(numbers)\nmax_freq = max(counter.values())\nmodes = sorted([k for k, v in counter.items() if v == max_freq])\nprint(modes[1] if len(modes) > 1 else modes[0])\n\n# 범위\nprint(numbers[-1] - numbers[0])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "from collections import Counter\nimport sys\nn = int(input())\nnums = [int(input()) for _ in range(n)]\nnums.sort()\n\n# 산술평균\nmean = round(sum(nums) / n)\nprint(mean)\n\n# 중앙값\nprint(nums[n//2])\n\n# 최빈값\ncounter = Counter(nums)\nmost_common = counter.most_common()\nif len(most_common) > 1 and most_common[0][1] == most_common[1][1]:\n    modes = [num for num, count in most_common if count == most_common[0][1]]\n    modes.sort()\n    print(modes[1])\nelse:\n    print(most_common[0][0])\n\n# 범위\nprint(nums[-1] - nums[0])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2110",
    "step_title": "이분 탐색",
    "title": "공유기 설치",
    "level": 12,
    "tags": [
      "이분 탐색",
      "매개 변수 탐색"
    ],
    "description": "도현이의 집 N개가 수직선 위에 있다. 각각의 집의 좌표는 x1, ..., xN이고, 집 여러개가 같은 좌표를 가지는 일은 없다.도현이는 언제 어디서나 와이파이를 즐기기 위해서 집에 공유기 C개를 설치하려고 한다. 최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, 가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려고 한다.C개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 집의 개수 N (2 ≤ N ≤ 200,000)과 공유기의 개수 C (2 ≤ C ≤ N)이 하나 이상의 빈 칸을 사이에 두고 주어진다. 둘째 줄부터 N개의 줄에는 집의 좌표를 나타내는 xi(0 ≤ xi≤ 1,000,000,000)가 한 줄에 하나씩 주어진다.",
    "output_description": "첫째 줄에 가장 인접한 두 공유기 사이의 최대 거리를 출력한다.",
    "examples": [
      {
        "input": "5 3\n1\n2\n8\n4\n9",
        "output": "3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2110",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def can_install(distance):\n    count = 1\n    last_pos = houses[0]\n    \n    for i in range(1, N):\n        if houses[i] - last_pos >= distance:\n            count += 1\n            last_pos = houses[i]\n    \n    return count >= C\n\nN, C = map(int, input().split())\nhouses = []\nfor _ in range(N):\n    houses.append(int(input()))\n\nhouses.sort()\n\nleft, right = 1, houses[-1] - houses[0]\nresult = 0\n\nwhile left <= right:\n    mid = (left + right) // 2\n    if can_install(mid):\n        result = mid\n        left = mid + 1\n    else:\n        right = mid - 1\n\nprint(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2150",
    "step_title": "강한 연결 요소",
    "title": "Strongly Connected Component",
    "level": 16,
    "tags": [
      "그래프 이론",
      "강한 연결 요소"
    ],
    "description": "방향 그래프가 주어졌을 때, 그 그래프를 SCC들로 나누는 프로그램을 작성하시오.방향 그래프의 SCC는 우선 정점의 최대 부분집합이며, 그 부분집합에 들어있는 서로 다른 임의의 두 정점 u, v에 대해서 u에서 v로 가는 경로와 v에서 u로 가는 경로가 모두 존재하는 경우를 말한다.예를 들어 위와 같은 그림을 보자. 이 그래프에서 SCC들은 {a, b, e}, {c, d}, {f, g}, {h} 가 있다. 물론 h에서 h로 가는 간선이 없는 경우에도 {h}는 SCC를 이룬다.",
    "input_description": "첫째 줄에 두 정수 V(1 ≤ V ≤ 10,000), E(1 ≤ E ≤ 100,000)가 주어진다. 이는 그래프가 V개의 정점과 E개의 간선으로 이루어져 있다는 의미이다. 다음 E개의 줄에는 간선에 대한 정보를 나타내는 두 정수 A, B가 주어진다. 이는 A번 정점과 B번 정점이 연결되어 있다는 의미이다. 이때 방향은 A → B가 된다.정점은 1부터 V까지 번호가 매겨져 있다.",
    "output_description": "첫째 줄에 SCC의 개수 K를 출력한다. 다음 K개의 줄에는 각 줄에 하나의 SCC에 속한 정점의 번호를 출력한다. 각 줄의 끝에는 -1을 출력하여 그 줄의 끝을 나타낸다. 각각의 SCC를 출력할 때 그 안에 속한 정점들은 오름차순으로 출력한다. 또한 여러 개의 SCC에 대해서는 그 안에 속해있는 가장 작은 정점의 정점 번호 순으로 출력한다.",
    "examples": [
      {
        "input": "7 9\n1 4\n4 5\n5 1\n1 6\n6 7\n2 7\n7 3\n3 7\n7 2",
        "output": "3\n1 4 5 -1\n2 3 7 -1\n6 -1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2150",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\ndef dfs1(v):\n    visited[v] = True\n    for next_v in graph[v]:\n        if not visited[next_v]:\n            dfs1(next_v)\n    stack.append(v)\n\ndef dfs2(v, scc_num):\n    scc_id[v] = scc_num\n    for next_v in reverse_graph[v]:\n        if scc_id[next_v] == -1:\n            dfs2(next_v, scc_num)\n\nV, E = map(int, input().split())\ngraph = [[] for _ in range(V + 1)]\nreverse_graph = [[] for _ in range(V + 1)]\n\nfor _ in range(E):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    reverse_graph[b].append(a)\n\nvisited = [False] * (V + 1)\nstack = []\n\nfor i in range(1, V + 1):\n    if not visited[i]:\n        dfs1(i)\n\nscc_id = [-1] * (V + 1)\nscc_num = 0\n\nwhile stack:\n    v = stack.pop()\n    if scc_id[v] == -1:\n        dfs2(v, scc_num)\n        scc_num += 1\n\nprint(scc_num)\n\nscc_list = [[] for _ in range(scc_num)]\nfor i in range(1, V + 1):\n    scc_list[scc_id[i]].append(i)\n\nscc_list = [sorted(scc) for scc in scc_list if scc]\nscc_list.sort()\n\nfor scc in scc_list:\n    print(*scc, -1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2156",
    "step_title": "동적 계획법 1",
    "title": "포도주 시식",
    "level": 10,
    "tags": [
      "다이나믹 프로그래밍"
    ],
    "description": "효주는 포도주 시식회에 갔다. 그 곳에 갔더니, 테이블 위에 다양한 포도주가 들어있는 포도주 잔이 일렬로 놓여 있었다. 효주는 포도주 시식을 하려고 하는데, 여기에는 다음과 같은 두 가지 규칙이 있다.포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.연속으로 놓여 있는 3잔을 모두 마실 수는 없다.효주는 될 수 있는 대로 많은 양의 포도주를 맛보기 위해서 어떤 포도주 잔을 선택해야 할지 고민하고 있다. 1부터 n까지의 번호가 붙어 있는 n개의 포도주 잔이 순서대로 테이블 위에 놓여 있고, 각 포도주 잔에 들어있는 포도주의 양이 주어졌을 때, 효주를 도와 가장 많은 양의 포도주를 마실 수 있도록 하는 프로그램을 작성하시오.예를 들어 6개의 포도주 잔이 있고, 각각의 잔에 순서대로 6, 10, 13, 9, 8, 1 만큼의 포도주가 들어 있을 때, 첫 번째, 두 번째, 네 번째, 다섯 번째 포도주 잔을 선택하면 총 포도주 양이 33으로 최대로 마실 수 있다.",
    "input_description": "첫째 줄에 포도주 잔의 개수 n이 주어진다. (1 ≤ n ≤ 10,000) 둘째 줄부터 n+1번째 줄까지 포도주 잔에 들어있는 포도주의 양이 순서대로 주어진다. 포도주의 양은 1,000 이하의 음이 아닌 정수이다.",
    "output_description": "첫째 줄에 최대로 마실 수 있는 포도주의 양을 출력한다.",
    "examples": [
      {
        "input": "6\n6\n10\n13\n9\n8\n1",
        "output": "33"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2156",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nwine = [0] + [int(input()) for _ in range(N)]\n\nif N == 1:\n    print(wine[1])\nelif N == 2:\n    print(wine[1] + wine[2])\nelse:\n    dp = [0] * (N + 1)\n    dp[1] = wine[1]\n    dp[2] = wine[1] + wine[2]\n    \n    for i in range(3, N + 1):\n        dp[i] = max(dp[i-1], dp[i-2] + wine[i], dp[i-3] + wine[i-1] + wine[i])\n    \n    print(dp[N])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2162",
    "step_title": "기하 2",
    "title": "선분 그룹",
    "level": 16,
    "tags": [
      "자료 구조",
      "기하학",
      "분리 집합",
      "선분 교차 판정"
    ],
    "description": "N개의 선분들이 2차원 평면상에 주어져 있다. 선분은 양 끝점의 x, y 좌표로 표현이 된다.두 선분이 서로 만나는 경우에, 두 선분은 같은 그룹에 속한다고 정의하며, 그룹의 크기는 그 그룹에 속한 선분의 개수로 정의한다. 두 선분이 만난다는 것은 선분의 끝점을 스치듯이 만나는 경우도 포함하는 것으로 한다.N개의 선분들이 주어졌을 때, 이 선분들은 총 몇 개의 그룹으로 되어 있을까? 또, 가장 크기가 큰 그룹에 속한 선분의 개수는 몇 개일까? 이 두 가지를 구하는 프로그램을 작성해 보자.",
    "input_description": "첫째 줄에 N(1 ≤ N ≤ 3,000)이 주어진다. 둘째 줄부터 N+1번째 줄에는 양 끝점의 좌표가 x1, y1, x2, y2의 순서로 주어진다. 각 좌표의 절댓값은 5,000을 넘지 않으며, 입력되는 좌표 사이에는 빈칸이 하나 있다.",
    "output_description": "첫째 줄에 그룹의 수를, 둘째 줄에 가장 크기가 큰 그룹에 속한 선분의 개수를 출력한다.",
    "examples": [
      {
        "input": "3\n1 1 2 3\n2 1 0 0\n1 0 1 1",
        "output": "1\n3"
      },
      {
        "input": "3\n-1 -1 1 1\n-2 -2 2 2\n0 1 -1 0",
        "output": "2\n2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2162",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2164",
    "step_title": "스택, 큐, 덱 1",
    "title": "카드2",
    "level": 7,
    "tags": [
      "자료 구조",
      "큐"
    ],
    "description": "N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.예를 들어 N=4인 경우를 생각해 보자. 카드는 제일 위에서부터 1234 의 순서로 놓여있다. 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 마지막으로 2를 버리고 나면, 남는 카드는 4가 된다.N이 주어졌을 때, 제일 마지막에 남게 되는 카드를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 정수 N(1 ≤ N ≤ 500,000)이 주어진다.",
    "output_description": "첫째 줄에 남게 되는 카드의 번호를 출력한다.",
    "examples": [
      {
        "input": "6",
        "output": "4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2164",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import deque\n\nN = int(input())\nqueue = deque(range(1, N + 1))\n\nwhile len(queue) > 1:\n    queue.popleft()\n    queue.append(queue.popleft())\n\nprint(queue[0])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2166",
    "step_title": "기하 2",
    "title": "다각형의 면적",
    "level": 11,
    "tags": [
      "기하학",
      "다각형의 넓이"
    ],
    "description": "2차원 평면상에 N(3 ≤ N ≤ 10,000)개의 점으로 이루어진 다각형이 있다. 이 다각형의 면적을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N이 주어진다. 다음 N개의 줄에는 다각형을 이루는 순서대로 N개의 점의 x, y좌표가 주어진다. 좌표값은 절댓값이 100,000을 넘지 않는 정수이다.",
    "output_description": "첫째 줄에 면적을 출력한다. 면적을 출력할 때에는 소수점 아래 둘째 자리에서 반올림하여 첫째 자리까지 출력한다.",
    "examples": [
      {
        "input": "4\r\n0 0\r\n0 10\r\n10 10\r\n10 0",
        "output": "100.0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2166",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\npoints = []\nfor _ in range(N):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\narea = 0\nfor i in range(N):\n    j = (i + 1) % N\n    area += points[i][0] * points[j][1]\n    area -= points[j][0] * points[i][1]\n\narea = abs(area) / 2\nprint(f\"{area:.1f}\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2169",
    "step_title": "동적 계획법 4",
    "title": "로봇 조종하기",
    "level": 14,
    "tags": [
      "다이나믹 프로그래밍"
    ],
    "description": "NASA에서는 화성 탐사를 위해 화성에 무선 조종 로봇을 보냈다. 실제 화성의 모습은 굉장히 복잡하지만, 로봇의 메모리가 얼마 안 되기 때문에 지형을 N×M 배열로 단순화 하여 생각하기로 한다.지형의 고저차의 특성상, 로봇은 움직일 때 배열에서 왼쪽, 오른쪽, 아래쪽으로 이동할 수 있지만, 위쪽으로는 이동할 수 없다. 또한 한 번 탐사한 지역(배열에서 하나의 칸)은 탐사하지 않기로 한다.각각의 지역은 탐사 가치가 있는데, 로봇을 배열의 왼쪽 위 (1, 1)에서 출발시켜 오른쪽 아래 (N, M)으로 보내려고 한다. 이때, 위의 조건을 만족하면서, 탐사한 지역들의 가치의 합이 최대가 되도록 하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N, M(1≤N, M≤1,000)이 주어진다. 다음 N개의 줄에는 M개의 수로 배열이 주어진다. 배열의 각 수는 절댓값이 100을 넘지 않는 정수이다. 이 값은 그 지역의 가치를 나타낸다.",
    "output_description": "첫째 줄에 최대 가치의 합을 출력한다.",
    "examples": [
      {
        "input": "5 5\n10 25 7 8 13\n68 24 -78 63 32\n12 -69 100 -29 -25\n-16 -22 -57 -33 99\n7 -76 -11 77 15",
        "output": "319"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2169",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2170",
    "step_title": "스위핑",
    "title": "선 긋기",
    "level": 11,
    "tags": [
      "정렬",
      "스위핑"
    ],
    "description": "매우 큰 도화지에 자를 대고 선을 그으려고 한다. 선을 그을 때에는 자의 한 점에서 다른 한 점까지 긋게 된다. 선을 그을 때에는 이미 선이 있는 위치에 겹쳐서 그릴 수도 있는데, 여러 번 그은 곳과 한 번 그은 곳의 차이를 구별할 수 없다고 하자.이와 같은 식으로 선을 그었을 때, 그려진 선(들)의 총 길이를 구하는 프로그램을 작성하시오. 선이 여러 번 그려진 곳은 한 번씩만 계산한다.",
    "input_description": "첫째 줄에 선을 그은 횟수 N (1 ≤ N ≤ 1,000,000)이 주어진다. 다음 N개의 줄에는 선을 그을 때 선택한 두 점의 위치 x, y (-1,000,000,000 ≤ x < y ≤ 1,000,000,000)가 주어진다.",
    "output_description": "첫째 줄에 그은 선의 총 길이를 출력한다.",
    "examples": [
      {
        "input": "4\n1 3\n2 5\n3 5\n6 7",
        "output": "5"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2170",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\ninput = sys.stdin.readline\n\nN = int(input())\nlines = []\nfor _ in range(N):\n    x, y = map(int, input().split())\n    lines.append((x, y))\n\nlines.sort()\n\ntotal = 0\nstart, end = lines[0]\n\nfor i in range(1, N):\n    if lines[i][0] <= end:\n        end = max(end, lines[i][1])\n    else:\n        total += end - start\n        start, end = lines[i]\n\ntotal += end - start\nprint(total)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "import sys\ninput = sys.stdin.readline\n\nn = int(input())\nlines = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    lines.append((x, y))\n\nlines.sort()\n\nmerged = [lines[0]]\nfor start, end in lines[1:]:\n    if start <= merged[-1][1]:\n        merged[-1] = (merged[-1][0], max(merged[-1][1], end))\n    else:\n        merged.append((start, end))\n\ntotal = sum(end - start for start, end in merged)\nprint(total)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2178",
    "step_title": "그래프와 순회",
    "title": "미로 탐색",
    "level": 10,
    "tags": [
      "그래프 이론",
      "그래프 탐색",
      "너비 우선 탐색",
      "격자 그래프"
    ],
    "description": "N×M크기의 배열로 표현되는 미로가 있다.101111101010101011111011미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.",
    "input_description": "첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은붙어서입력으로 주어진다.",
    "output_description": "첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.",
    "examples": [
      {
        "input": "4 6\r\n101111\r\n101010\r\n101011\r\n111011",
        "output": "15"
      },
      {
        "input": "4 6\r\n110110\r\n110110\r\n111111\r\n111101",
        "output": "9"
      },
      {
        "input": "2 25\r\n1011101110111011101110111\r\n1110111011101110111011101",
        "output": "38"
      },
      {
        "input": "7 7\r\n1011111\r\n1110001\r\n1000001\r\n1000001\r\n1000001\r\n1000001\r\n1111111",
        "output": "13"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2178",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import deque\n\nN, M = map(int, input().split())\nmaze = []\nfor _ in range(N):\n    maze.append(input())\n\nvisited = [[False] * M for _ in range(N)]\ndistance = [[0] * M for _ in range(N)]\n\nqueue = deque([(0, 0)])\nvisited[0][0] = True\ndistance[0][0] = 1\n\ndx = [-1, 1, 0, 0]\ndy = [0, 0, -1, 1]\n\nwhile queue:\n    x, y = queue.popleft()\n    \n    for i in range(4):\n        nx, ny = x + dx[i], y + dy[i]\n        \n        if 0 <= nx < N and 0 <= ny < M and not visited[nx][ny] and maze[nx][ny] == '1':\n            visited[nx][ny] = True\n            distance[nx][ny] = distance[x][y] + 1\n            queue.append((nx, ny))\n\nprint(distance[N-1][M-1])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2206",
    "step_title": "그래프와 순회",
    "title": "벽 부수고 이동하기",
    "level": 13,
    "tags": [
      "그래프 이론",
      "그래프 탐색",
      "너비 우선 탐색",
      "격자 그래프"
    ],
    "description": "N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다.만약에 이동하는 도중에 한 개의 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 한 개 까지 부수고 이동하여도 된다.한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다. (1, 1)과 (N, M)은 항상 0이라고 가정하자.",
    "output_description": "첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.",
    "examples": [
      {
        "input": "6 4\n0100\n1110\n1000\n0000\n0111\n0000",
        "output": "15"
      },
      {
        "input": "4 4\n0111\n1111\n1111\n1110",
        "output": "-1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2206",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import deque\n\nN, M = map(int, input().split())\nmaze = []\nfor _ in range(N):\n    maze.append(input())\n\nvisited = [[[0] * 2 for _ in range(M)] for _ in range(N)]\nqueue = deque([(0, 0, 0, 1)])\nvisited[0][0][0] = 1\n\ndx = [-1, 1, 0, 0]\ndy = [0, 0, -1, 1]\n\nwhile queue:\n    x, y, broken, dist = queue.popleft()\n    \n    if x == N - 1 and y == M - 1:\n        print(dist)\n        exit()\n    \n    for i in range(4):\n        nx, ny = x + dx[i], y + dy[i]\n        \n        if 0 <= nx < N and 0 <= ny < M:\n            if maze[nx][ny] == '0' and not visited[nx][ny][broken]:\n                visited[nx][ny][broken] = 1\n                queue.append((nx, ny, broken, dist + 1))\n            elif maze[nx][ny] == '1' and broken == 0 and not visited[nx][ny][1]:\n                visited[nx][ny][1] = 1\n                queue.append((nx, ny, 1, dist + 1))\n\nprint(-1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2213",
    "step_title": "트리에서의 동적 계획법",
    "title": "트리의 독립집합",
    "level": 15,
    "tags": [
      "다이나믹 프로그래밍",
      "트리",
      "트리에서의 다이나믹 프로그래밍",
      "역추적"
    ],
    "description": "그래프 G(V, E)에서 정점의 부분 집합 S에 속한 모든 정점쌍이 서로 인접하지 않으면 (정점쌍을 잇는 간선이 없으면) S를 독립 집합(independent set)이라고 한다. 독립 집합의 크기는 정점에 가중치가 주어져 있지 않을 경우는 독립 집합에 속한 정점의 수를 말하고, 정점에 가중치가 주어져 있으면 독립 집합에 속한 정점의 가중치의 합으로 정의한다. 독립 집합이 공집합일 때 그 크기는 0이라고 하자. 크기가 최대인 독립 집합을 최대 독립 집합이라고 한다.문제는 일반적인 그래프가 아니라 트리(연결되어 있고 사이클이 없는 그래프)와 각 정점의 가중치가 양의 정수로 주어져 있을 때, 최대 독립 집합을 구하는 것이다.",
    "input_description": "첫째 줄에 트리의 정점의 수 n이 주어진다. n은 10,000이하인 양의 정수이다. 1부터 n사이의 정수가 트리의 정점이라고 가정한다. 둘째 줄에는 n개의 정수 w1, w2, ..., wn이 주어지는데, wi는 정점 i의 가중치이다(1 ≤ i ≤ n). 셋째 줄부터 마지막 줄까지는 간선의 리스트가 주어지는데, 한 줄에 하나의 간선을 나타낸다. 간선은 정점의 쌍으로 주어진다. 입력되는 정수들 사이에는 빈 칸이 하나 있다. 가중치들의 값은 10,000을 넘지 않는 자연수이다.",
    "output_description": "첫째 줄에 최대 독립집합의 크기를 출력한다. 둘째 줄에는 최대 독립집합에 속하는 정점을 오름차순으로 출력한다. 최대 독립 집합이 하나 이상일 경우에는 하나만 출력하면 된다.",
    "examples": [
      {
        "input": "7\n10 30 40 10 20 20 70\n1 2\n2 3\n4 3\n4 5\n6 2\n6 7",
        "output": "140\n1 3 5 7"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2213",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\nn = int(input())\nweight = [0] + list(map(int, input().split()))\n\ntree = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    tree[a].append(b)\n    tree[b].append(a)\n\ndp = [[0, 0] for _ in range(n + 1)]\nvisited = [False] * (n + 1)\n\ndef dfs(node):\n    visited[node] = True\n    dp[node][0] = 0\n    dp[node][1] = weight[node]\n    \n    for child in tree[node]:\n        if not visited[child]:\n            dfs(child)\n            dp[node][0] += max(dp[child][0], dp[child][1])\n            dp[node][1] += dp[child][0]\n\ndfs(1)\n\nresult = []\ndef trace(node, include):\n    visited[node] = True\n    if include:\n        result.append(node)\n        for child in tree[node]:\n            if not visited[child]:\n                trace(child, False)\n    else:\n        for child in tree[node]:\n            if not visited[child]:\n                if dp[child][1] > dp[child][0]:\n                    trace(child, True)\n                else:\n                    trace(child, False)\n\nvisited = [False] * (n + 1)\nif dp[1][1] > dp[1][0]:\n    trace(1, True)\nelse:\n    trace(1, False)\n\nprint(max(dp[1][0], dp[1][1]))\nresult.sort()\nprint(' '.join(map(str, result)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2231",
    "step_title": "브루트 포스",
    "title": "분해합",
    "level": 4,
    "tags": [
      "브루트포스 알고리즘"
    ],
    "description": "어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다. 어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다. 예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다. 따라서 245는 256의 생성자가 된다. 물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다. 반대로, 생성자가 여러 개인 자연수도 있을 수 있다.자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.",
    "output_description": "첫째 줄에 답을 출력한다. 생성자가 없는 경우에는 0을 출력한다.",
    "examples": [
      {
        "input": "216",
        "output": "198"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2231",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nresult = 0\n\nfor i in range(1, N+1):\n    total = i + sum(int(digit) for digit in str(i))\n    if total == N:\n        result = i\n        break\n\nprint(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: 브루트포스",
        "solution_code": "N = int(input())\nfor i in range(1, N+1):\n    if i + sum(map(int, str(i))) == N:\n        print(i)\n        break\nelse:\n    print(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "모든 경우 확인",
            "description": "1부터 N까지 분해합을 계산하여 확인합니다.",
            "code_pattern": "if i + sum(map(int, str(i))) == N:",
            "socratic_hint": "분해합을 계산하려면?",
            "hint": "자릿수를 더합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3: 시작점 최적화",
        "solution_code": "N = int(input())\nstart = max(1, N - 9 * len(str(N)))\nfor i in range(start, N+1):\n    if i + sum(map(int, str(i))) == N:\n        print(i)\n        break\nelse:\n    print(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "탐색 범위 줄이기",
            "description": "생성자는 N - 9*자릿수보다 작을 수 없습니다.",
            "code_pattern": "start = max(1, N - 9 * len(str(N)))",
            "socratic_hint": "탐색 범위를 줄이려면?",
            "hint": "가능한 최소값부터 시작합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2252",
    "step_title": "위상 정렬",
    "title": "줄 세우기",
    "level": 13,
    "tags": [
      "그래프 이론",
      "방향 비순환 그래프",
      "위상 정렬"
    ],
    "description": "N명의 학생들을 키 순서대로 줄을 세우려고 한다. 각 학생의 키를 직접 재서 정렬하면 간단하겠지만, 마땅한 방법이 없어서 두 학생의 키를 비교하는 방법을 사용하기로 하였다. 그나마도 모든 학생들을 다 비교해 본 것이 아니고, 일부 학생들의 키만을 비교해 보았다.일부 학생들의 키를 비교한 결과가 주어졌을 때, 줄을 세우는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N(1 ≤ N ≤ 32,000), M(1 ≤ M ≤ 100,000)이 주어진다. M은 키를 비교한 횟수이다. 다음 M개의 줄에는 키를 비교한 두 학생의 번호 A, B가 주어진다. 이는 학생 A가 학생 B의 앞에 서야 한다는 의미이다.학생들의 번호는 1번부터 N번이다.",
    "output_description": "첫째 줄에 학생들을 앞에서부터 줄을 세운 결과를 출력한다. 답이 여러 가지인 경우에는 아무거나 출력한다.",
    "examples": [
      {
        "input": "3 2\n1 3\n2 3",
        "output": "1 2 3"
      },
      {
        "input": "4 2\n4 2\n3 1",
        "output": "4 2 3 1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2252",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\nindegree = [0] * (N + 1)\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    indegree[b] += 1\n\nqueue = deque()\nfor i in range(1, N + 1):\n    if indegree[i] == 0:\n        queue.append(i)\n\nresult = []\nwhile queue:\n    node = queue.popleft()\n    result.append(node)\n    \n    for next_node in graph[node]:\n        indegree[next_node] -= 1\n        if indegree[next_node] == 0:\n            queue.append(next_node)\n\nprint(' '.join(map(str, result)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2263",
    "step_title": "트리",
    "title": "트리의 순회",
    "level": 15,
    "tags": [
      "트리",
      "분할 정복",
      "재귀"
    ],
    "description": "n개의 정점을 갖는 이진 트리의 정점에 1부터 n까지의 번호가 중복 없이 매겨져 있다. 이와 같은 이진 트리의 인오더와 포스트오더가 주어졌을 때, 프리오더를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 n(1 ≤ n ≤ 100,000)이 주어진다. 다음 줄에는 인오더를 나타내는 n개의 자연수가 주어지고, 그 다음 줄에는 같은 식으로 포스트오더가 주어진다.",
    "output_description": "첫째 줄에 프리오더를 출력한다.",
    "examples": [
      {
        "input": "3\n1 2 3\n1 3 2",
        "output": "2 1 3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2263",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nsys.setrecursionlimit(10**6)\n\ndef solve(in_start, in_end, post_start, post_end):\n    if in_start > in_end or post_start > post_end:\n        return\n    \n    root = postorder[post_end]\n    print(root, end=' ')\n    \n    root_idx = position[root]\n    left_size = root_idx - in_start\n    \n    solve(in_start, root_idx - 1, post_start, post_start + left_size - 1)\n    solve(root_idx + 1, in_end, post_start + left_size, post_end - 1)\n\nn = int(input())\ninorder = list(map(int, input().split()))\npostorder = list(map(int, input().split()))\n\nposition = {}\nfor i, val in enumerate(inorder):\n    position[val] = i\n\nsolve(0, n - 1, 0, n - 1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2292",
    "step_title": "수학 1",
    "title": "벌집",
    "level": 4,
    "tags": [
      "수학"
    ],
    "description": "위의 그림과 같이 육각형으로 이루어진 벌집이 있다. 그림에서 보는 바와 같이 중앙의 방 1부터 시작해서 이웃하는 방에 돌아가면서 1씩 증가하는 번호를 주소로 매길 수 있다. 숫자 N이 주어졌을 때, 벌집의 중앙 1에서 N번 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나가는지(시작과 끝을 포함하여)를 계산하는 프로그램을 작성하시오. 예를 들면, 13까지는 3개, 58까지는 5개를 지난다.",
    "input_description": "첫째 줄에 N(1 ≤ N ≤ 1,000,000,000)이 주어진다.",
    "output_description": "입력으로 주어진 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나는지 출력한다.",
    "examples": [
      {
        "input": "13",
        "output": "3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2292",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nlayer = 1\ncount = 1\nwhile count < N:\n    count += 6 * layer\n    layer += 1\nprint(layer)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2293",
    "step_title": "동적 계획법 2",
    "title": "동전 1",
    "level": 12,
    "tags": [
      "다이나믹 프로그래밍"
    ],
    "description": "n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그 경우의 수를 구하시오. 각각의 동전은 몇 개라도 사용할 수 있다.사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.",
    "input_description": "첫째 줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다. 동전의 가치는 100,000보다 작거나 같은 자연수이다.",
    "output_description": "첫째 줄에 경우의 수를 출력한다. 경우의 수는 231보다 작다.",
    "examples": [
      {
        "input": "3 10\n1\n2\n5",
        "output": "10"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2293",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N, K = map(int, input().split())\ncoins = []\nfor _ in range(N):\n    coins.append(int(input()))\n\ndp = [0] * (K + 1)\ndp[0] = 1\n\nfor coin in coins:\n    for i in range(coin, K + 1):\n        dp[i] += dp[i - coin]\n\nprint(dp[K])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2315",
    "step_title": "동적 계획법 4",
    "title": "가로등 끄기",
    "level": 18,
    "tags": [
      "다이나믹 프로그래밍",
      "누적 합"
    ],
    "description": "연구소에서 “초 울트라 캡쑝 으라차 마징가 Z”(이하 마징가)를 완성했다. 하지만 지구는 이미 태권 V로 인해 평화로운 상태를 유지하고 있기 때문에 마징가는 동네에서 가로등을 끄는 일을 시키기로 했다.마을의 중심에는 매우 긴 도로가 있는데, 이 도로 변에는 가로등이 세워져 있다. 마징가는 이 가로등을 매일 새벽 5시에 끄기 시작해야 한다. 새벽 5시 정각에 마징가는 정확히 여러 가로등 중에서 어느 한 가로등 바로 밑에 위치하고 있다가 일을 시작한다. 그런데, 가로등에는 일정량의 전력을 소비하는 전구가 달려있고, 우리의 날쌘돌이 마징가는 절약정신이 매우 투철하기 때문에 쓸데없이 전력을 낭비하길 원치 않는다.그래서 소비전력을 최소화할 수 있도록 가로등을 끄는 순서를 알아내고 싶어 한다. 마징가는 일정하게 1m/sec 의 속도로 움직이며, 가로등을 끈 동안의 시간은 무시해도 된다. 왜냐하면 마징가는 너무 날쌔기 때문에 지나가면서 순식간에 가로등을 끌 수 있기 때문이다.그렇다면, 절약정신으로 똘똘 뭉쳐진 우리의 날쌘돌이 마징가를 도와줄 수 있는 프로그램을 작성하시오.가로등의 위치와 그 가로등이 소비하는 전력의 양이 주어져 있을 때, 5시 정각이후에 낭비될 수 있는 전력의 최솟값을 구하면 된다.",
    "input_description": "첫째 줄에는 2개의 정수 N(1 ≤ N ≤ 1,000), M 이 있다. 첫 번째 정수 N은 가로등의 개수를 나타내는 정수이고, 두 번째 정수 M은 마징가 처음에 위치하는 가로등 번호이다. 다음 N 개의 줄에는 각 가로등에 관한 두 개의 정수가 입력된다. 첫 번째 정수 D(0 ≤ D ≤ 1,000)는 가로등의 위치를 나타내고, 두 번째 정수는 이 가로등의 전력소비량 W(1 ≤ W ≤ 100,000,000)을 나타낸다. 가로등의 위치는 마을이 시작되는 부분부터의 거리를 나타내며, 전력소비량은 1초당 소비되는 전력량을 나타낸다. 그러므로, 어떤 가로등의 전력소비량이 w 이고, 이 가로등이 s 초 동안 켜져 있는 동안에 소비된 전력량은 ws 가 된다. 가로등은 위치를 나타내는 정수 D 의 오름차순으로 입력된다. 같은 줄에 나타나는 정수들 사이에는 하나의 space 가 있다. 가로등 번호는 입력되는 순서대로 1번, 2번, ..., N 번을 부여한다.단, 낭비되는 전력의 최솟값이 1,000,000,000 보다는 항상 작은 데이터가 입력된다.",
    "output_description": "첫 줄에 낭비되는 전력의 최솟값을 나타내는 정수를 출력한다.",
    "examples": [
      {
        "input": "6 5\r\n3 2\r\n11 10\r\n12 18\r\n13 19\r\n15 15\r\n17 19",
        "output": "370"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2315",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2316",
    "step_title": "네트워크 플로우 1",
    "title": "도시 왕복하기 2",
    "level": 18,
    "tags": [
      "그래프 이론",
      "최대 유량"
    ],
    "description": "N개의 도시가 P개의 양방향 길로 연결되어 있다. 이석원은 1번 도시와 2번 도시 사이를 오가며 워해머를 한다. 성실한 이석원은 두 도시 사이를 최대한 많이 왔다 갔다 하려 하는데, 이때 한 번 방문했던 도시(1, 2번 도시 제외)를 두 번 이상 방문하지 않으려 한다. 한 번 1번 도시와 2번 도시 사이를 오갈 때, 반드시 한 개 이상의 도시를 중간에 거쳐야 한다. 입력에는 1번 도시와 2번 도시를 연결하는 길은 없다. 도시의 번호는 1번부터 N번까지이다.",
    "input_description": "첫째 줄에 두 정수 N(3 ≤ N ≤ 400), P(1 ≤ P ≤ 10,000)이 주어진다. 다음 P개의 줄에는 각 길이 연결하는 서로 다른 두 도시의 번호가 주어진다.",
    "output_description": "첫째 줄에 왔다 갔다 할 수 있는 최대 횟수를 출력한다.",
    "examples": [
      {
        "input": "5 5\n1 3\n3 2\n1 5\n5 4\n4 2",
        "output": "2"
      },
      {
        "input": "6 7\n1 3\n3 2\n1 4\n4 2\n1 5\n5 6\n6 2",
        "output": "3"
      },
      {
        "input": "7 8\n1 3\n1 4\n3 5\n4 5\n5 6\n5 7\n6 2\n7 2",
        "output": "1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2316",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2346",
    "step_title": "스택, 큐, 덱 1",
    "title": "풍선 터뜨리기",
    "level": 8,
    "tags": [
      "자료 구조",
      "덱"
    ],
    "description": "1번부터 N번까지 N개의 풍선이 원형으로 놓여 있고. i번 풍선의 오른쪽에는 i+1번 풍선이 있고, 왼쪽에는 i-1번 풍선이 있다. 단, 1번 풍선의 왼쪽에 N번 풍선이 있고, N번 풍선의 오른쪽에 1번 풍선이 있다. 각 풍선 안에는 종이가 하나 들어있고, 종이에는 -N보다 크거나 같고, N보다 작거나 같은 정수가 하나 적혀있다. 이 풍선들을 다음과 같은 규칙으로 터뜨린다.우선, 제일 처음에는 1번 풍선을 터뜨린다. 다음에는 풍선 안에 있는 종이를 꺼내어 그 종이에 적혀있는 값만큼 이동하여 다음 풍선을 터뜨린다. 양수가 적혀 있을 경우에는 오른쪽으로, 음수가 적혀 있을 때는 왼쪽으로 이동한다. 이동할 때에는 이미 터진 풍선은 빼고 이동한다.예를 들어 다섯 개의 풍선 안에 차례로 3, 2, 1, -3, -1이 적혀 있었다고 하자. 이 경우 3이 적혀 있는 1번 풍선, -3이 적혀 있는 4번 풍선, -1이 적혀 있는 5번 풍선, 1이 적혀 있는 3번 풍선, 2가 적혀 있는 2번 풍선의 순서대로 터지게 된다.",
    "input_description": "첫째 줄에 자연수 N(1 ≤ N ≤ 1,000)이 주어진다. 다음 줄에는 차례로 각 풍선 안의 종이에 적혀 있는 수가 주어진다. 종이에 0은 적혀있지 않다.",
    "output_description": "첫째 줄에 터진 풍선의 번호를 차례로 나열한다.",
    "examples": [
      {
        "input": "5\n3 2 1 -3 -1",
        "output": "1 4 5 3 2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2346",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import deque\n\nN = int(input())\nmoves = list(map(int, input().split()))\n\ndq = deque([(i + 1, moves[i]) for i in range(N)])\nresult = []\n\nwhile dq:\n    idx, move = dq.popleft()\n    result.append(idx)\n    \n    if not dq:\n        break\n    \n    if move > 0:\n        dq.rotate(-(move - 1))\n    else:\n        dq.rotate(-move)\n\nprint(' '.join(map(str, result)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2357",
    "step_title": "세그먼트 트리 1",
    "title": "최솟값과 최댓값",
    "level": 15,
    "tags": [
      "세그먼트 트리",
      "자료 구조"
    ],
    "description": "N(1 ≤ N ≤ 100,000)개의 정수들이 있을 때, a번째 정수부터 b번째 정수까지 중에서 제일 작은 정수, 또는 제일 큰 정수를 찾는 것은 어려운 일이 아니다. 하지만 이와 같은 a, b의 쌍이 M(1 ≤ M ≤ 100,000)개 주어졌을 때는 어려운 문제가 된다. 이 문제를 해결해 보자.여기서 a번째라는 것은 입력되는 순서로 a번째라는 이야기이다. 예를 들어 a=1, b=3이라면 입력된 순서대로 1번, 2번, 3번 정수 중에서 최소, 최댓값을 찾아야 한다. 각각의 정수들은 1이상 1,000,000,000이하의 값을 갖는다.",
    "input_description": "첫째 줄에 N, M이 주어진다. 다음 N개의 줄에는 N개의 정수가 주어진다. 다음 M개의 줄에는 a, b의 쌍이 주어진다.",
    "output_description": "M개의 줄에 입력받은 순서대로 각 a, b에 대한 답을 최솟값, 최댓값 순서로 출력한다.",
    "examples": [
      {
        "input": "10 4\r\n75\r\n30\r\n100\r\n38\r\n50\r\n51\r\n52\r\n20\r\n81\r\n5\r\n1 10\r\n3 5\r\n6 9\r\n8 10",
        "output": "5 100\r\n38 100\r\n20 81\r\n5 81"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2357",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\ninput = sys.stdin.readline\n\nclass SegmentTree:\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree_min = [float('inf')] * (4 * self.n)\n        self.tree_max = [float('-inf')] * (4 * self.n)\n        self.build(arr, 1, 0, self.n - 1)\n    \n    def build(self, arr, node, start, end):\n        if start == end:\n            self.tree_min[node] = arr[start]\n            self.tree_max[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build(arr, node * 2, start, mid)\n            self.build(arr, node * 2 + 1, mid + 1, end)\n            self.tree_min[node] = min(self.tree_min[node * 2], self.tree_min[node * 2 + 1])\n            self.tree_max[node] = max(self.tree_max[node * 2], self.tree_max[node * 2 + 1])\n    \n    def query(self, node, start, end, left, right):\n        if left > end or right < start:\n            return (float('inf'), float('-inf'))\n        if left <= start and end <= right:\n            return (self.tree_min[node], self.tree_max[node])\n        mid = (start + end) // 2\n        left_result = self.query(node * 2, start, mid, left, right)\n        right_result = self.query(node * 2 + 1, mid + 1, end, left, right)\n        return (min(left_result[0], right_result[0]), max(left_result[1], right_result[1]))\n\nN, M = map(int, input().split())\narr = [int(input()) for _ in range(N)]\n\nseg = SegmentTree(arr)\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    min_val, max_val = seg.query(1, 0, N - 1, a - 1, b - 1)\n    print(min_val, max_val)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2365",
    "step_title": "네트워크 플로우 1",
    "title": "숫자판 만들기",
    "level": 19,
    "tags": [
      "그래프 이론",
      "이분 탐색",
      "매개 변수 탐색",
      "최대 유량"
    ],
    "description": "가로의 크기와 세로의 크기가 각각 N인 숫자판이 있다. 숫자판의 각 칸에는 음 아닌 정수들만 들어갈 수 있고 각 행과 각 열의 합이 미리 주어진다고 하자. N=2 인 경우의 예가 다음에 있다.??12??4610위 그림에서 숫자판 옆의 수는 해당하는 행에 들어가는 숫자의 합을 나타내며, 숫자판 아래의 수는 해당하는 열에 들어가는 숫자의 합을 나타낸다. 이제, 숫자판에 주어진 합과 일치하도록 수를 넣으려고 한다. 합이 일치되도록 숫자를 넣는 방법은 여러 가지 있을 수 있으며 위의 예에 대해 서로 다른 형태를 3가지만 보이면 다음과 같다.571366044822이 문제에서는 가능한 여러 가지 형태중 숫자판에 들어가는 최대 숫자의 값을 최소로 하는 형태를 찾고자 한다. 그러므로, 위의 예에서는 최대 숫자가 6 인 형태가 원하는 답이다. 이 문제를 해결하는 프로그램을 작성하시오.",
    "input_description": "입력의 첫째 줄에는 행(열)의 크기 N이 주어진다(1 ≤ N ≤ 50). 둘째 줄에는 N개의 정수가 주어진다. 주어지는 정수는 1행부터 N행까지의 합을 차례대로 나타낸다. 셋째 줄에는 N개의 정수가 주어진다. 주어지는 정수는 1열부터 N열까지의 합을 차례대로 나타낸다. 합을 나타내는 각 정수는 0 이상 10000 이하이다. 숫자판을 구성할 수 없는 입력은 주어지지 않는다고 가정한다.",
    "output_description": "첫 줄에는 배정된 수들중 최댓값을 출력한다. 둘째 줄부터 (N+1)째줄까지 각 행에 배정된 수들을 한 줄에 한 행씩 출력한다. 배정되는 각각의 정수는 0 이상이어야 한다.",
    "examples": [
      {
        "input": "2\n12 4\n6 10",
        "output": "6\n6 6\n0 4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2365",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2438",
    "step_title": "반복문",
    "title": "별 찍기 - 1",
    "level": 1,
    "tags": [
      "구현"
    ],
    "description": "첫째 줄에는 별 1개, 둘째 줄에는 별 2개, N번째 줄에는 별 N개를 찍는 문제",
    "input_description": "첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.",
    "output_description": "첫째 줄부터 N번째 줄까지 차례대로 별을 출력한다.",
    "examples": [
      {
        "input": "5",
        "output": "*\r\n**\r\n***\r\n****\r\n*****"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2438",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1: for 반복문",
        "solution_code": "N = int(input())\nfor i in range(1, N+1):\n    print('*' * i)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "N 입력받기",
            "description": "별을 찍을 줄 수를 입력받습니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "줄 수를 입력받으려면?",
            "hint": "N = int(input())을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "1부터 N까지 반복",
            "description": "각 줄마다 별의 개수가 증가합니다.",
            "code_pattern": "for i in range(1, N+1):",
            "socratic_hint": "1부터 N까지 반복하려면?",
            "hint": "range(1, N+1)을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "i개의 별 출력",
            "description": "문자열 곱셈으로 i개의 별을 한 번에 출력합니다.",
            "code_pattern": "    print('*' * i)",
            "socratic_hint": "같은 문자를 여러 개 출력하려면?",
            "hint": "'*' * i로 i개의 별을 만들 수 있습니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: 중첩 반복문",
        "solution_code": "N = int(input())\nfor i in range(1, N+1):\n    for j in range(i):\n        print('*', end='')\n    print()",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "N 입력받기",
            "description": "별을 찍을 줄 수를 입력받습니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "줄 수를 입력받으려면?",
            "hint": "N = int(input())을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문으로 줄 수 제어",
            "description": "1부터 N까지 각 줄을 처리합니다.",
            "code_pattern": "for i in range(1, N+1):",
            "socratic_hint": "줄 수를 제어하려면?",
            "hint": "외부 for 반복문을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "내부 반복문으로 별 출력",
            "description": "각 줄에서 i개의 별을 출력합니다. end=''로 줄바꿈을 방지합니다.",
            "code_pattern": "    for j in range(i):\n        print('*', end='')",
            "socratic_hint": "한 줄에 여러 별을 출력하려면?",
            "hint": "내부 for 반복문과 end=''를 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "줄바꿈",
            "description": "각 줄이 끝나면 줄바꿈을 합니다.",
            "code_pattern": "    print()",
            "socratic_hint": "줄을 바꾸려면?",
            "hint": "print()로 줄바꿈합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3: 리스트 컴프리헨션",
        "solution_code": "N = int(input())\nprint('\\n'.join(['*' * i for i in range(1, N+1)]))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "한 줄로 처리",
            "description": "리스트 컴프리헨션과 join으로 한 번에 처리합니다.",
            "code_pattern": "print('\\n'.join(['*' * i for i in range(1, N+1)]))",
            "socratic_hint": "모든 줄을 한 번에 만들려면?",
            "hint": "리스트 컴프리헨션과 join을 사용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4: while문",
        "solution_code": "N = int(input())\ni = 1\nwhile i <= N:\n    print('*' * i)\n    i += 1",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "while로 반복",
            "description": "while문으로 카운터를 증가시키며 출력합니다.",
            "code_pattern": "while i <= N:",
            "socratic_hint": "while문으로 반복하려면?",
            "hint": "조건을 확인하며 반복합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2439",
    "step_title": "반복문",
    "title": "별 찍기 - 2",
    "level": 2,
    "tags": [
      "구현"
    ],
    "description": "첫째 줄에는 별 1개, 둘째 줄에는 별 2개, N번째 줄에는 별 N개를 찍는 문제하지만, 오른쪽을 기준으로 정렬한 별(예제 참고)을 출력하시오.",
    "input_description": "첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.",
    "output_description": "첫째 줄부터 N번째 줄까지 차례대로 별을 출력한다.",
    "examples": [
      {
        "input": "5",
        "output": "*\r\n   **\r\n  ***\r\n ****\r\n*****"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2439",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nfor i in range(1, N + 1):\n    spaces = ' ' * (N - i)\n    stars = '*' * i\n    print(spaces + stars)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "줄 수 입력",
            "description": "출력할 줄 수 N을 입력받습니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "줄 수를 입력받으려면?",
            "hint": "N = int(input())"
          },
          {
            "step_id": 2,
            "goal": "1부터 N까지 반복",
            "description": "각 줄을 처리하기 위해 반복합니다.",
            "code_pattern": "for i in range(1, N + 1):",
            "socratic_hint": "N줄을 출력하려면?",
            "hint": "for i in range(1, N + 1):"
          },
          {
            "step_id": 3,
            "goal": "공백 개수 계산",
            "description": "i번째 줄에는 (N - i)개의 공백이 필요합니다.",
            "code_pattern": "    spaces = ' ' * (N - i)",
            "socratic_hint": "오른쪽 정렬을 위해 앞에 공백이 몇 개 필요한가요?",
            "hint": "(N - i)개의 공백이 필요합니다."
          },
          {
            "step_id": 4,
            "goal": "별 개수 계산",
            "description": "i번째 줄에는 i개의 별이 필요합니다.",
            "code_pattern": "    stars = '*' * i",
            "socratic_hint": "i번째 줄에 별을 몇 개 출력하나요?",
            "hint": "i개의 별을 출력합니다."
          },
          {
            "step_id": 5,
            "goal": "공백 + 별 출력",
            "description": "공백과 별을 합쳐서 출력합니다.",
            "code_pattern": "    print(spaces + stars)",
            "socratic_hint": "공백과 별을 이어붙여 출력하려면?",
            "hint": "print(' ' * (N - i) + '*' * i)"
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "N = int(input())\ni = 1\nwhile i <= N:\n    spaces = ' ' * (N - i)\n    stars = '*' * i\n    i += 1\n    print(spaces + stars)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "반복 처리",
            "description": "while i <= N:로 반복 작업을 수행합니다.",
            "code_pattern": "while i <= N:",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(spaces + stars)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3: rjust 활용",
        "solution_code": "N = int(input())\nfor i in range(1, N+1):\n    print(('*' * i).rjust(N))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "rjust로 오른쪽 정렬",
            "description": "rjust() 메서드로 오른쪽 정렬합니다.",
            "code_pattern": "('*' * i).rjust(N)",
            "socratic_hint": "문자열을 오른쪽 정렬하려면?",
            "hint": "rjust()를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4: format 정렬",
        "solution_code": "N = int(input())\nfor i in range(1, N+1):\n    print('{:>{width}}'.format('*' * i, width=N))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "format으로 정렬",
            "description": "format의 정렬 기능을 사용합니다.",
            "code_pattern": "'{:>{width}}'.format('*' * i, width=N)",
            "socratic_hint": "format으로 정렬하려면?",
            "hint": "{:>width} 형식을 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2444",
    "step_title": "심화 1",
    "title": "별 찍기 - 7",
    "level": 3,
    "tags": [
      "구현"
    ],
    "description": "예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요.",
    "input_description": "첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.",
    "output_description": "첫째 줄부터 2×N-1번째 줄까지 차례대로 별을 출력한다.",
    "examples": [
      {
        "input": "5",
        "output": "*\r\n   ***\r\n  *****\r\n *******\r\n*********\r\n *******\r\n  *****\r\n   ***\r\n    *"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2444",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nfor i in range(1, N+1):\n    print(' ' * (N-i) + '*' * (2*i-1))\nfor i in range(N-1, 0, -1):\n    print(' ' * (N-i) + '*' * (2*i-1))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for i in range(1, N+1):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(' ' * (N-i) + '*' * (2*i-1))",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2447",
    "step_title": "재귀",
    "title": "별 찍기 - 10",
    "level": 11,
    "tags": [
      "분할 정복",
      "재귀"
    ],
    "description": "재귀적인 패턴으로 별을 찍어 보자. N이 3의 거듭제곱(3, 9, 27, ...)이라고 할 때, 크기 N의 패턴은 N×N 정사각형 모양이다.크기 3의 패턴은 가운데에 공백이 있고, 가운데를 제외한 모든 칸에 별이 하나씩 있는 패턴이다.***\r\n* *\r\n***N이 3보다 클 경우, 크기 N의 패턴은 공백으로 채워진 가운데의 (N/3)×(N/3) 정사각형을 크기 N/3의 패턴으로 둘러싼 형태이다. 예를 들어 크기 27의 패턴은 예제 출력 1과 같다.",
    "input_description": "첫째 줄에 N이 주어진다. N은 3의 거듭제곱이다. 즉 어떤 정수 k에 대해 N=3k이며, 이때 1 ≤ k < 8이다.",
    "output_description": "첫째 줄부터 N번째 줄까지 별을 출력한다.",
    "examples": [
      {
        "input": "27",
        "output": "***************************\n* ** ** ** ** ** ** ** ** *\n***************************\n***   ******   ******   ***\n* *   * ** *   * ** *   * *\n***   ******   ******   ***\n***************************\n* ** ** ** ** ** ** ** ** *\n***************************\n*********         *********\n* ** ** *         * ** ** *\n*********         *********\n***   ***         ***   ***\n* *   * *         * *   * *\n***   ***         ***   ***\n*********         *********\n* ** ** *         * ** ** *\n*********         *********\n***************************\n* ** ** ** ** ** ** ** ** *\n***************************\n***   ******   ******   ***\n* *   * ** *   * ** *   * *\n***   ******   ******   ***\n***************************\n* ** ** ** ** ** ** ** ** *\n***************************"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2447",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def draw_star(n):\n    if n == 1:\n        return ['*']\n    \n    stars = draw_star(n // 3)\n    L = []\n    \n    for star in stars:\n        L.append(star * 3)\n    for star in stars:\n        L.append(star + ' ' * (n // 3) + star)\n    for star in stars:\n        L.append(star * 3)\n    \n    return L\n\nN = int(input())\nresult = draw_star(N)\nfor line in result:\n    print(line)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2470",
    "step_title": "투 포인터",
    "title": "두 용액",
    "level": 11,
    "tags": [
      "정렬",
      "이분 탐색",
      "두 포인터"
    ],
    "description": "KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. 각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다.  산성 용액의 특성값은 1부터 1,000,000,000까지의 양의 정수로 나타내고, 알칼리성 용액의 특성값은 -1부터 -1,000,000,000까지의 음의 정수로 나타낸다.같은 양의 두 용액을 혼합한 용액의 특성값은 혼합에 사용된 각 용액의 특성값의 합으로 정의한다. 이 연구소에서는 같은 양의 두 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 한다.예를 들어, 주어진 용액들의 특성값이 [-2, 4, -99, -1, 98]인 경우에는 특성값이 -99인 용액과 특성값이 98인 용액을 혼합하면 특성값이 -1인 용액을 만들 수 있고, 이 용액이 특성값이 0에 가장 가까운 용액이다. 참고로, 두 종류의 알칼리성 용액만으로나 혹은 두 종류의 산성 용액만으로 특성값이 0에 가장 가까운 혼합 용액을 만드는 경우도 존재할 수 있다.산성 용액과 알칼리성 용액의 특성값이 주어졌을 때, 이 중 두 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액을 찾는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에는 전체 용액의 수 N이 입력된다. N은 2 이상 100,000 이하이다. 둘째 줄에는 용액의 특성값을 나타내는 N개의 정수가 빈칸을 사이에 두고 주어진다. 이 수들은 모두 -1,000,000,000 이상 1,000,000,000 이하이다. N개의 용액들의 특성값은 모두 다르고, 산성 용액만으로나 알칼리성 용액만으로 입력이 주어지는 경우도 있을 수 있다.",
    "output_description": "첫째 줄에 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액의 특성값을 출력한다. 출력해야 하는 두 용액은 특성값의 오름차순으로 출력한다. 특성값이 0에 가장 가까운 용액을 만들어내는 경우가 두 개 이상일 경우에는 그 중 아무것이나 하나를 출력한다.",
    "examples": [
      {
        "input": "5\n-2 4 -99 -1 98",
        "output": "-99 98"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2470",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nsolutions = sorted(list(map(int, input().split())))\n\nleft, right = 0, N - 1\nmin_sum = float('inf')\nresult = (0, 0)\n\nwhile left < right:\n    current_sum = solutions[left] + solutions[right]\n    \n    if abs(current_sum) < abs(min_sum):\n        min_sum = current_sum\n        result = (solutions[left], solutions[right])\n    \n    if current_sum < 0:\n        left += 1\n    elif current_sum > 0:\n        right -= 1\n    else:\n        break\n\nprint(result[0], result[1])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = int(input())\nliquids = list(map(int, input().split()))\nliquids.sort()\n\nleft, right = 0, n - 1\nbest_sum = float('inf')\nresult = (liquids[0], liquids[-1])\n\nwhile left < right:\n    current_sum = liquids[left] + liquids[right]\n    \n    if abs(current_sum) < abs(best_sum):\n        best_sum = current_sum\n        result = (liquids[left], liquids[right])\n    \n    if current_sum < 0:\n        left += 1\n    elif current_sum > 0:\n        right -= 1\n    else:\n        break\n\nprint(result[0], result[1])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2480",
    "step_title": "조건문",
    "title": "주사위 세개",
    "level": 2,
    "tags": [
      "수학",
      "구현",
      "사칙연산",
      "많은 조건 분기"
    ],
    "description": "1에서부터 6까지의 눈을 가진 3개의 주사위를 던져서 다음과 같은 규칙에 따라 상금을 받는 게임이 있다.같은 눈이 3개가 나오면 10,000원+(같은 눈)×1,000원의 상금을 받게 된다.같은 눈이 2개만 나오는 경우에는 1,000원+(같은 눈)×100원의 상금을 받게 된다.모두 다른 눈이 나오는 경우에는 (그 중 가장 큰 눈)×100원의 상금을 받게 된다.예를 들어, 3개의 눈 3, 3, 6이 주어지면 상금은 1,000+3×100으로 계산되어 1,300원을 받게 된다. 또 3개의 눈이 2, 2, 2로 주어지면 10,000+2×1,000 으로 계산되어 12,000원을 받게 된다. 3개의 눈이 6, 2, 5로 주어지면 그중 가장 큰 값이 6이므로 6×100으로 계산되어 600원을 상금으로 받게 된다.3개 주사위의 나온 눈이 주어질 때, 상금을 계산하는 프로그램을 작성 하시오.",
    "input_description": "첫째 줄에 3개의 눈이 빈칸을 사이에 두고 각각 주어진다.",
    "output_description": "첫째 줄에 게임의 상금을 출력 한다.",
    "examples": [
      {
        "input": "3 3 6",
        "output": "1300"
      },
      {
        "input": "2 2 2",
        "output": "12000"
      },
      {
        "input": "6 2 5",
        "output": "600"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2480",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "a, b, c = map(int, input().split())\nif a == b == c:\n    print(10000 + a * 1000)\nelif a == b or a == c:\n    print(1000 + a * 100)\nelif b == c:\n    print(1000 + b * 100)\nelse:\n    print(max(a, b, c) * 100)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "주사위 세 개 입력",
            "description": "세 주사위의 눈 a, b, c를 각각 입력받습니다.",
            "code_pattern": "a = int(input())\nb = int(input())\nc = int(input())",
            "socratic_hint": "세 개의 주사위 눈을 입력받으려면?",
            "hint": "각각 int(input())으로 받습니다."
          },
          {
            "step_id": 2,
            "goal": "세 눈이 모두 같은지 확인",
            "description": "a == b == c 조건으로 세 값이 모두 같은지 확인합니다.",
            "code_pattern": "if a == b == c:",
            "socratic_hint": "세 개가 모두 같은지 어떻게 확인하나요?",
            "hint": "a == b == c를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "세 눈이 같을 때 상금",
            "description": "10000 + a * 1000을 계산합니다.",
            "code_pattern": "    prize = 10000 + a * 1000",
            "socratic_hint": "같은 눈이 3개일 때 상금 공식은?",
            "hint": "10000 + (같은 눈) × 1000"
          },
          {
            "step_id": 4,
            "goal": "두 눈이 같은지 확인 (a와 b 또는 a와 c)",
            "description": "a == b or a == c 조건으로 확인합니다.",
            "code_pattern": "elif a == b or a == c:",
            "socratic_hint": "a가 b나 c와 같은지 어떻게 확인하나요?",
            "hint": "or 연산자로 '또는'을 표현합니다."
          },
          {
            "step_id": 5,
            "goal": "a와 같은 눈이 있을 때 상금",
            "description": "1000 + a * 100을 계산합니다.",
            "code_pattern": "    prize = 1000 + a * 100",
            "socratic_hint": "같은 눈이 2개일 때 상금 공식은?",
            "hint": "1000 + (같은 눈) × 100"
          },
          {
            "step_id": 6,
            "goal": "b와 c가 같거나 모두 다른 경우",
            "description": "b == c면 1000 + b * 100, 모두 다르면 max(a, b, c) * 100입니다.",
            "code_pattern": "elif b == c:\n    prize = 1000 + b * 100\nelse:\n    prize = max(a, b, c) * 100",
            "socratic_hint": "b와 c만 같거나, 모두 다를 때는?",
            "hint": "모두 다를 때는 가장 큰 눈 × 100"
          },
          {
            "step_id": 7,
            "goal": "상금 출력",
            "description": "계산된 상금을 출력합니다.",
            "code_pattern": "print(prize)",
            "socratic_hint": "상금을 출력하려면?",
            "hint": "print(prize)"
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2482",
    "step_title": "동적 계획법 3",
    "title": "색상환",
    "level": 13,
    "tags": [
      "다이나믹 프로그래밍"
    ],
    "description": "색을 표현하는 기본 요소를 이용하여 표시할 수 있는 모든 색 중에서 대표적인 색을 고리 모양으로 연결하여 나타낸 것을 색상환이라고 한다. 미국의 화가 먼셀(Munsell)이 교육용으로 고안한 20색상환이 널리 알려져 있다. 아래 그림은 먼셀의 20색상환을 보여준다.그림 1. 먼셀의 20색상환색상환에서 인접한 두 색은 비슷하여 언뜻 보면 구별하기 어렵다. 위 그림의 20색상환에서 다홍은 빨강과 인접하고 또 주황과도 인접하다. 풀색은 연두, 녹색과 인접하다. 시각적 대비 효과를 얻기 위하여 인접한 두 색을 동시에 사용하지 않기로 한다.주어진 색상환에서 시각적 대비 효과를 얻기 위하여 서로 이웃하지 않은 색들을 선택하는 경우의 수를 생각해 보자.  먼셀의 20색상환에서 시각적 대비 효과를 얻을 수 있게 10개의 색을 선택하는 경우의 수는 2이지만, 시각적 대비 효과를 얻을 수 있게 11개 이상의 색을 선택할 수 없으므로 이 경우의 수는 0이다.주어진 정수 N과 K에 대하여, N개의 색으로 구성되어 있는 색상환 (N색상환)에서 어떤 인접한 두 색도 동시에 선택하지 않으면서 서로 다른 K개의 색을 선택하는 경우의 수를 구하는 프로그램을 작성하시오.",
    "input_description": "입력 파일의 첫째 줄에 색상환에 포함된 색의 개수를 나타내는 양의 정수 N(4 ≤ N ≤ 1,000)이 주어지고, 둘째 줄에 N색상환에서 선택할 색의 개수 K(1 ≤ K ≤ N)가 주어진다.",
    "output_description": "첫째 줄에 N색상환에서 어떤 인접한 두 색도 동시에 선택하지 않고 K개의 색을 고를 수 있는 경우의 수를 1,000,000,003 (10억 3) 으로 나눈 나머지를 출력한다.",
    "examples": [
      {
        "input": "4\n2",
        "output": "2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2482",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nK = int(input())\n\nMOD = 1000000003\n\ndp = [[0] * (N + 1) for _ in range(N + 1)]\n\nfor i in range(N + 1):\n    dp[i][0] = 1\n    dp[i][1] = i\n\nfor i in range(2, N + 1):\n    for j in range(2, i + 1):\n        dp[i][j] = (dp[i-1][j] + dp[i-2][j-1]) % MOD\n\nresult = (dp[N-3][K-1] + dp[N-1][K]) % MOD\nprint(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2485",
    "step_title": "약수, 배수와 소수 2",
    "title": "가로수",
    "level": 7,
    "tags": [
      "수학",
      "정수론",
      "유클리드 호제법"
    ],
    "description": "직선으로 되어있는 도로의 한 편에 가로수가 임의의 간격으로 심어져있다. KOI 시에서는 가로수들이 모두 같은 간격이 되도록 가로수를 추가로 심는 사업을 추진하고 있다. KOI 시에서는 예산문제로 가능한 한 가장 적은 수의 나무를 심고 싶다.편의상 가로수의 위치는 기준점으로 부터 떨어져 있는 거리로 표현되며, 가로수의 위치는 모두 양의 정수이다.예를 들어, 가로수가 (1, 3, 7, 13)의 위치에 있다면 (5, 9, 11)의 위치에 가로수를 더 심으면 모든 가로수들의 간격이 같게 된다. 또한, 가로수가 (2, 6, 12, 18)에 있다면 (4, 8, 10, 14, 16)에 가로수를 더 심어야 한다.심어져 있는 가로수의 위치가 주어질 때, 모든 가로수가 같은 간격이 되도록 새로 심어야 하는 가로수의 최소수를 구하는 프로그램을 작성하라. 단, 추가되는 나무는 기존의 나무들 사이에만 심을 수 있다.",
    "input_description": "첫째 줄에는 이미 심어져 있는 가로수의 수를 나타내는 하나의 정수 N이 주어진다(3 ≤ N ≤ 100,000). 둘째 줄부터 N개의 줄에는 각 줄마다 심어져 있는 가로수의 위치가 양의 정수로 주어지며, 가로수의 위치를 나타내는 정수는 1,000,000,000 이하이다. 가로수의 위치를 나타내는 정수는 모두 다르고, N개의 가로수는 기준점으로부터 떨어진 거리가 가까운 순서대로 주어진다.",
    "output_description": "모든 가로수가 같은 간격이 되도록 새로 심어야 하는 가로수의 최소수를 첫 번째 줄에 출력한다.",
    "examples": [
      {
        "input": "4\n1\n3\n7\n13",
        "output": "3"
      },
      {
        "input": "4\n2\n6\n12\n18",
        "output": "5"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2485",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import math\n\nN = int(input())\ntrees = []\nfor _ in range(N):\n    trees.append(int(input()))\n\ngaps = []\nfor i in range(1, N):\n    gaps.append(trees[i] - trees[i-1])\n\ngcd = gaps[0]\nfor gap in gaps[1:]:\n    gcd = math.gcd(gcd, gap)\n\ntotal_trees = (trees[-1] - trees[0]) // gcd + 1\nprint(total_trees - N)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2494",
    "step_title": "동적 계획법 4",
    "title": "숫자 맞추기",
    "level": 16,
    "tags": [
      "다이나믹 프로그래밍",
      "역추적"
    ],
    "description": "아래 그림과 같이 N개의 회전이 가능한 숫자 나사가 아래위로 연결되어 있다. 가장 위에 있는 숫자나사는 숫자나사 1이고 가장 아래에 있는 숫자나사는 숫자나사 N이다. 모든 숫자나사는 각각 10개의 면을 가지고 있고, 각 면에는 오른쪽 방향으로 0, 1, 2, 3, …, 9까지의 숫자가 하나씩 순서대로 적혀 있다. 하나의 숫자나사를 왼쪽으로 회전 시키면, 이 나사보다 아래에 위치한 모든 나사는 같이 따라서 돌게 되지만, 나사를 오른쪽으로 회전시키면, 다른 나사는 함께 돌지는 않는다. 정면에서 보아 위에서부터 아래쪽으로 숫자를 읽어 내려간다고 할 때, 현재의 상태에서 가장 적은 칸수의 움직임으로 원하는 숫자를 만들기 위한 방법을 출력하는 프로그램을 작성하라.예를 들어 세 개의 숫자나사가 주어졌을 때, 정면에서 보는 현재 상태가 326이고 원하는 상태는 446이라면 최소 회전 칸수는 4이다. 먼저 숫자나사 1을 왼쪽으로 한 칸 돌리면 437이 되고, 숫자나사 2를 역시 왼쪽으로 한 칸 돌리면 448이 되며, 마지막으로 숫자나사 3을 오른쪽으로 두 칸 돌리면 446이 된다.",
    "input_description": "첫째 줄에는 숫자나사의 개수 N이 주어지고, 둘째 줄에는 현재의 상태가, 셋째 줄에는 원하는 상태가 주어진다. N은 3 이상이고 10,000 이하이다.",
    "output_description": "첫째 줄에는 현재 상태에서 원하는 상태로 도달하는데 필요한 최소 회전 칸수를 출력한다. 다음 줄부터는 회전 순서대로 각 줄에 하나의 숫자나사 번호와 회전 칸수를 빈칸을 사이에 두고 출력한다. 회전 칸수는 왼쪽을 기준으로 하여 출력한다. 만일 왼쪽으로 4칸 회전한다면 4를, 오른쪽으로 3칸 회전한다면 -3을 출력한다. 답이 여러 개이면 그 중에 하나만 출력한다.",
    "examples": [
      {
        "input": "3\n326\n446",
        "output": "4\n1 1\n2 1\n3 -2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2494",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2501",
    "step_title": "약수, 배수와 소수 1",
    "title": "약수 구하기",
    "level": 3,
    "tags": [
      "수학",
      "브루트포스 알고리즘"
    ],
    "description": "어떤 자연수 p와 q가 있을 때, 만일 p를 q로 나누었을 때 나머지가 0이면 q는 p의 약수이다.6을 예로 들면6 ÷ 1 = 6 … 06 ÷ 2 = 3 … 06 ÷ 3 = 2 … 06 ÷ 4 = 1 … 26 ÷ 5 = 1 … 16 ÷ 6 = 1 … 0그래서 6의 약수는 1, 2, 3, 6, 총 네 개이다.두 개의 자연수 N과 K가 주어졌을 때, N의 약수들 중 K번째로 작은 수를 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N과 K가 빈칸을 사이에 두고 주어진다. N은 1 이상 10,000 이하이다. K는 1 이상 N 이하이다.",
    "output_description": "첫째 줄에 N의 약수들 중 K번째로 작은 수를 출력한다. 만일 N의 약수의 개수가 K개보다 적어서 K번째 약수가 존재하지 않을 경우에는 0을 출력하시오.",
    "examples": [
      {
        "input": "6 3",
        "output": "3"
      },
      {
        "input": "25 4",
        "output": "0"
      },
      {
        "input": "2735 1",
        "output": "1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2501",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "A, B = map(int, input().split())\nprint(A - B)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "여러 값 입력 받기",
            "description": "A, B = map(int, input().split())로 입력을 처리합니다.",
            "code_pattern": "A, B = map(int, input().split())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(A - B)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2525",
    "step_title": "조건문",
    "title": "오븐 시계",
    "level": 3,
    "tags": [
      "사칙연산",
      "수학"
    ],
    "description": "KOI 전자에서는 건강에 좋고 맛있는 훈제오리구이 요리를 간편하게 만드는 인공지능 오븐을 개발하려고 한다. 인공지능 오븐을 사용하는 방법은 적당한 양의 오리 훈제 재료를 인공지능 오븐에 넣으면 된다. 그러면 인공지능 오븐은 오븐구이가 끝나는 시간을 분 단위로 자동적으로 계산한다.또한, KOI 전자의 인공지능 오븐 앞면에는 사용자에게 훈제오리구이 요리가 끝나는 시각을 알려 주는 디지털 시계가 있다.훈제오리구이를 시작하는 시각과 오븐구이를 하는 데 필요한 시간이 분단위로 주어졌을 때, 오븐구이가 끝나는 시각을 계산하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에는 현재 시각이 나온다. 현재 시각은 시 A (0 ≤ A ≤ 23) 와 분 B (0 ≤ B ≤ 59)가 정수로 빈칸을 사이에 두고 순서대로 주어진다. 두 번째 줄에는 요리하는 데 필요한 시간 C (0 ≤ C ≤ 1,000)가 분 단위로 주어진다.",
    "output_description": "첫째 줄에 종료되는 시각의 시와 분을 공백을 사이에 두고 출력한다. (단, 시는 0부터 23까지의 정수, 분은 0부터 59까지의 정수이다. 디지털 시계는 23시 59분에서 1분이 지나면 0시 0분이 된다.)",
    "examples": [
      {
        "input": "14 30\n20",
        "output": "14 50"
      },
      {
        "input": "17 40\n80",
        "output": "19 0"
      },
      {
        "input": "23 48\n25",
        "output": "0 13"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2525",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "H, M = map(int, input().split())\nC = int(input())\nM += C\nH += M // 60\nM %= 60\nH %= 24\nprint(H, M)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "현재 시 입력",
            "description": "현재 시(H)를 입력받습니다.",
            "code_pattern": "H = int(input())",
            "socratic_hint": "현재 시를 입력받으려면?",
            "hint": "H = int(input())"
          },
          {
            "step_id": 2,
            "goal": "현재 분 입력",
            "description": "현재 분(M)을 입력받습니다.",
            "code_pattern": "M = int(input())",
            "socratic_hint": "현재 분을 입력받으려면?",
            "hint": "M = int(input())"
          },
          {
            "step_id": 3,
            "goal": "요리 시간 입력",
            "description": "요리하는 데 필요한 시간(분)을 입력받습니다.",
            "code_pattern": "cook_time = int(input())",
            "socratic_hint": "요리 시간을 입력받으려면?",
            "hint": "cook_time = int(input())"
          },
          {
            "step_id": 4,
            "goal": "분에 요리 시간 더하기",
            "description": "현재 분에 요리 시간을 더합니다.",
            "code_pattern": "M = M + cook_time",
            "socratic_hint": "현재 분에 요리 시간을 더하려면?",
            "hint": "M = M + cook_time"
          },
          {
            "step_id": 5,
            "goal": "60분 이상을 시간으로 변환",
            "description": "M // 60으로 몇 시간인지 계산하여 H에 더합니다.",
            "code_pattern": "H = H + M // 60",
            "socratic_hint": "예를 들어 80분은 몇 시간 몇 분인가요?",
            "hint": "//는 몫을 구합니다. M // 60은 시간입니다."
          },
          {
            "step_id": 6,
            "goal": "분을 60 미만으로 조정",
            "description": "M % 60으로 60을 넘지 않는 분만 남깁니다.",
            "code_pattern": "M = M % 60",
            "socratic_hint": "80분에서 1시간을 빼면 몇 분이 남나요?",
            "hint": "%는 나머지를 구합니다. M % 60은 분입니다."
          },
          {
            "step_id": 7,
            "goal": "시를 24시간 형식으로 조정하고 출력",
            "description": "H % 24로 시를 0~23 범위로 만들고, H와 M을 출력합니다.",
            "code_pattern": "H = H % 24\nprint(H, M)",
            "socratic_hint": "25시는 실제로는 다음날 몇 시인가요?",
            "hint": "H % 24로 24시간 형식으로 만들고 출력합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2533",
    "step_title": "트리에서의 동적 계획법",
    "title": "사회망 서비스(SNS)",
    "level": 13,
    "tags": [
      "다이나믹 프로그래밍",
      "트리에서의 다이나믹 프로그래밍",
      "트리"
    ],
    "description": "페이스북, 트위터, 카카오톡과 같은 사회망 서비스(SNS)가 널리 사용됨에 따라, 사회망을 통하여 사람들이 어떻게 새로운 아이디어를 받아들이게 되는가를 이해하는 문제가 중요해졌다. 사회망에서 사람들의 친구 관계는 그래프로 표현할 수 있는데,  이 그래프에서 사람은 정점으로 표현되고, 두 정점을 잇는 에지는 두 정점으로 표현되는 두 사람이 서로 친구 관계임을 표현한다.예를 들어, 철수와 영희, 철수와 만수, 영희와 순희가 서로 친구 관계라면 이를 표현하는 친구 관계 그래프는 다음과 같다.친구 관계 그래프를 이용하면 사회망 서비스에서 어떤 새로운 아이디어가 전파되는 과정을 이해하는데 도움을 줄 수 있다. 어떤 새로운 아이디어를 먼저 받아들인 사람을 얼리 아답터(early adaptor)라고 하는데, 사회망 서비스에 속한 사람들은 얼리 아답터이거나 얼리 아답터가 아니다. 얼리 아답터가 아닌 사람들은 자신의 모든 친구들이 얼리 아답터일 때만 이 아이디어를 받아들인다.어떤 아이디어를 사회망 서비스에서 퍼뜨리고자 할 때, 가능한 한 최소의 수의 얼리 아답터를 확보하여 모든 사람이 이 아이디어를 받아들이게 하는  문제는 매우 중요하다.일반적인 그래프에서 이 문제를 푸는 것이 매우 어렵다는 것이 알려져 있기 때문에, 친구 관계 그래프가 트리인 경우, 즉 모든 두 정점 사이에 이들을 잇는 경로가 존재하면서 사이클이 존재하지 않는 경우만 고려한다.예를 들어, 8명의 사람으로 이루어진 다음 친구 관계 트리를 생각해보자. 2, 3, 4번 노드가 표현하는 사람들이 얼리 아답터라면, 얼리 아답터가 아닌 사람들은 자신의 모든 친구가 얼리 아답터이기 때문에 새로운 아이디어를 받아들인다.친구 관계 트리가 주어졌을 때, 모든 개인이 새로운 아이디어를 수용하기 위하여 필요한 최소 얼리 어답터의 수를 구하는 프로그램을 작성하시오.",
    "input_description": "첫 번째 줄에는 친구 관계 트리의 정점 개수 N이 주어진다. 단, 2 ≤ N ≤ 1,000,000이며, 각 정점은 1부터 N까지 일련번호로 표현된다. 두 번째 줄부터 N-1개의 줄에는 각 줄마다 친구 관계 트리의 에지 (u, v)를 나타내는 두 정수 u와 v가 하나의 빈칸을 사이에 두고 주어진다.",
    "output_description": "주어진 친구 관계 그래프에서 아이디어를 전파하는데 필요한 얼리 아답터의 최소 수를 하나의 정수로 출력한다.",
    "examples": [
      {
        "input": "8\n1 2\n1 3\n1 4\n2 5\n2 6\n4 7\n4 8",
        "output": "3"
      },
      {
        "input": "9\n1 2\n1 3\n2 4\n3 5\n3 6\n4 7\n4 8\n4 9",
        "output": "3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2533",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(node):\n    visited[node] = True\n    dp[node][0] = 0\n    dp[node][1] = 1\n    \n    for child in tree[node]:\n        if not visited[child]:\n            dfs(child)\n            dp[node][0] += dp[child][1]\n            dp[node][1] += min(dp[child][0], dp[child][1])\n\nN = int(input())\ntree = [[] for _ in range(N + 1)]\ndp = [[0, 0] for _ in range(N + 1)]\nvisited = [False] * (N + 1)\n\nfor _ in range(N - 1):\n    u, v = map(int, input().split())\n    tree[u].append(v)\n    tree[v].append(u)\n\ndfs(1)\nprint(min(dp[1][0], dp[1][1]))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2557",
    "step_title": "입출력과 사칙연산",
    "title": "Hello World",
    "level": 1,
    "tags": [
      "구현"
    ],
    "description": "Hello World!를 출력하시오.",
    "input_description": "없음",
    "output_description": "Hello World!를 출력하시오.",
    "examples": [
      {
        "input": "",
        "output": "Hello World!"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2557",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "print(\"Hello World!\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "print() 함수로 Hello World! 출력",
            "description": "print() 함수를 사용하여 'Hello World!' 문자열을 화면에 출력합니다.",
            "code_pattern": "print(\"Hello World!\")",
            "socratic_hint": "문자열을 화면에 출력하려면 어떤 함수를 사용하나요?",
            "hint": "print(\"Hello World!\")를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: 변수 활용",
        "solution_code": "msg = \"Hello World!\"\nprint(msg)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문자열을 변수에 저장",
            "description": "출력할 문자열을 변수에 먼저 저장합니다.",
            "code_pattern": "msg = \"Hello World!\"",
            "socratic_hint": "문자열을 변수에 저장하려면?",
            "hint": "변수명 = '문자열' 형태로 저장합니다."
          },
          {
            "step_id": 2,
            "goal": "변수 출력",
            "description": "저장된 변수를 출력합니다.",
            "code_pattern": "print(msg)",
            "socratic_hint": "변수를 출력하려면?",
            "hint": "print(변수명)을 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3: f-string 활용",
        "solution_code": "greeting = \"Hello\"\ntarget = \"World\"\nprint(f\"{greeting} {target}!\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문자열 변수 선언",
            "description": "여러 부분으로 나누어 변수에 저장합니다.",
            "code_pattern": "greeting = \"Hello\"\ntarget = \"World\"",
            "socratic_hint": "문자열을 여러 변수로 나눌 수 있나요?",
            "hint": "각 부분을 별도 변수에 저장합니다."
          },
          {
            "step_id": 2,
            "goal": "f-string으로 조합하여 출력",
            "description": "f-string을 사용하여 변수들을 조합합니다.",
            "code_pattern": "print(f\"{greeting} {target}!\")",
            "socratic_hint": "변수들을 문자열로 조합하려면?",
            "hint": "f-string을 사용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4: sys.stdout 활용",
        "solution_code": "import sys\nsys.stdout.write('Hello World!\\n')",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "sys.stdout으로 출력",
            "description": "sys.stdout.write()를 사용하여 출력합니다.",
            "code_pattern": "sys.stdout.write('Hello World!\\n')",
            "socratic_hint": "print 대신 다른 출력 방법은?",
            "hint": "sys.stdout.write()를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 5,
        "solution_name": "풀이 5: 문자 반복",
        "solution_code": "h = 'Hello World!'\nfor c in h:\n    print(c, end='')\nprint()",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문자 하나씩 출력",
            "description": "문자열의 각 문자를 반복하며 출력합니다.",
            "code_pattern": "for c in h:\n    print(c, end='')",
            "socratic_hint": "문자열을 한 글자씩 출력하려면?",
            "hint": "for문으로 반복하며 end=''를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2559",
    "step_title": "누적 합",
    "title": "수열",
    "level": 8,
    "tags": [
      "누적 합",
      "두 포인터",
      "슬라이딩 윈도우"
    ],
    "description": "매일 아침 9시에 학교에서 측정한 온도가 어떤 정수의 수열로 주어졌을 때, 연속적인 며칠 동안의 온도의 합이 가장 큰 값을 알아보고자 한다.예를 들어, 아래와 같이 10일 간의 온도가 주어졌을 때,3 -2 -4 -9 0 3 7 13 8 -3모든 연속적인 이틀간의 온도의 합은 아래와 같다.이때, 온도의 합이 가장 큰 값은 21이다.또 다른 예로 위와 같은 온도가 주어졌을 때, 모든 연속적인 5일 간의 온도의 합은 아래와 같으며,이때, 온도의 합이 가장 큰 값은 31이다.매일 측정한 온도가 정수의 수열로 주어졌을 때, 연속적인 며칠 동안의 온도의 합이 가장 큰 값을 계산하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에는 두 개의 정수 N과 K가 한 개의 공백을 사이에 두고 순서대로 주어진다. 첫 번째 정수 N은 온도를 측정한 전체 날짜의 수이다. N은 2 이상 100,000 이하이다. 두 번째 정수 K는 합을 구하기 위한 연속적인 날짜의 수이다. K는 1과 N 사이의 정수이다. 둘째 줄에는 매일 측정한 온도를 나타내는 N개의 정수가 빈칸을 사이에 두고 주어진다. 이 수들은 모두 -100 이상 100 이하이다.",
    "output_description": "첫째 줄에는 입력되는 온도의 수열에서 연속적인 K일의 온도의 합이 최대가 되는 값을 출력한다.",
    "examples": [
      {
        "input": "10 2\n3 -2 -4 -9 0 3 7 13 8 -3",
        "output": "21"
      },
      {
        "input": "10 5\n3 -2 -4 -9 0 3 7 13 8 -3",
        "output": "31"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2559",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N, K = map(int, input().split())\ntemps = list(map(int, input().split()))\n\n# 첫 K개의 합\ncurrent_sum = sum(temps[:K])\nmax_sum = current_sum\n\n# 슬라이딩 윈도우\nfor i in range(K, N):\n    current_sum = current_sum - temps[i-K] + temps[i]\n    max_sum = max(max_sum, current_sum)\n\nprint(max_sum)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2562",
    "step_title": "1차원 배열",
    "title": "최댓값",
    "level": 3,
    "tags": [
      "구현"
    ],
    "description": "9개의 서로 다른 자연수가 주어질 때, 이들 중 최댓값을 찾고 그 최댓값이 몇 번째 수인지를 구하는 프로그램을 작성하시오.예를 들어, 서로 다른 9개의 자연수3, 29, 38, 12, 57, 74, 40, 85, 61이 주어지면, 이들 중 최댓값은 85이고, 이 값은 8번째 수이다.",
    "input_description": "첫째 줄부터 아홉 번째 줄까지 한 줄에 하나의 자연수가 주어진다. 주어지는 자연수는 100 보다 작다.",
    "output_description": "첫째 줄에 최댓값을 출력하고, 둘째 줄에 최댓값이 몇 번째 수인지를 출력한다.",
    "examples": [
      {
        "input": "3\n29\n38\n12\n57\n74\n40\n85\n61",
        "output": "85\n8"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2562",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "numbers = []\nfor i in range(9):\n    num = int(input())\n    numbers.append(num)\nmax_value = max(numbers)\nmax_position = numbers.index(max_value) + 1\nprint(max_value)\nprint(max_position)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "빈 리스트 생성",
            "description": "9개의 자연수를 저장할 빈 리스트를 만듭니다.",
            "code_pattern": "numbers = []",
            "socratic_hint": "숫자들을 저장할 공간을 만들려면?",
            "hint": "numbers = []"
          },
          {
            "step_id": 2,
            "goal": "9개 정수 입력받기",
            "description": "9번 반복하면서 정수를 입력받아 리스트에 추가합니다.",
            "code_pattern": "for i in range(9):\n    num = int(input())\n    numbers.append(num)",
            "socratic_hint": "9번 반복하면서 숫자를 입력받으려면?",
            "hint": "for i in range(9): 사용"
          },
          {
            "step_id": 3,
            "goal": "최댓값 찾기",
            "description": "max() 함수로 최댓값을 찾습니다.",
            "code_pattern": "max_value = max(numbers)",
            "socratic_hint": "리스트에서 가장 큰 값을 찾으려면?",
            "hint": "max(numbers)"
          },
          {
            "step_id": 4,
            "goal": "최댓값의 위치 찾기",
            "description": "index() 메서드로 최댓값의 인덱스를 찾습니다.",
            "code_pattern": "max_index = numbers.index(max_value)",
            "socratic_hint": "리스트에서 특정 값의 위치를 찾으려면?",
            "hint": "numbers.index(max_value)"
          },
          {
            "step_id": 5,
            "goal": "몇 번째 수인지 계산",
            "description": "인덱스는 0부터 시작하므로 1을 더합니다.",
            "code_pattern": "max_position = max_index + 1",
            "socratic_hint": "인덱스 0은 몇 번째 수인가요?",
            "hint": "인덱스 + 1 = 실제 순서"
          },
          {
            "step_id": 6,
            "goal": "최댓값과 위치 출력",
            "description": "최댓값을 먼저, 다음 줄에 위치를 출력합니다.",
            "code_pattern": "print(max_value)\nprint(max_position)",
            "socratic_hint": "두 값을 각각 다른 줄에 출력하려면?",
            "hint": "print()를 두 번 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: min/max 함수 직접 사용",
        "solution_code": "N = int(input())\nnumbers = list(map(int, input().split()))\nprint(max(numbers))\nprint(numbers.index(max(numbers)) + 1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수를 입력받고 리스트로 변환합니다.",
            "code_pattern": "numbers = list(map(int, input().split()))",
            "socratic_hint": "여러 정수를 리스트로 입력받으려면?",
            "hint": "list(map(int, input().split()))을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "min/max 함수 사용",
            "description": "내장 함수를 사용하여 최솟값과 최댓값을 찾습니다.",
            "code_pattern": "min(numbers), max(numbers)",
            "socratic_hint": "리스트의 최솟값과 최댓값을 찾으려면?",
            "hint": "min()과 max() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3: 반복문으로 직접 탐색",
        "solution_code": "N = int(input())\nnumbers = list(map(int, input().split()))\nmax_val = numbers[0]\nmax_idx = 0\nfor i in range(len(numbers)):\n    if numbers[i] > max_val:\n        max_val = numbers[i]\n        max_idx = i\nprint(max_val)\nprint(max_idx + 1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 및 초기화",
            "description": "입력을 받고 최솟값/최댓값을 첫 번째 원소로 초기화합니다.",
            "code_pattern": "min_val = numbers[0]\nmax_val = numbers[0]",
            "socratic_hint": "최솟값과 최댓값을 어떻게 초기화하나요?",
            "hint": "첫 번째 원소로 초기화합니다."
          },
          {
            "step_id": 2,
            "goal": "반복문으로 탐색",
            "description": "모든 원소를 확인하며 최솟값과 최댓값을 갱신합니다.",
            "code_pattern": "for num in numbers:\n    if num < min_val:\n        min_val = num",
            "socratic_hint": "모든 원소를 확인하며 최솟값을 찾으려면?",
            "hint": "for문과 if문을 사용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4: enumerate 활용",
        "solution_code": "numbers = [int(input()) for _ in range(9)]\nmax_val = max(numbers)\nmax_idx = numbers.index(max_val)\nprint(max_val)\nprint(max_idx + 1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "리스트 컴프리헨션으로 입력",
            "description": "9개 수를 리스트로 받습니다.",
            "code_pattern": "numbers = [int(input()) for _ in range(9)]",
            "socratic_hint": "여러 입력을 리스트로 받으려면?",
            "hint": "리스트 컴프리헨션을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "index 메서드",
            "description": "index() 메서드로 최댓값의 위치를 찾습니다.",
            "code_pattern": "max_idx = numbers.index(max_val)",
            "socratic_hint": "값의 위치를 찾으려면?",
            "hint": "index() 메서드를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 5,
        "solution_name": "풀이 5: max의 key 매개변수",
        "solution_code": "numbers = [int(input()) for _ in range(9)]\nmax_idx, max_val = max(enumerate(numbers), key=lambda x: x[1])\nprint(max_val)\nprint(max_idx + 1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "enumerate와 max",
            "description": "enumerate로 인덱스와 값을 함께 처리합니다.",
            "code_pattern": "max(enumerate(numbers), key=lambda x: x[1])",
            "socratic_hint": "인덱스와 값을 함께 비교하려면?",
            "hint": "enumerate와 key 매개변수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2563",
    "step_title": "2차원 배열",
    "title": "색종이",
    "level": 6,
    "tags": [
      "구현"
    ],
    "description": "가로, 세로의 크기가 각각 100인 정사각형 모양의 흰색 도화지가 있다. 이 도화지 위에 가로, 세로의 크기가 각각 10인 정사각형 모양의 검은색 색종이를 색종이의 변과 도화지의 변이 평행하도록 붙인다. 이러한 방식으로 색종이를 한 장 또는 여러 장 붙인 후 색종이가 붙은 검은 영역의 넓이를 구하는 프로그램을 작성하시오.예를 들어 흰색 도화지 위에 세 장의 검은색 색종이를 그림과 같은 모양으로 붙였다면 검은색 영역의 넓이는 260이 된다.",
    "input_description": "첫째 줄에 색종이의 수가 주어진다. 이어 둘째 줄부터 한 줄에 하나씩 색종이를 붙인 위치가 주어진다. 색종이를 붙인 위치는 두 개의 자연수로 주어지는데 첫 번째 자연수는 색종이의 왼쪽 변과 도화지의 왼쪽 변 사이의 거리이고, 두 번째 자연수는 색종이의 아래쪽 변과 도화지의 아래쪽 변 사이의 거리이다. 색종이의 수는 100 이하이며, 색종이가 도화지 밖으로 나가는 경우는 없다",
    "output_description": "첫째 줄에 색종이가 붙은 검은 영역의 넓이를 출력한다.",
    "examples": [
      {
        "input": "3\n3 7\n15 7\n5 2",
        "output": "260"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2563",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "paper = [[0] * 100 for _ in range(100)]\nN = int(input())\nfor _ in range(N):\n    x, y = map(int, input().split())\n    for i in range(x, x + 10):\n        for j in range(y, y + 10):\n            paper[i][j] = 1\nprint(sum(sum(row) for row in paper))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "paper = [[0] * 100 for _ in range(100)]\nN = int(input())\nfor _ in range(N):\n    x, y = map(int, inpu",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2565",
    "step_title": "동적 계획법 1",
    "title": "전깃줄",
    "level": 11,
    "tags": [
      "다이나믹 프로그래밍"
    ],
    "description": "두 전봇대 A와 B 사이에 하나 둘씩 전깃줄을 추가하다 보니 전깃줄이 서로 교차하는 경우가 발생하였다. 합선의 위험이 있어 이들 중 몇 개의 전깃줄을 없애 전깃줄이 교차하지 않도록 만들려고 한다.예를 들어, < 그림 1 >과 같이 전깃줄이 연결되어 있는 경우 A의 1번 위치와 B의 8번 위치를 잇는 전깃줄, A의 3번 위치와 B의 9번 위치를 잇는 전깃줄, A의 4번 위치와 B의 1번 위치를 잇는 전깃줄을 없애면 남아있는 모든 전깃줄이 서로 교차하지 않게 된다.< 그림 1 >전깃줄이 전봇대에 연결되는 위치는 전봇대 위에서부터 차례대로 번호가 매겨진다. 전깃줄의 개수와 전깃줄들이 두 전봇대에 연결되는 위치의 번호가 주어질 때, 남아있는 모든 전깃줄이 서로 교차하지 않게 하기 위해 없애야 하는 전깃줄의 최소 개수를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에는 두 전봇대 사이의 전깃줄의 개수가 주어진다. 전깃줄의 개수는 100 이하의 자연수이다. 둘째 줄부터 한 줄에 하나씩 전깃줄이 A전봇대와 연결되는 위치의 번호와 B전봇대와 연결되는 위치의 번호가 차례로 주어진다. 위치의 번호는 500 이하의 자연수이고, 같은 위치에 두 개 이상의 전깃줄이 연결될 수 없다.",
    "output_description": "첫째 줄에 남아있는 모든 전깃줄이 서로 교차하지 않게 하기 위해 없애야 하는 전깃줄의 최소 개수를 출력한다.",
    "examples": [
      {
        "input": "8\n1 8\n3 9\n2 2\n4 1\n6 4\n10 10\n9 7\n7 6",
        "output": "3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2565",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nwires = []\nfor _ in range(N):\n    a, b = map(int, input().split())\n    wires.append((a, b))\n\nwires.sort()\n\nB = [w[1] for w in wires]\ndp = [1] * N\n\nfor i in range(1, N):\n    for j in range(i):\n        if B[j] < B[i]:\n            dp[i] = max(dp[i], dp[j] + 1)\n\nprint(N - max(dp))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2566",
    "step_title": "2차원 배열",
    "title": "최댓값",
    "level": 3,
    "tags": [
      "구현"
    ],
    "description": "<그림 1>과 같이 9×9 격자판에 쓰여진 81개의 자연수 또는 0이 주어질 때, 이들 중 최댓값을 찾고 그 최댓값이 몇 행 몇 열에 위치한 수인지 구하는 프로그램을 작성하시오.예를 들어, 다음과 같이 81개의 수가 주어지면1열2열3열4열5열6열7열8열9열1행323853417742552652행107394288521472633행8742187853451884534행3428648512167536555행217745352875907616행2587651528113728747행652775417897864398행474770452365341449행871382383112292980이들 중 최댓값은 90이고, 이 값은 5행 7열에 위치한다.",
    "input_description": "첫째 줄부터 아홉 번째 줄까지 한 줄에 아홉 개씩 수가 주어진다. 주어지는 수는 100보다 작은 자연수 또는 0이다.",
    "output_description": "첫째 줄에 최댓값을 출력하고, 둘째 줄에 최댓값이 위치한 행 번호와 열 번호를 빈칸을 사이에 두고 차례로 출력한다. 최댓값이 두 개 이상인 경우 그 중 한 곳의 위치를 출력한다.",
    "examples": [
      {
        "input": "3 23 85 34 17 74 25 52 65\n10 7 39 42 88 52 14 72 63\n87 42 18 78 53 45 18 84 53\n34 28 64 85 12 16 75 36 55\n21 77 45 35 28 75 90 76 1\n25 87 65 15 28 11 37 28 74\n65 27 75 41 7 89 78 64 39\n47 47 70 45 23 65 3 41 44\n87 13 82 38 31 12 29 29 80",
        "output": "90\n5 7"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2566",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "max_val = -1\nmax_row = 0\nmax_col = 0\nfor i in range(9):\n    row = list(map(int, input().split()))\n    for j, val in enumerate(row):\n        if val > max_val:\n            max_val = val\n            max_row = i + 1\n            max_col = j + 1\nprint(max_val)\nprint(max_row, max_col)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "max_val = -1\nmax_row = 0\nmax_col = 0\nfor i in range(9):\n    row = list(map(int, input().split()))\n  ",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2579",
    "step_title": "동적 계획법 1",
    "title": "계단 오르기",
    "level": 8,
    "tags": [
      "다이나믹 프로그래밍"
    ],
    "description": "계단 오르기 게임은 계단 아래 시작점부터 계단 꼭대기에 위치한 도착점까지 가는 게임이다. <그림 1>과 같이 각각의 계단에는 일정한 점수가 쓰여 있는데 계단을 밟으면 그 계단에 쓰여 있는 점수를 얻게 된다.<그림 1>예를 들어 <그림 2>와 같이 시작점에서부터 첫 번째, 두 번째, 네 번째, 여섯 번째 계단을 밟아 도착점에 도달하면 총 점수는 10 + 20 + 25 + 20 = 75점이 된다.<그림 2>계단 오르는 데는 다음과 같은 규칙이 있다.계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.마지막 도착 계단은 반드시 밟아야 한다.따라서 첫 번째 계단을 밟고 이어 두 번째 계단이나, 세 번째 계단으로 오를 수 있다. 하지만, 첫 번째 계단을 밟고 이어 네 번째 계단으로 올라가거나, 첫 번째, 두 번째, 세 번째 계단을 연속해서 모두 밟을 수는 없다.각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구하는 프로그램을 작성하시오.",
    "input_description": "입력의 첫째 줄에 계단의 개수가 주어진다.둘째 줄부터 한 줄에 하나씩 제일 아래에 놓인 계단부터 순서대로 각 계단에 쓰여 있는 점수가 주어진다. 계단의 개수는 300이하의 자연수이고, 계단에 쓰여 있는 점수는 10,000이하의 자연수이다.",
    "output_description": "첫째 줄에 계단 오르기 게임에서 얻을 수 있는 총 점수의 최댓값을 출력한다.",
    "examples": [
      {
        "input": "6\n10\n20\n15\n25\n10\n20",
        "output": "75"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2579",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nstairs = [0] + [int(input()) for _ in range(N)]\n\nif N == 1:\n    print(stairs[1])\nelif N == 2:\n    print(stairs[1] + stairs[2])\nelse:\n    dp = [0] * (N + 1)\n    dp[1] = stairs[1]\n    dp[2] = stairs[1] + stairs[2]\n    \n    for i in range(3, N + 1):\n        dp[i] = max(dp[i-2] + stairs[i], dp[i-3] + stairs[i-1] + stairs[i])\n    \n    print(dp[N])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2580",
    "step_title": "백트래킹",
    "title": "스도쿠",
    "level": 12,
    "tags": [
      "구현",
      "백트래킹"
    ],
    "description": "스도쿠는 18세기 스위스 수학자가 만든 '라틴 사각형'이랑 퍼즐에서 유래한 것으로 현재 많은 인기를 누리고 있다. 이 게임은 아래 그림과 같이 가로, 세로 각각 9개씩 총 81개의 작은 칸으로 이루어진 정사각형 판 위에서 이뤄지는데, 게임 시작 전 일부 칸에는 1부터 9까지의 숫자 중 하나가 쓰여 있다.나머지 빈 칸을 채우는 방식은 다음과 같다.각각의 가로줄과 세로줄에는 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.굵은 선으로 구분되어 있는 3x3 정사각형 안에도 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.위의 예의 경우, 첫째 줄에는 1을 제외한 나머지 2부터 9까지의 숫자들이 이미 나타나 있으므로 첫째 줄 빈칸에는 1이 들어가야 한다.또한 위쪽 가운데 위치한 3x3 정사각형의 경우에는 3을 제외한 나머지 숫자들이 이미 쓰여있으므로 가운데 빈 칸에는 3이 들어가야 한다.이와 같이 빈 칸을 차례로 채워 가면 다음과 같은 최종 결과를 얻을 수 있다.게임 시작 전 스도쿠 판에 쓰여 있는 숫자들의 정보가 주어질 때 모든 빈 칸이 채워진 최종 모습을 출력하는 프로그램을 작성하시오.",
    "input_description": "아홉 줄에 걸쳐 한 줄에 9개씩 게임 시작 전 스도쿠판 각 줄에 쓰여 있는 숫자가 한 칸씩 띄워서 차례로 주어진다. 스도쿠 판의 빈 칸의 경우에는 0이 주어진다. 스도쿠 판을 규칙대로 채울 수 없는 경우의 입력은 주어지지 않는다.",
    "output_description": "모든 빈 칸이 채워진 스도쿠 판의 최종 모습을 아홉 줄에 걸쳐 한 줄에 9개씩 한 칸씩 띄워서 출력한다.스도쿠 판을 채우는 방법이 여럿인 경우는 그 중 하나만을 출력한다.",
    "examples": [
      {
        "input": "0 3 5 4 6 9 2 7 8\n7 8 2 1 0 5 6 0 9\n0 6 0 2 7 8 1 3 5\n3 2 1 0 4 6 8 9 7\n8 0 4 9 1 3 5 0 6\n5 9 6 8 2 0 4 1 3\n9 1 7 6 5 2 0 8 0\n6 0 3 7 0 1 9 5 2\n2 5 8 3 9 4 7 6 0",
        "output": "1 3 5 4 6 9 2 7 8\n7 8 2 1 3 5 6 4 9\n4 6 9 2 7 8 1 3 5\n3 2 1 5 4 6 8 9 7\n8 7 4 9 1 3 5 2 6\n5 9 6 8 2 7 4 1 3\n9 1 7 6 5 2 3 8 4\n6 4 3 7 8 1 9 5 2\n2 5 8 3 9 4 7 6 1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2580",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def find_empty():\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] == 0:\n                return i, j\n    return None, None\n\ndef is_valid(row, col, num):\n    if num in board[row]:\n        return False\n    \n    if num in [board[i][col] for i in range(9)]:\n        return False\n    \n    box_row, box_col = 3 * (row // 3), 3 * (col // 3)\n    for i in range(box_row, box_row + 3):\n        for j in range(box_col, box_col + 3):\n            if board[i][j] == num:\n                return False\n    \n    return True\n\ndef solve():\n    row, col = find_empty()\n    if row is None:\n        return True\n    \n    for num in range(1, 10):\n        if is_valid(row, col, num):\n            board[row][col] = num\n            if solve():\n                return True\n            board[row][col] = 0\n    \n    return False\n\nboard = []\nfor _ in range(9):\n    board.append(list(map(int, input().split())))\n\nsolve()\n\nfor row in board:\n    print(' '.join(map(str, row)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2581",
    "step_title": "약수, 배수와 소수 1",
    "title": "소수",
    "level": 4,
    "tags": [
      "소수 판정",
      "정수론",
      "수학"
    ],
    "description": "자연수 M과 N이 주어질 때 M이상 N이하의 자연수 중 소수인 것을 모두 골라 이들 소수의 합과 최솟값을 찾는 프로그램을 작성하시오.예를 들어 M=60, N=100인 경우 60이상 100이하의 자연수 중 소수는 61, 67, 71, 73, 79, 83, 89, 97 총 8개가 있으므로, 이들 소수의 합은 620이고, 최솟값은 61이 된다.",
    "input_description": "입력의 첫째 줄에 M이, 둘째 줄에 N이 주어진다.M과 N은 10,000이하의 자연수이며, M은 N보다 작거나 같다.",
    "output_description": "M이상 N이하의 자연수 중 소수인 것을 모두 찾아 첫째 줄에 그 합을, 둘째 줄에 그 중 최솟값을 출력한다.단, M이상 N이하의 자연수 중 소수가 없을 경우는 첫째 줄에 -1을 출력한다.",
    "examples": [
      {
        "input": "60\r\n100",
        "output": "620\r\n61"
      },
      {
        "input": "64\r\n65",
        "output": "-1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2581",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\nM = int(input())\nN = int(input())\nprimes = [i for i in range(M, N+1) if is_prime(i)]\n\nif primes:\n    print(sum(primes))\n    print(min(primes))\nelse:\n    print(-1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2587",
    "step_title": "정렬",
    "title": "대표값2",
    "level": 4,
    "tags": [
      "수학",
      "구현",
      "정렬",
      "사칙연산"
    ],
    "description": "어떤 수들이 있을 때, 그 수들을 대표하는 값으로 가장 흔하게 쓰이는 것은 평균이다. 평균은 주어진 모든 수의 합을 수의 개수로 나눈 것이다. 예를 들어 10, 40, 30, 60, 30의 평균은 (10 + 40 + 30 + 60 + 30) / 5 = 170 / 5 = 34가 된다.평균 이외의 또 다른 대표값으로 중앙값이라는 것이 있다. 중앙값은 주어진 수를 크기 순서대로 늘어 놓았을 때 가장 중앙에 놓인 값이다. 예를 들어 10, 40, 30, 60, 30의 경우, 크기 순서대로 늘어 놓으면10 30 30 40 60이 되고 따라서 중앙값은 30이 된다.다섯 개의 자연수가 주어질 때 이들의 평균과 중앙값을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄부터 다섯 번째 줄까지 한 줄에 하나씩 자연수가 주어진다. 주어지는 자연수는 100 보다 작은 10의 배수이다.",
    "output_description": "첫째 줄에는 평균을 출력하고, 둘째 줄에는 중앙값을 출력한다. 평균과 중앙값은 모두 자연수이다.",
    "examples": [
      {
        "input": "10\n40\n30\n60\n30",
        "output": "34\n30"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2587",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "numbers = []\nfor _ in range(5):\n    numbers.append(int(input()))\n\nnumbers.sort()\naverage = sum(numbers) // 5\nmedian = numbers[2]\nprint(average)\nprint(median)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "arr = [int(input()) for _ in range(5)]\nprint(sum(arr) // 5)\narr.sort()\nprint(arr[2])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2588",
    "step_title": "입출력과 사칙연산",
    "title": "곱셈",
    "level": 3,
    "tags": [
      "사칙연산",
      "수학"
    ],
    "description": "(세 자리 수) × (세 자리 수)는 다음과 같은 과정을 통하여 이루어진다.(1)과 (2)위치에 들어갈 세 자리 자연수가 주어질 때 (3), (4), (5), (6)위치에 들어갈 값을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 (1)의 위치에 들어갈 세 자리 자연수가, 둘째 줄에 (2)의 위치에 들어갈 세자리 자연수가 주어진다.",
    "output_description": "첫째 줄부터 넷째 줄까지 차례대로 (3), (4), (5), (6)에 들어갈 값을 출력한다.",
    "examples": [
      {
        "input": "472\n385",
        "output": "2360\n3776\n1416\n181720"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2588",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "A = int(input())\nB = input()\n# 일의 자리부터 계산\nprint(A * int(B[2]))\nprint(A * int(B[1]))\nprint(A * int(B[0]))\nprint(A * int(B))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 데이터 받기",
            "description": "문제에서 요구하는 데이터를 입력받습니다.",
            "code_pattern": "A = int(input())\nB = input()",
            "socratic_hint": "어떤 데이터를 입력받아야 하나요?",
            "hint": "input() 함수로 데이터를 받고, 필요하면 int()로 변환합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력하기",
            "description": "처리된 결과를 출력합니다.",
            "code_pattern": "print(A * int(B[2]))\nprint(A * int(B[1]))",
            "socratic_hint": "결과를 어떻게 출력하나요?",
            "hint": "print() 함수로 결과를 출력합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2606",
    "step_title": "그래프와 순회",
    "title": "바이러스",
    "level": 8,
    "tags": [
      "그래프 이론",
      "그래프 탐색",
      "너비 우선 탐색",
      "깊이 우선 탐색"
    ],
    "description": "신종 바이러스인 웜 바이러스는 네트워크를 통해 전파된다. 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다.예를 들어 7대의 컴퓨터가 <그림 1>과 같이 네트워크 상에서 연결되어 있다고 하자. 1번 컴퓨터가 웜 바이러스에 걸리면 웜 바이러스는 2번과 5번 컴퓨터를 거쳐 3번과 6번 컴퓨터까지 전파되어 2, 3, 5, 6 네 대의 컴퓨터는 웜 바이러스에 걸리게 된다. 하지만 4번과 7번 컴퓨터는 1번 컴퓨터와 네트워크상에서 연결되어 있지 않기 때문에 영향을 받지 않는다.어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다. 컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에는 컴퓨터의 수가 주어진다. 컴퓨터의 수는 100 이하인 양의 정수이고 각 컴퓨터에는 1번 부터 차례대로 번호가 매겨진다. 둘째 줄에는 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수가 주어진다. 이어서 그 수만큼 한 줄에 한 쌍씩 네트워크 상에서 직접 연결되어 있는 컴퓨터의 번호 쌍이 주어진다.",
    "output_description": "1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다.",
    "examples": [
      {
        "input": "7\n6\n1 2\n2 3\n1 5\n5 2\n5 6\n4 7",
        "output": "4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2606",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def dfs(node):\n    visited[node] = True\n    count = 1\n    \n    for next_node in graph[node]:\n        if not visited[next_node]:\n            count += dfs(next_node)\n    \n    return count\n\nN = int(input())\nM = int(input())\n\ngraph = [[] for _ in range(N + 1)]\nvisited = [False] * (N + 1)\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\nprint(dfs(1) - 1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2618",
    "step_title": "동적 계획법과 최단거리 역추적",
    "title": "경찰차",
    "level": 17,
    "tags": [
      "다이나믹 프로그래밍",
      "역추적"
    ],
    "description": "어떤 도시의 중심가는 N개의 동서방향 도로와 N개의 남북방향 도로로 구성되어 있다.모든 도로에는 도로 번호가 있으며 남북방향 도로는 왼쪽부터 1에서 시작하여 N까지 번호가 할당되어 있고 동서방향 도로는 위부터 1에서 시작하여 N까지 번호가 할당되어 있다. 또한 동서방향 도로 사이의 거리와 남 북방향 도로 사이의 거리는 모두 1이다. 동서방향 도로와 남북방향 도로가 교차하는 교차로의 위치는 두 도로의 번호의 쌍인 (동서방향 도로 번호, 남북방향 도로 번호)로 나타낸다. N이 6인 경우의 예를 들면 다음과 같다.이 도시에는 두 대의 경찰차가 있으며 두 차를 경찰차1과 경찰차2로 부른다. 처음에는 항상 경찰차1은 (1, 1)의 위치에 있고 경찰차2는 (N, N)의 위치에 있다. 경찰 본부에서는 처리할 사건이 있으면 그 사건이 발생된 위치를 두 대의 경찰차 중 하나에 알려 주고, 연락 받은 경찰차는 그 위치로 가장 빠른 길을 통해 이동하여 사건을 처리한다. (하나의 사건은 한 대의 경찰차가 처리한다.) 그리고 사건을 처리 한 경찰차는 경찰 본부로부터 다음 연락이 올 때까지 처리한 사건이 발생한 위치에서 기다린다. 경찰 본부에서는 사건이 발생한 순서대로 두 대의 경찰차에 맡기려고 한다. 처리해야 될 사건들은 항상 교차로에서 발생하며 경찰 본부에서는 이러한 사건들을 나누어 두 대의 경찰차에 맡기되, 두 대의 경찰차들이 이동하는 거리의 합을 최소화 하도록 사건을 맡기려고 한다.예를 들어 앞의 그림처럼 N=6인 경우, 처리해야 하는 사건들이 3개 있고 그 사건들이 발생된 위치 를 순서대로 (3, 5), (5, 5), (2, 3)이라고 하자. (3, 5)의 사건을 경찰차2에 맡기고 (5, 5)의 사건도 경찰차2에 맡기며, (2, 3)의 사건을 경찰차1에 맡기면 두 차가 이동한 거리의 합은 4 + 2 + 3 = 9가 되 고, 더 이상 줄일 수는 없다.처리해야 할 사건들이 순서대로 주어질 때, 두 대의 경찰차가 이동하는 거리의 합을 최소화 하도록 사건들을 맡기는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에는 동서방향 도로의 개수를 나타내는 정수 N(5 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 처리해야 하는 사건의 개수를 나타내는 정수 W(1 ≤ W ≤ 1,000)가 주어진다. 셋째 줄부터 (W+2)번째 줄까지 사건이 발생된 위치가 한 줄에 하나씩 주어진다. 경찰차들은 이 사건들을 주어진 순서대로 처리해야 한다. 각 위치는 동서방향 도로 번호를 나타내는 정수와 남북방향 도로 번호를 나타내는 정수로 주어지며 두 정수 사이에는 빈칸이 하나 있다. 두 사건이 발생한 위치가 같을 수 있다.",
    "output_description": "첫째 줄에 두 경찰차가 이동한 총 거리를 출력한다. 둘째 줄부터 시작하여 (i+1)번째 줄에 i(1 ≤ i ≤ W)번째 사건이 맡겨진 경찰차 번호 1 또는 2를 출력한다.",
    "examples": [
      {
        "input": "6\n3\n3 5\n5 5\n2 3",
        "output": "9\n2\n2\n1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2618",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2629",
    "step_title": "동적 계획법 2",
    "title": "양팔저울",
    "level": 13,
    "tags": [
      "다이나믹 프로그래밍",
      "배낭 문제"
    ],
    "description": "양팔 저울과 몇 개의 추가 주어졌을 때, 이를 이용하여 입력으로 주어진 구슬의 무게를 확인할 수 있는지를 결정하려고 한다.무게가 각각 1g과 4g인 두 개의 추가 있을 경우, 주어진 구슬과 1g 추 하나를 양팔 저울의 양쪽에 각각 올려놓아 수평을 이루면 구슬의 무게는 1g이다. 또 다른 구슬이 4g인지를 확인하려면 1g 추 대신 4g 추를 올려놓으면 된다.구슬이 3g인 경우 아래 <그림 1>과 같이 구슬과 추를 올려놓으면 양팔 저울이 수평을 이루게 된다. 따라서 각각 1g과 4g인 추가 하나씩 있을 경우 주어진 구슬이 3g인지도 확인해 볼 수 있다.<그림 1> 구슬이 3g인지 확인하는 방법 ($\\boxed{1}$은 1g인 추, $\\boxed{4}$는 4g인 추, ●은 무게를 확인할 구슬)<그림 2>와 같은 방법을 사용하면 구슬이 5g인지도 확인할 수 있다. 구슬이 2g이면 주어진 추를 가지고는 확인할 수 없다.추들의 무게와 확인할 구슬들의 무게가 입력되었을 때, 주어진 추만을 사용하여 구슬의 무게를 확인 할 수 있는지를 결정하는 프로그램을 작성하시오.<그림 2> 구슬이 5g인지 확인하는 방법",
    "input_description": "첫째 줄에는 추의 개수가 자연수로 주어진다. 추의 개수는 30 이하이다. 둘째 줄에는 추의 무게들이 자연수로 가벼운 것부터 차례로 주어진다. 같은 무게의 추가 여러 개 있을 수도 있다. 추의 무게는 500g이하이며, 입력되는 무게들 사이에는 빈칸이 하나씩 있다. 세 번째 줄에는 무게를 확인하고자 하는 구슬들의 개수가 주어진다. 확인할 구슬의 개수는 7이하이다. 네 번째 줄에는 확인하고자 하는 구슬들의 무게가 자연수로 주어지며, 입력되는 무게들 사이에는 빈 칸이 하나씩 있다. 확인하고자 하는 구슬의 무게는 40,000보다 작거나 같은 자연수이다.",
    "output_description": "주어진 각 구슬의 무게에 대하여 확인이 가능하면 Y, 아니면 N 을 차례로 출력한다. 출력은 한 개의 줄로 이루어지며, 각 구슬에 대한 답 사이에는 빈칸을 하나씩 둔다.",
    "examples": [
      {
        "input": "2\n1 4\n2\n3 2",
        "output": "Y N"
      },
      {
        "input": "4\n2 3 3 3\n3\n1 4 10",
        "output": "Y Y N"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2629",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "n = int(input())\nweights = list(map(int, input().split()))\nm = int(input())\nmarbles = list(map(int, input().split()))\n\nmax_weight = sum(weights)\ndp = [[False] * (max_weight * 2 + 1) for _ in range(n + 1)]\ndp[0][max_weight] = True\n\nfor i in range(n):\n    for j in range(max_weight * 2 + 1):\n        if dp[i][j]:\n            dp[i+1][j] = True\n            if j + weights[i] <= max_weight * 2:\n                dp[i+1][j + weights[i]] = True\n            if j - weights[i] >= 0:\n                dp[i+1][j - weights[i]] = True\n\nresult = []\nfor marble in marbles:\n    if marble <= max_weight and (dp[n][max_weight + marble] or dp[n][max_weight - marble]):\n        result.append('Y')\n    else:\n        result.append('N')\n\nprint(' '.join(result))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2630",
    "step_title": "분할 정복",
    "title": "색종이 만들기",
    "level": 9,
    "tags": [
      "분할 정복",
      "재귀"
    ],
    "description": "아래 <그림 1>과 같이 여러개의 정사각형칸들로 이루어진 정사각형 모양의 종이가 주어져 있고, 각 정사각형들은 하얀색으로 칠해져 있거나 파란색으로 칠해져 있다. 주어진 종이를 일정한 규칙에 따라 잘라서 다양한 크기를 가진 정사각형 모양의 하얀색 또는 파란색 색종이를 만들려고 한다.전체 종이의 크기가 N×N(N=2k, k는 1 이상 7 이하의 자연수) 이라면 종이를 자르는 규칙은 다음과 같다.전체 종이가 모두 같은 색으로 칠해져 있지 않으면 가로와 세로로 중간 부분을 잘라서 <그림 2>의 I, II, III, IV와 같이 똑같은 크기의 네 개의 N/2 × N/2색종이로 나눈다. 나누어진 종이 I, II, III, IV 각각에 대해서도 앞에서와 마찬가지로 모두 같은 색으로 칠해져 있지 않으면 같은 방법으로 똑같은 크기의 네 개의 색종이로 나눈다. 이와 같은 과정을 잘라진 종이가 모두 하얀색 또는 모두 파란색으로 칠해져 있거나, 하나의 정사각형 칸이 되어 더 이상 자를 수 없을 때까지 반복한다.위와 같은 규칙에 따라 잘랐을 때 <그림 3>은 <그림 1>의 종이를 처음 나눈 후의 상태를, <그림 4>는 두 번째 나눈 후의 상태를, <그림 5>는 최종적으로 만들어진 다양한 크기의 9장의 하얀색 색종이와 7장의 파란색 색종이를 보여주고 있다.입력으로 주어진 종이의 한 변의 길이 N과 각 정사각형칸의 색(하얀색 또는 파란색)이 주어질 때 잘라진 하얀색 색종이와 파란색 색종이의 개수를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에는 전체 종이의 한 변의 길이 N이 주어져 있다. N은 2, 4, 8, 16, 32, 64, 128 중 하나이다. 색종이의 각 가로줄의 정사각형칸들의 색이 윗줄부터 차례로 둘째 줄부터 마지막 줄까지 주어진다. 하얀색으로 칠해진 칸은 0, 파란색으로 칠해진 칸은 1로 주어지며, 각 숫자 사이에는 빈칸이 하나씩 있다.",
    "output_description": "첫째 줄에는 잘라진 햐얀색 색종이의 개수를 출력하고, 둘째 줄에는 파란색 색종이의 개수를 출력한다.",
    "examples": [
      {
        "input": "8\r\n1 1 0 0 0 0 1 1\r\n1 1 0 0 0 0 1 1\r\n0 0 0 0 1 1 0 0\r\n0 0 0 0 1 1 0 0\r\n1 0 0 0 1 1 1 1\r\n0 1 0 0 1 1 1 1\r\n0 0 1 1 1 1 1 1\r\n0 0 1 1 1 1 1 1",
        "output": "9\r\n7"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2630",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def count_paper(x, y, n):\n    global blue, white\n    \n    color = paper[x][y]\n    same = True\n    \n    for i in range(x, x + n):\n        for j in range(y, y + n):\n            if paper[i][j] != color:\n                same = False\n                break\n        if not same:\n            break\n    \n    if same:\n        if color == 1:\n            blue += 1\n        else:\n            white += 1\n    else:\n        half = n // 2\n        count_paper(x, y, half)\n        count_paper(x, y + half, half)\n        count_paper(x + half, y, half)\n        count_paper(x + half, y + half, half)\n\nN = int(input())\npaper = []\nfor _ in range(N):\n    paper.append(list(map(int, input().split())))\n\nblue = 0\nwhite = 0\ncount_paper(0, 0, N)\n\nprint(white)\nprint(blue)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2637",
    "step_title": "동적 계획법 3",
    "title": "장난감 조립",
    "level": 14,
    "tags": [
      "다이나믹 프로그래밍",
      "그래프 이론",
      "방향 비순환 그래프",
      "위상 정렬"
    ],
    "description": "우리는 어떤 장난감을 여러 가지 부품으로 조립하여 만들려고 한다. 이 장난감을 만드는데는 기본 부품과 그 기본 부품으로 조립하여 만든 중간 부품이 사용된다. 기본 부품은 다른 부품을 사용하여 조립될 수 없는 부품이다. 중간 부품은 또 다른 중간 부품이나 기본 부품을 이용하여 만들어지는 부품이다.예를 들어보자. 기본 부품으로서 1, 2, 3, 4가 있다. 중간 부품 5는 2개의 기본 부품 1과 2개의 기본 부품 2로 만들어진다. 그리고 중간 부품 6은 2개의 중간 부품 5, 3개의 기본 부품 3과 4개의 기본 부품 4로 만들어진다. 마지막으로 장난감 완제품 7은 2개의 중간 부품 5, 3개의 중간 부품 6과 5개의 기본 부품 4로 만들어진다. 이런 경우에 장난감 완제품 7을 만드는데 필요한 기본 부품의 개수는 1번 16개, 2번 16개, 3번 9개, 4번 17개이다.이와 같이 어떤 장난감 완제품과 그에 필요한 부품들 사이의 관계가 주어져 있을 때 하나의 장난감 완제품을 조립하기 위하여 필요한 기본 부품의 종류별 개수를 계산하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에는 자연수 N(3 ≤ N ≤ 100)이 주어지는데, 1부터 N-1까지는 기본 부품이나 중간 부품의 번호를 나타내고, N은 완제품의 번호를 나타낸다. 그리고 그 다음 줄에는 자연수 M(3 ≤ M ≤ 100)이 주어지고, 그 다음 M개의 줄에는 어떤 부품을 완성하는데 필요한 부품들 간의 관계가 3개의 자연수 X, Y, K로 주어진다. 이 뜻은 \"중간 부품이나 완제품 X를 만드는데 중간 부품 혹은 기본 부품 Y가 K개 필요하다\"는 뜻이다. 두 중간 부품이 서로를 필요로 하는 경우가 없다.",
    "output_description": "하나의 완제품을 조립하는데 필요한 기본 부품의 수를 한 줄에 하나씩 출력하되(중간 부품은 출력하지 않음), 반드시 기본 부품의 번호가 작은 것부터 큰 순서가 되도록 한다. 각 줄에는 기본 부품의 번호와 소요 개수를 출력한다.정답은 2,147,483,647 이하이다.",
    "examples": [
      {
        "input": "7\n8\n5 1 2\n5 2 2\n7 5 2\n6 5 2\n6 3 3\n6 4 4\n7 6 3\n7 4 5",
        "output": "1 16\n2 16\n3 9\n4 17"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2637",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2667",
    "step_title": "그래프와 순회",
    "title": "단지번호붙이기",
    "level": 10,
    "tags": [
      "그래프 이론",
      "그래프 탐색",
      "너비 우선 탐색",
      "깊이 우선 탐색",
      "격자 그래프",
      "플러드 필"
    ],
    "description": "<그림 1>과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 철수는 이 지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. 여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. 대각선상에 집이 있는 경우는 연결된 것이 아니다. <그림 2>는 <그림 1>을 단지별로 번호를 붙인 것이다. 지도를 입력하여 단지수를 출력하고, 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오.",
    "input_description": "첫 번째 줄에는 지도의 크기 N(정사각형이므로 가로와 세로의 크기는 같으며 5≤N≤25)이 입력되고, 그 다음 N줄에는 각각 N개의 자료(0혹은 1)가 입력된다.",
    "output_description": "첫 번째 줄에는 총 단지수를 출력하시오. 그리고 각 단지내 집의 수를 오름차순으로 정렬하여 한 줄에 하나씩 출력하시오.",
    "examples": [
      {
        "input": "7\n0110100\n0110101\n1110101\n0000111\n0100000\n0111110\n0111000",
        "output": "3\n7\n8\n9"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2667",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def dfs(x, y):\n    if x < 0 or x >= N or y < 0 or y >= N:\n        return 0\n    if not visited[x][y] and map_data[x][y] == '1':\n        visited[x][y] = True\n        count = 1\n        count += dfs(x-1, y)\n        count += dfs(x+1, y)\n        count += dfs(x, y-1)\n        count += dfs(x, y+1)\n        return count\n    return 0\n\nN = int(input())\nmap_data = []\nfor _ in range(N):\n    map_data.append(input())\n\nvisited = [[False] * N for _ in range(N)]\ncomplexes = []\n\nfor i in range(N):\n    for j in range(N):\n        if not visited[i][j] and map_data[i][j] == '1':\n            count = dfs(i, j)\n            complexes.append(count)\n\ncomplexes.sort()\nprint(len(complexes))\nfor c in complexes:\n    print(c)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2675",
    "step_title": "문자열",
    "title": "문자열 반복",
    "level": 4,
    "tags": [
      "구현",
      "문자열"
    ],
    "description": "문자열 S를 입력받은 후에, 각 문자를 R번 반복해 새 문자열 P를 만든 후 출력하는 프로그램을 작성하시오. 즉, 첫 번째 문자를 R번 반복하고, 두 번째 문자를 R번 반복하는 식으로 P를 만들면 된다. S에는 QR Code \"alphanumeric\" 문자만 들어있다.QR Code \"alphanumeric\" 문자는0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\$%*+-./:이다.",
    "input_description": "첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다. 각 테스트 케이스는 반복 횟수 R(1 ≤ R ≤ 8), 문자열 S가 공백으로 구분되어 주어진다. S의 길이는 적어도 1이며, 20글자를 넘지 않는다.",
    "output_description": "각 테스트 케이스에 대해 P를 출력한다.",
    "examples": [
      {
        "input": "2\r\n3 ABC\r\n5 /HTP",
        "output": "AAABBBCCC\r\n/////HHHHHTTTTTPPPPP"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2675",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "T = int(input())\nfor _ in range(T):\n    R, S = input().split()\n    R = int(R)\n    result = ''.join(char * R for char in S)\n    print(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "T = int(input())\nfor _ in range(T):\n    R, S = input().split()\n    R = int(R)\n    result = ''.join(c",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: join 활용",
        "solution_code": "T = int(input())\nfor _ in range(T):\n    R, S = input().split()\n    R = int(R)\n    print(''.join(c * R for c in S))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "제너레이터와 join",
            "description": "각 문자를 반복하여 join으로 연결합니다.",
            "code_pattern": "''.join(c * R for c in S)",
            "socratic_hint": "문자열을 효율적으로 연결하려면?",
            "hint": "join()을 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3: 리스트 컴프리헨션",
        "solution_code": "T = int(input())\nfor _ in range(T):\n    R, S = input().split()\n    R = int(R)\n    result = [c * R for c in S]\n    print(''.join(result))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "리스트로 먼저 생성",
            "description": "반복된 문자들을 리스트로 만든 후 join합니다.",
            "code_pattern": "result = [c * R for c in S]",
            "socratic_hint": "각 문자를 반복한 리스트를 만들려면?",
            "hint": "리스트 컴프리헨션을 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2696",
    "step_title": "우선순위 큐",
    "title": "중앙값 구하기",
    "level": 14,
    "tags": [
      "자료 구조",
      "우선순위 큐"
    ],
    "description": "어떤 수열을 읽고, 홀수번째 수를 읽을 때 마다, 지금까지 입력받은 값의 중앙값을 출력하는 프로그램을 작성하시오.예를 들어, 수열이 1, 5, 4, 3, 2 이면, 홀수번째 수는 1번째 수, 3번째 수, 5번째 수이고, 1번째 수를 읽었을 때 중앙값은 1, 3번째 수를 읽었을 때는 4, 5번째 수를 읽었을 때는 3이다.",
    "input_description": "첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다. 각 테스트 케이스의 첫째 줄에는 수열의 크기 M(1 ≤ M ≤ 9999, M은 홀수)이 주어지고, 그 다음 줄부터 이 수열의 원소가 차례대로 주어진다. 원소는 한 줄에 10개씩 나누어져있고, 32비트 부호있는 정수이다.",
    "output_description": "각 테스트 케이스에 대해 첫째 줄에 출력하는 중앙값의 개수를 출력하고, 둘째 줄에는 홀수 번째 수를 읽을 때 마다 구한 중앙값을 차례대로 공백으로 구분하여 출력한다. 이때, 한 줄에 10개씩 출력해야 한다.",
    "examples": [
      {
        "input": "3\n9\n1 2 3 4 5 6 7 8 9\n9\n9 8 7 6 5 4 3 2 1\n23\n23 41 13 22 -3 24 -31 -11 -8 -7\n3 5 103 211 -311 -45 -67 -73 -81 -99\n-33 24 56",
        "output": "5\n1 2 3 4 5\n5\n9 8 7 6 5\n12\n23 23 22 22 13 3 5 5 3 -3\n-7 -3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2696",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import heapq\n\nT = int(input())\nfor _ in range(T):\n    M = int(input())\n    numbers = []\n    lines = (M + 9) // 10\n    for i in range(lines):\n        numbers.extend(map(int, input().split()))\n    \n    min_heap = []\n    max_heap = []\n    result = []\n    \n    for i, num in enumerate(numbers):\n        if not max_heap or num <= -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        \n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        \n        if i % 2 == 0:\n            result.append(-max_heap[0])\n    \n    print(len(result))\n    for i in range(0, len(result), 10):\n        print(' '.join(map(str, result[i:i+10])))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2720",
    "step_title": "수학 1",
    "title": "세탁소 사장 동혁",
    "level": 3,
    "tags": [
      "수학",
      "그리디 알고리즘",
      "사칙연산"
    ],
    "description": "미국으로 유학간 동혁이는 세탁소를 운영하고 있다. 동혁이는 최근에 아르바이트로 고등학생 리암을 채용했다.동혁이는 리암에게 실망했다.리암은 거스름돈을 주는 것을 자꾸 실수한다.심지어 \\$0.5달러를 줘야하는 경우에 거스름돈으로 \\$5달러를 주는것이다!어쩔수 없이 뛰어난 코딩 실력을 발휘해 리암을 도와주는 프로그램을 작성하려고 하지만, 디아블로를 하느라 코딩할 시간이 없어서 이 문제를 읽고 있는 여러분이 대신 해주어야 한다.거스름돈의 액수가 주어지면 리암이 줘야할 쿼터(Quarter, \\$0.25)의 개수, 다임(Dime, \\$0.10)의 개수, 니켈(Nickel, \\$0.05)의 개수, 페니(Penny, \\$0.01)의 개수를 구하는 프로그램을 작성하시오. 거스름돈은 항상 \\$5.00 이하이고, 손님이 받는 동전의 개수를 최소로 하려고 한다. 예를 들어, \\$1.24를 거슬러 주어야 한다면, 손님은 4쿼터, 2다임, 0니켈, 4페니를 받게 된다.",
    "input_description": "첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 거스름돈 C를 나타내는 정수 하나로 이루어져 있다. C의 단위는 센트이다. (1달러 = 100센트) (1<=C<=500)",
    "output_description": "각 테스트케이스에 대해 필요한 쿼터의 개수, 다임의 개수, 니켈의 개수, 페니의 개수를 공백으로 구분하여 출력한다.",
    "examples": [
      {
        "input": "3\r\n124\r\n25\r\n194",
        "output": "4 2 0 4\r\n1 0 0 0\r\n7 1 1 4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2720",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "T = int(input())\ncoins = [25, 10, 5, 1]\nfor _ in range(T):\n    C = int(input())\n    counts = []\n    for coin in coins:\n        counts.append(C // coin)\n        C %= coin\n    print(' '.join(map(str, counts)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "T = int(input())로 입력을 처리합니다.",
            "code_pattern": "T = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "정수 입력 받기",
            "description": "C = int(input())로 입력을 처리합니다.",
            "code_pattern": "C = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(T):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(' '.join(map(str, counts)))",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2738",
    "step_title": "2차원 배열",
    "title": "행렬 덧셈",
    "level": 3,
    "tags": [
      "수학",
      "구현",
      "사칙연산"
    ],
    "description": "N*M크기의 두 행렬 A와 B가 주어졌을 때, 두 행렬을 더하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 행렬의 크기 N 과 M이 주어진다. 둘째 줄부터 N개의 줄에 행렬 A의 원소 M개가 차례대로 주어진다. 이어서 N개의 줄에 행렬 B의 원소 M개가 차례대로 주어진다. N과 M은 100보다 작거나 같고, 행렬의 원소는 절댓값이 100보다 작거나 같은 정수이다.",
    "output_description": "첫째 줄부터 N개의 줄에 행렬 A와 B를 더한 행렬을 출력한다. 행렬의 각 원소는 공백으로 구분한다.",
    "examples": [
      {
        "input": "3 3\n1 1 1\n2 2 2\n0 1 0\n3 3 3\n4 4 4\n5 5 100",
        "output": "4 4 4\n6 6 6\n5 6 100"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2738",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N, M = map(int, input().split())\nA = []\nfor _ in range(N):\n    row = list(map(int, input().split()))\n    A.append(row)\n\nB = []\nfor _ in range(N):\n    row = list(map(int, input().split()))\n    B.append(row)\n\nfor i in range(N):\n    result = []\n    for j in range(M):\n        result.append(A[i][j] + B[i][j])\n    print(' '.join(map(str, result)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: zip 활용",
        "solution_code": "N, M = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(N)]\nB = [list(map(int, input().split())) for _ in range(N)]\nfor row_a, row_b in zip(A, B):\n    print(' '.join(map(str, [a + b for a, b in zip(row_a, row_b)])))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "zip으로 쌍 만들기",
            "description": "zip을 사용하여 대응하는 원소끼리 더합니다.",
            "code_pattern": "for row_a, row_b in zip(A, B):",
            "socratic_hint": "두 리스트를 쌍으로 처리하려면?",
            "hint": "zip()을 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3: numpy 활용",
        "solution_code": "import numpy as np\nN, M = map(int, input().split())\nA = np.array([list(map(int, input().split())) for _ in range(N)])\nB = np.array([list(map(int, input().split())) for _ in range(N)])\nC = A + B\nfor row in C:\n    print(' '.join(map(str, row)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "numpy 배열 연산",
            "description": "numpy 배열로 변환하여 덧셈합니다.",
            "code_pattern": "C = A + B",
            "socratic_hint": "배열 전체를 한 번에 연산하려면?",
            "hint": "numpy를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2739",
    "step_title": "반복문",
    "title": "구구단",
    "level": 1,
    "tags": [
      "구현",
      "수학"
    ],
    "description": "N을 입력받은 뒤, 구구단 N단을 출력하는 프로그램을 작성하시오. 출력 형식에 맞춰서 출력하면 된다.",
    "input_description": "첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 9보다 작거나 같다.",
    "output_description": "출력형식과 같게 N*1부터 N*9까지 출력한다.",
    "examples": [
      {
        "input": "2",
        "output": "2 * 1 = 2\n2 * 2 = 4\n2 * 3 = 6\n2 * 4 = 8\n2 * 5 = 10\n2 * 6 = 12\n2 * 7 = 14\n2 * 8 = 16\n2 * 9 = 18"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2739",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1: for 반복문 (기본)",
        "solution_code": "N = int(input())\nfor i in range(1, 10):\n    print(N, '*', i, '=', N * i)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "단수 N 입력받기",
            "description": "출력할 구구단의 단수를 입력받습니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "구구단 단수를 입력받으려면?",
            "hint": "N = int(input())을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "1부터 9까지 반복",
            "description": "for 반복문으로 1부터 9까지 순회합니다.",
            "code_pattern": "for i in range(1, 10):",
            "socratic_hint": "1부터 9까지 반복하려면?",
            "hint": "range(1, 10)을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "N × i 형태로 출력",
            "description": "각 단계마다 'N * i = N×i' 형태로 출력합니다.",
            "code_pattern": "    print(N, '*', i, '=', N * i)",
            "socratic_hint": "구구단 형식으로 출력하려면?",
            "hint": "print(N, '*', i, '=', N * i)를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: f-string 활용",
        "solution_code": "N = int(input())\nfor i in range(1, 10):\n    print(f'{N} * {i} = {N * i}')",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "단수 N 입력받기",
            "description": "출력할 구구단의 단수를 입력받습니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "구구단 단수를 입력받으려면?",
            "hint": "N = int(input())을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "for 반복문과 f-string으로 출력",
            "description": "1부터 9까지 반복하며 f-string으로 깔끔하게 출력합니다.",
            "code_pattern": "for i in range(1, 10):\n    print(f'{N} * {i} = {N * i}')",
            "socratic_hint": "반복문과 f-string을 함께 사용하려면?",
            "hint": "f-string을 사용하면 더 깔끔하게 출력할 수 있습니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3: while문 활용",
        "solution_code": "N = int(input())\ni = 1\nwhile i <= 9:\n    print(f'{N} * {i} = {N * i}')\n    i += 1",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 N을 입력받습니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "정수를 입력받으려면?",
            "hint": "int(input())을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "while 반복문 작성",
            "description": "while문으로 조건을 만족하는 동안 반복합니다.",
            "code_pattern": "while i <= N:",
            "socratic_hint": "조건을 만족하는 동안 반복하려면?",
            "hint": "while 조건: 형태로 작성합니다."
          },
          {
            "step_id": 3,
            "goal": "결과 출력",
            "description": "각 단계의 결과를 출력합니다.",
            "code_pattern": "print(result)",
            "socratic_hint": "계산 결과를 출력하려면?",
            "hint": "print()를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4: 리스트 컴프리헨션",
        "solution_code": "N = int(input())\nresults = [f'{N} * {i} = {N * i}' for i in range(1, 10)]\nprint('\\n'.join(results))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 N을 입력받습니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "정수를 입력받으려면?",
            "hint": "int(input())을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "리스트 컴프리헨션으로 계산",
            "description": "리스트 컴프리헨션으로 모든 결과를 한 번에 생성합니다.",
            "code_pattern": "[표현식 for i in range(...)]",
            "socratic_hint": "여러 결과를 리스트로 한 번에 만들려면?",
            "hint": "리스트 컴프리헨션을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "결과 출력",
            "description": "생성된 결과를 출력합니다.",
            "code_pattern": "print()",
            "socratic_hint": "결과를 출력하려면?",
            "hint": "print()를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 5,
        "solution_name": "풀이 5: map과 람다",
        "solution_code": "N = int(input())\nprint('\\n'.join(map(lambda i: f'{N} * {i} = {N*i}', range(1, 10))))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "map과 람다 조합",
            "description": "map과 람다를 사용하여 한 줄로 처리합니다.",
            "code_pattern": "map(lambda i: f'{N} * {i} = {N*i}', range(1, 10))",
            "socratic_hint": "함수를 각 원소에 적용하려면?",
            "hint": "map과 lambda를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 6,
        "solution_name": "풀이 6: format 메서드",
        "solution_code": "N = int(input())\nfor i in range(1, 10):\n    print('{} * {} = {}'.format(N, i, N*i))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "format 메서드 사용",
            "description": "문자열의 format() 메서드를 사용합니다.",
            "code_pattern": "'{} * {} = {}'.format(N, i, N*i)",
            "socratic_hint": "문자열 포맷팅의 또 다른 방법은?",
            "hint": "format() 메서드를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 7,
        "solution_name": "풀이 7: % 포맷팅",
        "solution_code": "N = int(input())\nfor i in range(1, 10):\n    print('%d * %d = %d' % (N, i, N*i))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "% 포맷팅",
            "description": "% 연산자를 사용한 구식 포맷팅입니다.",
            "code_pattern": "'%d * %d = %d' % (N, i, N*i)",
            "socratic_hint": "구식 문자열 포맷팅 방법은?",
            "hint": "% 연산자를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2740",
    "step_title": "분할 정복",
    "title": "행렬 곱셈",
    "level": 6,
    "tags": [
      "수학",
      "구현",
      "선형대수학"
    ],
    "description": "N*M크기의 행렬 A와 M*K크기의 행렬 B가 주어졌을 때, 두 행렬을 곱하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 행렬 A의 크기 N 과 M이 주어진다. 둘째 줄부터 N개의 줄에 행렬 A의 원소 M개가 순서대로 주어진다. 그 다음 줄에는 행렬 B의 크기 M과 K가 주어진다. 이어서 M개의 줄에 행렬 B의 원소 K개가 차례대로 주어진다. N과 M, 그리고 K는 100보다 작거나 같고, 행렬의 원소는 절댓값이 100보다 작거나 같은 정수이다.",
    "output_description": "첫째 줄부터 N개의 줄에 행렬 A와 B를 곱한 행렬을 출력한다. 행렬의 각 원소는 공백으로 구분한다.",
    "examples": [
      {
        "input": "3 2\r\n1 2\r\n3 4\r\n5 6\r\n2 3\r\n-1 -2 0\r\n0 0 3",
        "output": "-1 -2 6\r\n-3 -6 12\r\n-5 -10 18"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2740",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N, M = map(int, input().split())\nA = []\nfor _ in range(N):\n    A.append(list(map(int, input().split())))\n\nM, K = map(int, input().split())\nB = []\nfor _ in range(M):\n    B.append(list(map(int, input().split())))\n\nresult = [[0] * K for _ in range(N)]\n\nfor i in range(N):\n    for j in range(K):\n        for k in range(M):\n            result[i][j] += A[i][k] * B[k][j]\n\nfor row in result:\n    print(' '.join(map(str, row)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2743",
    "step_title": "문자열",
    "title": "단어 길이 재기",
    "level": 1,
    "tags": [
      "구현",
      "문자열"
    ],
    "description": "알파벳으로만 이루어진 단어를 입력받아, 그 길이를 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 영어 소문자와 대문자로만 이루어진 단어가 주어진다. 단어의 길이는 최대 100이다.",
    "output_description": "첫째 줄에 입력으로 주어진 단어의 길이를 출력한다.",
    "examples": [
      {
        "input": "pulljima",
        "output": "8"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2743",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "print(len(input()))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "print(len(input()))",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2745",
    "step_title": "수학 1",
    "title": "진법 변환",
    "level": 4,
    "tags": [
      "구현",
      "문자열",
      "수학"
    ],
    "description": "B진법 수 N이 주어진다. 이 수를 10진법으로 바꿔 출력하는 프로그램을 작성하시오.10진법을 넘어가는 진법은 숫자로 표시할 수 없는 자리가 있다. 이런 경우에는 다음과 같이 알파벳 대문자를 사용한다.A: 10, B: 11, ..., F: 15, ..., Y: 34, Z: 35",
    "input_description": "첫째 줄에 N과 B가 주어진다. (2 ≤ B ≤ 36)B진법 수 N을 10진법으로 바꾸면, 항상 10억보다 작거나 같다.",
    "output_description": "첫째 줄에 B진법 수 N을 10진법으로 출력한다.",
    "examples": [
      {
        "input": "ZZZZZ 36",
        "output": "60466175"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2745",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N, B = input().split()\nB = int(B)\nresult = 0\nfor i, char in enumerate(reversed(N)):\n    if char.isdigit():\n        result += int(char) * (B ** i)\n    else:\n        result += (ord(char) - ord('A') + 10) * (B ** i)\nprint(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "N, B = input().split()로 입력을 처리합니다.",
            "code_pattern": "N, B = input().split()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for i, char in enumerate(reversed(N)):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "조건 판단",
            "description": "조건문을 사용하여 상황에 따라 다르게 처리합니다.",
            "code_pattern": "if char.isdigit():",
            "socratic_hint": "조건에 따라 다르게 처리하려면?",
            "hint": "if-else 문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(result)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2750",
    "step_title": "정렬",
    "title": "수 정렬하기",
    "level": 4,
    "tags": [
      "정렬",
      "구현"
    ],
    "description": "N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수가 주어진다. 이 수는 절댓값이 1,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.",
    "output_description": "첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.",
    "examples": [
      {
        "input": "5\n5\n2\n3\n4\n1",
        "output": "1\n2\n3\n4\n5"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2750",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nnumbers = []\nfor _ in range(N):\n    numbers.append(int(input()))\n\nnumbers.sort()\nfor num in numbers:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor num in sorted(arr):\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\narr.sort()\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sort() 메서드로 정렬",
            "description": "arr.sort()로 리스트를 제자리에서 정렬합니다.",
            "code_pattern": "arr.sort()",
            "socratic_hint": "리스트를 제자리에서 정렬하는 메서드는?",
            "hint": ".sort() 메서드를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문을 사용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor i in range(n-1):\n    for j in range(n-1-i):\n        if arr[j] > arr[j+1]:\n            arr[j], arr[j+1] = arr[j+1], arr[j]\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 패스 횟수 제어",
            "description": "n-1번 반복하며 각 패스를 수행합니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "버블 정렬에서 몇 번의 패스가 필요한가요?",
            "hint": "n-1번의 패스가 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "내부 반복문: 인접 원소 비교",
            "description": "각 패스에서 인접한 두 원소를 비교합니다. 이미 정렬된 뒤쪽 부분은 제외합니다.",
            "code_pattern": "for j in range(n-1-i):",
            "socratic_hint": "각 패스에서 비교해야 할 원소의 범위는?",
            "hint": "n-1-i까지 비교합니다 (이미 정렬된 부분 제외)."
          },
          {
            "step_id": 4,
            "goal": "원소 교환",
            "description": "왼쪽 원소가 오른쪽 원소보다 크면 위치를 교환합니다.",
            "code_pattern": "if arr[j] > arr[j+1]:\n    arr[j], arr[j+1] = arr[j+1], arr[j]",
            "socratic_hint": "인접한 두 원소의 순서가 잘못되었을 때 어떻게 하나요?",
            "hint": "두 원소의 위치를 swap합니다."
          },
          {
            "step_id": 5,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      },
      {
        "solution_id": 5,
        "solution_name": "풀이 5",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor i in range(n-1):\n    min_idx = i\n    for j in range(i+1, n):\n        if arr[j] < arr[min_idx]:\n            min_idx = j\n    arr[i], arr[min_idx] = arr[min_idx], arr[i]\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 정렬할 위치 선택",
            "description": "n-1번 반복하며 각 위치에 올 최솟값을 찾습니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "선택 정렬에서 몇 번의 선택이 필요한가요?",
            "hint": "n-1번의 선택이 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "최솟값 인덱스 초기화",
            "description": "현재 위치를 최솟값 인덱스로 가정합니다.",
            "code_pattern": "min_idx = i",
            "socratic_hint": "최솟값을 찾기 위한 초기값은?",
            "hint": "현재 위치 i를 초기값으로 설정합니다."
          },
          {
            "step_id": 4,
            "goal": "내부 반복문: 최솟값 찾기",
            "description": "현재 위치 이후의 원소들 중 최솟값의 인덱스를 찾습니다.",
            "code_pattern": "for j in range(i+1, n):\n    if arr[j] < arr[min_idx]:\n        min_idx = j",
            "socratic_hint": "정렬되지 않은 부분에서 최솟값을 어떻게 찾나요?",
            "hint": "i+1부터 끝까지 순회하며 최솟값 인덱스를 업데이트합니다."
          },
          {
            "step_id": 5,
            "goal": "원소 교환",
            "description": "찾은 최솟값을 현재 위치로 이동시킵니다.",
            "code_pattern": "arr[i], arr[min_idx] = arr[min_idx], arr[i]",
            "socratic_hint": "최솟값을 현재 위치로 가져오려면?",
            "hint": "현재 위치의 값과 최솟값을 swap합니다."
          },
          {
            "step_id": 6,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      },
      {
        "solution_id": 6,
        "solution_name": "풀이 6: 버블 정렬",
        "solution_code": "N = int(input())\nnums = [int(input()) for _ in range(N)]\nfor i in range(N):\n    for j in range(N-1-i):\n        if nums[j] > nums[j+1]:\n            nums[j], nums[j+1] = nums[j+1], nums[j]\nfor n in nums:\n    print(n)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "버블 정렬 구현",
            "description": "인접한 원소를 비교하며 정렬합니다.",
            "code_pattern": "if nums[j] > nums[j+1]:\n    nums[j], nums[j+1] = nums[j+1], nums[j]",
            "socratic_hint": "버블 정렬은 어떻게 구현하나요?",
            "hint": "이중 for문으로 인접 원소를 비교합니다."
          }
        ]
      },
      {
        "solution_id": 7,
        "solution_name": "풀이 7: 선택 정렬",
        "solution_code": "N = int(input())\nnums = [int(input()) for _ in range(N)]\nfor i in range(N):\n    min_idx = i\n    for j in range(i+1, N):\n        if nums[j] < nums[min_idx]:\n            min_idx = j\n    nums[i], nums[min_idx] = nums[min_idx], nums[i]\nfor n in nums:\n    print(n)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "선택 정렬 구현",
            "description": "최솟값을 찾아 맨 앞과 교환합니다.",
            "code_pattern": "min_idx = i\nfor j in range(i+1, N):\n    if nums[j] < nums[min_idx]:\n        min_idx = j",
            "socratic_hint": "선택 정렬은 어떻게 구현하나요?",
            "hint": "최솟값을 찾아 앞과 교환합니다."
          }
        ]
      },
      {
        "solution_id": 8,
        "solution_name": "풀이 8: 삽입 정렬",
        "solution_code": "N = int(input())\nnums = [int(input()) for _ in range(N)]\nfor i in range(1, N):\n    key = nums[i]\n    j = i - 1\n    while j >= 0 and nums[j] > key:\n        nums[j+1] = nums[j]\n        j -= 1\n    nums[j+1] = key\nfor n in nums:\n    print(n)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "삽입 정렬 구현",
            "description": "현재 원소를 정렬된 부분에 삽입합니다.",
            "code_pattern": "key = nums[i]\nwhile j >= 0 and nums[j] > key:\n    nums[j+1] = nums[j]",
            "socratic_hint": "삽입 정렬은 어떻게 구현하나요?",
            "hint": "정렬된 부분에 원소를 삽입합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2751",
    "step_title": "정렬",
    "title": "수 정렬하기 2",
    "level": 6,
    "tags": [
      "정렬"
    ],
    "description": "N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수가 주어진다. 이 수는 절댓값이 1,000,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.",
    "output_description": "첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.",
    "examples": [
      {
        "input": "5\n5\n4\n3\n2\n1",
        "output": "1\n2\n3\n4\n5"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2751",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\ninput = sys.stdin.readline\n\nN = int(input())\nnumbers = []\nfor _ in range(N):\n    numbers.append(int(input()))\n\nnumbers.sort()\nfor num in numbers:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor num in sorted(arr):\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\narr.sort()\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sort() 메서드로 정렬",
            "description": "arr.sort()로 리스트를 제자리에서 정렬합니다.",
            "code_pattern": "arr.sort()",
            "socratic_hint": "리스트를 제자리에서 정렬하는 메서드는?",
            "hint": ".sort() 메서드를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문을 사용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor i in range(n-1):\n    for j in range(n-1-i):\n        if arr[j] > arr[j+1]:\n            arr[j], arr[j+1] = arr[j+1], arr[j]\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 패스 횟수 제어",
            "description": "n-1번 반복하며 각 패스를 수행합니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "버블 정렬에서 몇 번의 패스가 필요한가요?",
            "hint": "n-1번의 패스가 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "내부 반복문: 인접 원소 비교",
            "description": "각 패스에서 인접한 두 원소를 비교합니다. 이미 정렬된 뒤쪽 부분은 제외합니다.",
            "code_pattern": "for j in range(n-1-i):",
            "socratic_hint": "각 패스에서 비교해야 할 원소의 범위는?",
            "hint": "n-1-i까지 비교합니다 (이미 정렬된 부분 제외)."
          },
          {
            "step_id": 4,
            "goal": "원소 교환",
            "description": "왼쪽 원소가 오른쪽 원소보다 크면 위치를 교환합니다.",
            "code_pattern": "if arr[j] > arr[j+1]:\n    arr[j], arr[j+1] = arr[j+1], arr[j]",
            "socratic_hint": "인접한 두 원소의 순서가 잘못되었을 때 어떻게 하나요?",
            "hint": "두 원소의 위치를 swap합니다."
          },
          {
            "step_id": 5,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      },
      {
        "solution_id": 5,
        "solution_name": "풀이 5",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor i in range(n-1):\n    min_idx = i\n    for j in range(i+1, n):\n        if arr[j] < arr[min_idx]:\n            min_idx = j\n    arr[i], arr[min_idx] = arr[min_idx], arr[i]\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 정렬할 위치 선택",
            "description": "n-1번 반복하며 각 위치에 올 최솟값을 찾습니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "선택 정렬에서 몇 번의 선택이 필요한가요?",
            "hint": "n-1번의 선택이 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "최솟값 인덱스 초기화",
            "description": "현재 위치를 최솟값 인덱스로 가정합니다.",
            "code_pattern": "min_idx = i",
            "socratic_hint": "최솟값을 찾기 위한 초기값은?",
            "hint": "현재 위치 i를 초기값으로 설정합니다."
          },
          {
            "step_id": 4,
            "goal": "내부 반복문: 최솟값 찾기",
            "description": "현재 위치 이후의 원소들 중 최솟값의 인덱스를 찾습니다.",
            "code_pattern": "for j in range(i+1, n):\n    if arr[j] < arr[min_idx]:\n        min_idx = j",
            "socratic_hint": "정렬되지 않은 부분에서 최솟값을 어떻게 찾나요?",
            "hint": "i+1부터 끝까지 순회하며 최솟값 인덱스를 업데이트합니다."
          },
          {
            "step_id": 5,
            "goal": "원소 교환",
            "description": "찾은 최솟값을 현재 위치로 이동시킵니다.",
            "code_pattern": "arr[i], arr[min_idx] = arr[min_idx], arr[i]",
            "socratic_hint": "최솟값을 현재 위치로 가져오려면?",
            "hint": "현재 위치의 값과 최솟값을 swap합니다."
          },
          {
            "step_id": 6,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2753",
    "step_title": "조건문",
    "title": "윤년",
    "level": 1,
    "tags": [
      "구현",
      "사칙연산",
      "수학"
    ],
    "description": "연도가 주어졌을 때, 윤년이면 1, 아니면 0을 출력하는 프로그램을 작성하시오.윤년은 연도가 4의 배수이면서, 100의 배수가 아닐 때 또는 400의 배수일 때이다.예를 들어, 2012년은 4의 배수이면서 100의 배수가 아니라서 윤년이다. 1900년은 100의 배수이고 400의 배수는 아니기 때문에 윤년이 아니다. 하지만, 2000년은 400의 배수이기 때문에 윤년이다.",
    "input_description": "첫째 줄에 연도가 주어진다. 연도는 1보다 크거나 같고, 4000보다 작거나 같은 자연수이다.",
    "output_description": "첫째 줄에 윤년이면 1, 아니면 0을 출력한다.",
    "examples": [
      {
        "input": "2000",
        "output": "1"
      },
      {
        "input": "1999",
        "output": "0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2753",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "year = int(input())\nif (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):\n    print(1)\nelse:\n    print(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "연도 입력",
            "description": "연도를 입력받습니다.",
            "code_pattern": "year = int(input())",
            "socratic_hint": "연도를 입력받으려면?",
            "hint": "year = int(input())"
          },
          {
            "step_id": 2,
            "goal": "4로 나누어떨어지는지 확인",
            "description": "year % 4 == 0으로 4의 배수인지 확인합니다.",
            "code_pattern": "year % 4 == 0",
            "socratic_hint": "4의 배수는 어떻게 확인하나요?",
            "hint": "% 연산자로 나머지가 0인지 확인합니다."
          },
          {
            "step_id": 3,
            "goal": "100으로 나누어떨어지지 않는지 확인",
            "description": "year % 100 != 0으로 100의 배수가 아닌지 확인합니다.",
            "code_pattern": "year % 100 != 0",
            "socratic_hint": "100의 배수가 아닌 것은 어떻게 확인하나요?",
            "hint": "!= 는 '같지 않다'를 의미합니다."
          },
          {
            "step_id": 4,
            "goal": "400으로 나누어떨어지는지 확인",
            "description": "year % 400 == 0으로 400의 배수인지 확인합니다.",
            "code_pattern": "year % 400 == 0",
            "socratic_hint": "400의 배수는 어떻게 확인하나요?",
            "hint": "year % 400 == 0"
          },
          {
            "step_id": 5,
            "goal": "윤년 조건 조합",
            "description": "(4의 배수 and 100의 배수 아님) or (400의 배수) 조건을 만듭니다.",
            "code_pattern": "(year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)",
            "socratic_hint": "여러 조건을 어떻게 조합하나요?",
            "hint": "and는 '그리고', or는 '또는'입니다."
          },
          {
            "step_id": 6,
            "goal": "윤년이면 1, 아니면 0 출력",
            "description": "조건이 참이면 1, 거짓이면 0을 출력합니다.",
            "code_pattern": "if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):\n    print(1)\nelse:\n    print(0)",
            "socratic_hint": "조건에 따라 다른 값을 출력하려면?",
            "hint": "if-else로 1 또는 0을 출력합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: 삼항 연산자 활용",
        "solution_code": "year = int(input())\nprint(1 if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0) else 0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "필요한 값을 입력받습니다.",
            "code_pattern": "A, B = map(int, input().split())",
            "socratic_hint": "입력을 받으려면?",
            "hint": "input()과 split()을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "삼항 연산자로 조건 판단",
            "description": "삼항 연산자를 연쇄적으로 사용하여 조건을 판단합니다.",
            "code_pattern": "결과 = 값1 if 조건1 else 값2 if 조건2 else 값3",
            "socratic_hint": "여러 조건을 간결하게 표현하려면?",
            "hint": "삼항 연산자를 연쇄적으로 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3: calendar 모듈",
        "solution_code": "import calendar\nyear = int(input())\nprint(1 if calendar.isleap(year) else 0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "calendar 모듈 사용",
            "description": "calendar.isleap()로 윤년을 판단합니다.",
            "code_pattern": "calendar.isleap(year)",
            "socratic_hint": "내장 함수로 윤년을 확인하려면?",
            "hint": "calendar.isleap()을 사용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4: 2월 29일 확인",
        "solution_code": "from datetime import date\nyear = int(input())\ntry:\n    date(year, 2, 29)\n    print(1)\nexcept ValueError:\n    print(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "날짜 생성으로 확인",
            "description": "2월 29일을 생성해보고 성공하면 윤년입니다.",
            "code_pattern": "date(year, 2, 29)",
            "socratic_hint": "실제 날짜로 윤년을 확인하려면?",
            "hint": "try-except로 2월 29일 생성을 시도합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2798",
    "step_title": "브루트 포스",
    "title": "블랙잭",
    "level": 4,
    "tags": [
      "브루트포스 알고리즘"
    ],
    "description": "카지노에서 제일 인기 있는 게임 블랙잭의 규칙은 상당히 쉽다. 카드의 합이 21을 넘지 않는 한도 내에서, 카드의 합을 최대한 크게 만드는 게임이다. 블랙잭은 카지노마다 다양한 규정이 있다.한국 최고의 블랙잭 고수 김정인은 새로운 블랙잭 규칙을 만들어 상근, 창영이와 게임하려고 한다.김정인 버전의 블랙잭에서 각 카드에는 양의 정수가 쓰여 있다. 그 다음, 딜러는 N장의 카드를 모두 숫자가 보이도록 바닥에 놓는다. 그런 후에 딜러는 숫자 M을 크게 외친다.이제 플레이어는 제한된 시간 안에 N장의 카드 중에서 3장의 카드를 골라야 한다. 블랙잭 변형 게임이기 때문에, 플레이어가 고른 카드의 합은 M을 넘지 않으면서 M과 최대한 가깝게 만들어야 한다.N장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오.",
    "input_description": "첫째 줄에 카드의 개수 N(3 ≤ N ≤ 100)과 M(10 ≤ M ≤ 300,000)이 주어진다. 둘째 줄에는 카드에 쓰여 있는 수가 주어지며, 이 값은 100,000을 넘지 않는 양의 정수이다.합이 M을 넘지 않는 카드 3장을 찾을 수 있는 경우만 입력으로 주어진다.",
    "output_description": "첫째 줄에 M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 출력한다.",
    "examples": [
      {
        "input": "5 21\n5 6 7 8 9",
        "output": "21"
      },
      {
        "input": "10 500\n93 181 245 214 315 36 185 138 216 295",
        "output": "497"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2798",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N, M = map(int, input().split())\ncards = list(map(int, input().split()))\n\nresult = 0\nfor i in range(N):\n    for j in range(i+1, N):\n        for k in range(j+1, N):\n            total = cards[i] + cards[j] + cards[k]\n            if total <= M and total > result:\n                result = total\n\nprint(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: combinations",
        "solution_code": "from itertools import combinations\nN, M = map(int, input().split())\ncards = list(map(int, input().split()))\nresult = 0\nfor comb in combinations(cards, 3):\n    s = sum(comb)\n    if s <= M:\n        result = max(result, s)\nprint(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "조합 생성",
            "description": "itertools.combinations로 3장의 조합을 만듭니다.",
            "code_pattern": "combinations(cards, 3)",
            "socratic_hint": "조합을 생성하려면?",
            "hint": "itertools.combinations를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3: 3중 for문",
        "solution_code": "N, M = map(int, input().split())\ncards = list(map(int, input().split()))\nresult = 0\nfor i in range(N):\n    for j in range(i+1, N):\n        for k in range(j+1, N):\n            s = cards[i] + cards[j] + cards[k]\n            if s <= M:\n                result = max(result, s)\nprint(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "3중 반복문",
            "description": "3개를 선택하는 모든 경우를 확인합니다.",
            "code_pattern": "for i in range(N):\n    for j in range(i+1, N):\n        for k in range(j+1, N):",
            "socratic_hint": "3개를 선택하는 방법은?",
            "hint": "3중 반복문을 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2803",
    "step_title": "동적 계획법 5",
    "title": "내가 어렸을 때 가지고 놀던 장난감",
    "level": 21,
    "tags": [
      "다이나믹 프로그래밍",
      "비트마스킹",
      "비트필드를 이용한 다이나믹 프로그래밍",
      "포함 배제의 원리",
      "부분집합의 합 다이나믹 프로그래밍"
    ],
    "description": "어젯밤에 나는 어렸을 때 가지고 놀던 장난감 상자 N개를 창고에서 발견했다. 상자를 좀 뒤적여보니 나는 M종류의 장난감을 가지고 있었다. 오랫동안 기억 속에서 잊혀졌던 장난감을 보니, 내가 어렸을 때, 붙여 주었던 이름이 생각난다. 하지만, 그 이름이 모두 기억나지 않는다. 장난감 마다 숫자를 붙여주어야 겠다. 같은 종류 장난감은 모두 같은 번호를 붙이기로 했다. 상자를 살펴보면서 1번부터 M번까지 번호를 붙여주었다.어렸을적부터 정리정돈의 귀재였던 나는 항상 한 박스에는 한 종류의 장난감을 넣었다. 하지만, 이 상자는 내가 정리한 것이 아닌가보다. 장난감들이 뒤죽박죽 들어가있다. 심지어는 같은 종류의 장난감인데도 여러 상자에 나누어져있는 경우도 있다.이렇게 어렸을 적 추억에 젖어있다보니 지금 내가 얼머나 순수함을 잃었는지를 생각하게 된다. 장난감을 항상 내 곁에 두어 절대 어렸을 적의 순수함을 잃지 않아야겠다.내 방은 좁다. 박스를 놓기에는 너무나도 좁다. 일부 박스만 선택해서 내 곁에 두어야 겠다. 하지만, 모든 종류의 장난감이 있어야 나는 순수함을 잃지 않을 것 같다.모든 종류의 장난감이 선택한 박스 안에 들어있게 박스를 선택하는 방법은 총 몇 가지나 있을까?",
    "input_description": "첫째 줄에 N과 M이 주어진다. (1 ≤ N ≤ 1,000,000, 1 ≤ M ≤ 20)다음 N개 줄에는 각 박스에 들어있는 장난감의 종류의 수 Ki와 어떤 종류가 들어있는지 주어진다. 첫 번째 수는 Ki이고, 다음 숫자 Ki개는 장난감 종류이다. (0 ≤ Ki≤ M)",
    "output_description": "첫째 줄에 모든 종류의 장난감이 들어있게 박스를 고르는 방법의 수를 1,000,000,007로 나눈 나머지를 출력한다.",
    "examples": [
      {
        "input": "3 3\r\n3 1 2 3\r\n3 1 2 3\r\n3 1 2 3",
        "output": "7"
      },
      {
        "input": "3 3\r\n1 1\r\n1 2\r\n1 3",
        "output": "1"
      },
      {
        "input": "4 5\r\n2 2 3\r\n2 1 2\r\n4 1 2 3 5\r\n4 1 2 4 5",
        "output": "6"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2803",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2805",
    "step_title": "이분 탐색",
    "title": "나무 자르기",
    "level": 9,
    "tags": [
      "이분 탐색",
      "매개 변수 탐색"
    ],
    "description": "상근이는 나무 M미터가 필요하다. 근처에 나무를 구입할 곳이 모두 망해버렸기 때문에, 정부에 벌목 허가를 요청했다. 정부는 상근이네 집 근처의 나무 한 줄에 대한 벌목 허가를 내주었고, 상근이는 새로 구입한 목재절단기를 이용해서 나무를 구할것이다.목재절단기는 다음과 같이 동작한다. 먼저, 상근이는 절단기에 높이 H를 지정해야 한다. 높이를 지정하면 톱날이 땅으로부터 H미터 위로 올라간다. 그 다음, 한 줄에 연속해있는 나무를 모두 절단해버린다. 따라서, 높이가 H보다 큰 나무는 H 위의 부분이 잘릴 것이고, 낮은 나무는 잘리지 않을 것이다. 예를 들어, 한 줄에 연속해있는 나무의 높이가 20, 15, 10, 17이라고 하자. 상근이가 높이를 15로 지정했다면, 나무를 자른 뒤의 높이는 15, 15, 10, 15가 될 것이고, 상근이는 길이가 5인 나무와 2인 나무를 들고 집에 갈 것이다. (총 7미터를 집에 들고 간다) 절단기에 설정할 수 있는 높이는 양의 정수 또는 0이다.상근이는 환경에 매우 관심이 많기 때문에, 나무를 필요한 만큼만 집으로 가져가려고 한다. 이때, 적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 나무의 수 N과 상근이가 집으로 가져가려고 하는 나무의 길이 M이 주어진다. (1 ≤ N ≤ 1,000,000, 1 ≤ M ≤ 2,000,000,000)둘째 줄에는 나무의 높이가 주어진다. 나무의 높이의 합은 항상 M보다 크거나 같기 때문에, 상근이는 집에 필요한 나무를 항상 가져갈 수 있다. 높이는 1,000,000,000보다 작거나 같은 양의 정수 또는 0이다.",
    "output_description": "적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 출력한다.",
    "examples": [
      {
        "input": "4 7\n20 15 10 17",
        "output": "15"
      },
      {
        "input": "5 20\n4 42 40 26 46",
        "output": "36"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2805",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def can_cut(height):\n    total = sum(max(0, tree - height) for tree in trees)\n    return total >= M\n\nN, M = map(int, input().split())\ntrees = list(map(int, input().split()))\n\nleft, right = 0, max(trees)\nresult = 0\n\nwhile left <= right:\n    mid = (left + right) // 2\n    if can_cut(mid):\n        result = mid\n        left = mid + 1\n    else:\n        right = mid - 1\n\nprint(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2809",
    "step_title": "문자열 알고리즘 2",
    "title": "아스키 거리",
    "level": 20,
    "tags": [
      "자료 구조",
      "문자열",
      "트리",
      "트라이",
      "아호-코라식"
    ],
    "description": "상근이네 집 앞의 아스키 거리는 알파벳 소문자가 적혀 있는 타일 N개로 이루어져 있다. 정부는 알 수 없는 이유 때문에 거리의 타일을 자주 바꾼다. 하지만, 글자가 적혀있는 타일은 공급이 수요를 따라갈 수 없기 때문에 정부는 M종류의 묶음 타일만 사용할 수 있다.i번째 묶음 타일은 Li개의 글자로 이루어져 있다. 묶음 타일은 회전하거나 조각으로 나눌 수 없다. 또, 거리와 연속해서 글자가 모두 일치하는 경우에만 그 묶음을 사용해서 타일을 교체할 수 있다. 타일은 겹쳐도 상관없고, 한 묶음을 여러 번 사용해도 된다.현재 거리에 쓰여 있는 타일과 묶음 타일의 정보가 주어졌을 때, 그 어떤 타일로도 바꿀 수 없는 칸의 수를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 거리의 길이 N이 주어진다. 다음 줄에는 거리에 원래 적혀져있는 알파벳이 주어진다. 셋째 줄에는 묶음 타일의 종류의 개수 M이 주어진다. 다음 M개 줄에는 각 묶음 타일에 적혀져있는 알파벳이 주어진다. (1 ≤ N ≤ 300,000, 1 ≤ M ≤ 5000, 1 ≤ 각 묶음 타일의 길이 ≤ 5000)",
    "output_description": "첫째 줄에 그 어떤 묶음 타일로도 바꿀 수 없는 타일의 개수를 출력한다.",
    "examples": [
      {
        "input": "6\nabcbab\n2\ncb\ncbab",
        "output": "2"
      },
      {
        "input": "4\nabab\n2\nbac\nbaba",
        "output": "4"
      },
      {
        "input": "6\nabcabc\n2\nabca\ncab",
        "output": "1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2809",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 그래프 문제 기본 구조\nfrom collections import deque\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\n# BFS/DFS 구현\nvisited = [False] * (N + 1)\n\ndef bfs(start):\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        node = queue.popleft()\n        for next_node in graph[node]:\n            if not visited[next_node]:\n                visited[next_node] = True\n                queue.append(next_node)\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2836",
    "step_title": "스위핑",
    "title": "수상 택시",
    "level": 13,
    "tags": [
      "정렬",
      "스위핑"
    ],
    "description": "상근이가 살고 있는 도시에는 큰 강이 흐르고 있고, 모든 사람의 집은 이 강 근처에 있다. 집은 0번부터 M번까지 강을 따라서 번호가 매겨져 있고, 인접한 집 사이의 거리는 모두 1 킬로미터이다.상근이는 0번 집에 살고 있고, 보트를 이용해서 사람들을 운송하는 일을 하고 있다.오늘은 저녁때까지 M번 집으로 가야한다. 상근이는 M번 집으로 가는 길에 사람들을 태워주려고 한다.오늘 상근이의 수상 택시를 타려고 하는 사람은 총 N명이다. 상근이는 각 사람들이 탑승할 위치와 목적지를 알고 있다. 상근이의 보트는 매우 커서 N명 모두 보트에 태울 수 있다.예를 들어, 사람 A가 2번 집에서 8번으로 가려고 하고, B가 6에서 4로 가려고 하는 경우를 생각해보자. 상근이는 0번 집에서 시작해서, 2번에서 A를 태우고, 6번에서 B를 태울 것이다. 그 다음 4로 돌아가 B를 내려주고, 8번에서 A를 내려다준다. 그 다음에 원래 상근이가 가려고 했던 M번 집으로 가면 된다.상근이가 모든 사람을 데려다주고, M번 집으로 가기 위해서 이동해야 하는 거리의 최솟값을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N과 M이 주어진다. (N ≤ 300,000, 3 ≤ M ≤ 109)다음 N개 줄에는 각 사람이 상근이의 수상 택시를 타는 위치와 목적지가 주어진다. 모든 수는 0과 M 사이 정수이다.",
    "output_description": "첫째 줄에 상근이의 이동 거리의 최솟값을 출력한다.",
    "examples": [
      {
        "input": "2 10\n2 8\n6 4",
        "output": "14"
      },
      {
        "input": "8 15\n1 12\n3 1\n3 9\n4 2\n7 13\n12 11\n14 11\n14 13",
        "output": "27"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2836",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "n, m = map(int, input().split())\nbackwards = []\n\nfor _ in range(n):\n    start, end = map(int, input().split())\n    if start > end:\n        backwards.append((end, start))\n\nif not backwards:\n    print(m)\nelse:\n    backwards.sort()\n    \n    merged = [backwards[0]]\n    for start, end in backwards[1:]:\n        if start <= merged[-1][1]:\n            merged[-1] = (merged[-1][0], max(merged[-1][1], end))\n        else:\n            merged.append((start, end))\n    \n    extra = sum(end - start for start, end in merged)\n    print(m + 2 * extra)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor num in sorted(arr):\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2839",
    "step_title": "브루트 포스",
    "title": "설탕 배달",
    "level": 7,
    "tags": [
      "다이나믹 프로그래밍",
      "그리디 알고리즘",
      "수학"
    ],
    "description": "상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 되지만, 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다.상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N이 주어진다. (3 ≤ N ≤ 5000)",
    "output_description": "상근이가 배달하는 봉지의 최소 개수를 출력한다. 만약, 정확하게 N킬로그램을 만들 수 없다면 -1을 출력한다.",
    "examples": [
      {
        "input": "18",
        "output": "4"
      },
      {
        "input": "4",
        "output": "-1"
      },
      {
        "input": "6",
        "output": "2"
      },
      {
        "input": "9",
        "output": "3"
      },
      {
        "input": "11",
        "output": "3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2839",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nresult = -1\n\nfor five in range(N // 5, -1, -1):\n    remainder = N - (five * 5)\n    if remainder % 3 == 0:\n        result = five + remainder // 3\n        break\n\nprint(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2869",
    "step_title": "수학 1",
    "title": "달팽이는 올라가고 싶다",
    "level": 5,
    "tags": [
      "수학"
    ],
    "description": "땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다.달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다. 또, 정상에 올라간 후에는 미끄러지지 않는다.달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 세 정수 A, B, V가 공백으로 구분되어서 주어진다. (1 ≤ B < A ≤ V ≤ 1,000,000,000)",
    "output_description": "첫째 줄에 달팽이가 나무 막대를 모두 올라가는데 며칠이 걸리는지 출력한다.",
    "examples": [
      {
        "input": "2 1 5",
        "output": "4"
      },
      {
        "input": "5 1 6",
        "output": "2"
      },
      {
        "input": "100 99 1000000000",
        "output": "999999901"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2869",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import math\nA, B, V = map(int, input().split())\ndays = math.ceil((V - B) / (A - B))\nprint(days)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "import math\nA, B, V = map(int, input().split())\ndays = math.ceil((V - B) / (A - B))\nprint(days)",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2884",
    "step_title": "조건문",
    "title": "알람 시계",
    "level": 3,
    "tags": [
      "수학",
      "사칙연산"
    ],
    "description": "상근이는 매일 아침 알람을 듣고 일어난다. 알람을 듣고 바로 일어나면 다행이겠지만, 항상 조금만 더 자려는 마음 때문에 매일 학교를 지각하고 있다.상근이는 모든 방법을 동원해보았지만, 조금만 더 자려는 마음은 그 어떤 것도 없앨 수가 없었다.이런 상근이를 불쌍하게 보던 창영이는 자신이 사용하는 방법을 추천해 주었다.바로 \"45분 일찍 알람 설정하기\"이다.이 방법은 단순하다. 원래 설정되어 있는 알람을 45분 앞서는 시간으로 바꾸는 것이다. 어차피 알람 소리를 들으면, 알람을 끄고 조금 더 잘 것이기 때문이다. 이 방법을 사용하면, 매일 아침 더 잤다는 기분을 느낄 수 있고, 학교도 지각하지 않게 된다.현재 상근이가 설정한 알람 시각이 주어졌을 때, 창영이의 방법을 사용한다면, 이를 언제로 고쳐야 하는지 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 두 정수 H와 M이 주어진다. (0 ≤ H ≤ 23, 0 ≤ M ≤ 59) 그리고 이것은 현재 상근이가 설정한 알람 시간 H시 M분을 의미한다.입력 시간은 24시간 표현을 사용한다. 24시간 표현에서 하루의 시작은 0:0(자정)이고, 끝은 23:59(다음날 자정 1분 전)이다. 시간을 나타낼 때, 불필요한 0은 사용하지 않는다.",
    "output_description": "첫째 줄에 상근이가 창영이의 방법을 사용할 때, 설정해야 하는 알람 시간을 출력한다. (입력과 같은 형태로 출력하면 된다.)",
    "examples": [
      {
        "input": "10 10",
        "output": "9 25"
      },
      {
        "input": "0 30",
        "output": "23 45"
      },
      {
        "input": "23 40",
        "output": "22 55"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2884",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "H, M = map(int, input().split())\nif M < 45:\n    H -= 1\n    M += 60\n    if H < 0:\n        H = 23\nM -= 45\nprint(H, M)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "시 입력",
            "description": "현재 시(H)를 입력받습니다.",
            "code_pattern": "H = int(input())",
            "socratic_hint": "현재 시를 입력받으려면?",
            "hint": "H = int(input())"
          },
          {
            "step_id": 2,
            "goal": "분 입력",
            "description": "현재 분(M)을 입력받습니다.",
            "code_pattern": "M = int(input())",
            "socratic_hint": "현재 분을 입력받으려면?",
            "hint": "M = int(input())"
          },
          {
            "step_id": 3,
            "goal": "45분 빼기",
            "description": "분에서 45를 뺍니다.",
            "code_pattern": "M = M - 45",
            "socratic_hint": "45분 전으로 가려면 분에서 무엇을 빼나요?",
            "hint": "M = M - 45"
          },
          {
            "step_id": 4,
            "goal": "분이 음수인지 확인",
            "description": "M < 0인지 확인합니다.",
            "code_pattern": "if M < 0:",
            "socratic_hint": "분이 0보다 작아졌나요?",
            "hint": "if M < 0:"
          },
          {
            "step_id": 5,
            "goal": "음수 분을 양수로 변환",
            "description": "M이 음수면 60을 더해 양수로 만들고, 시를 1 감소시킵니다.",
            "code_pattern": "    M = M + 60\n    H = H - 1",
            "socratic_hint": "예를 들어 -10분은 실제로는 전 시간의 몇 분인가요?",
            "hint": "음수 분에 60을 더하고, 시에서 1을 뺍니다."
          },
          {
            "step_id": 6,
            "goal": "시가 음수면 23시로",
            "description": "H < 0이면 H = 23으로 조정합니다.",
            "code_pattern": "    if H < 0:\n        H = 23",
            "socratic_hint": "0시에서 1시간 전은 몇 시인가요?",
            "hint": "0시 이전은 전날 23시입니다."
          },
          {
            "step_id": 7,
            "goal": "결과 출력",
            "description": "조정된 시와 분을 출력합니다.",
            "code_pattern": "print(H, M)",
            "socratic_hint": "최종 시각을 출력하려면?",
            "hint": "print(H, M)"
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2903",
    "step_title": "수학 1",
    "title": "중앙 이동 알고리즘",
    "level": 3,
    "tags": [
      "수학"
    ],
    "description": "상근이는 친구들과 함께 SF영화를 찍으려고 한다. 이 영화는 외계 지형이 필요하다. 실제로 우주선을 타고 외계 행성에 가서 촬영을 할 수 없기 때문에, 컴퓨터 그래픽으로 CG처리를 하려고 한다.외계 지형은 중앙 이동 알고리즘을 이용해서 만들려고 한다.알고리즘을 시작하면서 상근이는 정사각형을 이루는 점 4개를 고른다. 그 후에는 다음과 같은 과정을 거쳐서 지형을 만든다.정사각형의 각 변의 중앙에 점을 하나 추가한다.정사각형의 중심에 점을 하나 추가한다.초기 상태에서 위와 같은 과정을 한 번 거치면 총 4개의 정사각형이 새로 생긴다. 이와 같은 과정을 상근이가 만족할 때 까지 계속한다.아래 그림은 과정을 총 2번 거쳤을 때까지의 모습이다.초기 상태 - 점 4개1번 - 점 9개2번 - 25개상근이는 어떤 점은 한 개 보다 많은 정사각형에 포함될 수 있다는 사실을 알았다. 메모리 소모량을 줄이기 위해서 중복하는 점을 한 번만 저장하려고 한다. 과정을 N번 거친 후 점 몇 개를 저장해야 하는지 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N이 주어진다. (1 ≤ N ≤ 15)",
    "output_description": "첫째 줄에 과정을 N번 거친 후 점의 수를 출력한다.",
    "examples": [
      {
        "input": "1",
        "output": "9"
      },
      {
        "input": "2",
        "output": "25"
      },
      {
        "input": "5",
        "output": "1089"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2903",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\npoints = (2**N + 1) ** 2\nprint(points)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2908",
    "step_title": "문자열",
    "title": "상수",
    "level": 4,
    "tags": [
      "수학",
      "구현"
    ],
    "description": "상근이의 동생 상수는 수학을 정말 못한다. 상수는 숫자를 읽는데 문제가 있다. 이렇게 수학을 못하는 상수를 위해서 상근이는 수의 크기를 비교하는 문제를 내주었다. 상근이는 세 자리 수 두 개를 칠판에 써주었다. 그 다음에 크기가 큰 수를 말해보라고 했다.상수는 수를 다른 사람과 다르게 거꾸로 읽는다. 예를 들어, 734와 893을 칠판에 적었다면, 상수는 이 수를 437과 398로 읽는다. 따라서, 상수는 두 수중 큰 수인 437을 큰 수라고 말할 것이다.두 수가 주어졌을 때, 상수의 대답을 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 상근이가 칠판에 적은 두 수 A와 B가 주어진다. 두 수는 같지 않은 세 자리 수이며, 0이 포함되어 있지 않다.",
    "output_description": "첫째 줄에 상수의 대답을 출력한다.",
    "examples": [
      {
        "input": "734 893",
        "output": "437"
      },
      {
        "input": "221 231",
        "output": "132"
      },
      {
        "input": "839 237",
        "output": "938"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2908",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "A, B = input().split()\nA_reversed = int(A[::-1])\nB_reversed = int(B[::-1])\nprint(max(A_reversed, B_reversed))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "2941",
    "step_title": "심화 1",
    "title": "크로아티아 알파벳",
    "level": 6,
    "tags": [
      "구현",
      "문자열"
    ],
    "description": "예전에는 운영체제에서 크로아티아 알파벳을 입력할 수가 없었다. 따라서, 다음과 같이 크로아티아 알파벳을 변경해서 입력했다.크로아티아 알파벳변경čc=ćc-dždz=đd-ljljnjnjšs=žz=예를 들어, ljes=njak은 크로아티아 알파벳 6개(lj, e, š, nj, a, k)로 이루어져 있다. 단어가 주어졌을 때, 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.dž는 무조건 하나의 알파벳으로 쓰이고, d와 ž가 분리된 것으로 보지 않는다. lj와 nj도 마찬가지이다. 위 목록에 없는 알파벳은 한 글자씩 센다.",
    "input_description": "첫째 줄에 최대 100글자의 단어가 주어진다. 알파벳 소문자와 '-', '='로만 이루어져 있다.단어는 크로아티아 알파벳으로 이루어져 있다. 문제 설명의 표에 나와있는 알파벳은 변경된 형태로 입력된다.",
    "output_description": "입력으로 주어진 단어가 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.",
    "examples": [
      {
        "input": "ljes=njak",
        "output": "6"
      },
      {
        "input": "ddz=z=",
        "output": "3"
      },
      {
        "input": "nljj",
        "output": "3"
      },
      {
        "input": "c=c=",
        "output": "2"
      },
      {
        "input": "dz=ak",
        "output": "3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/2941",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "croatian = ['c=', 'c-', 'dz=', 'd-', 'lj', 'nj', 's=', 'z=']\nword = input()\nfor c in croatian:\n    word = word.replace(c, '*')\nprint(len(word))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "word = input()로 입력을 처리합니다.",
            "code_pattern": "word = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for c in croatian:",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(len(word))",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "3003",
    "step_title": "심화 1",
    "title": "킹, 퀸, 룩, 비숍, 나이트, 폰",
    "level": 1,
    "tags": [
      "구현",
      "사칙연산",
      "수학"
    ],
    "description": "동혁이는 오래된 창고를 뒤지다가 낡은 체스판과 피스를 발견했다.체스판의 먼지를 털어내고 걸레로 닦으니 그럭저럭 쓸만한 체스판이 되었다. 하지만, 검정색 피스는 모두 있었으나, 흰색 피스는 개수가 올바르지 않았다.체스는 총 16개의 피스를 사용하며, 킹 1개, 퀸 1개, 룩 2개, 비숍 2개, 나이트 2개, 폰 8개로 구성되어 있다.동혁이가 발견한 흰색 피스의 개수가 주어졌을 때, 몇 개를 더하거나 빼야 올바른 세트가 되는지 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 동혁이가 찾은 흰색 킹, 퀸, 룩, 비숍, 나이트, 폰의 개수가 주어진다. 이 값은 0보다 크거나 같고 10보다 작거나 같은 정수이다.",
    "output_description": "첫째 줄에 입력에서 주어진 순서대로 몇 개의 피스를 더하거나 빼야 되는지를 출력한다. 만약 수가 양수라면 동혁이는 그 개수 만큼 피스를 더해야 하는 것이고, 음수라면 제거해야 하는 것이다.",
    "examples": [
      {
        "input": "0 1 2 2 2 7",
        "output": "1 0 0 0 0 1"
      },
      {
        "input": "2 1 2 1 2 1",
        "output": "-1 0 0 1 0 7"
      }
    ],
    "url": "https://www.acmicpc.net/problem/3003",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "pieces = list(map(int, input().split()))\ncorrect = [1, 1, 2, 2, 2, 8]\nresult = [correct[i] - pieces[i] for i in range(6)]\nprint(' '.join(map(str, result)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "pieces = list(map(int, input().split()))\ncorrect = [1, 1, 2, 2, 2, 8]\nresult = [correct[i] - pieces[",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "3009",
    "step_title": "기하 1: 직사각형과 삼각형",
    "title": "네 번째 점",
    "level": 3,
    "tags": [
      "구현",
      "기하학"
    ],
    "description": "세 점이 주어졌을 때, 축에 평행한 직사각형을 만들기 위해서 필요한 네 번째 점을 찾는 프로그램을 작성하시오.",
    "input_description": "세 점의 좌표가 한 줄에 하나씩 주어진다. 좌표는 1보다 크거나 같고, 1000보다 작거나 같은 정수이다.",
    "output_description": "직사각형의 네 번째 점의 좌표를 출력한다.",
    "examples": [
      {
        "input": "5 5\n5 7\n7 5",
        "output": "7 7"
      },
      {
        "input": "30 20\n10 10\n10 20",
        "output": "30 10"
      }
    ],
    "url": "https://www.acmicpc.net/problem/3009",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "coords = [list(map(int, input().split())) for _ in range(3)]\nx_coords = [c[0] for c in coords]\ny_coords = [c[1] for c in coords]\nx = [i for i in x_coords if x_coords.count(i) == 1][0]\ny = [i for i in y_coords if y_coords.count(i) == 1][0]\nprint(x, y)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "coords = [list(map(int, input().split())) for _ in range(3)]\nx_coords = [c[0] for c in coords]\ny_coo",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "3015",
    "step_title": "스택, 큐, 덱 2",
    "title": "오아시스 재결합",
    "level": 16,
    "tags": [
      "자료 구조",
      "스택"
    ],
    "description": "오아시스의 재결합 공연에 N명이 한 줄로 서서 기다리고 있다.이 역사적인 순간을 맞이하기 위해 줄에서 기다리고 있던 백준이는 갑자기 자기가 볼 수 있는 사람의 수가 궁금해졌다.두 사람 A와 B가 서로 볼 수 있으려면, 두 사람 사이에 A 또는 B보다 키가 큰 사람이 없어야 한다.줄에 서 있는 사람의 키가 주어졌을 때, 서로 볼 수 있는 쌍의 수를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 줄에서 기다리고 있는 사람의 수 N이 주어진다. (1 ≤ N ≤ 500,000)둘째 줄부터 N개의 줄에는 각 사람의 키가 나노미터 단위로 주어진다. 모든 사람의 키는 231나노미터 보다 작다.사람들이 서 있는 순서대로 입력이 주어진다.",
    "output_description": "서로 볼 수 있는 쌍의 수를 출력한다.",
    "examples": [
      {
        "input": "7\n2\n4\n1\n2\n2\n5\n1",
        "output": "10"
      }
    ],
    "url": "https://www.acmicpc.net/problem/3015",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nstack = []\nanswer = 0\n\nfor _ in range(N):\n    height = int(input())\n    count = 1\n    \n    while stack and stack[-1][0] <= height:\n        answer += stack[-1][1]\n        if stack[-1][0] == height:\n            count += stack[-1][1]\n        stack.pop()\n    \n    if stack:\n        answer += 1\n    \n    stack.append((height, count))\n\nprint(answer)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "3052",
    "step_title": "1차원 배열",
    "title": "나머지",
    "level": 4,
    "tags": [
      "수학",
      "집합과 맵",
      "사칙연산"
    ],
    "description": "두 자연수 A와 B가 있을 때, A%B는 A를 B로 나눈 나머지 이다. 예를 들어, 7, 14, 27, 38을 3으로 나눈 나머지는 1, 2, 0, 2이다.수 10개를 입력받은 뒤, 이를 42로 나눈 나머지를 구한다. 그 다음 서로 다른 값이 몇 개 있는지 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄부터 열번째 줄 까지 숫자가 한 줄에 하나씩 주어진다. 이 숫자는 1,000보다 작거나 같고, 음이 아닌 정수이다.",
    "output_description": "첫째 줄에, 42로 나누었을 때, 서로 다른 나머지가 몇 개 있는지 출력한다.",
    "examples": [
      {
        "input": "1\n2\n3\n4\n5\n6\n7\n8\n9\n10",
        "output": "10"
      },
      {
        "input": "42\n84\n252\n420\n840\n126\n42\n84\n420\n126",
        "output": "1"
      },
      {
        "input": "39\n40\n41\n42\n43\n44\n82\n83\n84\n85",
        "output": "6"
      }
    ],
    "url": "https://www.acmicpc.net/problem/3052",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "remainders = []\nfor i in range(10):\n    num = int(input())\n    remainder = num % 42\n    if remainder not in remainders:\n        remainders.append(remainder)\nprint(len(remainders))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "빈 리스트 생성",
            "description": "서로 다른 나머지를 저장할 빈 리스트를 만듭니다.",
            "code_pattern": "remainders = []",
            "socratic_hint": "나머지들을 저장할 공간을 만들려면?",
            "hint": "remainders = []"
          },
          {
            "step_id": 2,
            "goal": "10번 반복 시작",
            "description": "10개의 수를 처리하기 위해 반복합니다.",
            "code_pattern": "for i in range(10):",
            "socratic_hint": "10번 반복하려면?",
            "hint": "for i in range(10):"
          },
          {
            "step_id": 3,
            "goal": "수 입력받기",
            "description": "매번 정수를 입력받습니다.",
            "code_pattern": "    num = int(input())",
            "socratic_hint": "반복할 때마다 정수를 입력받으려면?",
            "hint": "num = int(input())"
          },
          {
            "step_id": 4,
            "goal": "42로 나눈 나머지 계산",
            "description": "num % 42로 나머지를 계산합니다.",
            "code_pattern": "    remainder = num % 42",
            "socratic_hint": "42로 나눈 나머지를 구하려면?",
            "hint": "num % 42"
          },
          {
            "step_id": 5,
            "goal": "나머지가 리스트에 없으면 추가",
            "description": "나머지가 리스트에 없으면 추가합니다. 이렇게 중복을 제거합니다.",
            "code_pattern": "    if remainder not in remainders:\n        remainders.append(remainder)",
            "socratic_hint": "리스트에 같은 값이 없을 때만 추가하려면?",
            "hint": "if remainder not in remainders: 사용"
          },
          {
            "step_id": 6,
            "goal": "서로 다른 나머지 개수 출력",
            "description": "리스트의 길이가 서로 다른 나머지의 개수입니다.",
            "code_pattern": "print(len(remainders))",
            "socratic_hint": "리스트에 몇 개의 원소가 있는지 확인하려면?",
            "hint": "len(remainders)"
          }
        ]
      }
    ]
  },
  {
    "problem_id": "3176",
    "step_title": "최소 공통 조상",
    "title": "도로 네트워크",
    "level": 17,
    "tags": [
      "자료 구조",
      "트리",
      "최소 공통 조상",
      "희소 배열"
    ],
    "description": "N개의 도시와 그 도시를 연결하는 N-1개의 도로로 이루어진 도로 네트워크가 있다.모든 도시의 쌍에는 그 도시를 연결하는 유일한 경로가 있고, 각 도로의 길이는 입력으로 주어진다.총 K개의 도시 쌍이 주어진다. 이때, 두 도시를 연결하는 경로 상에서 가장 짧은 도로의 길이와 가장 긴 도로의 길이를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N이 주어진다. (2 ≤ N ≤ 100,000)다음 N-1개 줄에는 도로를 나타내는 세 정수 A, B, C가 주어진다. A와 B사이에 길이가 C인 도로가 있다는 뜻이다. 도로의 길이는 1,000,000보다 작거나 같은 양의 정수이다.다음 줄에는 K가 주어진다. (1 ≤ K ≤ 100,000)다음 K개 줄에는 서로 다른 두 자연수 D와 E가 주어진다. D와 E를 연결하는 경로에서 가장 짧은 도로의 길이와 가장 긴 도로의 길이를 구해서 출력하면 된다.",
    "output_description": "총 K개 줄에 D와 E를 연결하는 경로에서 가장 짧은 도로의 길이와 가장 긴 도로의 길이를 출력한다.",
    "examples": [
      {
        "input": "5\n2 3 100\n4 3 200\n1 5 150\n1 3 50\n3\n2 4\n3 5\n1 2",
        "output": "100 200\n50 150\n50 100"
      },
      {
        "input": "7\n3 6 4\n1 7 1\n1 3 2\n1 2 6\n2 5 4\n2 4 4\n5\n6 4\n7 6\n1 2\n1 3\n3 5",
        "output": "2 6\n1 4\n6 6\n2 2\n2 6"
      },
      {
        "input": "9\n1 2 2\n2 3 1\n3 4 5\n2 7 4\n1 5 3\n5 6 1\n5 9 2\n1 8 3\n5\n6 9\n7 8\n9 4\n1 2\n7 3",
        "output": "1 2\n2 4\n1 5\n2 2\n1 4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/3176",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nfrom math import log2\ninput = sys.stdin.readline\n\nN = int(input())\nMAX_LOG = int(log2(N)) + 1\n\ntree = [[] for _ in range(N + 1)]\ndepth = [0] * (N + 1)\nparent = [[0] * MAX_LOG for _ in range(N + 1)]\n\nfor _ in range(N - 1):\n    a, b = map(int, input().split())\n    tree[a].append(b)\n    tree[b].append(a)\n\ndef dfs(node, par, d):\n    depth[node] = d\n    parent[node][0] = par\n    \n    for next_node in tree[node]:\n        if next_node != par:\n            dfs(next_node, node, d + 1)\n\ndfs(1, 0, 0)\n\nfor j in range(1, MAX_LOG):\n    for i in range(1, N + 1):\n        parent[i][j] = parent[parent[i][j-1]][j-1]\n\ndef lca(a, b):\n    if depth[a] < depth[b]:\n        a, b = b, a\n    \n    diff = depth[a] - depth[b]\n    for i in range(MAX_LOG):\n        if diff & (1 << i):\n            a = parent[a][i]\n    \n    if a == b:\n        return a\n    \n    for i in range(MAX_LOG - 1, -1, -1):\n        if parent[a][i] != parent[b][i]:\n            a = parent[a][i]\n            b = parent[b][i]\n    \n    return parent[a][0]\n\nM = int(input())\nfor _ in range(M):\n    a, b = map(int, input().split())\n    print(lca(a, b))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "3273",
    "step_title": "투 포인터",
    "title": "두 수의 합",
    "level": 8,
    "tags": [
      "정렬",
      "두 포인터"
    ],
    "description": "n개의 서로 다른 양의 정수 a1, a2, ..., an으로 이루어진 수열이 있다. ai의 값은 1보다 크거나 같고, 1000000보다 작거나 같은 자연수이다. 자연수 x가 주어졌을 때, ai+ aj= x (1 ≤ i < j ≤ n)을 만족하는 (ai, aj)쌍의 수를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 수열의 크기 n이 주어진다. 다음 줄에는 수열에 포함되는 수가 주어진다. 셋째 줄에는 x가 주어진다. (1 ≤ n ≤ 100000, 1 ≤ x ≤ 2000000)",
    "output_description": "문제의 조건을 만족하는 쌍의 개수를 출력한다.",
    "examples": [
      {
        "input": "9\r\n5 12 7 10 9 1 2 3 11\r\n13",
        "output": "3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/3273",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "n = int(input())\nnumbers = sorted(list(map(int, input().split())))\nx = int(input())\n\nleft, right = 0, n - 1\ncount = 0\n\nwhile left < right:\n    total = numbers[left] + numbers[right]\n    if total == x:\n        count += 1\n        left += 1\n        right -= 1\n    elif total < x:\n        left += 1\n    else:\n        right -= 1\n\nprint(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = int(input())\narr = list(map(int, input().split()))\nx = int(input())\n\narr.sort()\ncount = 0\nleft, right = 0, n - 1\n\nwhile left < right:\n    current_sum = arr[left] + arr[right]\n    if current_sum == x:\n        count += 1\n        left += 1\n        right -= 1\n    elif current_sum < x:\n        left += 1\n    else:\n        right -= 1\n\nprint(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "3419",
    "step_title": "네트워크 플로우 3",
    "title": "Racing Car Trail",
    "level": 23,
    "tags": [
      "그래프 이론",
      "그래프 탐색",
      "깊이 우선 탐색",
      "게임 이론",
      "이분 매칭"
    ],
    "description": "Have you ever read any description of some encryption algorithm? These descriptions almost always include messages being sent between Alice and Bob. We (the people organizing the 2011 Central Europe Regional Contest) think that those descriptions are too impersonal — considering these two people are probably the most famous cryptographers in the whole world, we know so little about them. They deserve more attention, don’t you think? We can learn about their hobbies, for instance.In their free time, Alice and Bob like to play a game inspired by Tron. In this game, you race a car through a square grid and you need to avoid hitting obstacles placed in the grid. Furthermore, the car leaves a permanent trail, which you also need to avoid. The car only moves in the four cardinal directions (east, west, north, or south). In their version of the game, Alice and Bob alternate in controling the car—Alice starts, moves the car from its initial position to one of the adjacent positions in the grid, then Bob takes over and moves the same car to another adjacent position, etc.The player who crashes the car (i.e., moves it to a position occupied by an obstacle, or to one of the previously visited positions) loses. Both Alice and Bob are incredibly skilled players and never make mistakes; in particular, they only crash if there is no possible move from their current position that would avoid it. Given the map of the obstacles, your task is to determine which player wins from which initial position.",
    "input_description": "The input contains descriptions of several game fields. The first line of each description contains two integers N and E (1 ≤ N,E ≤ 100) — the size of the grid in the north-south and in the east-west directions. The following N lines describe the map. Each of the lines contains a string of E characters, where the j-th character on the i-th line determines the state of the position with coordinates (j,i). The possible characters are “.” (a dot) if the position is empty and the uppercase letter “X” if there is an obstacle. All positions not covered by the map (i.e., with coordinates (j,i) such that i ≤ 0 or j ≤ 0 or i > N or j > E) are forbidden and not used in the game, they work as if there were obstacles.The last game field is followed by a line containing two zeros.",
    "output_description": "For each game field, output N lines of strings of length E, showing whether Alice or Bob wins when the game starts from the given location. The j-th character on the i-th line should be “A” if Alice wins when starting from the position (j,i), “B” if Bob wins, or “X” if the position contains an obstacle.After each output, print one empty line.",
    "examples": [
      {
        "input": "1 1\r\n.\r\n3 3\r\n...\r\n.X.\r\n...\r\n1 4\r\n....\r\n3 3\r\nX.X\r\n...\r\nX.X\r\n5 8\r\n........\r\n.XX.XXX.\r\n.X..X...\r\n.X.XX.X.\r\n........\r\n0 0",
        "output": "B\r\n\r\nAAA\r\nAXA\r\nAAA\r\n\r\nAAAA\r\n\r\nXBX\r\nBAB\r\nXBX\r\n\r\nBABABABA\r\nAXXBXXXB\r\nBXBAXABA\r\nAXAXXBXB\r\nBABABABA"
      }
    ],
    "url": "https://www.acmicpc.net/problem/3419",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "3584",
    "step_title": "최소 공통 조상",
    "title": "가장 가까운 공통 조상",
    "level": 12,
    "tags": [
      "그래프 이론",
      "그래프 탐색",
      "트리",
      "깊이 우선 탐색",
      "최소 공통 조상"
    ],
    "description": "루트가 있는 트리(rooted tree)가 주어지고, 그 트리 상의 두 정점이 주어질 때 그들의 가장 가까운 공통 조상(Nearest Common Ancestor)은 다음과 같이 정의됩니다.두 노드의 가장 가까운 공통 조상은, 두 노드를 모두 자손으로 가지면서 깊이가 가장 깊은(즉 두 노드에 가장 가까운) 노드를 말합니다.예를 들어  15와 11를 모두 자손으로 갖는 노드는 4와 8이 있지만, 그 중 깊이가 가장 깊은(15와 11에 가장 가까운) 노드는 4 이므로 가장 가까운 공통 조상은 4가 됩니다.루트가 있는 트리가 주어지고, 두 노드가 주어질 때 그 두 노드의 가장 가까운 공통 조상을 찾는 프로그램을 작성하세요",
    "input_description": "첫 줄에 테스트 케이스의 개수 T가 주어집니다.각 테스트 케이스마다, 첫째 줄에 트리를 구성하는 노드의 수 N이 주어집니다. (2 ≤ N ≤ 10,000)그리고 그 다음 N-1개의 줄에 트리를 구성하는 간선 정보가 주어집니다. 한 간선 당 한 줄에 두 개의 숫자 A B 가 순서대로 주어지는데, 이는 A가 B의 부모라는 뜻입니다. (당연히 정점이 N개인 트리는 항상 N-1개의 간선으로 이루어집니다!) A와 B는 1 이상 N 이하의 정수로 이름 붙여집니다.테스트 케이스의 마지막 줄에 가장 가까운 공통 조상을 구할 두 노드가 주어집니다.",
    "output_description": "각 테스트 케이스 별로, 첫 줄에 입력에서 주어진 두 노드의 가장 가까운 공통 조상을 출력합니다.",
    "examples": [
      {
        "input": "2\n16\n1 14\n8 5\n10 16\n5 9\n4 6\n8 4\n4 10\n1 13\n6 15\n10 11\n6 7\n10 2\n16 3\n8 1\n16 12\n16 7\n5\n2 3\n3 4\n3 1\n1 5\n3 5",
        "output": "4\n3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/3584",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import deque\n\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    parent = [0] * (N + 1)\n    \n    for _ in range(N - 1):\n        A, B = map(int, input().split())\n        parent[B] = A\n    \n    node1, node2 = map(int, input().split())\n    \n    ancestors1 = set()\n    while node1 != 0:\n        ancestors1.add(node1)\n        node1 = parent[node1]\n    \n    while node2 not in ancestors1:\n        node2 = parent[node2]\n    \n    print(node2)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "3648",
    "step_title": "강한 연결 요소",
    "title": "아이돌",
    "level": 18,
    "tags": [
      "그래프 이론",
      "강한 연결 요소",
      "2-sat"
    ],
    "description": "상근이는 오디션 프로그램 대한민국 아이돌의 예선에 참가중이다.대한민국 아이돌 오디션 프로그램에서 참가자는 심사위원에게 10분동안 자신의 매력을 발산할 기회를 갖는다. 모든 참가자가 경연이 끝난후에, 심사위원은 모두 모여서 투표를 하게 된다. 각 심사위원은 다음 라운드에 꼭 진출시켰으면 하는 사람(찬성)이나 이번 라운드에서 꼭 탈락시켰으면 하는 사람(반대)을 두 명 고른다. 한 심사위원이 찬성표를 두 개 내는 것과 반대표를 두 개 내는 것도 가능하며, 찬성과 반대를 각각 하나씩 내는 것도 가능하다. 또, 반드시 두 표를 내야 한다.다음 라운드에 진출하는 참가자의 수는 정해져 있지 않다. 즉, 실력이 참가자의 경연이 모두 나쁜 경우에는 다음 라운드에 진출하는 참가자가 없을 수도 있고, 모두 엄청난 경연을 한 경우에는 모든 참가자기 다음 라운드에 진출할 수도 있다.상근이는 심판들이 자신의 프로그래밍 능력에 큰 관심을 보이지 않을 것 같아 걱정하고 있다. 따라서, 상근이는 해킹을 이용해서 다음 라운드에 진출하려고 한다. 상근이는 투표 집계 시스템을 해킹해서, 다음 라운드 진출자를 선택하는 프로그램을 바꿔치기 하려고 한다. 하지만, 의심을 받지 않아야 한다.각 심사위원은 자신이 행사한 두 표 중 적어도 하나는 결과에 영향을 미쳐야 한다고 생각을 한다. 두 표 모두와 반대되는 결과가 나오면, 심사위원은 투표 결과에 대해서 의심을 하게 된다. 예를 들어, 고원섭 심사위원이 박현수 참가자에게 찬성을, 김선영 참가자에게 반대를 한 경우를 생각해보자. 이 경우에 김선영이 다음 라운드에 진출하고, 박현수가 탈락을 하게 된다면, 두 결과가 모두 영향을 미치지 못했기 때문에, 고원섭 심사위원은 투표를 의심하게 된다.상근이는 심사위원의 의심을 받지 않으면서, 다음 라운드에 진출하는 목록을 만들 수 있는지를 알고 싶어 한다. 당연히 이 목록에는 상근이가 포함되어 있어야 한다. 각 심사위원이 투표한 결과가 주어졌을 때, 상근이가 포함된 다음 라운드 진출 목록을 만들 수 있는지 없는지를 구하는 프로그램을 작성하시오.",
    "input_description": "입력은 여러 개의 테스트 케이스로 이루어져 있다.각 테스트 케이스의 첫째 줄에는 참가자의 수 n (2 ≤ n < 1000) 과 심사위원의 수 m (1 ≤ m < 2000)이 주어진다.다음 m개 줄에는 각 심사위원이 행사한 투표의 정보 a와 b가 주어진다. (1 ≤ |a|, |b| ≤ n, |a| ≠ |b|) 정보가 x < 0인 경우에는 그 심사위원이 참가자 |x|에게 반대표를 행사한 것이고, x > 0인 경우는 |x|에게 찬성을 던진 것이다.참가자의 번호는 1번부터 n번이다. 상근이는 1번 참가자이다.",
    "output_description": "각 테스트 케이스에 대해서, 상근이를 포함해, 다음 라운드 진출 목록을 심사위원의 의심 없이 만들 수 있으면 'yes'를, 없으면 'no'를 출력한다.",
    "examples": [
      {
        "input": "4 3\n1 2\n-2 -3\n2 4\n2 4\n1 2\n1 -2\n-1 2\n-1 -2",
        "output": "yes\nno"
      }
    ],
    "url": "https://www.acmicpc.net/problem/3648",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\ndef dfs1(v):\n    visited[v] = True\n    for next_v in graph[v]:\n        if not visited[next_v]:\n            dfs1(next_v)\n    stack.append(v)\n\ndef dfs2(v, scc_num):\n    scc_id[v] = scc_num\n    for next_v in reverse_graph[v]:\n        if scc_id[next_v] == -1:\n            dfs2(next_v, scc_num)\n\nN, M = map(int, input().split())\n\ngraph = [[] for _ in range(2 * N + 1)]\nreverse_graph = [[] for _ in range(2 * N + 1)]\n\ndef get_node(x):\n    if x > 0:\n        return x\n    else:\n        return N + abs(x)\n\ndef get_not(x):\n    if x <= N:\n        return x + N\n    else:\n        return x - N\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[get_not(get_node(a))].append(get_node(b))\n    graph[get_not(get_node(b))].append(get_node(a))\n    reverse_graph[get_node(b)].append(get_not(get_node(a)))\n    reverse_graph[get_node(a)].append(get_not(get_node(b)))\n\nvisited = [False] * (2 * N + 1)\nstack = []\n\nfor i in range(1, 2 * N + 1):\n    if not visited[i]:\n        dfs1(i)\n\nscc_id = [-1] * (2 * N + 1)\nscc_num = 0\n\nwhile stack:\n    v = stack.pop()\n    if scc_id[v] == -1:\n        dfs2(v, scc_num)\n        scc_num += 1\n\n# 2-SAT 가능 여부 확인\npossible = True\nfor i in range(1, N + 1):\n    if scc_id[i] == scc_id[N + i]:\n        possible = False\n        break\n\nprint(1 if possible else 0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "3665",
    "step_title": "위상 정렬",
    "title": "최종 순위",
    "level": 15,
    "tags": [
      "그래프 이론",
      "방향 비순환 그래프",
      "위상 정렬"
    ],
    "description": "올해 ACM-ICPC 대전 인터넷 예선에는 총 n개의 팀이 참가했다. 팀은 1번부터 n번까지 번호가 매겨져 있다. 놀랍게도 올해 참가하는 팀은 작년에 참가했던 팀과 동일하다.올해는 인터넷 예선 본부에서는 최종 순위를 발표하지 않기로 했다. 그 대신에 작년에 비해서 상대적인 순위가 바뀐 팀의 목록만 발표하려고 한다. (작년에는 순위를 발표했다) 예를 들어, 작년에 팀 13이 팀 6 보다 순위가 높았는데, 올해 팀 6이 팀 13보다 순위가 높다면, (6, 13)을 발표할 것이다.창영이는 이 정보만을 가지고 올해 최종 순위를 만들어보려고 한다. 작년 순위와 상대적인 순위가 바뀐 모든 팀의 목록이 주어졌을 때, 올해 순위를 만드는 프로그램을 작성하시오. 하지만, 본부에서 발표한 정보를 가지고 확실한 올해 순위를 만들 수 없는 경우가 있을 수도 있고, 일관성이 없는 잘못된 정보일 수도 있다. 이 두 경우도 모두 찾아내야 한다.",
    "input_description": "첫째 줄에는 테스트 케이스의 개수가 주어진다. 테스트 케이스는 100개를 넘지 않는다. 각 테스트 케이스는 다음과 같이 이루어져 있다.팀의 수 n을 포함하고 있는 한 줄. (2 ≤ n ≤ 500)n개의 정수 ti를 포함하고 있는 한 줄. (1 ≤ ti≤ n) ti는 작년에 i등을 한 팀의 번호이다. 1등이 가장 성적이 높은 팀이다. 모든 ti는 서로 다르다.상대적인 등수가 바뀐 쌍의 수 m (0 ≤ m ≤ 25000)두 정수 ai와 bi를 포함하고 있는 m줄. (1 ≤ ai< bi≤ n) 상대적인 등수가 바뀐 두 팀이 주어진다. 같은 쌍이 여러 번 발표되는 경우는 없다.",
    "output_description": "각 테스트 케이스에 대해서 다음을 출력한다.n개의 정수를 한 줄에 출력한다. 출력하는 숫자는 올해 순위이며, 1등팀부터 순서대로 출력한다. 만약, 확실한 순위를 찾을 수 없다면 \"?\"를 출력한다. 데이터에 일관성이 없어서 순위를 정할 수 없는 경우에는 \"IMPOSSIBLE\"을 출력한다.",
    "examples": [
      {
        "input": "3\r\n5\r\n5 4 3 2 1\r\n2\r\n2 4\r\n3 4\r\n3\r\n2 3 1\r\n0\r\n4\r\n1 2 3 4\r\n3\r\n1 2\r\n3 4\r\n2 3",
        "output": "5 3 2 4 1\r\n2 3 1\r\nIMPOSSIBLE"
      }
    ],
    "url": "https://www.acmicpc.net/problem/3665",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import deque\n\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    rank = list(map(int, input().split()))\n    \n    # 초기 그래프 구성\n    graph = [[False] * (n + 1) for _ in range(n + 1)]\n    indegree = [0] * (n + 1)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            graph[rank[i]][rank[j]] = True\n            indegree[rank[j]] += 1\n    \n    # 순위 변경\n    m = int(input())\n    for _ in range(m):\n        a, b = map(int, input().split())\n        if graph[a][b]:\n            graph[a][b] = False\n            graph[b][a] = True\n            indegree[b] -= 1\n            indegree[a] += 1\n        else:\n            graph[b][a] = False\n            graph[a][b] = True\n            indegree[a] -= 1\n            indegree[b] += 1\n    \n    # 위상 정렬\n    queue = deque()\n    for i in range(1, n + 1):\n        if indegree[i] == 0:\n            queue.append(i)\n    \n    result = []\n    certain = True\n    \n    for _ in range(n):\n        if len(queue) == 0:\n            certain = False\n            break\n        if len(queue) > 1:\n            certain = False\n            break\n        \n        node = queue.popleft()\n        result.append(node)\n        \n        for i in range(1, n + 1):\n            if graph[node][i]:\n                indegree[i] -= 1\n                if indegree[i] == 0:\n                    queue.append(i)\n    \n    if not certain or len(result) != n:\n        print(\"IMPOSSIBLE\")\n    else:\n        print(' '.join(map(str, result)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "3679",
    "step_title": "기하 3",
    "title": "단순 다각형",
    "level": 17,
    "tags": [
      "정렬",
      "기하학",
      "볼록 껍질",
      "각도 정렬"
    ],
    "description": "평면 위의 점의 집합이 주어졌을 때, 다각형을 만드는 프로그램을 작성하시오. 집합의 모든 점은 다각형의 꼭짓점이어야 하고, 집합에 없는 점을 다각형의 꼭짓점으로 가질 수 없다. 다각형의 두 선분은 연속하는 두 선분의 교점을 제외하고는 교차할 수 없다.예를 들어, 왼쪽 그림의 점으로 만든 다각형은 오른쪽과 같다.항상 문제의 조건을 만족하는 다각형만 입력으로 주어지며, 가능한 다각형이 여러 가지인 경우에는 아무거나 출력해도 된다. 두 점이 같은 위치에 있는 경우는 없으며, 모든 점이 한 직선위에 있는 경우는 없다.",
    "input_description": "첫째 줄에 테스트 케이스의 개수 c (1 ≤ c ≤ 200)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있다. 테스트 케이스의 첫 번째 숫자는 점의 개수 n (3 ≤ n ≤ 2000) 이다. 다음 숫자는 점의 좌표 x와 y이며, 좌표는 -10,000보다 크거나 같고, 10,000보다 작거나 같은 정수이다.",
    "output_description": "각 테스트 케이스마다 0부터 n-1까지 순열중 하나를 출력해야 한다. 출력하는 순열은 입력으로 주어지는 점의 번호를 나타내며, 출력하는 순서대로 점을 이었을 때, 올바른 다각형을 만들어야 한다.",
    "examples": [
      {
        "input": "2\r\n4 0 0 2 0 0 1 1 0\r\n5 0 0 10 0 10 5 5 -1 0 5",
        "output": "0 3 1 2\r\n3 1 2 4 0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/3679",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor num in sorted(arr):\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\narr.sort()\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sort() 메서드로 정렬",
            "description": "arr.sort()로 리스트를 제자리에서 정렬합니다.",
            "code_pattern": "arr.sort()",
            "socratic_hint": "리스트를 제자리에서 정렬하는 메서드는?",
            "hint": ".sort() 메서드를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문을 사용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor i in range(n-1):\n    for j in range(n-1-i):\n        if arr[j] > arr[j+1]:\n            arr[j], arr[j+1] = arr[j+1], arr[j]\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 패스 횟수 제어",
            "description": "n-1번 반복하며 각 패스를 수행합니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "버블 정렬에서 몇 번의 패스가 필요한가요?",
            "hint": "n-1번의 패스가 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "내부 반복문: 인접 원소 비교",
            "description": "각 패스에서 인접한 두 원소를 비교합니다. 이미 정렬된 뒤쪽 부분은 제외합니다.",
            "code_pattern": "for j in range(n-1-i):",
            "socratic_hint": "각 패스에서 비교해야 할 원소의 범위는?",
            "hint": "n-1-i까지 비교합니다 (이미 정렬된 부분 제외)."
          },
          {
            "step_id": 4,
            "goal": "원소 교환",
            "description": "왼쪽 원소가 오른쪽 원소보다 크면 위치를 교환합니다.",
            "code_pattern": "if arr[j] > arr[j+1]:\n    arr[j], arr[j+1] = arr[j+1], arr[j]",
            "socratic_hint": "인접한 두 원소의 순서가 잘못되었을 때 어떻게 하나요?",
            "hint": "두 원소의 위치를 swap합니다."
          },
          {
            "step_id": 5,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      },
      {
        "solution_id": 5,
        "solution_name": "풀이 5",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor i in range(n-1):\n    min_idx = i\n    for j in range(i+1, n):\n        if arr[j] < arr[min_idx]:\n            min_idx = j\n    arr[i], arr[min_idx] = arr[min_idx], arr[i]\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 정렬할 위치 선택",
            "description": "n-1번 반복하며 각 위치에 올 최솟값을 찾습니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "선택 정렬에서 몇 번의 선택이 필요한가요?",
            "hint": "n-1번의 선택이 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "최솟값 인덱스 초기화",
            "description": "현재 위치를 최솟값 인덱스로 가정합니다.",
            "code_pattern": "min_idx = i",
            "socratic_hint": "최솟값을 찾기 위한 초기값은?",
            "hint": "현재 위치 i를 초기값으로 설정합니다."
          },
          {
            "step_id": 4,
            "goal": "내부 반복문: 최솟값 찾기",
            "description": "현재 위치 이후의 원소들 중 최솟값의 인덱스를 찾습니다.",
            "code_pattern": "for j in range(i+1, n):\n    if arr[j] < arr[min_idx]:\n        min_idx = j",
            "socratic_hint": "정렬되지 않은 부분에서 최솟값을 어떻게 찾나요?",
            "hint": "i+1부터 끝까지 순회하며 최솟값 인덱스를 업데이트합니다."
          },
          {
            "step_id": 5,
            "goal": "원소 교환",
            "description": "찾은 최솟값을 현재 위치로 이동시킵니다.",
            "code_pattern": "arr[i], arr[min_idx] = arr[min_idx], arr[i]",
            "socratic_hint": "최솟값을 현재 위치로 가져오려면?",
            "hint": "현재 위치의 값과 최솟값을 swap합니다."
          },
          {
            "step_id": 6,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "3736",
    "step_title": "네트워크 플로우 1",
    "title": "System Engineer",
    "level": 18,
    "tags": [
      "이분 매칭"
    ],
    "description": "Bob is a skilled system engineer. He is always facing challenging problems, and now he must solve a new one. He has to handle a set of servers with differing capabilities available to process job requests from persistent sources - jobs that need to be processed over a long or indefinite period of time. A sequence of persistent job requests arrives revealing a subset of servers capable of servicing their request. A job is processed on a single server and a server processes only one job. Bob has to schedule the maximum number of jobs on the servers. For example, if there are 2 jobs j1, j2and 2 servers s1, s2, job j1requiring the server s1, and job j2requiring also the server s1In this case Bob can schedule only one job. Can you help him?In the general case there are n jobs numbered from 0 to n-1, n servers numbered from n to 2 *n-1, and a sequence of job requests. The problem asks to find the maximum number of jobs that can be processed.",
    "input_description": "The program input is from a text file (at most 1 MB). Each data set in the file stands for a particular set of jobs. A data set starts with the number n (n ≤ 10000) of jobs, followed by the list of required servers for each job, in the format: jobnumber: (nr_servers) s1 … snr_serversThe program prints the maximum number of jobs that can be processed.White spaces can occur freely in the input. The input data are correct and terminate with an end of file.",
    "output_description": "For each set of data the program prints the result to the standard output from the beginning of a line. An input/output sample is in the table bellow.",
    "examples": [
      {
        "input": "2\r\n0: (1) 2\r\n1: (1) 2\r\n1\r\n0: (1) 1",
        "output": "1\r\n1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/3736",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "3830",
    "step_title": "유니온 파인드 2",
    "title": "교수님은 기다리지 않는다",
    "level": 18,
    "tags": [
      "자료 구조",
      "분리 집합"
    ],
    "description": "상근이는 매일 아침 실험실로 출근해서 샘플의 무게를 재는 일을 하고 있다. 상근이는 두 샘플을 고른 뒤, 저울을 이용해서 무게의 차이를 잰다.교수님의 마음에 들기 위해서 매일 아침부터 무게를 재고 있지만, 가끔 교수님이 실험실에 들어와서 상근이에게 어떤 두 샘플의 무게의 차이를 물어보기도 한다. 이때, 상근이는 지금까지 잰 결과를 바탕으로 대답을 할 수도 있고, 못 할 수도 있다.상근이는 결과를 출근한 첫 날부터 공책에 적어 두었다. 하지만, 엄청난 양의 무게가 적혀있기 때문에, 교수님의 질문에 재빨리 대답할 수가 없었다. 이런 상근이를 위해서 프로그램을 만들려고 한다.상근이가 실험실에서 한 일이 순서대로 주어진다. 어떤 두 샘플의 무게의 차이를 구할 수 있는지 없는지를 알아내는 프로그램을 작성하시오.",
    "input_description": "입력은 여러 개의 테스트 케이스로 이루어져 있다.각 테스트 케이스의 첫째 줄에는 샘플의 종류의 개수 N (2 ≤ N ≤ 100,000)과 상근이가 실험실에서 한 일의 수 M (1 ≤ M ≤ 100,000)이 주어진다. 샘플은 1번부터 N번까지 번호가 매겨져 있다. 다음 M개 줄에는 상근이가 실험실에서 한 일이 주어진다.상근이가 무게를 쟀다면, ! a b w와 같은 형식으로 주어진다. 이 뜻은 b가 a보다 w그램 무겁다는 뜻이다. (a ≠ b) w는 1,000,000을 넘지 않는 음이 아닌 정수이다. 모든 측정은 정확하고, 일관성을 유지한다.교수님의 질문은 ? a b와 같은 형식으로 주어진다. 이 뜻은 b가 a보다 얼마나 무거운지를 출력하라는 뜻이다.마지막 줄에는 0이 두 개 주어진다.",
    "output_description": "교수님의 질문 (? a b)이 입력으로 들어올 때 마다, 지금까지 측정한 결과를 바탕으로 a와 b의 무게 차이를 계산할 수 있다면, b가 a보다 얼마나 무거운지를 출력한다. 무게의 차이의 절댓값이 1,000,000을 넘지 않는다. 만약, 측정한 결과를 바탕으로 무게의 차이를 계산할 수 없다면, \"UNKNOWN\"을 출력한다.",
    "examples": [
      {
        "input": "2 2\r\n! 1 2 1\r\n? 1 2\r\n2 2\r\n! 1 2 1\r\n? 2 1\r\n4 7\r\n! 1 2 100\r\n? 2 3\r\n! 2 3 100\r\n? 2 3\r\n? 1 3\r\n! 4 3 150\r\n? 4 1\r\n0 0",
        "output": "1\r\n-1\r\nUNKNOWN\r\n100\r\n200\r\n-50"
      }
    ],
    "url": "https://www.acmicpc.net/problem/3830",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "3878",
    "step_title": "기하 3",
    "title": "점 분리",
    "level": 19,
    "tags": [
      "기하학",
      "볼록 껍질",
      "선분 교차 판정",
      "볼록 다각형 내부의 점 판정"
    ],
    "description": "평면 위에 여러 개의 검정 점과 흰 점이 있다. 이때, 길이가 무한대인 직선을 그어 흰 점과 검은 점을 분리하려고 한다. 직선은 어떤 점과도 만나면 안 된다. 직선으로 인해서 나누어지는 두 그룹 중 한 그룹에는 흰 점만 있어야 하고, 다른 그룹에는 검은 점만 있어야 한다.아래 그림에서 제일 왼쪽 예제는 점선으로 표시된 직선으로 두 점을 나눌 수 있다. 하지만 나머지 예제는 직선으로 점을 분리할 수 없다.흰 점과 검은 점의 좌표가 주어졌을 때, 직선으로 점을 분리할 수 있는지 없는지를 알아내는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에는 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에 검정 점의 개수 n과 흰 점의 개수 m이 공백으로 구분되어 주어진다. n과 m은 100보다 작거나 같다. 다음 줄부터 n개의 줄에는 검정 점의 좌표가 공백으로 구분되어 주어진다. 그 다음 m개의 줄에는 흰 점의 좌표가 주어진다.모든 점의 x, y좌표는 0보다 크거나 같고, 10000보다 작거나 같은 정수이다. 또한, 같은 위치에 점이 2개 이상 있는 경우는 없다.",
    "output_description": "각각의 테스트 케이스에 대해서, 점을 문제의 설명대로 분리할 수 있으면 YES를, 아니면 NO를 출력한다.",
    "examples": [
      {
        "input": "10\n3 3\n100 700\n200 200\n600 600\n500 100\n500 300\n800 500\n3 3\n100 300\n400 600\n400 100\n600 400\n500 900\n300 300\n3 4\n300 300\n500 300\n400 600\n100 100\n200 900\n500 900\n800 100\n1 2\n300 300\n100 100\n500 500\n1 1\n100 100\n200 100\n2 2\n0 0\n500 700\n1000 1400\n1500 2100\n2 2\n0 0\n1000 1000\n1000 0\n0 1000\n3 3\n0 100\n4999 102\n10000 103\n5001 102\n10000 102\n0 101\n3 3\n100 100\n200 100\n100 200\n0 0\n400 0\n0 400\n3 3\n2813 1640\n2583 2892\n2967 1916\n541 3562\n9298 3686\n7443 7921",
        "output": "YES\nNO\nNO\nNO\nYES\nYES\nNO\nNO\nNO\nYES"
      }
    ],
    "url": "https://www.acmicpc.net/problem/3878",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "3955",
    "step_title": "수학 2",
    "title": "캔디 분배",
    "level": 16,
    "tags": [
      "수학",
      "정수론",
      "확장 유클리드 호제법"
    ],
    "description": "창영이는 선영이가 사탕을 공평하게 나누어주지 않으면 친구들을 때릴정도로 사탕을 좋아한다.따라서, 선영이는 다음 파티에 사용할 사탕을 구매하기 전에 고민을 하기 시작했다.만약 파티에 K명이 참가한다면, 공정하게 나누어주려면 K×X개를 사야 한다. (X는 자연수)선영이는 항상 적어도 한 아이는 사탕을 잃어버린다는 사실을 알고 있다. 그래서 캔디를 하나 더 구매해 총 (K×X+1)개를 구매하려고 한다.사탕은 봉지 단위로 판매한다. 한 봉지에는 사탕이 총 C개 들어있다. 문제의 조건을 만족하면서 구매할 수 있는 사탕 봉지의 개수를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 테스트 케이스의 개수 t가 주어진다. (0 < t < 100) 각 테스트 케이스는 한 줄로 이루어져 있고, K와 C가 공백으로 구분되어져서 주어진다. (1 ≤ K, C ≤ 109) 선영이는 부자가 아니기 때문에 109개를 넘는 사탕 봉지를 구매하지 못한다.",
    "output_description": "각 테스트 케이스에 대해서 문제의 조건을 만족시키면서 구매할 수 있는 사탕 봉지가 없다면, \"IMPOSSIBLE\"을 출력한다. 이 경우가 아닌 경우에는 선영이가 구매해야 하는 사탕 봉지의 수를 출력한다. 만약, 가능한 봉지의 수가 여러개라면 아무거나 출력한다.",
    "examples": [
      {
        "input": "5\r\n10 5\r\n10 7\r\n1337 23\r\n123454321 42\r\n999999937 142857133",
        "output": "IMPOSSIBLE\r\n3\r\n872\r\n14696943\r\n166666655"
      }
    ],
    "url": "https://www.acmicpc.net/problem/3955",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 수학 문제 기본 구조\ndef solve():\n    # 입력 처리\n    N = int(input())\n    \n    # 계산\n    result = N\n    \n    return result\n\nprint(solve())",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "3977",
    "step_title": "강한 연결 요소",
    "title": "축구 전술",
    "level": 17,
    "tags": [
      "그래프 이론",
      "강한 연결 요소"
    ],
    "description": "World Soccer Championship이 다가오고 있다! 천재적인 전술을 창조하는 플랜 아티스트 감독 도현이는 자신의 팀이 승리하도록 만반의 준비를 가하고 있다. 도현이의 전략은 경기장을 여러 개의 구역으로 나누고, 어떤 선수가 A구역에서 B구역으로 이동하게 하는 움직임을 (A, B)로 표현한다. 모든 도현이의 팀 선수들이 이 움직임만을 따라서 이동한다면 승리하리라고 도현이는 확신한다.도현이는 선수들에게 자신의 전술을 말해주며, 다른 모든 구역에 도달할 수 있는 시작 구역을 찾은 뒤 지시한 움직임만을 따라가라고 했다. 그러나 도현이는 한 가지 간과한 것이 있었는데 그건 선수들이 자신만큼 똑똑하지 않다는 것이다. 선수들은 그러한 시작 구역을 찾는 것이 어려웠다. 이제 당신이 적절한 시작 구역을 찾아줘야 한다.",
    "input_description": "첫 번째 줄에 테스트 케이스의 개수가 주어지며, 이는 11보다 작거나 같은 정수이다.그 다음 줄부터 여러 개의 테스트 케이스가 주어지는데, 각 테스트 케이스마다 첫 번째 줄에 구역의 수 N, 지시한 움직임의 수 M이 주어지며 1 ≤ N, M ≤ 100,000 이다. 그 다음 M개의 줄에 걸쳐서 움직임 (A, B)가 주어지며, A, B는 0 ≤ A, B < N인 정수이다.각 테스트 케이스는 하나의 빈 줄로 구분된다.",
    "output_description": "각 테스트 케이스마다 가능한 모든 시작 구역을 오름차순으로 한 줄에 하나씩 출력한다. 만약 그러한 시작 구역이 없으면, \"Confused\"를 출력한다.각 테스트 케이스의 끝에는 하나의 빈 줄을 출력한다.",
    "examples": [
      {
        "input": "2\r\n4 4\r\n0 1\r\n1 2\r\n2 0\r\n2 3\r\n\r\n4 4\r\n0 3\r\n1 0\r\n2 0\r\n2 3",
        "output": "0\r\n1\r\n2\r\n\r\nConfused"
      }
    ],
    "url": "https://www.acmicpc.net/problem/3977",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\ndef dfs1(v):\n    visited[v] = True\n    for next_v in graph[v]:\n        if not visited[next_v]:\n            dfs1(next_v)\n    stack.append(v)\n\ndef dfs2(v, scc_num):\n    scc_id[v] = scc_num\n    for next_v in reverse_graph[v]:\n        if scc_id[next_v] == -1:\n            dfs2(next_v, scc_num)\n\nV, E = map(int, input().split())\ngraph = [[] for _ in range(V + 1)]\nreverse_graph = [[] for _ in range(V + 1)]\n\nfor _ in range(E):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    reverse_graph[b].append(a)\n\nvisited = [False] * (V + 1)\nstack = []\n\nfor i in range(1, V + 1):\n    if not visited[i]:\n        dfs1(i)\n\nscc_id = [-1] * (V + 1)\nscc_num = 0\n\nwhile stack:\n    v = stack.pop()\n    if scc_id[v] == -1:\n        dfs2(v, scc_num)\n        scc_num += 1\n\nprint(scc_num)\n\nscc_list = [[] for _ in range(scc_num)]\nfor i in range(1, V + 1):\n    scc_list[scc_id[i]].append(i)\n\nscc_list = [sorted(scc) for scc in scc_list if scc]\nscc_list.sort()\n\nfor scc in scc_list:\n    print(*scc, -1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "4008",
    "step_title": "동적 계획법 최적화 1",
    "title": "특공대",
    "level": 21,
    "tags": [
      "다이나믹 프로그래밍",
      "볼록 껍질을 이용한 최적화"
    ],
    "description": "1부터 n까지 번호가 붙여진 n명의 병사들로 이루어진 군대의 지휘관이 있다. 이 지휘관은 앞으로의 전투를 위하여 n명의 병사들을 여러 개의 특공대로 나누고자 한다. 결속력과 사기를 높이기 위하여 각 특공대는 {i, i+1, ..., i+k}형태의 번호가 연속하는 병사들로 구성된다.각 병사 i의 전투력은 xi이다. 병사들 {i, i+1, ..., i+k}로 구성된 특공대의 전투력 x는 원래는 각 병사의 전투력의 합으로 계산되었다. 달리 말하면 x = xi+ xi+1+ ... + xk이었다.그러나 여러 해의 영광스러운 승리를 통하여 특공대의 전투력을 다음과 같이 조정해야 하는 것으로 결론을 내렸다: 특공대의 조정된 전투력 x′는 등식 x′ = ax2+ bx + c로 계산한다. 여기서 a, b, c는 알려져 있는 계수들로서 a<0이고, x는 특공대의 원래 정의된 전투력이다.여러분이 할 일은 모든 특공대의 조정된 전투력의 합을 최대화하도록 병사들을 특공대로 나누는 것이다.예를 들어, 4명의 병사들이 있고, 각 병사의 전투력 x1= 2, x2= 2, x3= 3, x4= 4라 하자. 특공대의 조정된 전투력 등식에 있는 계수가 a=-1, b=10, c=-20이라 하자. 이러한 경우, 최적인 해는 병사들을 다음과 같이 세 개의 특공대로 나누는 것이다: 첫 번째 특공대는 병사 1과 2로 구성하고, 두 번째 특공대는 병사 3으로 구성하고, 세 번째 특공대는 병사 4로 구성한다. 이들 세 특공대의 원래의 전투력은 각각 4, 3, 4이고 조정된 전투력은 각각 4, 1, 4이다. 이렇게 나눌 때 조정된 전체 전투력은 각 특공대의 조정된 전투력의 합인 9이며, 이보다 더 좋은 해가 없음을 알 수 있다.",
    "input_description": "입력은 세 줄로 구성된다. 첫 번째 줄에 전체 병사들 수인 양의 정수 n이 주어진다. 두 번째 줄에 특공대의 조정된 전투력 계산 등식의 계수인 세 정수 a, b, c가 주어진다. 마지막 줄에 병사들 1, 2, ..., n의 전투력을 나타내는 n개의 정수 x1, x2, ..., xn이 공백을 사이에 두고 주어진다.n ≤ 1,000,000, -5 ≤ a ≤ -1, |b| ≤ 10,000,000, |c| ≤ 30,000,000, 1 ≤ xi≤ 100",
    "output_description": "얻을 수 있는 최대의 조정된 전체 전투력을 나타내는 하나의 정수를 한 줄에 출력한다.",
    "examples": [
      {
        "input": "4\n-1 10 -20\n2 2 3 4",
        "output": "9"
      }
    ],
    "url": "https://www.acmicpc.net/problem/4008",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "4013",
    "step_title": "강한 연결 요소",
    "title": "ATM",
    "level": 19,
    "tags": [
      "다이나믹 프로그래밍",
      "그래프 이론",
      "방향 비순환 그래프",
      "위상 정렬",
      "강한 연결 요소"
    ],
    "description": "인도의 도시 중 하나인 시루세리에는 모든 도로들이 일방통행으로 되어 있다. 도로들이 만나는 모든 교차로에는 시루세리 은행의 현금입출금기(ATM)가 설치되어 있다. 시루세리에는 유명한 레스토랑 체인인 아웃백 커리 하우스가 있다. 이 레스토랑의 각 체인점들은 교차로에만 위치한다. 물론 각 교차로마다 항상 이 레스토랑 체인점이 있는 것은 아니다. 이 레스토랑은 현금만 사용할 수 있다.시루세리에 사는 반디치는 오늘 오후에 이 레스토랑에서 가족들과 파티를 열려고 한다. 그런데 갖고 있는 현금이 부족하여 레스토랑으로 가는 동안에 가능한 한 많은 현금을 ATM 기기로부터 인출할 계획을 세웠다. 그는 자신의 집에서 출발하여 차로 이동하면서 통과하는 모든 교차로 ATM 기기에 들어있는 현금 전부를 인출하려고 한다. 차량의 최종 목적지는 아웃백 커리 하우스 체인점 중의 한 곳이고, 이 체인점이 어떤 교차로에 위치하는지는 상관없다.반디치는 시루세리 은행의 홈페이지 정보를 통해 각 ATM 기기에 현금이 얼마나 들어 있는지를 알고 있다. 이동 시 동일한 도로나 교차로를 여러 번 지날 수 있다. ATM 기기의 현금은 새로 보충되지 않기 때문에 첫 번째 이후 다시 방문하는 교차로의 ATM 기기에는 인출할 현금이 없다.예를 들어, 아래 그림처럼 도시에 6개의 교차로가 있다고 하자. 교차로는 원으로 표시되어 있고, 화살표는 도로를 나타낸다. 이중 원으로 표시된 교차로에는 레스토랑이 있다. 각 ATM 기기가 갖고 있는 현금의 액수는 교차로 위에 표시된 숫자이다. 이 예에서 현금 인출을 1번 교차로부터 시작한다면, 반디치는 1-2-4-1-2-3-5의 경로를 통해서 총 47의 현금을 인출할 수 있다.반디치가 출발 장소에서 어떤 레스토랑까지 이동하면서 인출할 수 있는 현금의 최대 액수가 얼마인지를 계산하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 교차로의 수와 도로의 수를 나타내는 2개의 정수 N과 M(N, M ≤ 500,000)이 차례로 주어진다. 교차로는 1부터 N까지 번호로 표시된다. 그 다음 M개의 줄에는 각 줄마다 각 도로의 시작 교차로 번호와 끝 교차로 번호를 나타내는 2개의 정수가 주어진다. 그 다음 N개의 줄에는 1번 교차로부터 차례대로 각 교차로의 ATM 기기가 보유한 현금의 액수를 나타내는 정수가 각 줄에 하나씩 주어진다. 그 다음 줄에는 두 개의 정수 S와 P가 주어진다. 여기서 S는 출발 장소(현금 인출의 시작 장소)인 교차로 번호이고 P는 레스토랑의 개수이다(1 ≤ P ≤ N). 그 다음 줄에는 각 레스토랑이 있는 교차로의 번호를 나열한 P개의 정수가 주어진다.각 ATM 기기에 들어 있는 현금의 액수는 0 이상 4,000 이하이다. 모든 입력에서 경로의 출발 장소로부터 일방통행 도로를 통해 도달 가능한 레스토랑이 항상 하나 이상 존재한다.",
    "output_description": "출력은 한 개의 정수이다. 이 정수는 반디치가 출발 장소에서 어떤 레스토랑까지 이동하면서 인출할 수 있는 현금의 최대 액수이다.",
    "examples": [
      {
        "input": "6 7\n1 2\n2 3\n3 5\n2 4\n4 1\n2 6\n6 5\n10\n12\n8\n16\n1\n5\n1 4\n4 3 5 6",
        "output": "47"
      }
    ],
    "url": "https://www.acmicpc.net/problem/4013",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\ndef dfs1(v):\n    visited[v] = True\n    for next_v in graph[v]:\n        if not visited[next_v]:\n            dfs1(next_v)\n    stack.append(v)\n\ndef dfs2(v, scc_num):\n    scc_id[v] = scc_num\n    for next_v in reverse_graph[v]:\n        if scc_id[next_v] == -1:\n            dfs2(next_v, scc_num)\n\nV, E = map(int, input().split())\ngraph = [[] for _ in range(V + 1)]\nreverse_graph = [[] for _ in range(V + 1)]\n\nfor _ in range(E):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    reverse_graph[b].append(a)\n\nvisited = [False] * (V + 1)\nstack = []\n\nfor i in range(1, V + 1):\n    if not visited[i]:\n        dfs1(i)\n\nscc_id = [-1] * (V + 1)\nscc_num = 0\n\nwhile stack:\n    v = stack.pop()\n    if scc_id[v] == -1:\n        dfs2(v, scc_num)\n        scc_num += 1\n\nprint(scc_num)\n\nscc_list = [[] for _ in range(scc_num)]\nfor i in range(1, V + 1):\n    scc_list[scc_id[i]].append(i)\n\nscc_list = [sorted(scc) for scc in scc_list if scc]\nscc_list.sort()\n\nfor scc in scc_list:\n    print(*scc, -1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "4134",
    "step_title": "약수, 배수와 소수 2",
    "title": "다음 소수",
    "level": 7,
    "tags": [
      "수학",
      "브루트포스 알고리즘",
      "정수론",
      "소수 판정"
    ],
    "description": "정수 n(0 ≤ n ≤ 4*109)가 주어졌을 때, n보다 크거나 같은 소수 중 가장 작은 소수 찾는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다.",
    "output_description": "각각의 테스트 케이스에 대해서 n보다 크거나 같은 소수 중 가장 작은 소수를 한 줄에 하나씩 출력한다.",
    "examples": [
      {
        "input": "3\r\n6\r\n20\r\n100",
        "output": "7\r\n23\r\n101"
      }
    ],
    "url": "https://www.acmicpc.net/problem/4134",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def is_prime(n):\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    while not is_prime(n):\n        n += 1\n    print(n)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "4149",
    "step_title": "수학 3",
    "title": "큰 수 소인수분해",
    "level": 20,
    "tags": [
      "밀러–라빈 소수 판별법",
      "폴라드 로",
      "정수론",
      "수학",
      "소수 판정",
      "소인수분해"
    ],
    "description": "큰 수를 소인수분해 해보자.",
    "input_description": "입력은 한 줄로 이루어져 있고, 소인수분해 해야 하는 수가 주어진다. 이 수는 1보다 크고, 262보다 작다.",
    "output_description": "입력으로 주어진 양의 정수를 소인수분해 한 뒤, 모든 인수를 한 줄에 하나씩 증가하는 순서로 출력한다.",
    "examples": [
      {
        "input": "18991325453139",
        "output": "3\n3\n13\n179\n271\n1381\n2423"
      }
    ],
    "url": "https://www.acmicpc.net/problem/4149",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 수학 문제 기본 구조\ndef solve():\n    # 입력 처리\n    N = int(input())\n    \n    # 계산\n    result = N\n    \n    return result\n\nprint(solve())",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "4195",
    "step_title": "유니온 파인드 1",
    "title": "친구 네트워크",
    "level": 14,
    "tags": [
      "자료 구조",
      "집합과 맵",
      "해시를 사용한 집합과 맵",
      "분리 집합"
    ],
    "description": "민혁이는 소셜 네트워크 사이트에서 친구를 만드는 것을 좋아하는 친구이다. 우표를 모으는 취미가 있듯이, 민혁이는 소셜 네트워크 사이트에서 친구를 모으는 것이 취미이다.어떤 사이트의 친구 관계가 생긴 순서대로 주어졌을 때, 두 사람의 친구 네트워크에 몇 명이 있는지 구하는 프로그램을 작성하시오.친구 네트워크란 친구 관계만으로 이동할 수 있는 사이를 말한다.",
    "input_description": "첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스의 첫째 줄에는 친구 관계의 수 F가 주어지며, 이 값은 100,000을 넘지 않는다. 다음 F개의 줄에는 친구 관계가 생긴 순서대로 주어진다. 친구 관계는 두 사용자의 아이디로 이루어져 있으며, 알파벳 대문자 또는 소문자로만 이루어진 길이 20 이하의 문자열이다.",
    "output_description": "친구 관계가 생길 때마다, 두 사람의 친구 네트워크에 몇 명이 있는지 구하는 프로그램을 작성하시오.",
    "examples": [
      {
        "input": "2\r\n3\r\nFred Barney\r\nBarney Betty\r\nBetty Wilma\r\n3\r\nFred Barney\r\nBetty Wilma\r\nBarney Betty",
        "output": "2\r\n3\r\n4\r\n2\r\n2\r\n4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/4195",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def find(x):\n    if parent[x] != x:\n        parent[x] = find(parent[x])\n    return parent[x]\n\ndef union(x, y):\n    x = find(x)\n    y = find(y)\n    if x != y:\n        parent[y] = x\n        size[x] += size[y]\n    return size[x]\n\nT = int(input())\nfor _ in range(T):\n    F = int(input())\n    parent = {}\n    size = {}\n    \n    for _ in range(F):\n        a, b = input().split()\n        \n        if a not in parent:\n            parent[a] = a\n            size[a] = 1\n        if b not in parent:\n            parent[b] = b\n            size[b] = 1\n        \n        print(union(a, b))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "4196",
    "step_title": "강한 연결 요소",
    "title": "도미노",
    "level": 17,
    "tags": [
      "그래프 이론",
      "방향 비순환 그래프",
      "위상 정렬",
      "강한 연결 요소"
    ],
    "description": "도미노는 재밌다. 도미노 블록을 일렬로 길게 늘어세운 뒤 블록 하나를 넘어뜨리면 그 블록이 넘어지며 다음 블록을 넘어뜨리는 일이 반복되어 일렬로 늘어선 블록들을 연쇄적으로 모두 쓰러뜨릴 수 있다. 그러나, 가끔씩 도미노가 다른 블록을 넘어뜨리지 못하게 배치되어 있다면, 우리는 다음 블록을 수동으로 넘어뜨려야 한다.이제 각 도미노 블록의 배치가 주어졌을 때, 모든 블록을 넘어뜨리기 위해 손으로 넘어뜨려야 하는 블록 개수의 최솟값을 구하자.",
    "input_description": "첫 번째 줄에 테스트 케이스의 개수가 주어진다.각 테스트 케이스의 첫 번째 줄에는 두 정수 N, M이 주어지며 두 수는 100,000을 넘지 않는다. N은 도미노의 개수를, M은 관계의 개수를 나타낸다. 도미노 블록의 번호는 1과 N 사이의 정수다. 다음 M개의 줄에는 각각 두 정수 x, y가 주어지는데, 이는 x번 블록이 넘어지면 y번 블록도 넘어짐을 뜻한다.",
    "output_description": "각 테스트 케이스마다 한 줄에 정수 하나를 출력한다. 정답은 손으로 넘어뜨려야 하는 최소의 도미노 블록 개수이다.",
    "examples": [
      {
        "input": "1\r\n3 2\r\n1 2\r\n2 3",
        "output": "1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/4196",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\ndef dfs1(v):\n    visited[v] = True\n    for next_v in graph[v]:\n        if not visited[next_v]:\n            dfs1(next_v)\n    stack.append(v)\n\ndef dfs2(v, scc_num):\n    scc_id[v] = scc_num\n    for next_v in reverse_graph[v]:\n        if scc_id[next_v] == -1:\n            dfs2(next_v, scc_num)\n\nV, E = map(int, input().split())\ngraph = [[] for _ in range(V + 1)]\nreverse_graph = [[] for _ in range(V + 1)]\n\nfor _ in range(E):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    reverse_graph[b].append(a)\n\nvisited = [False] * (V + 1)\nstack = []\n\nfor i in range(1, V + 1):\n    if not visited[i]:\n        dfs1(i)\n\nscc_id = [-1] * (V + 1)\nscc_num = 0\n\nwhile stack:\n    v = stack.pop()\n    if scc_id[v] == -1:\n        dfs2(v, scc_num)\n        scc_num += 1\n\nprint(scc_num)\n\nscc_list = [[] for _ in range(scc_num)]\nfor i in range(1, V + 1):\n    scc_list[scc_id[i]].append(i)\n\nscc_list = [sorted(scc) for scc in scc_list if scc]\nscc_list.sort()\n\nfor scc in scc_list:\n    print(*scc, -1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "4386",
    "step_title": "최소 신장 트리",
    "title": "별자리 만들기",
    "level": 13,
    "tags": [
      "그래프 이론",
      "최소 스패닝 트리"
    ],
    "description": "도현이는 우주의 신이다. 이제 도현이는 아무렇게나 널브러져 있는 n개의 별들을 이어서 별자리를 하나 만들 것이다. 별자리의 조건은 다음과 같다.별자리를 이루는 선은 서로 다른 두 별을 일직선으로 이은 형태이다.모든 별들은 별자리 위의 선을 통해 서로 직/간접적으로 이어져 있어야 한다.별들이 2차원 평면 위에 놓여 있다. 선을 하나 이을 때마다 두 별 사이의 거리만큼의 비용이 든다고 할 때, 별자리를 만드는 최소 비용을 구하시오.",
    "input_description": "첫째 줄에 별의 개수 n이 주어진다. (1 ≤ n ≤ 100)둘째 줄부터 n개의 줄에 걸쳐 각 별의 x, y좌표가 실수 형태로 주어지며, 최대 소수점 둘째자리까지 주어진다. 좌표는 1000을 넘지 않는 양의 실수이다.",
    "output_description": "첫째 줄에 정답을 출력한다. 절대/상대 오차는 10-2까지 허용한다.",
    "examples": [
      {
        "input": "3\r\n1.0 1.0\r\n2.0 2.0\r\n2.0 4.0",
        "output": "3.41"
      }
    ],
    "url": "https://www.acmicpc.net/problem/4386",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import math\n\ndef find(x):\n    if parent[x] != x:\n        parent[x] = find(parent[x])\n    return parent[x]\n\ndef union(x, y):\n    x = find(x)\n    y = find(y)\n    if x != y:\n        parent[y] = x\n        return True\n    return False\n\nn = int(input())\nstars = []\nfor _ in range(n):\n    x, y = map(float, input().split())\n    stars.append((x, y))\n\nedges = []\nfor i in range(n):\n    for j in range(i + 1, n):\n        dist = math.sqrt((stars[i][0] - stars[j][0])**2 + (stars[i][1] - stars[j][1])**2)\n        edges.append((dist, i, j))\n\nedges.sort()\nparent = list(range(n))\n\ntotal = 0\nfor dist, a, b in edges:\n    if union(a, b):\n        total += dist\n\nprint(f\"{total:.2f}\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "4779",
    "step_title": "재귀",
    "title": "칸토어 집합",
    "level": 8,
    "tags": [
      "분할 정복",
      "재귀"
    ],
    "description": "칸토어 집합은 0과 1사이의 실수로 이루어진 집합으로, 구간 [0, 1]에서 시작해서 각 구간을 3등분하여 가운데 구간을 반복적으로 제외하는 방식으로 만든다.전체 집합이 유한이라고 가정하고, 다음과 같은 과정을 통해서 칸토어 집합의 근사를 만들어보자.1. -가 3N개 있는 문자열에서 시작한다.2. 문자열을 3등분 한 뒤, 가운데 문자열을 공백으로 바꾼다. 이렇게 하면, 선(문자열) 2개가 남는다.3. 이제 각 선(문자열)을 3등분 하고, 가운데 문자열을 공백으로 바꾼다. 이 과정은 모든 선의 길이가 1일때 까지 계속 한다.예를 들어, N=3인 경우, 길이가 27인 문자열로 시작한다.---------------------------여기서 가운데 문자열을 공백으로 바꾼다.---------         ---------남은 두 선의 가운데 문자열을 공백으로 바꾼다.---   ---         ---   ---한번 더- -   - -         - -   - -모든 선의 길이가 1이면 멈춘다. N이 주어졌을 때, 마지막 과정이 끝난 후 결과를 출력하는 프로그램을 작성하시오.",
    "input_description": "입력을 여러 줄로 이루어져 있다. 각 줄에 N이 주어진다. 파일의 끝에서 입력을 멈춘다. N은 0보다 크거나 같고, 12보다 작거나 같은 정수이다.",
    "output_description": "입력으로 주어진 N에 대해서, 해당하는 칸토어 집합의 근사를 출력한다.",
    "examples": [
      {
        "input": "0\r\n1\r\n3\r\n2",
        "output": "-\r\n- -\r\n- -   - -         - -   - -\r\n- -   - -"
      }
    ],
    "url": "https://www.acmicpc.net/problem/4779",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def cantor(n, start):\n    if n == 0:\n        return\n    \n    length = 3 ** (n - 1)\n    for i in range(start + length, start + 2 * length):\n        result[i] = ' '\n    \n    cantor(n - 1, start)\n    cantor(n - 1, start + 2 * length)\n\nimport sys\ninput = sys.stdin.readline\n\nfor line in sys.stdin:\n    N = int(line.strip())\n    length = 3 ** N\n    result = ['-'] * length\n    cantor(N, 0)\n    print(''.join(result))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "4803",
    "step_title": "트리",
    "title": "트리",
    "level": 12,
    "tags": [
      "그래프 이론",
      "자료 구조",
      "그래프 탐색",
      "트리",
      "깊이 우선 탐색",
      "분리 집합"
    ],
    "description": "그래프는 정점과 간선으로 이루어져 있다. 두 정점 사이에 경로가 있다면, 두 정점은 연결되어 있다고 한다. 연결 요소는 모든 정점이 서로 연결되어 있는 정점의 부분집합이다. 그래프는 하나 또는 그 이상의 연결 요소로 이루어져 있다.트리는 사이클이 없는 연결 요소이다. 트리에는 여러 성질이 있다. 예를 들어, 트리는 정점이 n개, 간선이 n-1개 있다. 또, 임의의 두 정점에 대해서 경로가 유일하다.그래프가 주어졌을 때, 트리의 개수를 세는 프로그램을 작성하시오.",
    "input_description": "입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 n ≤ 500과 m ≤ n(n-1)/2을 만족하는 정점의 개수 n과 간선의 개수 m이 주어진다. 다음 m개의 줄에는 간선을 나타내는 두 개의 정수가 주어진다. 같은 간선은 여러 번 주어지지 않는다. 정점은 1번부터 n번까지 번호가 매겨져 있다. 입력의 마지막 줄에는 0이 두 개 주어진다.",
    "output_description": "입력으로 주어진 그래프에 트리가 없다면 \"No trees.\"를, 한 개라면 \"There is one tree.\"를, T개(T > 1)라면 \"A forest of T trees.\"를 테스트 케이스 번호와 함께 출력한다.",
    "examples": [
      {
        "input": "6 3\r\n1 2\r\n2 3\r\n3 4\r\n6 5\r\n1 2\r\n2 3\r\n3 4\r\n4 5\r\n5 6\r\n6 6\r\n1 2\r\n2 3\r\n1 3\r\n4 5\r\n5 6\r\n6 4\r\n0 0",
        "output": "Case 1: A forest of 3 trees.\r\nCase 2: There is one tree.\r\nCase 3: No trees."
      }
    ],
    "url": "https://www.acmicpc.net/problem/4803",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def find(x):\n    if parent[x] != x:\n        parent[x] = find(parent[x])\n    return parent[x]\n\ndef union(x, y):\n    x = find(x)\n    y = find(y)\n    \n    if x == y:\n        has_cycle[x] = True\n        return False\n    \n    if has_cycle[x] or has_cycle[y]:\n        has_cycle[x] = has_cycle[y] = True\n    \n    parent[y] = x\n    return True\n\ncase = 1\nwhile True:\n    n, m = map(int, input().split())\n    if n == 0 and m == 0:\n        break\n    \n    parent = list(range(n + 1))\n    has_cycle = [False] * (n + 1)\n    \n    for _ in range(m):\n        a, b = map(int, input().split())\n        union(a, b)\n    \n    trees = set()\n    for i in range(1, n + 1):\n        root = find(i)\n        if not has_cycle[root]:\n            trees.add(root)\n    \n    count = len(trees)\n    if count == 0:\n        print(f\"Case {case}: No trees.\")\n    elif count == 1:\n        print(f\"Case {case}: There is one tree.\")\n    else:\n        print(f\"Case {case}: A forest of {count} trees.\")\n    \n    case += 1",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "4948",
    "step_title": "약수, 배수와 소수 2",
    "title": "베르트랑 공준",
    "level": 9,
    "tags": [
      "수학",
      "정수론",
      "소수 판정",
      "에라토스테네스의 체"
    ],
    "description": "베르트랑 공준은 임의의 자연수 n에 대하여, n보다 크고, 2n보다 작거나 같은 소수는 적어도 하나 존재한다는 내용을 담고 있다.이 명제는 조제프 베르트랑이 1845년에 추측했고, 파프누티 체비쇼프가 1850년에 증명했다.예를 들어, 10보다 크고, 20보다 작거나 같은 소수는 4개가 있다. (11, 13, 17, 19) 또, 14보다 크고, 28보다 작거나 같은 소수는 3개가 있다. (17,19, 23)자연수 n이 주어졌을 때, n보다 크고, 2n보다 작거나 같은 소수의 개수를 구하는 프로그램을 작성하시오.",
    "input_description": "입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 케이스는 n을 포함하는 한 줄로 이루어져 있다.입력의 마지막에는 0이 주어진다.",
    "output_description": "각 테스트 케이스에 대해서, n보다 크고, 2n보다 작거나 같은 소수의 개수를 출력한다.",
    "examples": [
      {
        "input": "1\n10\n13\n100\n1000\n10000\n100000\n0",
        "output": "1\n4\n3\n21\n135\n1033\n8392"
      }
    ],
    "url": "https://www.acmicpc.net/problem/4948",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def sieve(n):\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n + 1, i):\n                is_prime[j] = False\n    \n    return is_prime\n\nis_prime = sieve(246912)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    count = sum(1 for i in range(n + 1, 2 * n + 1) if is_prime[i])\n    print(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "4949",
    "step_title": "스택, 큐, 덱 1",
    "title": "균형잡힌 세상",
    "level": 7,
    "tags": [
      "자료 구조",
      "문자열",
      "스택"
    ],
    "description": "세계는 균형이 잘 잡혀있어야 한다. 양과 음, 빛과 어둠 그리고 왼쪽 괄호와 오른쪽 괄호처럼 말이다.정민이의 임무는 어떤 문자열이 주어졌을 때, 괄호들의 균형이 잘 맞춰져 있는지 판단하는 프로그램을 짜는 것이다.문자열에 포함되는 괄호는 소괄호(\"()\") 와 대괄호(\"[]\")로 2종류이고, 문자열이 균형을 이루는 조건은 아래와 같다.모든 왼쪽 소괄호(\"(\")는 오른쪽 소괄호(\")\")와만 짝을 이뤄야 한다.모든 왼쪽 대괄호(\"[\")는 오른쪽 대괄호(\"]\")와만 짝을 이뤄야 한다.모든 오른쪽 괄호들은 자신과 짝을 이룰 수 있는 왼쪽 괄호가 존재한다.모든 괄호들의 짝은 1:1 매칭만 가능하다. 즉, 괄호 하나가 둘 이상의 괄호와 짝지어지지 않는다.짝을 이루는 두 괄호가 있을 때, 그 사이에 있는 문자열도 균형이 잡혀야 한다.정민이를 도와 문자열이 주어졌을 때 균형잡힌 문자열인지 아닌지를 판단해보자.",
    "input_description": "각 문자열은 마지막 글자를 제외하고 영문 알파벳, 공백, 소괄호(\"( )\"), 대괄호(\"[ ]\")로 이루어져 있으며, 온점(\".\")으로 끝나고, 길이는 100글자보다 작거나 같다.입력의 종료조건으로 맨 마지막에 온점 하나(\".\")가 들어온다.",
    "output_description": "각 줄마다 해당 문자열이 균형을 이루고 있으면 \"yes\"를, 아니면 \"no\"를 출력한다.",
    "examples": [
      {
        "input": "So when I die (the [first] I will see in (heaven) is a score list).\n[ first in ] ( first out ).\nHalf Moon tonight (At least it is better than no Moon at all].\nA rope may form )( a trail in a maze.\nHelp( I[m being held prisoner in a fortune cookie factory)].\n([ (([( [ ] ) ( ) (( ))] )) ]).\n .\n.",
        "output": "yes\nyes\nno\nno\nno\nyes\nyes"
      }
    ],
    "url": "https://www.acmicpc.net/problem/4949",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "while True:\n    s = input()\n    if s == '.':\n        break\n    \n    stack = []\n    valid = True\n    \n    for char in s:\n        if char in '([':\n            stack.append(char)\n        elif char == ')':\n            if stack and stack[-1] == '(':\n                stack.pop()\n            else:\n                valid = False\n                break\n        elif char == ']':\n            if stack and stack[-1] == '[':\n                stack.pop()\n            else:\n                valid = False\n                break\n    \n    if valid and not stack:\n        print(\"yes\")\n    else:\n        print(\"no\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "5073",
    "step_title": "기하 1: 직사각형과 삼각형",
    "title": "삼각형과 세 변",
    "level": 3,
    "tags": [
      "수학",
      "구현",
      "기하학"
    ],
    "description": "삼각형의 세 변의 길이가 주어질 때 변의 길이에 따라 다음과 같이 정의한다.Equilateral :  세 변의 길이가 모두 같은 경우Isosceles : 두 변의 길이만 같은 경우Scalene : 세 변의 길이가 모두 다른 경우단 주어진 세 변의 길이가 삼각형의 조건을 만족하지 못하는 경우에는 \"Invalid\" 를 출력한다. 예를 들어 6, 3, 2가 이 경우에 해당한다. 가장 긴 변의 길이보다 나머지 두 변의 길이의 합이 길지 않으면 삼각형의 조건을 만족하지 못한다.세 변의 길이가 주어질 때 위 정의에 따른 결과를 출력하시오.",
    "input_description": "각 줄에는 1,000을 넘지 않는 양의 정수 3개가 입력된다. 마지막 줄은 0 0 0이며 이 줄은 계산하지 않는다.",
    "output_description": "각 입력에 맞는 결과 (Equilateral, Isosceles, Scalene, Invalid) 를 출력하시오.",
    "examples": [
      {
        "input": "7 7 7\r\n6 5 4\r\n3 2 5\r\n6 2 6\r\n0 0 0",
        "output": "Equilateral\r\nScalene\r\nInvalid\r\nIsosceles"
      }
    ],
    "url": "https://www.acmicpc.net/problem/5073",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "while True:\n    sides = sorted(map(int, input().split()))\n    if sides == [0, 0, 0]:\n        break\n    if sides[0] + sides[1] <= sides[2]:\n        print(\"Invalid\")\n    elif sides[0] == sides[1] == sides[2]:\n        print(\"Equilateral\")\n    elif sides[0] == sides[1] or sides[1] == sides[2]:\n        print(\"Isosceles\")\n    else:\n        print(\"Scalene\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "여러 값 입력 받기",
            "description": "sides = sorted(map(int, input().split()))로 입력을 처리합니다.",
            "code_pattern": "sides = sorted(map(int, input().split()))",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "조건 판단",
            "description": "조건문을 사용하여 상황에 따라 다르게 처리합니다.",
            "code_pattern": "if sides == [0, 0, 0]:",
            "socratic_hint": "조건에 따라 다르게 처리하려면?",
            "hint": "if-else 문을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(\"Invalid\")",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "5086",
    "step_title": "약수, 배수와 소수 1",
    "title": "배수와 약수",
    "level": 3,
    "tags": [
      "수학",
      "사칙연산"
    ],
    "description": "4 × 3 = 12이다.이 식을 통해 다음과 같은 사실을 알 수 있다.3은 12의 약수이고, 12는 3의 배수이다.4도 12의 약수이고, 12는 4의 배수이다.두 수가 주어졌을 때, 다음 3가지 중 어떤 관계인지 구하는 프로그램을 작성하시오.첫 번째 숫자가 두 번째 숫자의 약수이다.첫 번째 숫자가 두 번째 숫자의 배수이다.첫 번째 숫자가 두 번째 숫자의 약수와 배수 모두 아니다.",
    "input_description": "입력은 여러 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 10,000이 넘지않는 두 자연수로 이루어져 있다. 마지막 줄에는 0이 2개 주어진다. 두 수가 같은 경우는 없다.",
    "output_description": "각 테스트 케이스마다 첫 번째 숫자가 두 번째 숫자의 약수라면 factor를, 배수라면 multiple을, 둘 다 아니라면 neither를 출력한다.",
    "examples": [
      {
        "input": "8 16\r\n32 4\r\n17 5\r\n0 0",
        "output": "factor\r\nmultiple\r\nneither"
      }
    ],
    "url": "https://www.acmicpc.net/problem/5086",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "while True:\n    a, b = map(int, input().split())\n    if a == 0 and b == 0:\n        break\n    if b % a == 0:\n        print(\"factor\")\n    elif a % b == 0:\n        print(\"multiple\")\n    else:\n        print(\"neither\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "while True:\n    a, b = map(int, input().split())\n    if a == 0 and b == 0:\n        break\n    if b % ",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "5419",
    "step_title": "스위핑",
    "title": "북서풍",
    "level": 18,
    "tags": [
      "자료 구조",
      "세그먼트 트리",
      "스위핑",
      "값 / 좌표 압축"
    ],
    "description": "강한 북서풍이 불고 있다. 이 뜻은 동쪽과 남쪽 사이의 모든 방향으로 항해할 수 있다는 뜻이다. 북쪽이나 서쪽으로 항해하는 것은 불가능하다.작은 섬이 여러 개 있는 바다가 있다. 섬은 좌표 평면의 한 점으로 나타낼 수 있다. y 좌표가 증가하는 방향은 북쪽, x좌표가 증가하는 방향은 동쪽이다. 북서풍을 타고 항해할 수 있는 섬의 쌍의 수를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 테스트 케이스의 개수가 주어진다.각 테스트 케이스의 첫째 줄에는 섬의 수 n (1 ≤ n ≤ 75000)이 주어진다. 다음 n개 줄에는 각 섬의 좌표 xi, yi가 주어진다. 두 섬의 좌표가 같은 경우는 없다. (-109≤ xi, yi≤ 109)",
    "output_description": "각 테스트 케이스에 대해서, 북서풍을 타고 항해할 수 있는 섬의 쌍의 수를 출력한다.",
    "examples": [
      {
        "input": "2\r\n4\r\n-10 -10\r\n-10 10\r\n10 -10\r\n10 10\r\n3\r\n1 3\r\n2 2\r\n3 1",
        "output": "5\r\n3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/5419",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "5597",
    "step_title": "1차원 배열",
    "title": "과제 안 내신 분..?",
    "level": 3,
    "tags": [
      "구현"
    ],
    "description": "X대학 M교수님은 프로그래밍 수업을 맡고 있다. 교실엔 학생이 30명이 있는데, 학생 명부엔 각 학생별로 1번부터 30번까지 출석번호가 붙어 있다.교수님이 내준 특별과제를 28명이 제출했는데, 그 중에서 제출 안 한 학생 2명의 출석번호를 구하는 프로그램을 작성하시오.",
    "input_description": "입력은 총 28줄로 각 제출자(학생)의 출석번호 n(1 ≤ n ≤ 30)가 한 줄에 하나씩 주어진다. 출석번호에 중복은 없다.",
    "output_description": "출력은 2줄이다. 1번째 줄엔 제출하지 않은 학생의 출석번호 중 가장 작은 것을 출력하고, 2번째 줄에선 그 다음 출석번호를 출력한다.",
    "examples": [
      {
        "input": "3\n1\n4\n5\n7\n9\n6\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30",
        "output": "2\n8"
      },
      {
        "input": "9\n30\n6\n12\n10\n20\n21\n11\n7\n5\n28\n4\n18\n29\n17\n19\n27\n13\n16\n26\n14\n23\n22\n15\n3\n1\n24\n25",
        "output": "2\n8"
      }
    ],
    "url": "https://www.acmicpc.net/problem/5597",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "submitted = set()\nfor _ in range(28):\n    submitted.add(int(input()))\nfor i in range(1, 31):\n    if i not in submitted:\n        print(i)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(28):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "조건 판단",
            "description": "조건문을 사용하여 상황에 따라 다르게 처리합니다.",
            "code_pattern": "if i not in submitted:",
            "socratic_hint": "조건에 따라 다르게 처리하려면?",
            "hint": "if-else 문을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(i)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: 집합 차집합",
        "solution_code": "submitted = set(int(input()) for _ in range(28))\nall_students = set(range(1, 31))\nmissing = sorted(all_students - submitted)\nfor m in missing:\n    print(m)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "집합 연산",
            "description": "전체 학생 집합에서 제출한 학생을 뺍니다.",
            "code_pattern": "all_students - submitted",
            "socratic_hint": "차집합을 구하려면?",
            "hint": "set1 - set2를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3: 불린 배열",
        "solution_code": "submitted = [False] * 31\nfor _ in range(28):\n    submitted[int(input())] = True\nfor i in range(1, 31):\n    if not submitted[i]:\n        print(i)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "불린 배열 사용",
            "description": "제출 여부를 불린 배열로 관리합니다.",
            "code_pattern": "submitted = [False] * 31",
            "socratic_hint": "존재 여부를 배열로 관리하려면?",
            "hint": "불린 배열을 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "5615",
    "step_title": "수학 3",
    "title": "아파트 임대",
    "level": 20,
    "tags": [
      "밀러–라빈 소수 판별법",
      "정수론",
      "수학",
      "소수 판정"
    ],
    "description": "동규부동산에서 아파트를 임대하고 있다. 아파트의 방은 아래 그림과 같이 면적이 2xy + x + y이다. (x와 y는 양의 정수)동규부동산의 카탈로그에는 아파트의 면적이 오름차순으로 적혀져 있지만, 이 중 일부는 있을 수 없는 크기의 아파트이다. 만약, 이런 크기의 아파트를 임대하겠다고 말하면, 동규는 꽝! 이라고 외치면서, 수수료만 떼어간다.동규부동산의 카탈로그에 적힌 아파트의 면적이 주어졌을 때, 있을 수 없는 크기의 아파트의 수를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 아파트의 면적의 수 N이 주어진다. 다음 줄부터 N개 줄에 카탈로그에 적혀있는 순서대로 면적이 주어진다. N은 100,000이하이고 면적은 231-1이하인 양의 정수이다.",
    "output_description": "첫째 줄에 있을 수 없는 아파트 면적의 수를 출력한다.",
    "examples": [
      {
        "input": "10\n4\n7\n9\n10\n12\n13\n16\n17\n19\n20",
        "output": "2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/5615",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 수학 문제 기본 구조\ndef solve():\n    # 입력 처리\n    N = int(input())\n    \n    # 계산\n    result = N\n    \n    return result\n\nprint(solve())",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "5622",
    "step_title": "문자열",
    "title": "다이얼",
    "level": 4,
    "tags": [
      "구현"
    ],
    "description": "상근이의 할머니는 아래 그림과 같이 오래된 다이얼 전화기를 사용한다.전화를 걸고 싶은 번호가 있다면, 숫자를 하나를 누른 다음에 금속 핀이 있는 곳 까지 시계방향으로 돌려야 한다. 숫자를 하나 누르면 다이얼이 처음 위치로 돌아가고, 다음 숫자를 누르려면 다이얼을 처음 위치에서 다시 돌려야 한다.숫자 1을 걸려면 총 2초가 필요하다. 1보다 큰 수를 거는데 걸리는 시간은 이보다 더 걸리며, 한 칸 옆에 있는 숫자를 걸기 위해선 1초씩 더 걸린다.상근이의 할머니는 전화 번호를 각 숫자에 해당하는 문자로 외운다. 즉, 어떤 단어를 걸 때, 각 알파벳에 해당하는 숫자를 걸면 된다. 예를 들어, UNUCIC는 868242와 같다.할머니가 외운 단어가 주어졌을 때, 이 전화를 걸기 위해서 필요한 최소 시간을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 알파벳 대문자로 이루어진 단어가 주어진다. 단어의 길이는 2보다 크거나 같고, 15보다 작거나 같다.",
    "output_description": "첫째 줄에 다이얼을 걸기 위해서 필요한 최소 시간을 출력한다.",
    "examples": [
      {
        "input": "WA",
        "output": "13"
      },
      {
        "input": "UNUCIC",
        "output": "36"
      }
    ],
    "url": "https://www.acmicpc.net/problem/5622",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "dial = ['', '', 'ABC', 'DEF', 'GHI', 'JKL', 'MNO', 'PQRS', 'TUV', 'WXYZ']\nword = input()\ntime = 0\nfor char in word:\n    for i, letters in enumerate(dial):\n        if char in letters:\n            time += i + 1\n            break\nprint(time)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "word = input()로 입력을 처리합니다.",
            "code_pattern": "word = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for char in word:",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "조건 판단",
            "description": "조건문을 사용하여 상황에 따라 다르게 처리합니다.",
            "code_pattern": "if char in letters:",
            "socratic_hint": "조건에 따라 다르게 처리하려면?",
            "hint": "if-else 문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(time)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "5639",
    "step_title": "트리",
    "title": "이진 검색 트리",
    "level": 12,
    "tags": [
      "그래프 이론",
      "그래프 탐색",
      "트리",
      "재귀"
    ],
    "description": "이진 검색 트리는 다음과 같은 세 가지 조건을 만족하는 이진 트리이다.노드의 왼쪽 서브트리에 있는 모든 노드의 키는 노드의 키보다 작다.노드의 오른쪽 서브트리에 있는 모든 노드의 키는 노드의 키보다 크다.왼쪽, 오른쪽 서브트리도 이진 검색 트리이다.전위 순회 (루트-왼쪽-오른쪽)은 루트를 방문하고, 왼쪽 서브트리, 오른쪽 서브 트리를 순서대로 방문하면서 노드의 키를 출력한다. 후위 순회 (왼쪽-오른쪽-루트)는 왼쪽 서브트리, 오른쪽 서브트리, 루트 노드 순서대로 키를 출력한다. 예를 들어, 위의 이진 검색 트리의 전위 순회 결과는 50 30 24 5 28 45 98 52 60 이고, 후위 순회 결과는 5 28 24 45 30 60 52 98 50 이다.이진 검색 트리를 전위 순회한 결과가 주어졌을 때, 이 트리를 후위 순회한 결과를 구하는 프로그램을 작성하시오.",
    "input_description": "트리를 전위 순회한 결과가 주어진다. 노드에 들어있는 키의 값은 106보다 작은 양의 정수이다. 모든 값은 한 줄에 하나씩 주어지며, 노드의 수는 10,000개 이하이다. 같은 키를 가지는 노드는 없다.",
    "output_description": "입력으로 주어진 이진 검색 트리를 후위 순회한 결과를 한 줄에 하나씩 출력한다.",
    "examples": [
      {
        "input": "50\r\n30\r\n24\r\n5\r\n28\r\n45\r\n98\r\n52\r\n60",
        "output": "5\r\n28\r\n24\r\n45\r\n30\r\n60\r\n52\r\n98\r\n50"
      }
    ],
    "url": "https://www.acmicpc.net/problem/5639",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nsys.setrecursionlimit(10**6)\n\ndef postorder(start, end):\n    if start > end:\n        return\n    \n    root = tree[start]\n    right_start = end + 1\n    \n    for i in range(start + 1, end + 1):\n        if tree[i] > root:\n            right_start = i\n            break\n    \n    postorder(start + 1, right_start - 1)\n    postorder(right_start, end)\n    print(root)\n\ntree = []\nfor line in sys.stdin:\n    tree.append(int(line.strip()))\n\npostorder(0, len(tree) - 1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "5670",
    "step_title": "문자열 알고리즘 1",
    "title": "휴대폰 자판",
    "level": 17,
    "tags": [
      "자료 구조",
      "문자열",
      "트리",
      "트라이"
    ],
    "description": "휴대폰에서 길이가 P인 영단어를 입력하려면 버튼을 P번 눌러야 한다. 그러나 시스템프로그래밍 연구실에 근무하는 승혁연구원은 사전을 사용해 이 입력을 더 빨리 할 수 있는 자판 모듈을 개발하였다. 이 모듈은 사전 내에서 가능한 다음 글자가 하나뿐이라면 그 글자를 버튼 입력 없이 자동으로 입력해 준다! 자세한 작동 과정을 설명하자면 다음과 같다.모듈이 단어의 첫 번째 글자를 추론하지는 않는다. 즉, 사전의 모든 단어가 같은 알파벳으로 시작하더라도 반드시 첫 글자는 사용자가 버튼을 눌러 입력해야 한다.길이가 1 이상인 문자열 c1c2...cn이 지금까지 입력되었을 때, 사전 안의 모든 c1c2...cn으로 시작하는 단어가 c1c2...cnc로도 시작하는 글자 c가 존재한다면 모듈은 사용자의 버튼 입력 없이도 자동으로 c를 입력해 준다. 그렇지 않다면 사용자의 입력을 기다린다.예를 들면, 사전에 \"hello\", \"hell\", \"heaven\", \"goodbye\" 4개의 단어가 있고 사용자가 \"h\"를 입력하면 모듈은 자동으로 \"e\"를 입력해 준다. 사전상의 \"h\"로 시작하는 단어들은 모두 그 뒤에 \"e\"가 오기 때문이다. 그러나 단어들 중 \"hel\"로 시작하는 것도, \"hea\"로 시작하는 것도 있기 때문에 여기서 모듈은 사용자의 입력을 기다린다. 이어서 사용자가 \"l\"을 입력하면 모듈은 \"l\"을 자동으로 입력해 준다. 그러나 여기서 끝나는 단어인 \"hell\"과 그렇지 않은 단어인 \"hello\"가 공존하므로 모듈은 다시 입력을 기다린다. 사용자가 \"hell\"을 입력하기 원한다면 여기서 입력을 멈출 것이고, \"hello\"를 입력하기 원한다면 직접 \"o\" 버튼을 눌러서 입력해 줘야 한다. 따라서 \"hello\"를 입력하려면 사용자는 총 3번 버튼을 눌러야 하고, \"hell\", \"heaven\"은 2번이다. \"heaven\"의 경우 \"he\"에서 \"a\"를 입력하면 바로 뒷부분이 모두 자동으로 입력되기 때문이다. 비슷하게, \"goodbye\"는 단 한 번만 버튼을 눌러도 입력이 완료될 것이다. \"g\"를 입력하는 순간 뒤에 오는 글자가 항상 유일하므로 끝까지 자동으로 입력되기 때문이다. 이때 사전에 있는 단어들을 입력하기 위해 버튼을 눌러야 하는 횟수의 평균은 (3 + 2 + 2 + 1)/4 = 2.00이다.사전이 주어졌을 때, 이 모듈을 사용하면서 이와 같이 각 단어를 입력하기 위해 버튼을 눌러야 하는 횟수의 평균을 구하는 프로그램을 작성하시오.",
    "input_description": "입력은 여러 개의 테스트 케이스로 이루어져 있다.각 테스트 케이스의 첫째 줄에 사전에 속한 단어의 개수 N이 주어지며(1 ≤ N ≤ 105), 이어서 N개의 줄에 1~80글자인 영어 소문자로만 이루어진 단어가 하나씩 주어진다. 이 단어들로 사전이 구성되어 있으며, 똑같은 단어는 두 번 주어지지 않는다. 각 테스트 케이스마다 입력으로 주어지는 단어의 길이 총합은 최대 106이다.",
    "output_description": "각 테스트 케이스마다 한 줄에 걸쳐 문제의 정답을 소수점 둘째 자리까지 반올림하여 출력한다.",
    "examples": [
      {
        "input": "4\r\nhello\r\nhell\r\nheaven\r\ngoodbye\r\n3\r\nhi\r\nhe\r\nh\r\n7\r\nstructure\r\nstructures\r\nride\r\nriders\r\nstress\r\nsolstice\r\nridiculous",
        "output": "2.00\r\n1.67\r\n2.71"
      }
    ],
    "url": "https://www.acmicpc.net/problem/5670",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n    \n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end\n\nN = int(input())\ntrie = Trie()\n\nfor _ in range(N):\n    word = input().strip()\n    trie.insert(word)\n\nM = int(input())\nfor _ in range(M):\n    query = input().strip()\n    print(1 if trie.search(query) else 0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "5820",
    "step_title": "트리와 쿼리",
    "title": "경주",
    "level": 22,
    "tags": [
      "트리",
      "분할 정복",
      "centroid",
      "센트로이드 분할"
    ],
    "description": "IOI 를 개최하는 파타야 시는 경주대회인 IOR 2011 도 함께 개최하며 이를 위해 가장 적합한 경주코스를 찾고 있다.파타야 인근 지역에는 N 개의 도시가 있고 N-1 개의 고속도로가 이 도시들을 연결하고 있다. 각 고속도로는 양방향이며 서로 다른 두 개의 도시를 연결한다. 각 고속도로의 길이는 킬로미터 단위로 나타내며 정수 값이다. 그리고 임의의 두 도시는 직접 고속도로로 연결되지 않더라도 단 하나의 경로에 의해 연결된다. 즉, 같은 도시를 두 번 이상 방문하지 않고 한 도시에서 출발하여 다른 도시에 도착하는 방법은 유일하다.IOR 에 사용되는 경주코스는 출발 도시와 도착 도시가 서로 달라야 하며 길이는 정확하게 K 킬로미터인 경로이다. 그리고 충돌을 방지하기 위해 한 고속도로를 두 번 이상 사용하지 않는다. (따라서 한 도시도 두 번 이상 방문하지 않는다.) 또한 교통체증을 줄이기 위해 되도록 가장 작은 수의 고속도로를 사용하여 경주코스를 구성하려고 한다.다음의 파라미터를 받는 best_path(N,K,H,L) 함수를 작성하라.N – 도시의 수. 각 도시는 0 번부터 N-1 번까지 정수로 나타낸다.K – 경주코스의 길이.H – 각 고속도로를 나타내는 2 차원 배열. 고속도로 i (0 ≤ i < N-1)는 도시 H[i][0]와 도시 H[i][1]를 연결하는 도로이다.L – 고속도로의 길이를 나타내는 1 차원 배열. 고속도로 i (0 ≤ i < N-1)의 길이는 L[i]이다.배열 H 에 저장된 값은 0 이상 N-1 이하이다. 또한 배열 L 에 저장된 값은 0 이상 1 000 000 이하의 정수이다. 그리고 모든 도시들은 연결되어 있다.당신이 작성한 함수는 길이가 K 인 경주코스 중에서 고속도로 수가 가장 작은 경주코스의 고속도로 수를 반환한다. 만약 길이가 K 인 경주코스가 없다면 -1 을 반환하라.",
    "input_description": "첫째 줄에 N과 K가 주어진다. 둘째 줄부터 N-1개 줄에는 H[i][0], H[i][1], L[i]가 주어진다.",
    "output_description": "best_path(N,K,H,L)가 리턴한 값을 출력한다.",
    "examples": [
      {
        "input": "4 3\n0 1 1\n1 2 2\n1 3 4",
        "output": "2"
      },
      {
        "input": "3 3\n0 1 1\n1 2 1",
        "output": "-1"
      },
      {
        "input": "11 12\n0 1 3\n0 2 4\n2 3 5\n3 4 4\n4 5 6\n0 6 3\n6 7 2\n6 8 5\n8 9 6\n8 10 7",
        "output": "2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/5820",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 그래프 문제 기본 구조\nfrom collections import deque\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\n# BFS/DFS 구현\nvisited = [False] * (N + 1)\n\ndef bfs(start):\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        node = queue.popleft()\n        for next_node in graph[node]:\n            if not visited[next_node]:\n                visited[next_node] = True\n                queue.append(next_node)\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "5977",
    "step_title": "스택, 큐, 덱 2",
    "title": "Mowing the Lawn",
    "level": 18,
    "tags": [
      "다이나믹 프로그래밍",
      "자료 구조",
      "덱",
      "덱을 이용한 구간 최댓값 트릭",
      "덱을 이용한 다이나믹 프로그래밍"
    ],
    "description": "After winning the annual town competition for best lawn a year ago, Farmer John has grown lazy; he has not mowed the lawn since then and thus his lawn has become unruly. However, the competition is once again coming soon, and FJ would like to get his lawn into tiptop shape so that he can claim the title.Unfortunately, FJ has realized that his lawn is so unkempt that he will need to get some of his N (1 <= N <= 100,000) cows, who are lined up in a row and conveniently numbered 1..N, to help him. Some cows are more efficient than others at mowing the lawn; cow i has efficiency E_i (0 <= E_i <= 1,000,000,000).FJ has noticed that cows near each other in line often know each other well; he has also discovered that if he chooses more than K (1 <= K <= N) consecutive (adjacent) cows to help him, they will ignore the lawn and start a party instead. Thus, FJ needs you to assist him: determine the largest total cow efficiency FJ can obtain without choosing more than K consecutive cows.",
    "input_description": "Line 1: Two space-separated integers: N and KLines 2..N+1: Line i+1 contains the single integer: E_i",
    "output_description": "Line 1: A single integer that is the best total efficiency FJ can obtain.",
    "examples": [
      {
        "input": "5 2\n1\n2\n3\n4\n5",
        "output": "12"
      }
    ],
    "url": "https://www.acmicpc.net/problem/5977",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N, K = map(int, input().split())\nE = [int(input()) for _ in range(N)]\n\ndp = [0] * (N + 1)\n\nfor i in range(1, N + 1):\n    dp[i] = dp[i - 1]\n    \n    total = 0\n    for j in range(i, max(0, i - K - 1), -1):\n        total += E[j - 1]\n        dp[i] = max(dp[i], dp[j - 1] + total)\n\nprint(dp[N])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "6497",
    "step_title": "최소 신장 트리",
    "title": "전력난",
    "level": 12,
    "tags": [
      "그래프 이론",
      "최소 스패닝 트리"
    ],
    "description": "성진이는 한 도시의 시장인데 거지라서 전력난에 끙끙댄다. 그래서 모든 길마다 원래 켜져 있던 가로등 중 일부를 소등하기로 하였다. 길의 가로등을 켜 두면 하루에 길의 미터 수만큼 돈이 들어가는데, 일부를 소등하여 그만큼의 돈을 절약할 수 있다.그러나 만약 어떤 두 집을 왕래할 때, 불이 켜져 있지 않은 길을 반드시 지나야 한다면 위험하다. 그래서 도시에 있는 모든 두 집 쌍에 대해, 불이 켜진 길만으로 서로를 왕래할 수 있어야 한다.위 조건을 지키면서 절약할 수 있는 최대 액수를 구하시오.",
    "input_description": "입력은 여러 개의 테스트 케이스로 구분되어 있다.각 테스트 케이스의 첫째 줄에는 집의 수 m과 길의 수 n이 주어진다. (1 ≤ m ≤ 200000,m-1 ≤ n ≤ 200000)이어서 n개의 줄에 각 길에 대한 정보 x, y, z가 주어지는데, 이는 x번 집과 y번 집 사이에 양방향 도로가 있으며 그 거리가 z미터라는 뜻이다. (0 ≤ x, y < m,x ≠ y)도시는 항상 연결 그래프의 형태이고(즉, 어떤 두 집을 골라도 서로 왕래할 수 있는 경로가 있다), 도시상의 모든 길의 거리 합은 231미터보다 작다.입력의 끝에서는 첫 줄에 0이 2개 주어진다.",
    "output_description": "각 테스트 케이스마다 한 줄에 걸쳐 절약할 수 있는 최대 비용을 출력한다.",
    "examples": [
      {
        "input": "7 11\n0 1 7\n0 3 5\n1 2 8\n1 3 9\n1 4 7\n2 4 5\n3 4 15\n3 5 6\n4 5 8\n4 6 9\n5 6 11\n0 0",
        "output": "51"
      }
    ],
    "url": "https://www.acmicpc.net/problem/6497",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\ninput = sys.stdin.readline\n\ndef find(x):\n    if parent[x] != x:\n        parent[x] = find(parent[x])\n    return parent[x]\n\ndef union(a, b):\n    a = find(a)\n    b = find(b)\n    if a != b:\n        parent[b] = a\n        return True\n    return False\n\nwhile True:\n    m, n = map(int, input().split())\n    if m == 0 and n == 0:\n        break\n    \n    edges = []\n    total_cost = 0\n    \n    for _ in range(n):\n        x, y, z = map(int, input().split())\n        edges.append((z, x, y))\n        total_cost += z\n    \n    edges.sort()\n    parent = list(range(m))\n    \n    mst_cost = 0\n    for cost, a, b in edges:\n        if union(a, b):\n            mst_cost += cost\n    \n    print(total_cost - mst_cost)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "6549",
    "step_title": "분할 정복",
    "title": "히스토그램에서 가장 큰 직사각형",
    "level": 16,
    "tags": [
      "자료 구조",
      "세그먼트 트리",
      "분할 정복",
      "스택"
    ],
    "description": "히스토그램은 직사각형 여러 개가 아래쪽으로 정렬되어 있는 도형이다. 각 직사각형은 같은 너비를 가지고 있지만, 높이는 서로 다를 수도 있다. 예를 들어, 왼쪽 그림은 높이가 2, 1, 4, 5, 1, 3, 3이고 너비가 1인 직사각형으로 이루어진 히스토그램이다.히스토그램에서 가장 넓이가 큰 직사각형을 구하는 프로그램을 작성하시오.",
    "input_description": "입력은 테스트 케이스 여러 개로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있고, 직사각형의 수 n이 가장 처음으로 주어진다. (1 ≤ n ≤ 100,000) 그 다음 n개의 정수 h1, ..., hn(0 ≤ hi≤ 1,000,000,000)가 주어진다. 이 숫자들은 히스토그램에 있는 직사각형의 높이이며, 왼쪽부터 오른쪽까지 순서대로 주어진다. 모든 직사각형의 너비는 1이고, 입력의 마지막 줄에는 0이 하나 주어진다.",
    "output_description": "각 테스트 케이스에 대해서, 히스토그램에서 가장 넓이가 큰 직사각형의 넓이를 출력한다.",
    "examples": [
      {
        "input": "7 2 1 4 5 1 3 3\n4 1000 1000 1000 1000\n0",
        "output": "8\n4000"
      }
    ],
    "url": "https://www.acmicpc.net/problem/6549",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def largest_rectangle(heights, start, end):\n    if start > end:\n        return 0\n    if start == end:\n        return heights[start]\n    \n    mid = (start + end) // 2\n    left_max = largest_rectangle(heights, start, mid)\n    right_max = largest_rectangle(heights, mid + 1, end)\n    \n    # 중앙을 포함하는 직사각형\n    left, right = mid, mid + 1\n    height = min(heights[left], heights[right])\n    max_area = height * 2\n    \n    while start < left or right < end:\n        if right < end and (left == start or heights[left - 1] < heights[right + 1]):\n            right += 1\n            height = min(height, heights[right])\n        else:\n            left -= 1\n            height = min(height, heights[left])\n        \n        max_area = max(max_area, height * (right - left + 1))\n    \n    return max(left_max, right_max, max_area)\n\nwhile True:\n    data = list(map(int, input().split()))\n    n = data[0]\n    if n == 0:\n        break\n    heights = data[1:]\n    print(largest_rectangle(heights, 0, n - 1))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "7420",
    "step_title": "기하 3",
    "title": "맹독 방벽",
    "level": 17,
    "tags": [
      "기하학",
      "볼록 껍질"
    ],
    "description": "화학 제국의 왕 성준이는 계속되는 이웃나라의 침범으로부터 자유로워지기 위해 자국의 자랑화학 방벽을 건설하기로 마음먹었다. 이 방벽은 근처에 다가오는 생명체에게 해로운 독성을 내뿜어서 더이상 다른 나라들이 얼씬도 못하게 만들 것이다!그러나 이 방벽은 만들기 까다롭기에 가능한 한 적게 지어야 하며, 자국민들에게도 악영향을 끼칠 수 있으므로 자국의 모든 건물들로부터 L 이상의 거리를 유지해야만 한다.자국의 건물들의 좌표가 주어졌을 때, 모든 건물들로부터 L 이상의 거리를 두면서 모든 건물을 한번에 두르는 방벽의 최소 길이를 구하시오.",
    "input_description": "첫 번째 줄에 건물의 수 N과 거리 L이 주어진다. (3 ≤ N ≤ 1000, 1 ≤ L ≤ 1000, N과 L은 정수)다음 N개의 줄에 거쳐 건물의 좌표 Xi와 Yi가 정수로 주어진다. (-10000 ≤ Xi, Yi≤ 10000) 모든 건물의 좌표는 다르며, 건물은 충분히 작아서 점과 같다고 생각해도 좋다. 방벽은 자신들끼리 교차해서는 안 되며 끊어져서도 안 된다.",
    "output_description": "첫째 줄에 답을 정수 단위로 반올림하여 출력한다.",
    "examples": [
      {
        "input": "9 100\n200 400\n300 400\n300 300\n400 300\n400 400\n500 400\n500 200\n350 200\n200 200",
        "output": "1628"
      }
    ],
    "url": "https://www.acmicpc.net/problem/7420",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "7562",
    "step_title": "그래프와 순회",
    "title": "나이트의 이동",
    "level": 10,
    "tags": [
      "너비 우선 탐색",
      "그래프 이론",
      "그래프 탐색",
      "최단 경로",
      "격자 그래프"
    ],
    "description": "체스판 위에 한 나이트가 놓여져 있다. 나이트가 한 번에 이동할 수 있는 칸은 아래 그림에 나와있다. 나이트가 이동하려고 하는 칸이 주어진다. 나이트는 몇 번 움직이면 이 칸으로 이동할 수 있을까?",
    "input_description": "입력의 첫째 줄에는 테스트 케이스의 개수가 주어진다.각 테스트 케이스는 세 줄로 이루어져 있다. 첫째 줄에는 체스판의 한 변의 길이 l(4 ≤ l ≤ 300)이 주어진다. 체스판의 크기는 l × l이다. 체스판의 각 칸은 두 수의 쌍 {0, ..., l-1} × {0, ..., l-1}로 나타낼 수 있다. 둘째 줄과 셋째 줄에는 나이트가 현재 있는 칸, 나이트가 이동하려고 하는 칸이 주어진다.",
    "output_description": "각 테스트 케이스마다 나이트가 최소 몇 번만에 이동할 수 있는지 출력한다.",
    "examples": [
      {
        "input": "3\n8\n0 0\n7 0\n100\n0 0\n30 50\n10\n1 1\n1 1",
        "output": "5\n28\n0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/7562",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import deque\n\nT = int(input())\nfor _ in range(T):\n    l = int(input())\n    start_x, start_y = map(int, input().split())\n    end_x, end_y = map(int, input().split())\n    \n    if start_x == end_x and start_y == end_y:\n        print(0)\n        continue\n    \n    visited = [[False] * l for _ in range(l)]\n    queue = deque([(start_x, start_y, 0)])\n    visited[start_x][start_y] = True\n    \n    dx = [-2, -1, 1, 2, 2, 1, -1, -2]\n    dy = [1, 2, 2, 1, -1, -2, -2, -1]\n    \n    while queue:\n        x, y, count = queue.popleft()\n        \n        for i in range(8):\n            nx, ny = x + dx[i], y + dy[i]\n            \n            if 0 <= nx < l and 0 <= ny < l and not visited[nx][ny]:\n                if nx == end_x and ny == end_y:\n                    print(count + 1)\n                    break\n                visited[nx][ny] = True\n                queue.append((nx, ny, count + 1))\n        else:\n            continue\n        break",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "7569",
    "step_title": "그래프와 순회",
    "title": "토마토",
    "level": 11,
    "tags": [
      "너비 우선 탐색",
      "그래프 이론",
      "그래프 탐색",
      "격자 그래프",
      "최단 경로"
    ],
    "description": "철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자모양 상자의 칸에 하나씩 넣은 다음, 상자들을 수직으로 쌓아 올려서 창고에 보관한다.창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토에 인접한 곳은 위, 아래, 왼쪽, 오른쪽, 앞, 뒤 여섯 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지 그 최소 일수를 알고 싶어 한다.토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.",
    "input_description": "첫 줄에는 상자의 크기를 나타내는 두 정수 M,N과 쌓아올려지는 상자의 수를 나타내는 H가 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M ≤ 100, 2 ≤ N ≤ 100, 1 ≤ H ≤ 100 이다. 둘째 줄부터는 가장 밑의 상자부터 가장 위의 상자까지에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 하나의 상자에 담긴 토마토의 정보가 주어진다. 각 줄에는 상자 가로줄에 들어있는 토마토들의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0 은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다. 이러한 N개의 줄이 H번 반복하여 주어진다.토마토가 하나 이상 있는 경우만 입력으로 주어진다.",
    "output_description": "여러분은 토마토가 모두 익을 때까지 최소 며칠이 걸리는지를 계산해서 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.",
    "examples": [
      {
        "input": "5 3 1\n0 -1 0 0 0\n-1 -1 0 1 1\n0 0 0 1 1",
        "output": "-1"
      },
      {
        "input": "5 3 2\n0 0 0 0 0\n0 0 0 0 0\n0 0 0 0 0\n0 0 0 0 0\n0 0 1 0 0\n0 0 0 0 0",
        "output": "4"
      },
      {
        "input": "4 3 2\n1 1 1 1\n1 1 1 1\n1 1 1 1\n1 1 1 1\n-1 -1 -1 -1\n1 1 1 -1",
        "output": "0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/7569",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import deque\n\nM, N, H = map(int, input().split())\nbox = []\nfor _ in range(H):\n    layer = []\n    for _ in range(N):\n        layer.append(list(map(int, input().split())))\n    box.append(layer)\n\nqueue = deque()\nfor h in range(H):\n    for i in range(N):\n        for j in range(M):\n            if box[h][i][j] == 1:\n                queue.append((h, i, j, 0))\n\ndh = [0, 0, 0, 0, 1, -1]\ndi = [-1, 1, 0, 0, 0, 0]\ndj = [0, 0, -1, 1, 0, 0]\nmax_days = 0\n\nwhile queue:\n    h, i, j, days = queue.popleft()\n    max_days = max(max_days, days)\n    \n    for d in range(6):\n        nh, ni, nj = h + dh[d], i + di[d], j + dj[d]\n        \n        if 0 <= nh < H and 0 <= ni < N and 0 <= nj < M and box[nh][ni][nj] == 0:\n            box[nh][ni][nj] = 1\n            queue.append((nh, ni, nj, days + 1))\n\nfor h in range(H):\n    for i in range(N):\n        for j in range(M):\n            if box[h][i][j] == 0:\n                print(-1)\n                exit()\n\nprint(max_days)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "7576",
    "step_title": "그래프와 순회",
    "title": "토마토",
    "level": 11,
    "tags": [
      "너비 우선 탐색",
      "그래프 이론",
      "그래프 탐색",
      "격자 그래프",
      "최단 경로"
    ],
    "description": "철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자 모양 상자의 칸에 하나씩 넣어서 창고에 보관한다.창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토의 인접한 곳은 왼쪽, 오른쪽, 앞, 뒤 네 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지, 그 최소 일수를 알고 싶어 한다.토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.",
    "input_description": "첫 줄에는 상자의 크기를 나타내는 두 정수 M,N이 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M,N ≤ 1,000 이다. 둘째 줄부터는 하나의 상자에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 상자에 담긴 토마토의 정보가 주어진다. 하나의 줄에는 상자 가로줄에 들어있는 토마토의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다.토마토가 하나 이상 있는 경우만 입력으로 주어진다.",
    "output_description": "여러분은 토마토가 모두 익을 때까지의 최소 날짜를 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.",
    "examples": [
      {
        "input": "6 4\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 1",
        "output": "8"
      },
      {
        "input": "6 4\n0 -1 0 0 0 0\n-1 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 1",
        "output": "-1"
      },
      {
        "input": "6 4\n1 -1 0 0 0 0\n0 -1 0 0 0 0\n0 0 0 0 -1 0\n0 0 0 0 -1 1",
        "output": "6"
      },
      {
        "input": "5 5\n-1 1 0 0 0\n0 -1 -1 -1 0\n0 -1 -1 -1 0\n0 -1 -1 -1 0\n0 0 0 0 0",
        "output": "14"
      },
      {
        "input": "2 2\n1 -1\n-1 1",
        "output": "0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/7576",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import deque\n\nM, N = map(int, input().split())\nbox = []\nfor _ in range(N):\n    box.append(list(map(int, input().split())))\n\nqueue = deque()\nfor i in range(N):\n    for j in range(M):\n        if box[i][j] == 1:\n            queue.append((i, j, 0))\n\ndx = [-1, 1, 0, 0]\ndy = [0, 0, -1, 1]\nmax_days = 0\n\nwhile queue:\n    x, y, days = queue.popleft()\n    max_days = max(max_days, days)\n    \n    for i in range(4):\n        nx, ny = x + dx[i], y + dy[i]\n        \n        if 0 <= nx < N and 0 <= ny < M and box[nx][ny] == 0:\n            box[nx][ny] = 1\n            queue.append((nx, ny, days + 1))\n\nfor i in range(N):\n    for j in range(M):\n        if box[i][j] == 0:\n            print(-1)\n            exit()\n\nprint(max_days)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "7579",
    "step_title": "동적 계획법 2",
    "title": "앱",
    "level": 13,
    "tags": [
      "다이나믹 프로그래밍",
      "배낭 문제"
    ],
    "description": "우리는 스마트폰을 사용하면서 여러 가지 앱(App)을 실행하게 된다. 대개의 경우 화면에 보이는 ‘실행 중’인 앱은 하나뿐이지만 보이지 않는 상태로 많은 앱이 '활성화'되어 있다. 앱들이 활성화 되어 있다는 것은 화면에 보이지 않더라도 메인 메모리에 직전의 상태가 기록되어 있는 것을 말한다. 현재 실행 중이 아니더라도 이렇게 메모리에 남겨두는 이유는 사용자가 이전에 실행하던 앱을 다시 불러올 때에 직전의 상태를 메인 메모리로부터 읽어 들여 실행 준비를 빠르게 마치기 위해서이다.하지만 스마트폰의 메모리는 제한적이기 때문에 한번이라도 실행했던 모든 앱을 활성화된 채로 메인 메모리에 남겨두다 보면 메모리 부족 상태가 오기 쉽다. 새로운 앱을 실행시키기 위해 필요한 메모리가 부족해지면 스마트폰의 운영체제는 활성화 되어 있는 앱들 중 몇 개를 선택하여 메모리로부터 삭제하는 수밖에 없다. 이러한 과정을 앱의 ‘비활성화’라고 한다.메모리 부족 상황에서 활성화 되어 있는 앱들을 무작위로 필요한 메모리만큼 비활성화 하는 것은 좋은 방법이 아니다. 비활성화된 앱들을 재실행할 경우 그만큼 시간이 더 필요하기 때문이다. 여러분은 이러한 앱의 비활성화 문제를 스마트하게 해결하기 위한 프로그램을 작성해야 한다현재 N개의 앱, A1, ..., AN이 활성화 되어 있다고 가정하자. 이들 앱 Ai는 각각 mi바이트만큼의 메모리를 사용하고 있다. 또한, 앱 Ai를 비활성화한 후에 다시 실행하고자 할 경우, 추가적으로 들어가는 비용(시간 등)을 수치화 한 것을 ci라고 하자. 이러한 상황에서 사용자가 새로운 앱 B를 실행하고자 하여, 추가로 M 바이트의 메모리가 필요하다고 하자. 즉, 현재 활성화 되어 있는 앱 A1, ..., AN중에서 몇 개를 비활성화 하여 M 바이트 이상의 메모리를 추가로 확보해야 하는 것이다. 여러분은 그 중에서 비활성화 했을 경우의 비용 ci의 합을 최소화하여 필요한 메모리 M 바이트를 확보하는 방법을 찾아야 한다.",
    "input_description": "입력은 3줄로 이루어져 있다. 첫 줄에는 정수 N과 M이 공백문자로 구분되어 주어지며, 둘째 줄과 셋째 줄에는 각각 N개의 정수가 공백문자로 구분되어 주어진다. 둘째 줄의 N개의 정수는 현재 활성화 되어 있는 앱 A1, ..., AN이 사용 중인 메모리의 바이트 수인 m1, ..., mN을 의미하며, 셋째 줄의 정수는 각 앱을 비활성화 했을 경우의 비용 c1, ..., cN을 의미한다단, 1 ≤ N ≤ 100, 1 ≤ M ≤ 10,000,000이며, 1 ≤ m1, ..., mN≤ 10,000,000을 만족한다. 또한, 0 ≤ c1, ..., cN≤ 100이고, M ≤ m1+ m2+ ... + mN이다.",
    "output_description": "필요한 메모리 M 바이트를 확보하기 위한 앱 비활성화의 최소의 비용을 계산하여 한 줄에 출력해야 한다.",
    "examples": [
      {
        "input": "5 60\n30 10 20 35 40\n3 0 3 5 4",
        "output": "6"
      }
    ],
    "url": "https://www.acmicpc.net/problem/7579",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N, M = map(int, input().split())\nmemory = list(map(int, input().split()))\ncost = list(map(int, input().split()))\n\ntotal_cost = sum(cost)\ndp = [0] * (total_cost + 1)\n\nfor i in range(N):\n    for j in range(total_cost, cost[i] - 1, -1):\n        dp[j] = max(dp[j], dp[j - cost[i]] + memory[i])\n\nfor i in range(total_cost + 1):\n    if dp[i] >= M:\n        print(i)\n        break",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "7626",
    "step_title": "스위핑",
    "title": "직사각형",
    "level": 20,
    "tags": [
      "자료 구조",
      "세그먼트 트리",
      "스위핑",
      "값 / 좌표 압축"
    ],
    "description": "축에 평행한 직사각형 N개가 평면 위에 있다. 이 직사각형들이 차지하는 전체 면적을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 양의 정수 N이 주어진다. (1 ≤ N ≤ 200,000) 다음 N개 줄에는 공백으로 나누어진 네 값 \"x1, x2, y1, y2\"가 주어진다. 이 값은 직사각형 [x1,x2] × [y1,y2]를 나타낸다. 모든 좌표는 0보다 크거나 같고, 109보다 작거나 같으며, 각각의 직사각형은 x1< x2, y1< y2를 만족한다.",
    "output_description": "첫째 줄에 주어진 직사각형 N개가 차지하는 전체 면적을 출력한다. 한 구역이 여러 개의 직사각형으로 덮어져 있는 경우에도 한 번으로 센다.",
    "examples": [
      {
        "input": "2\r\n0 3 1 2\r\n1 2 0 3",
        "output": "5"
      }
    ],
    "url": "https://www.acmicpc.net/problem/7626",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "7785",
    "step_title": "집합과 맵",
    "title": "회사에 있는 사람",
    "level": 6,
    "tags": [
      "자료 구조",
      "집합과 맵",
      "해시를 사용한 집합과 맵"
    ],
    "description": "상근이는 세계적인 소프트웨어 회사 기글에서 일한다. 이 회사의 가장 큰 특징은 자유로운 출퇴근 시간이다. 따라서, 직원들은 반드시 9시부터 6시까지 회사에 있지 않아도 된다.각 직원은 자기가 원할 때 출근할 수 있고, 아무때나 퇴근할 수 있다.상근이는 모든 사람의 출입카드 시스템의 로그를 가지고 있다. 이 로그는 어떤 사람이 회사에 들어왔는지, 나갔는지가 기록되어져 있다. 로그가 주어졌을 때, 현재 회사에 있는 모든 사람을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 로그에 기록된 출입 기록의 수 n이 주어진다. (2 ≤ n ≤ 106) 다음 n개의 줄에는 출입 기록이 순서대로 주어지며, 각 사람의 이름이 주어지고 \"enter\"나 \"leave\"가 주어진다. \"enter\"인 경우는 출근, \"leave\"인 경우는 퇴근이다.회사에는 동명이인이 없으며, 대소문자가 다른 경우에는 다른 이름이다. 사람들의 이름은 알파벳 대소문자로 구성된 5글자 이하의 문자열이다.",
    "output_description": "현재 회사에 있는 사람의 이름을 사전 순의 역순으로 한 줄에 한 명씩 출력한다.",
    "examples": [
      {
        "input": "4\r\nBaha enter\r\nAskar enter\r\nBaha leave\r\nArtem enter",
        "output": "Askar\r\nArtem"
      }
    ],
    "url": "https://www.acmicpc.net/problem/7785",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "n = int(input())\npeople = set()\nfor _ in range(n):\n    name, action = input().split()\n    if action == \"enter\":\n        people.add(name)\n    else:\n        people.discard(name)\nfor person in sorted(people, reverse=True):\n    print(person)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "n = int(input())\npeople = set()\nfor _ in range(n):\n    name, action = input().split()\n    if action ",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "7869",
    "step_title": "기하 2",
    "title": "두 원",
    "level": 14,
    "tags": [
      "수학",
      "기하학",
      "많은 조건 분기"
    ],
    "description": "두 원이 주어졌을 때, 교차하는 영역의 넓이를 소수점 셋째자리까지 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 두 원의 중심과 반지름 x1, y1, r1, x2, y2, r2가 주어진다. 실수는 최대 소수점 둘째자리까지 주어진다.",
    "output_description": "첫째 줄에 교차하는 영역의 넓이를 반올림해 소수점 셋째자리까지 출력한다.",
    "examples": [
      {
        "input": "20.0 30.0 15.0 40.0 30.0 30.0",
        "output": "608.366"
      }
    ],
    "url": "https://www.acmicpc.net/problem/7869",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 수학 문제 기본 구조\ndef solve():\n    # 입력 처리\n    N = int(input())\n    \n    # 계산\n    result = N\n    \n    return result\n\nprint(solve())",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "8170",
    "step_title": "스프라그 그런디 정리",
    "title": "Pebbles",
    "level": 21,
    "tags": [
      "게임 이론",
      "스프라그–그런디 정리",
      "홀짝성",
      "차분 배열 트릭"
    ],
    "description": "Johny and Margaret are playing \"pebbles\". Initially there is a certain number of pebbles on a table, grouped in n piles. The piles are next to each other, forming a single row. The arrangement of stones satisfies an additional property that each pile consists of at least as many pebbles as the one to the left (with the obvious exception of the leftmost pile). The players alternately remove any number of pebbles from a single pile of their choice. They have to take care, though, not to make any pile smaller than the one left to it. In other words, the piles have to satisfy the initial property after the move as well. When one of the players cannot make a move (i.e. before his move there are no more pebbles on the table), he loses. Johny always starts, to compensate for Margaret's mastery in this game.In fact Margaret is so good that she always makes the best move, and wins the game whenever she has a chance. Therefore Johny asks your help - he would like to know if he stands a chance of beating Margaret with a particular initial arrangement. Write a programme that determines answers to Johny's inquiries.",
    "input_description": "In the first line of the standard input there is a single integer u (1 ≤ u ≤ 10) denoting the number of initial pebble arrangements to analyse. The following 2u lines contain descriptions of these arrangements; each one takes exactly two lines.The first line of each description contains a single integer n, 1 ≤ n ≤ 1,000  - the number of piles. The second line of description holds n non-negative integers aiseparated by single spaces and denoting the numbers of pebbles in successive piles, left to right. These numbers satisfy the following inequality a1≤ a2≤ … ≤ an. The total number of pebbles in any arrangement does not exceed 10,000.",
    "output_description": "Precisely u lines should be printed out on the standard output. The i-th of these lines (for 1 ≤ i ≤ u) should hold the word TAK (yes in Polish), if Johny can win starting with the i-th initial arrangement given in the input, or the word NIE (no in Polish), if Johny is bound to lose that game, assuming optimal play of Margaret.",
    "examples": [
      {
        "input": "2\r\n2\r\n2 2\r\n3\r\n1 2 4",
        "output": "NIE\r\nTAK"
      }
    ],
    "url": "https://www.acmicpc.net/problem/8170",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "8393",
    "step_title": "반복문",
    "title": "합",
    "level": 1,
    "tags": [
      "구현",
      "수학"
    ],
    "description": "n이 주어졌을 때, 1부터 n까지 합을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 n (1 ≤ n ≤ 10,000)이 주어진다.",
    "output_description": "1부터 n까지 합을 출력한다.",
    "examples": [
      {
        "input": "3",
        "output": "6"
      }
    ],
    "url": "https://www.acmicpc.net/problem/8393",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1: for 반복문",
        "solution_code": "n = int(input())\ntotal = 0\nfor i in range(1, n+1):\n    total += i\nprint(total)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "n 입력받기",
            "description": "합을 구할 마지막 수 n을 입력받습니다.",
            "code_pattern": "n = int(input())",
            "socratic_hint": "n을 입력받으려면?",
            "hint": "n = int(input())을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "합계 변수 초기화",
            "description": "합을 저장할 변수를 0으로 초기화합니다.",
            "code_pattern": "total = 0",
            "socratic_hint": "합계를 저장할 변수를 어떻게 준비하나요?",
            "hint": "total = 0으로 초기화합니다."
          },
          {
            "step_id": 3,
            "goal": "1부터 n까지 반복하며 더하기",
            "description": "for 반복문으로 1부터 n까지 순회하며 total에 더합니다.",
            "code_pattern": "for i in range(1, n+1):\n    total += i",
            "socratic_hint": "1부터 n까지의 합을 구하려면?",
            "hint": "range(1, n+1)로 반복하며 누적합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "최종 합계를 출력합니다.",
            "code_pattern": "print(total)",
            "socratic_hint": "합계를 출력하려면?",
            "hint": "print(total)을 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: 수학 공식",
        "solution_code": "N = int(input())\nprint(N * (N + 1) // 2)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "n 입력받기",
            "description": "합을 구할 마지막 수 n을 입력받습니다.",
            "code_pattern": "n = int(input())",
            "socratic_hint": "n을 입력받으려면?",
            "hint": "n = int(input())을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "등차수열 합 공식으로 계산",
            "description": "1부터 n까지의 합은 n×(n+1)/2 공식을 사용합니다.",
            "code_pattern": "print(n * (n + 1) // 2)",
            "socratic_hint": "1부터 n까지의 합을 한 번에 구하는 공식이 있을까요?",
            "hint": "등차수열 합 공식: n×(n+1)÷2"
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3: while문 활용",
        "solution_code": "N = int(input())\nresult = 0\ni = 1\nwhile i <= N:\n    result += i\n    i += 1\nprint(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 N을 입력받습니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "정수를 입력받으려면?",
            "hint": "int(input())을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "while 반복문 작성",
            "description": "while문으로 조건을 만족하는 동안 반복합니다.",
            "code_pattern": "while i <= N:",
            "socratic_hint": "조건을 만족하는 동안 반복하려면?",
            "hint": "while 조건: 형태로 작성합니다."
          },
          {
            "step_id": 3,
            "goal": "결과 출력",
            "description": "각 단계의 결과를 출력합니다.",
            "code_pattern": "print(result)",
            "socratic_hint": "계산 결과를 출력하려면?",
            "hint": "print()를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4: 리스트 컴프리헨션",
        "solution_code": "N = int(input())\nprint(sum(range(1, N + 1)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 N을 입력받습니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "정수를 입력받으려면?",
            "hint": "int(input())을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "리스트 컴프리헨션으로 계산",
            "description": "리스트 컴프리헨션으로 모든 결과를 한 번에 생성합니다.",
            "code_pattern": "[표현식 for i in range(...)]",
            "socratic_hint": "여러 결과를 리스트로 한 번에 만들려면?",
            "hint": "리스트 컴프리헨션을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "결과 출력",
            "description": "생성된 결과를 출력합니다.",
            "code_pattern": "print()",
            "socratic_hint": "결과를 출력하려면?",
            "hint": "print()를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 5,
        "solution_name": "풀이 5: 재귀함수",
        "solution_code": "def sum_recursive(n):\n    return n if n == 1 else n + sum_recursive(n-1)\nN = int(input())\nprint(sum_recursive(N))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "재귀 함수 정의",
            "description": "재귀적으로 합을 계산하는 함수를 만듭니다.",
            "code_pattern": "return n if n == 1 else n + sum_recursive(n-1)",
            "socratic_hint": "재귀로 합을 구하려면?",
            "hint": "자기 자신을 호출하는 함수를 만듭니다."
          }
        ]
      },
      {
        "solution_id": 6,
        "solution_name": "풀이 6: numpy 활용",
        "solution_code": "import numpy as np\nN = int(input())\nprint(np.arange(1, N+1).sum())",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "numpy 배열 사용",
            "description": "numpy로 배열을 만들고 sum() 메서드를 사용합니다.",
            "code_pattern": "np.arange(1, N+1).sum()",
            "socratic_hint": "numpy로 합을 구하려면?",
            "hint": "arange()와 sum()을 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "8472",
    "step_title": "네트워크 플로우 3",
    "title": "Vacation",
    "level": 22,
    "tags": [
      "그래프 이론",
      "최대 유량",
      "최소 비용 최대 유량"
    ],
    "description": "Byteman wants to go for a vacation and he would like to select the best days for that. He bases his choices on a weather forecast for the next 3n days. He is only interested in the highest temperature anticipated for a given day.Byteman is additionally constrained by terms set by his boss. During any consecutive n days he can take no more than k days of absence. What is the best way to plan the vacation, so that the sum of temperatures in the selected days is maximized?",
    "input_description": "The first line of the input contains two integers n and k (1 ≤ n ≤ 200, 1 ≤ k ≤ 10, k < n). In the second line there are 3n positive integers not exceeding 106that describe the temperatures anticipated for each of the next 3n days.",
    "output_description": "Your program should output a single integer: the maximum possible sum of temperatures during vacation days picked with respect to boss' terms.",
    "examples": [
      {
        "input": "5 3\r\n14 21 9 30 11 8 1 20 29 23 17 27 7 8 35",
        "output": "195"
      }
    ],
    "url": "https://www.acmicpc.net/problem/8472",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "8551",
    "step_title": "네트워크 플로우 1",
    "title": "Blokada",
    "level": 19,
    "tags": [
      "그래프 이론",
      "최대 유량",
      "최대 유량 최소 컷 정리"
    ],
    "description": "Już w zeszłym roku UOB (Urząd Ochrony Bajtocji) dowiedział się o planowanym zamachu na bajtockie łącza internetowe. Długie śledztwo wykazało, że za tym zamachem stoi jedna osoba. Mózgiem całej operacji jest prawdopodobnie pewien informatyk ukrywjący się pod pseudonimem \"S**\" (nie możemy go całkowicie ujawnić ze względu na dobro śledztwa). Jednakże od kilku miesięcy nie mozna go znaleźć mimo poszukiwań na wielką skalę. Ze zdobytych podczas śledztwa informacji wynika, że celem ataku będzie uniemożliwienie wysyłania komunikatów z serwera 1 do serweran. Wiadomo, że Bajtocki Internet niewiele różni się od tego jaki znamy. Składa się on z serwerów i łączy internetowych pomiędzy nimi. Jednakże bajtockie łącza są jednokierunkowe. Przebiegły informatyk \"S**\" pozakładał pułapki na łączach. Po aktywacji pułapka przerywa łącze, na którym została założona. Wiadomo, że \"S**\" zlecił założenie możliwie najmniejszej liczby pułapek, ale w sposób uniemożliwiający komunikację od serwera 1 do serweran. UOB zwraca się do Ciebie (jako najlepszego programisty :-)) z prośbą o pomoc. Chciałby wiedzieć ile pułapek polecił założyć \"S**\" (jak je znaleźć to już inna historia).",
    "input_description": "Na wejściu znajdują się informacje na temat bajtockiej sieci internetowej. W pierwszej lini są podane liczbynim, 2 ≤ n ≤ 10 000, oznaczające odpowiednio liczbę serwerów i łączy. Serwery ponumerowane są od 1 don. W następnychmwierszach znajdują się opisy łączy. Opis każdego łącza składa się z liczbaib, 1 ≤a,b≤n,a≠b. Oznaczają one, że istnieje łącze od serweraado serwerab. Wiadomo, że pomiędzy dwoma dowolnymi serwerami może istnieć tylko jedno bezpośrednie łącze.",
    "output_description": "Na wyjściu powinna znaleźć się jedna liczba - minimalna liczba pułapek, które polecił zastawić \"S**\", żeby przerwać połączenie pomiędzy serwerami 1 in.",
    "examples": [
      {
        "input": "5 5\n1 2\n1 3\n2 4\n3 4\n4 5",
        "output": "1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/8551",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "8898",
    "step_title": "네트워크 플로우 3",
    "title": "스포츠 전문 채널 GSK",
    "level": 22,
    "tags": [
      "그래프 이론",
      "방향 비순환 그래프",
      "이분 매칭"
    ],
    "description": "상근이는 자신의 이름을 딴 방송국 GSK를 만들었다. GSK는 스포츠 전문 방송국으로 곧 열리는 경기 N개를 모두 취재하려고 한다.각각의 스포츠 경기 Ei(1 ≤ i ≤ n)의 시작 시간은 si, 경기 시간은 di, 경기장은 gi이다. gi에서 gj로 가는 이동 시간은 ti,j(1 ≤ i,j ≤ n)이며, ti,j= tj,i와 ti,j≤ ti,k+ tk,j(1 ≤ i,j,k ≤ n)을 만족한다.리포터는 경기가 열리는 동안 그 경기장에서 계속 취재를 해야 한다. 즉, 한 리포터가 두 경기 Ei와 Ej를 취재하려면, si+ di+ ti,j≤ sj나 sj+ dj+ tj,i≤ si를 만족해야 한다.경기 정보가 모두 주어졌을 때, 한 리포터가 동시에 취재할 수 없는 가장 큰 경기의 부분집합을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 경기의 수 n (1 ≤ n ≤ 1,000)이 주어진다. 둘째 줄에는 각 경기의 시작 시간 si, 셋째 줄에는 경기 시간 di가 주어진다. (1 ≤ si, di≤ 1,000,000) 넷째 줄부터 총 n개 줄 중 i번째 줄에는 n-i+1개의 정수가 주어지며, ti,i, ti,i+1, ..., ti,n을 나타낸다. (0 ≤ ti,j≤ 1,000,000) ti,i는 항상 0이다.",
    "output_description": "각 테스트 케이스마다 두 줄을 출력한다. 첫째 줄은 한 리포터가 동시에 취재할 수 없는 가장 큰 경기의 부분집합의 크기 k이고, 둘째 줄에는 집합에 포함된 경기의 번호를 출력한다. (Ei에서 i) 가능한 정답이 여러 가지인 경우에는 아무거나 출력한다.",
    "examples": [
      {
        "input": "2\r\n3\r\n7 8 9\r\n1 1 1\r\n0 2 2\r\n0 1\r\n0\r\n2\r\n7 12\r\n3 2\r\n0 2\r\n0",
        "output": "3\r\n2 3 1\r\n1\r\n2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/8898",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "9012",
    "step_title": "스택, 큐, 덱 1",
    "title": "괄호",
    "level": 7,
    "tags": [
      "자료 구조",
      "문자열",
      "스택"
    ],
    "description": "괄호 문자열(Parenthesis String, PS)은 두 개의 괄호 기호인 ‘(’ 와 ‘)’ 만으로 구성되어 있는 문자열이다. 그 중에서 괄호의 모양이 바르게 구성된 문자열을 올바른 괄호 문자열(Valid PS, VPS)이라고 부른다. 한 쌍의 괄호 기호로 된 “( )” 문자열은 기본 VPS 이라고 부른다. 만일 x 가 VPS 라면 이것을 하나의 괄호에 넣은 새로운 문자열 “(x)”도 VPS 가 된다. 그리고 두 VPS x 와 y를 접합(concatenation)시킨 새로운 문자열 xy도 VPS 가 된다. 예를 들어 “(())()”와 “((()))” 는 VPS 이지만 “(()(”, “(())()))” , 그리고 “(()” 는 모두 VPS 가 아닌 문자열이다.여러분은 입력으로 주어진 괄호 문자열이 VPS 인지 아닌지를 판단해서 그 결과를 YES 와 NO 로 나타내어야 한다.",
    "input_description": "입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 주어진다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터의 첫째 줄에는 괄호 문자열이 한 줄에 주어진다. 하나의 괄호 문자열의 길이는 2 이상 50 이하이다.",
    "output_description": "출력은 표준 출력을 사용한다. 만일 입력 괄호 문자열이 올바른 괄호 문자열(VPS)이면 “YES”, 아니면 “NO”를 한 줄에 하나씩 차례대로 출력해야 한다.",
    "examples": [
      {
        "input": "6\n(())())\n(((()())()\n(()())((()))\n((()()(()))(((())))()\n()()()()(()()())()\n(()((())()(",
        "output": "NO\nNO\nYES\nNO\nYES\nNO"
      },
      {
        "input": "3\n((\n))\n())(()",
        "output": "NO\nNO\nNO"
      }
    ],
    "url": "https://www.acmicpc.net/problem/9012",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "T = int(input())\nfor _ in range(T):\n    s = input()\n    stack = []\n    valid = True\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                valid = False\n                break\n    if valid and not stack:\n        print(\"YES\")\n    else:\n        print(\"NO\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "9019",
    "step_title": "동적 계획법과 최단거리 역추적",
    "title": "DSLR",
    "level": 12,
    "tags": [
      "그래프 이론",
      "그래프 탐색",
      "너비 우선 탐색",
      "역추적"
    ],
    "description": "네 개의 명령어 D, S, L, R 을 이용하는 간단한 계산기가 있다. 이 계산기에는 레지스터가 하나 있는데, 이 레지스터에는 0 이상 10,000 미만의 십진수를 저장할 수 있다. 각 명령어는 이 레지스터에 저장된 n을 다음과 같이 변환한다. n의 네 자릿수를 d1, d2, d3, d4라고 하자(즉 n = ((d1× 10 + d2) × 10 + d3) × 10 + d4라고 하자)D: D 는 n을 두 배로 바꾼다. 결과 값이 9999 보다 큰 경우에는 10000 으로 나눈 나머지를 취한다. 그 결과 값(2n mod 10000)을 레지스터에 저장한다.S: S 는 n에서 1 을 뺀 결과 n-1을 레지스터에 저장한다. n이 0 이라면 9999 가 대신 레지스터에 저장된다.L: L 은 n의 각 자릿수를 왼편으로 회전시켜 그 결과를 레지스터에 저장한다. 이 연산이 끝나면 레지스터에 저장된 네 자릿수는 왼편부터 d2, d3, d4, d1이 된다.R: R 은 n의 각 자릿수를 오른편으로 회전시켜 그 결과를 레지스터에 저장한다. 이 연산이 끝나면 레지스터에 저장된 네 자릿수는 왼편부터 d4, d1, d2, d3이 된다.위에서 언급한 것처럼, L 과 R 명령어는 십진 자릿수를 가정하고 연산을 수행한다. 예를 들어서 n = 1234 라면 여기에 L 을 적용하면 2341 이 되고 R 을 적용하면 4123 이 된다.여러분이 작성할 프로그램은 주어진 서로 다른 두 정수 A와 B(A ≠ B)에 대하여 A를 B로 바꾸는 최소한의 명령어를 생성하는 프로그램이다. 예를 들어서 A = 1234, B = 3412 라면 다음과 같이 두 개의 명령어를 적용하면 A를 B로 변환할 수 있다.1234 →L2341 →L34121234 →R4123 →R3412따라서 여러분의 프로그램은 이 경우에 LL 이나 RR 을 출력해야 한다.n의 자릿수로 0 이 포함된 경우에 주의해야 한다. 예를 들어서 1000 에 L 을 적용하면 0001 이 되므로 결과는 1 이 된다. 그러나 R 을 적용하면 0100 이 되므로 결과는 100 이 된다.",
    "input_description": "프로그램 입력은 T 개의 테스트 케이스로 구성된다. 테스트 케이스 개수 T 는 입력의 첫 줄에 주어진다. 각 테스트 케이스로는 두 개의 정수 A와 B(A ≠ B)가 공백으로 분리되어 차례로 주어지는데 A는 레지스터의 초기 값을 나타내고 B는 최종 값을 나타낸다. A 와 B는 모두 0 이상 10,000 미만이다.",
    "output_description": "A에서 B로 변환하기 위해 필요한 최소한의 명령어 나열을 출력한다. 가능한 명령어 나열이 여러가지면, 아무거나 출력한다.",
    "examples": [
      {
        "input": "3\n1234 3412\n1000 1\n1 16",
        "output": "LL\nL\nDDDD"
      }
    ],
    "url": "https://www.acmicpc.net/problem/9019",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import deque\n\nT = int(input())\nfor _ in range(T):\n    A, B = map(int, input().split())\n    \n    if A == B:\n        print()\n        continue\n    \n    visited = [False] * 10000\n    queue = deque([(A, \"\")])\n    visited[A] = True\n    \n    while queue:\n        num, commands = queue.popleft()\n        \n        if num == B:\n            print(commands)\n            break\n        \n        # D\n        d = (num * 2) % 10000\n        if not visited[d]:\n            visited[d] = True\n            queue.append((d, commands + \"D\"))\n        \n        # S\n        s = (num - 1) % 10000\n        if not visited[s]:\n            visited[s] = True\n            queue.append((s, commands + \"S\"))\n        \n        # L\n        l = (num % 1000) * 10 + num // 1000\n        if not visited[l]:\n            visited[l] = True\n            queue.append((l, commands + \"L\"))\n        \n        # R\n        r = (num % 10) * 1000 + num // 10\n        if not visited[r]:\n            visited[r] = True\n            queue.append((r, commands + \"R\"))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "9063",
    "step_title": "기하 1: 직사각형과 삼각형",
    "title": "대지",
    "level": 3,
    "tags": [
      "수학",
      "구현",
      "기하학"
    ],
    "description": "임씨는 1950 년 한국전쟁으로 많은 손해를 본 사람들 중 하나다. 전쟁 통에 손해보지 않은 사람이 어디 있을까 만은 그는 6.25 가 일어나기 전만 해도 충청도 지방에 넓은 대지를 소유한 큰 부자였다. 전쟁이 나자 임씨는 땅문서와 값 나가는 것들만 챙겨서 일본으로 피난을 가지만 피난 중에 그만 땅문서를 잃어버리고 만다. 전쟁이 끝난 후에 임씨의 땅은 이미 다른 사람들의 논밭이 되어 있었고, 임씨는 땅을 되찾으려 했지만 문서가 없으니 생떼 쓰는 것과 다를 바 없었다. 이러다가 임씨는 길바닥에 나앉게 생겼다.이때, 임씨에게 좋은 생각이 떠올랐으니 바로 자신이 습관처럼 땅 깊숙이 뭔가 표식을 해놓았던 사실이다. 임씨는 한적할 때마다 자신의 논밭을 거닐다가 땅속 깊은 곳에 자신의 이름이 씌어진 옥구슬을 묻어놓았던 것이다. 즉, 어떤 지점에서 그의 이름이 적힌 옥구슬이 나온다면 그 지점은 예전에 임씨의 땅이었다는 것을 증명하는 것이다.임씨는 즉시 민사소송을 통해 자신의 땅을 찾고자 했고 논리적인 근거를 들어 옥구슬이 나오는 지점이 원래 자신의 땅의 한 지점이었다는 것을 주장하여 결국 담당판사를 설득하는 데에 성공하였다. 담당판사는 다음과 같은 판결을 내렸다. “ 6.25 이전의 개인소유 대지들은 99%가 남북, 동서 방향으로 평행한 직사각형 모양이었으므로, 임씨의 이름이 새겨진 옥구슬이 나오는 모든 지점을 포함하는 가장 작은 남북, 동서 방향으로 평행한 변을 갖는 직사각형의 대지를 임씨의 소유로 인정한다.” 임씨는 많은 손해를 보는 셈이지만 더 이상을 요구할 만한 근거가 없었기 때문에 이 판결을 따르기로 했다.임씨의 이름이 새겨진 옥구슬의 위치 N 개가 주어질 때에, 임씨에게 돌아갈 대지의 넓이를 계산하는 프로그램을 작성하시오. 단, 옥구슬의 위치는 2 차원 정수 좌표로 주어지고 옥구슬은 같은 위치에 여러 개가 발견될 수도 있으며, x 축의 양의방향을 동쪽, y 축의 양의방향을 북쪽이라고 가정한다.예를 들어 위와 같이 (2, 1), (3, 2), (5, 2), (3, 4) 네 점에서 옥구슬을 발견하였다면, 임씨에게 돌아갈 대지는 (2, 1), (5, 1), (2, 4), (5, 4)를 네 꼭짓점으로 하는 직사각형이며, 넓이는 (5 - 2) × (4 - 1) = 9 가 된다.",
    "input_description": "첫째 줄에는 점의 개수 N (1 ≤ N ≤ 100,000) 이 주어진다. 이어지는 N 줄에는 각 점의 좌표가 두 개의 정수로 한 줄에 하나씩 주어진다. 각각의 좌표는 -10,000 이상 10,000 이하의 정수이다.",
    "output_description": "첫째 줄에 N 개의 점을 둘러싸는 최소 크기의 직사각형의 넓이를 출력하시오.",
    "examples": [
      {
        "input": "3\n20 24\n40 21\n10 12",
        "output": "360"
      },
      {
        "input": "1\n15 13",
        "output": "0"
      },
      {
        "input": "4\n2 1\n3 2\n5 2\n3 4",
        "output": "9"
      }
    ],
    "url": "https://www.acmicpc.net/problem/9063",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nif N == 1:\n    print(0)\nelse:\n    x_coords = []\n    y_coords = []\n    for _ in range(N):\n        x, y = map(int, input().split())\n        x_coords.append(x)\n        y_coords.append(y)\n    \n    width = max(x_coords) - min(x_coords)\n    height = max(y_coords) - min(y_coords)\n    print(width * height)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "9086",
    "step_title": "문자열",
    "title": "문자열",
    "level": 1,
    "tags": [
      "구현",
      "문자열"
    ],
    "description": "문자열을 입력으로 주면 문자열의 첫 글자와 마지막 글자를 출력하는 프로그램을 작성하시오.",
    "input_description": "입력의 첫 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 10)가 주어진다. 각 테스트 케이스는 한 줄에 하나의 문자열이 주어진다. 문자열은 알파벳 A~Z 대문자로 이루어지며 알파벳 사이에 공백은 없으며 문자열의 길이는 1000보다 작다.",
    "output_description": "각 테스트 케이스에 대해서 주어진 문자열의 첫 글자와 마지막 글자를 연속하여 출력한다.",
    "examples": [
      {
        "input": "3\nACDKJFOWIEGHE\nO\nAB",
        "output": "AE\nOO\nAB"
      }
    ],
    "url": "https://www.acmicpc.net/problem/9086",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "T = int(input())\nfor _ in range(T):\n    s = input()\n    print(s[0] + s[-1])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "T = int(input())\nfor _ in range(T):\n    s = input()\n    print(s[0] + s[-1])",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "9184",
    "step_title": "동적 계획법 1",
    "title": "신나는 함수 실행",
    "level": 9,
    "tags": [
      "다이나믹 프로그래밍",
      "재귀"
    ],
    "description": "재귀 호출만 생각하면 신이 난다! 아닌가요?다음과 같은 재귀함수 w(a, b, c)가 있다.if a <= 0 or b <= 0 or c <= 0, then w(a, b, c) returns:\r\n    1\r\n\r\nif a > 20 or b > 20 or c > 20, then w(a, b, c) returns:\r\n    w(20, 20, 20)\r\n\r\nif a < b and b < c, then w(a, b, c) returns:\r\n    w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c)\r\n\r\notherwise it returns:\r\n    w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1)위의 함수를 구현하는 것은 매우 쉽다. 하지만, 그대로 구현하면 값을 구하는데 매우 오랜 시간이 걸린다. (예를 들면, a=15, b=15, c=15)a, b, c가 주어졌을 때, w(a, b, c)를 출력하는 프로그램을 작성하시오.",
    "input_description": "입력은 세 정수 a, b, c로 이루어져 있으며, 한 줄에 하나씩 주어진다. 입력의 마지막은 -1 -1 -1로 나타내며, 세 정수가 모두 -1인 경우는 입력의 마지막을 제외하면 없다.",
    "output_description": "입력으로 주어진 각각의 a, b, c에 대해서, w(a, b, c)를 출력한다.",
    "examples": [
      {
        "input": "1 1 1\n2 2 2\n10 4 6\n50 50 50\n-1 7 18\n-1 -1 -1",
        "output": "w(1, 1, 1) = 2\nw(2, 2, 2) = 4\nw(10, 4, 6) = 523\nw(50, 50, 50) = 1048576\nw(-1, 7, 18) = 1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/9184",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def w(a, b, c):\n    if a <= 0 or b <= 0 or c <= 0:\n        return 1\n    \n    if a > 20 or b > 20 or c > 20:\n        return w(20, 20, 20)\n    \n    if dp[a][b][c]:\n        return dp[a][b][c]\n    \n    if a < b < c:\n        dp[a][b][c] = w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c)\n    else:\n        dp[a][b][c] = w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1)\n    \n    return dp[a][b][c]\n\ndp = [[[0] * 21 for _ in range(21)] for _ in range(21)]\n\nwhile True:\n    a, b, c = map(int, input().split())\n    if a == -1 and b == -1 and c == -1:\n        break\n    print(f\"w({a}, {b}, {c}) = {w(a, b, c)}\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "9248",
    "step_title": "문자열 알고리즘 2",
    "title": "Suffix Array",
    "level": 18,
    "tags": [
      "문자열",
      "접미사 배열과 LCP 배열"
    ],
    "description": "Suffix Array란, 문자열 S가 있을 때 그 접미사들을 정렬해 놓은 배열이다. 예를 들어, 문자열 S=banana의 접미사는 아래와 같이 총 6개가 있다.Suffixibanana1anana2nana3ana4na5a6이를 Suffix 순으로 정렬하면 아래와 같다.Suffixia6ana4anana2banana1na5nana3정렬된 i의 배열 [6,4,2,1,5,3]을 S의 Suffix Array라고 한다.문자열 S의 LCP Array는 Suffix Array를 구한 다음, 각 Suffix마다 정렬된 상태에서 바로 이전 Suffix와의 LCP (Longest Common Prefix, 최장 공통 접두사)의 길이를 배열에 담은 것이다. 위의 예에서 LCP Array는 [x,1,3,0,0,2]가 된다.길이가 50만보다 작거나 같은 문자열이 주어졌을 때, Suffix Array와 LCP Array를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 알파벳 소문자로만 이루어진 문자열 S가 주어진다. S의 길이는 50만보다 작거나 같다.",
    "output_description": "첫째 줄에는 Suffix Array를, 둘째 줄에는 LCP Array를 공백으로 구분하여 출력한다. LCP Array의 첫 값은 항상 'x'이다.",
    "examples": [
      {
        "input": "abracadabra",
        "output": "11 8 1 4 6 9 2 5 7 10 3\r\nx 1 4 1 1 0 3 0 0 0 2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/9248",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "9250",
    "step_title": "문자열 알고리즘 2",
    "title": "문자열 집합 판별",
    "level": 19,
    "tags": [
      "자료 구조",
      "문자열",
      "트리",
      "트라이",
      "아호-코라식"
    ],
    "description": "집합 S는 크기가 N이고, 원소가 문자열인 집합이다. Q개의 문자열이 주어졌을 때, 각 문자열의 부분 문자열이 집합 S에 있는지 판별하는 프로그램을 작성하시오. 문자열의 여러 부분 문자열 중 하나라도 집합 S에 있으면 'YES'를 출력하고, 아무것도 없으면 'NO'를 출력한다.예를 들어, 집합 S = {\"www\",\"woo\",\"jun\"} 일 때, \"myungwoo\"의 부분 문자열인 \"woo\" 가 집합 S에 있으므로 답은 'YES'이고, \"hongjun\"의 부분 문자열 \"jun\"이 집합 S에 있으므로 답은 'YES'이다. 하지만, \"dooho\"는 모든 부분 문자열이 집합 S에 없기 때문에 답은 'NO'이다.",
    "input_description": "첫째 줄에 집합 S의 크기 N이 주어진다. (1 ≤ N ≤ 1000)다음 N개 줄에 집합 S의 원소들이 주어진다. 이 문자열의 길이는 100을 넘지 않는다.다음 줄에 답을 판별해야 하는 문자열의 개수 Q가 주어진다. (1 ≤ Q ≤ 1000)다음 Q개 줄에 답을 판별해야 하는 문자열이 주어진다. 이 문자열의 길이는 10000을 넘지 않는다.입력으로 주어지는 모든 문자열은 알파벳 소문자로만 이루어져 있다.",
    "output_description": "Q개 줄에 각 문자열에 대한 답을 출력한다.",
    "examples": [
      {
        "input": "3\nwww\nwoo\njun\n3\nmyungwoo\nhongjun\ndooho",
        "output": "YES\nYES\nNO"
      }
    ],
    "url": "https://www.acmicpc.net/problem/9250",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 그래프 문제 기본 구조\nfrom collections import deque\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\n# BFS/DFS 구현\nvisited = [False] * (N + 1)\n\ndef bfs(start):\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        node = queue.popleft()\n        for next_node in graph[node]:\n            if not visited[next_node]:\n                visited[next_node] = True\n                queue.append(next_node)\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "9251",
    "step_title": "동적 계획법 1",
    "title": "LCS",
    "level": 11,
    "tags": [
      "다이나믹 프로그래밍",
      "문자열",
      "최장 공통 부분 수열 문제"
    ],
    "description": "LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.",
    "input_description": "첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다.",
    "output_description": "첫째 줄에 입력으로 주어진 두 문자열의 LCS의 길이를 출력한다.",
    "examples": [
      {
        "input": "ACAYKP\nCAPCAK",
        "output": "4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/9251",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "A = input()\nB = input()\n\ndp = [[0] * (len(B) + 1) for _ in range(len(A) + 1)]\n\nfor i in range(1, len(A) + 1):\n    for j in range(1, len(B) + 1):\n        if A[i-1] == B[j-1]:\n            dp[i][j] = dp[i-1][j-1] + 1\n        else:\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\nprint(dp[len(A)][len(B)])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "9252",
    "step_title": "동적 계획법과 최단거리 역추적",
    "title": "LCS 2",
    "level": 12,
    "tags": [
      "다이나믹 프로그래밍",
      "문자열",
      "역추적",
      "최장 공통 부분 수열 문제"
    ],
    "description": "LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.",
    "input_description": "첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다.",
    "output_description": "첫째 줄에 입력으로 주어진 두 문자열의 LCS의 길이를, 둘째 줄에 LCS를 출력한다.LCS가 여러 가지인 경우에는 아무거나 출력하고, LCS의 길이가 0인 경우에는 둘째 줄을 출력하지 않는다.",
    "examples": [
      {
        "input": "ACAYKP\nCAPCAK",
        "output": "4\nACAK"
      }
    ],
    "url": "https://www.acmicpc.net/problem/9252",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "A = input()\nB = input()\n\ndp = [[0] * (len(B) + 1) for _ in range(len(A) + 1)]\n\nfor i in range(1, len(A) + 1):\n    for j in range(1, len(B) + 1):\n        if A[i-1] == B[j-1]:\n            dp[i][j] = dp[i-1][j-1] + 1\n        else:\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\nprint(dp[len(A)][len(B)])\n\nif dp[len(A)][len(B)] > 0:\n    result = []\n    i, j = len(A), len(B)\n    \n    while i > 0 and j > 0:\n        if A[i-1] == B[j-1]:\n            result.append(A[i-1])\n            i -= 1\n            j -= 1\n        elif dp[i-1][j] > dp[i][j-1]:\n            i -= 1\n        else:\n            j -= 1\n    \n    result.reverse()\n    print(''.join(result))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "9345",
    "step_title": "세그먼트 트리 1",
    "title": "디지털 비디오 디스크(DVDs)",
    "level": 18,
    "tags": [
      "자료 구조",
      "세그먼트 트리"
    ],
    "description": "최근 유튜브와 같은 온라인 비디오 스트리밍 서비스 때문에 DVD 대여점들이 자취를 감추고 있다. 이러한 어려운 상황 속에서, DVD 대여점 주인들은 실낱같은 희망을 잡고자 인기있는 N개의 DVD들로 구성된 시리즈를 구매한다(각 DVD들은 0번부터 N-1 까지 이루어져 있다).ACM 대여점의 주인 원주연 또한 울며 겨자먹기로 인기있는 시리즈물을 구매했고, 진열을 하기 위해 맞춤형 선반을 주문제작 하였다(맟춤제작이기 때문에 선반의 번호 또한 0번부터 N-1 까지 이루어져 있다). 주연이는 매우 정갈한 사람이기 때문에 DVD를 진열할 때 i번 DVD는 i번 선반에 진열을 한다.이 시리즈의 열렬한 팬인 민호는 주연이네 대여점에 시리즈가 입고되었다는 소식을 듣고 찾아왔다. 시리즈물은 연속으로 봐야 흥미가 안떨어지기 때문에 민호는 L번부터 R번까지의 DVD들을 빌리려고 한다. 민호는 주연이가 매우 정갈한 성격인 것임을 알기에 주연이를 믿고 실제 DVD들의 번호를 확인하지 않고 L번 선반부터 R번 선반까지 존재하는 DVD들을 들고 카운터에 가져왔다.그러나, 민호는 간과한 사실이 있다. 주연이네 대여점에는 진상 손님인 진일이가 찾아온다는 것이였다. 진일이는 선반 A 에 있는 DVD와 선반 B에 있는 DVD를 서로 바꿔 놓는다. 이러한 진일이의 몰상식한 행동때문에 민호와 같이 주연이를 믿고 DVD의 번호를 확인 안하는 선량한 고객들이 피해를 입는 사례들이 속출하였다. 아무 이유가 없는 묻지마 테러로 인해 가게매출이 떨어질 위기에 처하자 주연이는 진일이가 보일때마다 쫒아 냈지만, 시도때도없이 찾아오는 진일이의 진상짓을 막기에는 역부족이였다.이러한 주연이를 보고 안타까운 마음이 든 민호는 주연이를 위해 프로그램을 작성하기로 결심을 한다. 의욕이 넘치는 민호의 마음과는 달리 실력이 따라주지 못해 프로그램의 기능은 조촐하기만 하다. 프로그램의 기능은 다음과 같다.손님이 L번 선반부터 R번 선반까지에 있는 DVD들을 가져 왔을때 실제로 DVD가 L번부터 R번까지 있나 확인을 해 줄 수 있다.DVD의 순서는 상관이 없다. 예를 들어 손님이 2번 선반부터 4번 선반까지에 있는 DVD를 가져왔을 때 DVD가 2, 3, 4 순서로 진열되어 있건, 4, 2, 3 순서로 진열되어 있건 상관이 없다는 얘기다. 즉 L번부터 R번까지의 DVD가 있으면 된다.문제의 단순화를위해 고객이 DVD를 빌려가면, 그 즉시 시청한뒤 바로 반납한다고 가정한다. 또한 가져다 놓는 위치는 빌리기 전과 동일하다(4, 3, 2 순서로 진열되어 있었으면 다시 4, 3, 2 순서로 진열한다).",
    "input_description": "첫 번째 줄에는 테스트 케이스의 수 T가 주어진다. (T ≤ 20 인 자연수)각각의 테스트 케이스 첫 번째 줄에는 DVD들의 수를 의미하는 정수 N 과 대여점에서 일어나는 사건의 수를 의미하는 정수 K 가 주어진다. (1 ≤ N ≤ 100,000 , 1 ≤ K ≤ 50,000)이어서 대여점에서 일어나는 사건 K 개가 주어진다. 각각의 줄은 세 정수 Q, A, B 을 포함한다. (Q는 0또는 1이고, 0 ≤ A ≤ B < N )Q는 0 일때, 진상 손님 진일이가 선반 A의 DVD와 선반 B의 DVD를 서로 바꿔 끼우는 사건을 의미한다.Q가 1 일때는 손님이 선반 A부터 선반 B에 있는 DVD를 카운터에 가져오는 사건을 의미한다. 위에서도 언급했듯이 이 사건이 DVD들의 위치를 바꾸는 일은 일어나지 않는다.",
    "output_description": "손님이 DVD를 카운터에 가져왔을 때 손님이 원하는 DVD가 전부 존재하면, (A번 선반부터 B번 선반까지에 있는 DVD를 전부 가져왔을 때 순서에 상관없이 A번 DVD부터 B번 DVD까지 있다면) \"YES\"를 출력하고, 그렇지 않다면 \"NO\"를 출력한다.",
    "examples": [
      {
        "input": "2\n5 8\n1 0 4\n1 1 2\n0 1 3\n1 2 2\n1 1 3\n1 0 0\n1 0 2\n1 2 4\n5 5\n0 1 2\n0 2 3\n0 1 3\n1 0 1\n1 0 2",
        "output": "YES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nNO"
      }
    ],
    "url": "https://www.acmicpc.net/problem/9345",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "9370",
    "step_title": "최단 경로",
    "title": "미확인 도착지",
    "level": 14,
    "tags": [
      "그래프 이론",
      "최단 경로",
      "데이크스트라"
    ],
    "description": "(취익)B100 요원, 요란한 옷차림을 한 서커스 예술가 한 쌍이 한 도시의 거리들을 이동하고 있다. 너의 임무는 그들이 어디로 가고 있는지 알아내는 것이다. 우리가 알아낸 것은 그들이 s지점에서 출발했다는 것, 그리고 목적지 후보들 중 하나가 그들의 목적지라는 것이다. 그들이 급한 상황이기 때문에 목적지까지 우회하지 않고 최단거리로 갈 것이라 확신한다. 이상이다. (취익)어휴! (요란한 옷차림을 했을지도 모를) 듀오가 어디에도 보이지 않는다. 다행히도 당신은 후각이 개만큼 뛰어나다. 이 후각으로 그들이 g와 h 교차로 사이에 있는 도로를 지나갔다는 것을 알아냈다.이 듀오는 대체 어디로 가고 있는 것일까?예제 입력의 두 번째 케이스를 시각화한 것이다. 이 듀오는 회색 원에서 두 검은 원 중 하나로 가고 있고 점선으로 표시된 도로에서 냄새를 맡았다. 따라서 그들은 6으로 향하고 있다.",
    "input_description": "첫 번째 줄에는 테스트 케이스의 T(1 ≤ T ≤ 100)가 주어진다. 각 테스트 케이스마다첫 번째 줄에 3개의 정수 n, m, t (2 ≤ n ≤ 2 000, 1 ≤ m ≤ 50 000 and 1 ≤ t ≤ 100)가 주어진다. 각각 교차로, 도로, 목적지 후보의 개수이다.두 번째 줄에 3개의 정수 s, g, h (1 ≤ s, g, h ≤ n)가 주어진다. s는 예술가들의 출발지이고, g, h는 문제 설명에 나와 있다. (g ≠ h)그 다음 m개의 각 줄마다 3개의 정수 a, b, d (1 ≤ a < b ≤ n and 1 ≤ d ≤ 1 000)가 주어진다. a와 b 사이에 길이 d의 양방향 도로가 있다는 뜻이다.그 다음 t개의 각 줄마다 정수 x가 주어지는데, t개의 목적지 후보들을 의미한다. 이 t개의 지점들은 서로 다른 위치이며 모두 s와 같지 않다.교차로 사이에는 도로가 많아봐야 1개이다. m개의 줄 중에서 g와 h 사이의 도로를 나타낸 것이 존재한다. 또한 이 도로는 목적지 후보들 중 적어도 1개로 향하는 최단 경로의 일부이다.",
    "output_description": "테스트 케이스마다입력에서 주어진 목적지 후보들 중 불가능한 경우들을 제외한 목적지들을 공백으로 분리시킨 오름차순의 정수들로 출력한다.",
    "examples": [
      {
        "input": "2\n5 4 2\n1 2 3\n1 2 6\n2 3 2\n3 4 4\n3 5 3\n5\n4\n6 9 2\n2 3 1\n1 2 1\n1 3 3\n2 4 4\n2 5 5\n3 4 3\n3 6 2\n4 5 4\n4 6 3\n5 6 7\n5\n6",
        "output": "4 5\n6"
      }
    ],
    "url": "https://www.acmicpc.net/problem/9370",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import heapq\nimport sys\ninput = sys.stdin.readline\nINF = float('inf')\n\ndef dijkstra(graph, start, n):\n    dist = [INF] * (n + 1)\n    dist[start] = 0\n    heap = [(0, start)]\n    \n    while heap:\n        d, node = heapq.heappop(heap)\n        if d > dist[node]:\n            continue\n        for next_node, weight in graph[node]:\n            new_dist = d + weight\n            if new_dist < dist[next_node]:\n                dist[next_node] = new_dist\n                heapq.heappush(heap, (new_dist, next_node))\n    \n    return dist\n\nT = int(input())\nfor _ in range(T):\n    n, m, t = map(int, input().split())\n    s, g, h = map(int, input().split())\n    \n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b, d = map(int, input().split())\n        graph[a].append((b, d))\n        graph[b].append((a, d))\n    \n    candidates = []\n    for _ in range(t):\n        candidates.append(int(input()))\n    \n    dist_from_s = dijkstra(graph, s, n)\n    dist_from_g = dijkstra(graph, g, n)\n    dist_from_h = dijkstra(graph, h, n)\n    \n    # g-h 간 거리\n    gh_dist = 0\n    for next_node, weight in graph[g]:\n        if next_node == h:\n            gh_dist = weight\n            break\n    \n    result = []\n    for cand in candidates:\n        # s -> g -> h -> cand or s -> h -> g -> cand\n        path1 = dist_from_s[g] + gh_dist + dist_from_h[cand]\n        path2 = dist_from_s[h] + gh_dist + dist_from_g[cand]\n        \n        if min(path1, path2) == dist_from_s[cand]:\n            result.append(cand)\n    \n    result.sort()\n    print(' '.join(map(str, result)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "9372",
    "step_title": "최소 신장 트리",
    "title": "상근이의 여행",
    "level": 7,
    "tags": [
      "그래프 이론",
      "트리"
    ],
    "description": "상근이는 겨울방학을 맞아 N개국을 여행하면서 자아를 찾기로 마음먹었다.하지만 상근이는 새로운 비행기를 무서워하기 때문에, 최대한 적은 종류의 비행기를 타고 국가들을 이동하려고 한다.이번 방학 동안의 비행 스케줄이 주어졌을 때, 상근이가가장 적은 종류의 비행기를 타고 모든 국가들을 여행할 수 있도록 도와주자.상근이가 한 국가에서 다른 국가로 이동할 때 다른 국가를 거쳐 가도(심지어 이미 방문한 국가라도) 된다.",
    "input_description": "첫 번째 줄에는 테스트 케이스의 수 T(T ≤ 100)가 주어지고,각 테스트 케이스마다 다음과 같은 정보가 주어진다.첫 번째 줄에는 국가의 수 N(2 ≤ N ≤ 1 000)과 비행기의 종류 M(1 ≤ M ≤ 10 000) 가 주어진다.이후 M개의 줄에 a와 b 쌍들이 입력된다. a와 b를 왕복하는 비행기가 있다는 것을 의미한다. (1 ≤ a, b ≤ n; a ≠ b)주어지는 비행 스케줄은 항상 연결 그래프를 이룬다.",
    "output_description": "테스트 케이스마다 한 줄을 출력한다.상근이가 모든 국가를 여행하기 위해 타야 하는 비행기 종류의 최소 개수를 출력한다.",
    "examples": [
      {
        "input": "2\r\n3 3\r\n1 2\r\n2 3\r\n1 3\r\n5 4\r\n2 1\r\n2 3\r\n4 3\r\n4 5",
        "output": "2\r\n4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/9372",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def find(x):\n    if parent[x] != x:\n        parent[x] = find(parent[x])\n    return parent[x]\n\ndef union(x, y):\n    x = find(x)\n    y = find(y)\n    if x != y:\n        parent[y] = x\n        return True\n    return False\n\nT = int(input())\nfor _ in range(T):\n    N, M = map(int, input().split())\n    parent = list(range(N + 1))\n    \n    edges = []\n    for _ in range(M):\n        a, b = map(int, input().split())\n        edges.append((a, b))\n    \n    count = 0\n    for a, b in edges:\n        if union(a, b):\n            count += 1\n    \n    print(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "9461",
    "step_title": "동적 계획법 1",
    "title": "파도반 수열",
    "level": 8,
    "tags": [
      "수학",
      "다이나믹 프로그래밍"
    ],
    "description": "오른쪽 그림과 같이 삼각형이 나선 모양으로 놓여져 있다. 첫 삼각형은 정삼각형으로 변의 길이는 1이다. 그 다음에는 다음과 같은 과정으로 정삼각형을 계속 추가한다. 나선에서 가장 긴 변의 길이를 k라 했을 때, 그 변에 길이가 k인 정삼각형을 추가한다.파도반 수열 P(N)은 나선에 있는 정삼각형의 변의 길이이다. P(1)부터 P(10)까지 첫 10개 숫자는 1, 1, 1, 2, 2, 3, 4, 5, 7, 9이다.N이 주어졌을 때, P(N)을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. (1 ≤ N ≤ 100)",
    "output_description": "각 테스트 케이스마다 P(N)을 출력한다.",
    "examples": [
      {
        "input": "2\r\n6\r\n12",
        "output": "3\r\n16"
      }
    ],
    "url": "https://www.acmicpc.net/problem/9461",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "T = int(input())\nP = [0] * 101\nP[1] = P[2] = P[3] = 1\n\nfor i in range(4, 101):\n    P[i] = P[i-2] + P[i-3]\n\nfor _ in range(T):\n    N = int(input())\n    print(P[N])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "9483",
    "step_title": "문자열 알고리즘 2",
    "title": "Tandem Repeats",
    "level": 22,
    "tags": [
      "수학",
      "문자열",
      "분할 정복",
      "접미사 배열과 LCP 배열",
      "조화수",
      "z"
    ],
    "description": "Tandem Repeats occur in DNA when a pattern of one or more nucleotides is repeated,and the repetitions are directly adjacent to each other. For example, consider the sequence:ATTCGATTCGATTCGThis contains 9 Tandem Repeats:ATTCGATTCGATTCGATTCGATTCGATTCGATTCGATTCGATTCGATTCGATTCGATTCGATTCGATTCGATTCGATTCGATTCGATTCGATTCGATTCGATTCGATTCGATTCGATTCGATTCGATTCGATTCGGiven a nucleotide sequence, how many Tandem Repeats occur in it?",
    "input_description": "There will be several test cases in the input. Each test case will consist of a single string on its own line, with from 1 to 100,000 capital letters, consisting only of A, G, T and C. This represents a nucleotide sequence. The input will end with a line with a single 0.",
    "output_description": "For each test case, output a single integer on its own line, indicating the number Tandem Repeats in the nucleotide sequence. Output no spaces, and do not separate answers with blank lines.",
    "examples": [
      {
        "input": "AGGA\r\nAGAG\r\nATTCGATTCGATTCG\r\n0",
        "output": "1\r\n1\r\n9"
      }
    ],
    "url": "https://www.acmicpc.net/problem/9483",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 수학 문제 기본 구조\ndef solve():\n    # 입력 처리\n    N = int(input())\n    \n    # 계산\n    result = N\n    \n    return result\n\nprint(solve())",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "9498",
    "step_title": "조건문",
    "title": "시험 성적",
    "level": 1,
    "tags": [
      "구현"
    ],
    "description": "시험 점수를 입력받아 90 ~ 100점은 A, 80 ~ 89점은 B, 70 ~ 79점은 C, 60 ~ 69점은 D, 나머지 점수는 F를 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 시험 점수가 주어진다. 시험 점수는 0보다 크거나 같고, 100보다 작거나 같은 정수이다.",
    "output_description": "시험 성적을 출력한다.",
    "examples": [
      {
        "input": "100",
        "output": "A"
      }
    ],
    "url": "https://www.acmicpc.net/problem/9498",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "score = int(input())\nif score >= 90:\n    print(\"A\")\nelif score >= 80:\n    print(\"B\")\nelif score >= 70:\n    print(\"C\")\nelif score >= 60:\n    print(\"D\")\nelse:\n    print(\"F\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "점수 입력",
            "description": "시험 점수를 입력받습니다.",
            "code_pattern": "score = int(input())",
            "socratic_hint": "점수를 입력받으려면?",
            "hint": "score = int(input())"
          },
          {
            "step_id": 2,
            "goal": "90점 이상 확인 (A)",
            "description": "점수가 90점 이상이면 'A'를 출력합니다.",
            "code_pattern": "if score >= 90:\n    print(\"A\")",
            "socratic_hint": "90점 이상은 무슨 학점인가요?",
            "hint": "if score >= 90: print(\"A\")"
          },
          {
            "step_id": 3,
            "goal": "80점 이상 확인 (B)",
            "description": "80점 이상이면 'B'를 출력합니다.",
            "code_pattern": "elif score >= 80:\n    print(\"B\")",
            "socratic_hint": "80점 이상은 무슨 학점인가요?",
            "hint": "elif score >= 80: print(\"B\")"
          },
          {
            "step_id": 4,
            "goal": "70점, 60점 이상 확인 (C, D)",
            "description": "70점 이상이면 'C', 60점 이상이면 'D'를 출력합니다.",
            "code_pattern": "elif score >= 70:\n    print(\"C\")\nelif score >= 60:\n    print(\"D\")",
            "socratic_hint": "70점과 60점 기준은?",
            "hint": "C는 70점 이상, D는 60점 이상입니다."
          },
          {
            "step_id": 5,
            "goal": "60점 미만 처리 (F)",
            "description": "나머지(60점 미만)는 'F'를 출력합니다.",
            "code_pattern": "else:\n    print(\"F\")",
            "socratic_hint": "60점 미만은 무슨 학점인가요?",
            "hint": "else: print(\"F\")"
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: 삼항 연산자 활용",
        "solution_code": "score = int(input())\ngrade = 'A' if score >= 90 else 'B' if score >= 80 else 'C' if score >= 70 else 'D' if score >= 60 else 'F'\nprint(grade)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "필요한 값을 입력받습니다.",
            "code_pattern": "A, B = map(int, input().split())",
            "socratic_hint": "입력을 받으려면?",
            "hint": "input()과 split()을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "삼항 연산자로 조건 판단",
            "description": "삼항 연산자를 연쇄적으로 사용하여 조건을 판단합니다.",
            "code_pattern": "결과 = 값1 if 조건1 else 값2 if 조건2 else 값3",
            "socratic_hint": "여러 조건을 간결하게 표현하려면?",
            "hint": "삼항 연산자를 연쇄적으로 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3: 딕셔너리 범위",
        "solution_code": "score = int(input())\ngrades = {9: 'A', 8: 'B', 7: 'C', 6: 'D'}\nprint(grades.get(score // 10, 'F'))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "점수를 10으로 나눔",
            "description": "점수를 10으로 나누어 딕셔너리 키로 사용합니다.",
            "code_pattern": "grades.get(score // 10, 'F')",
            "socratic_hint": "점수 범위를 간단히 처리하려면?",
            "hint": "10으로 나눈 몫을 사용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4: bisect 활용",
        "solution_code": "import bisect\nscore = int(input())\nbreaks = [0, 60, 70, 80, 90]\ngrades = ['F', 'D', 'C', 'B', 'A']\nprint(grades[bisect.bisect(breaks, score) - 1])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "bisect로 구간 찾기",
            "description": "bisect 모듈로 점수 구간을 찾습니다.",
            "code_pattern": "bisect.bisect(breaks, score)",
            "socratic_hint": "정렬된 리스트에서 위치를 찾으려면?",
            "hint": "bisect 모듈을 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "9506",
    "step_title": "약수, 배수와 소수 1",
    "title": "약수들의 합",
    "level": 5,
    "tags": [
      "수학",
      "구현",
      "정수론"
    ],
    "description": "어떤 숫자 n이 자신을 제외한 모든 약수들의 합과 같으면,그 수를 완전수라고 한다.예를 들어 6은 6 = 1 + 2 + 3 으로 완전수이다.n이 완전수인지 아닌지 판단해주는 프로그램을 작성하라.",
    "input_description": "입력은 테스트 케이스마다 한 줄 간격으로 n이 주어진다. (2 < n < 100,000)입력의 마지막엔 -1이 주어진다.",
    "output_description": "테스트케이스 마다 한줄에 하나씩 출력해야 한다.n이 완전수라면, n을 n이 아닌 약수들의 합으로 나타내어 출력한다(예제 출력 참고).이때, 약수들은 오름차순으로 나열해야 한다.n이 완전수가 아니라면 n is NOT perfect. 를 출력한다.",
    "examples": [
      {
        "input": "6\n12\n28\n-1",
        "output": "6 = 1 + 2 + 3\n12 is NOT perfect.\n28 = 1 + 2 + 4 + 7 + 14"
      }
    ],
    "url": "https://www.acmicpc.net/problem/9506",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "while True:\n    n = int(input())\n    if n == -1:\n        break\n    divisors = [i for i in range(1, n) if n % i == 0]\n    if sum(divisors) == n:\n        print(f\"{n} = \" + \" + \".join(map(str, divisors)))\n    else:\n        print(f\"{n} is NOT perfect.\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "while True:\n    n = int(input())\n    if n == -1:\n        break\n    divisors = [i for i in range(1, n",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "9522",
    "step_title": "네트워크 플로우 3",
    "title": "직선 게임",
    "level": 22,
    "tags": [
      "이분 매칭",
      "게임 이론"
    ],
    "description": "상근이와 선영이는 새로운 게임을 만들기로 했다.게임을 시작하기에 앞서 두 사람은 먼저 좌표 평면에 점 N개를 그린다. 그 다음, 턴을 번갈아가면서 게임을 하며, 상근이가 게임을 먼저 시작한다.상근이는 점 N개중 하나를 통과하고, 좌표축 중 하나에 평행한 직선을 하나 그린다. 그 다음부터는 각 플레이어는 좌표축에 평행하면서 N개의 점 가운데 상대방이 이전에 그린 직선 위의 점을 지나는 직선을 하나 그린다. 같은 직선을 두 번 그릴 수는 없다. 더 이상 그릴 수 있는 직선이 없는 사람이 게임을 지게 된다.누가 이기는 전략을 가지고 있는지 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N이 주어진다. (1 ≤ N ≤ 10,000)다음 N개 줄에는 그린 점의 좌표 X와 Y가 주어진다. (1 ≤ X, Y ≤ 500)",
    "output_description": "상근이가 이기는 경우에는 'Mirko'를, 선영이가 이기는 경우에는 'Slavko'를 출력한다.",
    "examples": [
      {
        "input": "3\n1 1\n1 2\n1 3",
        "output": "Mirko"
      },
      {
        "input": "4\n1 1\n1 2\n2 1\n2 2",
        "output": "Slavko"
      }
    ],
    "url": "https://www.acmicpc.net/problem/9522",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "9658",
    "step_title": "스프라그 그런디 정리",
    "title": "돌 게임 4",
    "level": 9,
    "tags": [
      "다이나믹 프로그래밍",
      "게임 이론"
    ],
    "description": "돌 게임은 두 명이서 즐기는 재밌는 게임이다.탁자 위에 돌 N개가 있다. 상근이와 창영이는 턴을 번갈아가면서 돌을 가져가며, 돌은 1개, 3개 또는 4개 가져갈 수 있다. 마지막 돌을 가져가는 사람이 게임을 지게 된다.두 사람이 완벽하게 게임을 했을 때, 이기는 사람을 구하는 프로그램을 작성하시오. 게임은 상근이가 먼저 시작한다.",
    "input_description": "첫째 줄에 N이 주어진다. (1 ≤ N ≤ 1000)",
    "output_description": "상근이가 게임을 이기면 SK를, 창영이가 게임을 이기면 CY을 출력한다.",
    "examples": [
      {
        "input": "6",
        "output": "SK"
      }
    ],
    "url": "https://www.acmicpc.net/problem/9658",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "9662",
    "step_title": "스프라그 그런디 정리",
    "title": "돌 게임 8",
    "level": 20,
    "tags": [
      "다이나믹 프로그래밍",
      "게임 이론"
    ],
    "description": "돌 게임은 두 명이서 즐기는 재밌는 게임이다.탁자 위에 돌 N개가 있다. 상근이와 창영이는 턴을 번갈아가면서 돌을 가져가며, 가져갈 수 있는 돌의 개수는 정해져있다. 돌을 올바른 개수만큼 가져갈 수 있는 방법이 없는 사람이 게임을 지게 된다.M과 가져갈 수 있는 돌의 개수가 주어졌을 때, 창영이가 이기는 N중에서 1보다 크거나 같고, M보다 작거나 같은 것의 개수를 구하는 프로그램을 작성하시오. 게임은 상근이가 먼저 시작한다.",
    "input_description": "첫째 줄에 M이 주어진다. (1 ≤ M ≤ 109)둘째 줄에는 가져갈 수 있는 방법의 수 K가 주어진다. (1 ≤ K ≤ 22)셋째 줄에는 가져갈 수 있는 돌의 개수가 공백으로 구분되어서 주어진다. 개수는 1보다 크거나 같고, 22보다 작거나 같으며, 중복되는 수는 없다. 또, 오름차순으로 주어진다.",
    "output_description": "창영이가 이기는 N의 개수를 출력한다. (1 ≤ N ≤ M)",
    "examples": [
      {
        "input": "20\n3\n1 2 3",
        "output": "5"
      },
      {
        "input": "999\n1\n1",
        "output": "499"
      },
      {
        "input": "1000000000\n2\n1 2",
        "output": "333333333"
      },
      {
        "input": "6543\n5\n2 4 7 11 20",
        "output": "1637"
      }
    ],
    "url": "https://www.acmicpc.net/problem/9662",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "9663",
    "step_title": "백트래킹",
    "title": "N-Queen",
    "level": 12,
    "tags": [
      "브루트포스 알고리즘",
      "백트래킹"
    ],
    "description": "N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N이 주어진다. (1 ≤ N < 15)",
    "output_description": "첫째 줄에 퀸 N개를 서로 공격할 수 없게 놓는 경우의 수를 출력한다.",
    "examples": [
      {
        "input": "8",
        "output": "92"
      }
    ],
    "url": "https://www.acmicpc.net/problem/9663",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def is_safe(row, col):\n    for i in range(row):\n        if board[i] == col or abs(board[i] - col) == row - i:\n            return False\n    return True\n\ndef solve(row):\n    global count\n    if row == N:\n        count += 1\n        return\n    \n    for col in range(N):\n        if is_safe(row, col):\n            board[row] = col\n            solve(row + 1)\n            board[row] = -1\n\nN = int(input())\nboard = [-1] * N\ncount = 0\nsolve(0)\nprint(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "9867",
    "step_title": "동적 계획법 5",
    "title": "Optimal Milking",
    "level": 20,
    "tags": [
      "자료 구조",
      "세그먼트 트리",
      "분할 정복"
    ],
    "description": "Farmer John has recently purchased a new barn containing N milking machines (1 <= N <= 40,000), conveniently numbered 1..N and arranged in a row.Milking machine i is capable of extracting M(i) units of milk per day (1 <= M(i) <= 100,000).  Unfortunately, the machines were installed so close together that if a machine i is in use on a particular day, its two neighboring machines cannot be used that day (endpoint machines have only one neighbor, of course).  Farmer John is free to select different subsets of machines to operate on different days.Farmer John is interested in computing the maximum amount of milk he can extract over a series of D days (1 <= D <= 50,000).  At the beginning of each day, he has enough time to perform maintenance on one selected milking machine i, thereby changing its daily milk output M(i) from that day forward. Given a list of these daily modifications, please tell Farmer John how much milk he can produce over D days (note that this number might not fit into a 32-bit integer).",
    "input_description": "Line 1: The values of N and D.Lines 2..1+N: Line i+1 contains the initial value of M(i).Lines 2+N..1+N+D: Line 1+N+d contains two integers i and m, indicating that Farmer John updates the value of M(i) to m at the beginning of day d.",
    "output_description": "Line 1: The maximum total amount of milk FJ can produce over D days.",
    "examples": [
      {
        "input": "5 3\r\n1\r\n2\r\n3\r\n4\r\n5\r\n5 2\r\n2 7\r\n1 10",
        "output": "32"
      }
    ],
    "url": "https://www.acmicpc.net/problem/9867",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "9935",
    "step_title": "스택, 큐, 덱 2",
    "title": "문자열 폭발",
    "level": 12,
    "tags": [
      "자료 구조",
      "문자열",
      "스택"
    ],
    "description": "상근이는 문자열에 폭발 문자열을 심어 놓았다. 폭발 문자열이 폭발하면 그 문자는 문자열에서 사라지며, 남은 문자열은 합쳐지게 된다.폭발은 다음과 같은 과정으로 진행된다.문자열이 폭발 문자열을 포함하고 있는 경우에, 모든 폭발 문자열이 폭발하게 된다. 남은 문자열을 순서대로 이어 붙여 새로운 문자열을 만든다.새로 생긴 문자열에 폭발 문자열이 포함되어 있을 수도 있다.폭발은 폭발 문자열이 문자열에 없을 때까지 계속된다.상근이는 모든 폭발이 끝난 후에 어떤 문자열이 남는지 구해보려고 한다. 남아있는 문자가 없는 경우가 있다. 이때는 \"FRULA\"를 출력한다.폭발 문자열은 같은 문자를 두 개 이상 포함하지 않는다.",
    "input_description": "첫째 줄에 문자열이 주어진다. 문자열의 길이는 1보다 크거나 같고, 1,000,000보다 작거나 같다.둘째 줄에 폭발 문자열이 주어진다. 길이는 1보다 크거나 같고, 36보다 작거나 같다.두 문자열은 모두 알파벳 소문자와 대문자, 숫자 0, 1, ..., 9로만 이루어져 있다.",
    "output_description": "첫째 줄에 모든 폭발이 끝난 후 남은 문자열을 출력한다.",
    "examples": [
      {
        "input": "mirkovC4nizCC44\nC4",
        "output": "mirkovniz"
      },
      {
        "input": "12ab112ab2ab\n12ab",
        "output": "FRULA"
      }
    ],
    "url": "https://www.acmicpc.net/problem/9935",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "string = input()\nbomb = input()\n\nstack = []\n\nfor char in string:\n    stack.append(char)\n    \n    if len(stack) >= len(bomb) and ''.join(stack[-len(bomb):]) == bomb:\n        for _ in range(len(bomb)):\n            stack.pop()\n\nif stack:\n    print(''.join(stack))\nelse:\n    print(\"FRULA\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10067",
    "step_title": "동적 계획법 최적화 1",
    "title": "수열 나누기",
    "level": 22,
    "tags": [
      "다이나믹 프로그래밍",
      "역추적",
      "볼록 껍질을 이용한 최적화"
    ],
    "description": "은기는 음이 아닌 정수 n개로 이루어진 수열을 이용해 시간을 때우고 있다. 은기는 수열을 총 k+1개로 나누어야 하고, 각 부분은 비어있지 않아야 한다. 수열을 k+1개로 나누러면, 아래와 같은 과정을 k번 반복해야 한다.원소를 두 개 이상 가지고 있는 부분을 고른다. (가장 처음에는 수열 전체밖에 없다)임의의 두 원소 사이를 기준으로 수열을 두 부분으로 나눈다.위의 과정을 할 때마다 얻게되는 점수는 새로 나누어진 각 부분에 들어있는 원소의 합을 곱한 것이다. 위의 과정을 k번 반복하면서 은기가 얻을 수 있는 점수의 최댓값을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 두 정수 n과 k가 주어진다. (2 ≤ n ≤ 100,000, 1 ≤ k ≤ min(n-1, 200)) 둘째 줄에는 수열을 나타내는 음이 아닌 정수 n개 a1, a2, ..., an이 주어진다. (0 ≤ ai≤ 104)",
    "output_description": "첫째 줄에 얻을 수 있는 가장 큰 점수를 출력한다. 둘째 줄에는 그러한 점수를 얻기 위해 몇 번째 원소 다음에 수열을 나누어야 하는지 순서대로 출력한다. 가능한 답이 여러개라면, 아무거나 출력한다.",
    "examples": [
      {
        "input": "7 3\n4 1 3 4 0 2 3",
        "output": "108\n1 3 5"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10067",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10070",
    "step_title": "세그먼트 트리 3",
    "title": "벽",
    "level": 21,
    "tags": [
      "자료 구조",
      "세그먼트 트리",
      "느리게 갱신되는 세그먼트 트리"
    ],
    "description": "지안지아는 똑같은 크기의 벽돌을 쌓아서 벽을 만들고 있다. 이 벽은 n열의 벽돌로 되어 있는데, 각 열은 왼쪽부터 오른쪽으로 차례대로 0부터 n-1까지 번호가 매겨져 있다. 각 열의 높이는 서로 다를 수 있다. 열의 높이는 이 열에 쌓인 벽돌의 수이다.지안지아는 다음과 같이 벽을 만든다. 처음에는 어느 열에도 벽돌이 없다. 다음, 지안지아는 k 단계에 걸쳐 벽돌을 더하거나 또는 빼거나 한다. k 단계가 다 끝나면 벽을 다 쌓은 것이다. 매 단계마다 지안지아는 연속된 벽돌 열의 범위와 높이 h를 받고, 다음과 같은 절차에 따라 정해진 일을 한다.벽돌을 더하는 단계에서는, 지안지아는 주어진 범위에 해당하는 열들 중 h장 미만의 벽돌이 쌓인 열들에 벽돌을 더해서 정확히 벽돌 h장이 쌓이게 한다. h장 이상 벽돌이 있는 열에는 아무 일도 하지 않는다.벽돌을 빼는 단계에는, 지안지아는 주어진 범위에 해당하는 열들 중 h장 초과의 벽돌이 쌓인 열들에서 벽돌을 빼서 정확히 벽돌 h장이 쌓이게 한다. h장 이하 벽돌이 있는 열에는 아무 일도 하지 않는다.당신이 할 일은 벽의 최종 모양을 결정하는 것이다.10열의 벽돌이 있고 6단계를 거쳐 벽을 만든다고 가정하자. 아래 표의 모든 범위는 양 끝을 포함한다. 각 단계가 끝났을 때 벽의 모양은 아래 그림과 같다.단계하는 일범위높이0더하기1열부터 8열까지41빼기4열부터 9열까지12빼기3열부터 6열까지53더하기0열부터 5열까지34더하기2열55빼기6열부터 7열까지0처음에 모든 열에는 벽돌이 없기 때문에, 단계 0이 끝나면 1열부터 8열까지는 모두 4장의 벽돌이 있다. 0열과 9열은 비어 있다. 단계 1에서는, 4열부터 8열까지는 벽돌이 빠져서 모든 열에 각각 벽돌이 1장이 있고, 9열은 계속 비어 있다. 주어진 범위 밖인 0열부터 3열은 아무 변화가 없다. 단계 2는 아무 변화가 없는데, 3열부터 6열까지 5장을 초과하여 벽돌이 있는 열이 없기 때문이다. 단계 3이 끝나면 0, 4, 5열의 벽돌은 3장으로 늘어난다. 단계 4가 끝나면 2열에는 벽돌이 5장 있다. 단계 5는 6열과 7열의 모든 벽돌을 없앤다.각 단계에서 하는 일이 주어졌을 때, 모든 단계가 끝난 다음 각 열에 남아 있는 벽돌의 수를 계산하시오.",
    "input_description": "첫째 줄에 벽에 있는 열의 수 n과 단계의 수 k가 주어진다.둘째 줄부터 총 k개의 줄에 걸쳐서 단계 i에서 하는 일이 주어진다. op, left, right, height로 이루어져 있으며, 아래와 같은 의미를 갖는다.op: 1이면 더하는 단계, 2이면 빼는 단계이다.left와 right: 각 단계에 해당하는 열의 범위이다. left 열에서 시작하고, right 열에서 끝난다. (양 끝점 left와 right도 포함된다) 항상 left ≤ right이다.height: 각 단계에서 주어지는 높이이다.",
    "output_description": "모든 단계가 끝난 다음 각 열에 남아 있는 벽돌의 수를 한 줄에 하나씩 순서대로 출력한다.",
    "examples": [
      {
        "input": "10 6\n1 1 8 4\n2 4 9 1\n2 3 6 5\n1 0 5 3\n1 2 2 5\n2 6 7 0",
        "output": "3\n4\n5\n4\n3\n3\n0\n0\n1\n0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10070",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10101",
    "step_title": "기하 1: 직사각형과 삼각형",
    "title": "삼각형 외우기",
    "level": 2,
    "tags": [
      "구현",
      "기하학"
    ],
    "description": "창영이는 삼각형의 종류를 잘 구분하지 못한다. 따라서 프로그램을 이용해 이를 외우려고 한다.삼각형의 세 각을 입력받은 다음,세 각의 크기가 모두 60이면, Equilateral세 각의 합이 180이고, 두 각이 같은 경우에는 Isosceles세 각의 합이 180이고, 같은 각이 없는 경우에는 Scalene세 각의 합이 180이 아닌 경우에는 Error를 출력하는 프로그램을 작성하시오.",
    "input_description": "총 3개의 줄에 걸쳐 삼각형의 각의 크기가 주어진다. 모든 정수는 0보다 크고, 180보다 작다.",
    "output_description": "문제의 설명에 따라 Equilateral, Isosceles, Scalene, Error 중 하나를 출력한다.",
    "examples": [
      {
        "input": "60\n70\n50",
        "output": "Scalene"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10101",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "angles = [int(input()) for _ in range(3)]\nif sum(angles) != 180:\n    print(\"Error\")\nelif angles[0] == angles[1] == angles[2]:\n    print(\"Equilateral\")\nelif angles[0] == angles[1] or angles[1] == angles[2] or angles[0] == angles[2]:\n    print(\"Isosceles\")\nelse:\n    print(\"Scalene\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "angles = [int(input()) for _ in range(3)]로 입력을 처리합니다.",
            "code_pattern": "angles = [int(input()) for _ in range(3)]",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "angles = [int(input()) for _ in range(3)]",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "조건 판단",
            "description": "조건문을 사용하여 상황에 따라 다르게 처리합니다.",
            "code_pattern": "if sum(angles) != 180:",
            "socratic_hint": "조건에 따라 다르게 처리하려면?",
            "hint": "if-else 문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(\"Error\")",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10167",
    "step_title": "세그먼트 트리 3",
    "title": "금광",
    "level": 21,
    "tags": [
      "자료 구조",
      "세그먼트 트리",
      "스위핑",
      "값 / 좌표 압축",
      "최대 부분 배열 문제"
    ],
    "description": "황금의 땅이라는 별명을 가진 나라가 있다. 이 나라에는 개발 되지 않은 많은 금광들이 존재한다. 이 금광들을 지도상에 표시할 때, 평면상의 점들로 표현한다.그림-1각 점 pi에는 양수 또는 음수의 정수 값 wi가 주어진다. 이 wi는 금광을 개발한다면 얻게 되는 이익 또는 손해를 나타낸다. wi가 양수이면, wi만큼의 이익이 발생함을 나타낸다. wi가 음수이면, |wi| 만큼의 손해가 발생함을 나타낸다.금광 개발업자는 x축 또는 y축과 평행한 변들을 가진 직사각형 모양의 땅 R을 사서 R에 포함된 금광들을 모두 개발할 것이다. 이때 금광들을 개발하여 얻게 되는 개발 이익은 금광들의 wi들의 합이다.개발업자는 R에 포함된 금광들의 개발 이익이 최대가 되는 직사각형 영역 R을 찾을 것이다. 예를 들어서, 위의 그림-1에서 개발 이익이 최대가 되는 영역 R은 그림-2에서 보여 지는 것과 같고 개발 이익은 7이다.금광들의 좌표와 금광을 개발하면 얻게 되는 이익 또는 손해가 주어질 때, 직사각형 모양의 땅을 사서 얻게 되는 최대 개발 이익을 출력하는 프로그램을 작성하시오.그림-2",
    "input_description": "첫 줄에는 금광들의 개수 N (1 ≤ N ≤ 3,000)이 주어진다. 이어지는 N개의 줄 각각에는 금광의 좌표 (x, y)를 나타내는 음이 아닌 두 정수 x와 y(0 ≤ x, y ≤ 109), 그리고 금광을 개발하면 얻게 되는 이익 또는 손해를 나타내는 정수 w(-109≤ w ≤ 109)가 주어진다. 금광의 좌표는 모두 서로 다르며 w > 0인 금광은 적어도 하나 존재한다.",
    "output_description": "출력은 한 줄로 이루어진다. 금광 개발업자가 직사각형 모양의 땅 R을 사서 얻을 수 있는 최대 개발 이익을 출력한다. 계산 과정에서 32비트 정수 변수가 표현할 수 있는 범위를 넘어서 64비트 정수 변수(long long type)를 사용해야 할 수도 있음에 주의하라.",
    "examples": [
      {
        "input": "7\n2 8 2\n5 5 3\n3 3 -1\n10 2 5\n9 7 -2\n6 7 -1\n7 3 -1",
        "output": "7"
      },
      {
        "input": "10\n4 9 2\n6 10 -1\n6 8 3\n5 6 5\n8 5 10\n7 6 -7\n9 10 4\n20 1 1\n10 8 6\n10 6 -5",
        "output": "18"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10167",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10171",
    "step_title": "입출력과 사칙연산",
    "title": "고양이",
    "level": 1,
    "tags": [
      "구현"
    ],
    "description": "아래 예제와 같이 고양이를 출력하시오.",
    "input_description": "없음.",
    "output_description": "고양이를 출력한다.",
    "examples": [
      {
        "input": "",
        "output": "\\    /\\\r\n )  ( ')\r\n(  /  )\r\n \\(__)|"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10171",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "print(\"\\\\    /\\\\\")\nprint(\" )  ( ')\")\nprint(\"(  /  )\")\nprint(\" \\\\(__)|\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 및 처리",
            "description": "문제에서 요구하는 데이터를 입력받고 처리합니다.",
            "code_pattern": "print(\"\\\\    /\\\\\")\nprint(\" )  ( ')\")\nprint(\"(  /  )\")\nprint(\" \\\\(__)|\")",
            "socratic_hint": "이 문제를 해결하기 위한 첫 단계는 무엇인가요?",
            "hint": "입력을 받고 필요한 계산을 수행합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(result)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: 여러 줄 문자열",
        "solution_code": "cat = \"\"\"\\\\    /\\\\\n )  ( ')\n(  /  )\n \\\\(__)| \"\"\"\nprint(cat)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "여러 줄 문자열 변수에 저장",
            "description": "삼중 따옴표를 사용하여 여러 줄 문자열을 저장합니다.",
            "code_pattern": "cat = \"\"\"...\"\"\"",
            "socratic_hint": "여러 줄의 문자열을 한 번에 저장하려면?",
            "hint": "삼중 따옴표 \"\"\"...\"\"\"를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "변수 출력",
            "description": "저장된 문자열을 출력합니다.",
            "code_pattern": "print(cat)",
            "socratic_hint": "변수를 출력하려면?",
            "hint": "print()를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10172",
    "step_title": "입출력과 사칙연산",
    "title": "개",
    "level": 1,
    "tags": [
      "구현"
    ],
    "description": "아래 예제와 같이 개를 출력하시오.",
    "input_description": "없음.",
    "output_description": "개를 출력한다.",
    "examples": [
      {
        "input": "",
        "output": "|\\_/|\r\n|q p|   /}\r\n( 0 )\"\"\"\\\r\n|\"^\"`    |\r\n||_/=\\\\__|"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10172",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "print(\"|\\\\_/|\")\nprint(\"|q p|   /}\")\nprint(\"( 0 )\\\"\\\"\\\"\\\\\")\nprint(\"|\\\"^\\\"`    |\")\nprint(\"||_/=\\\\\\\\__|\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(\"|\\_/|\")",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10254",
    "step_title": "기하 3",
    "title": "고속도로",
    "level": 19,
    "tags": [
      "기하학",
      "볼록 껍질",
      "회전하는 캘리퍼스"
    ],
    "description": "n개의 도시를 가진 나라가 있다. 이 나라에서는 도시들 중 가장 먼 두 도시 사이에 직행 고속도로를 놓으려 한다.고속도로는 시작점과 끝점이 아닌 다른 나라를 통과해도 된다. 즉, n개의 도시 중 유클리드 거리가 가장 먼 두 도시를 찾으려 한다. 모든 도시는 한 평면 위에 있다.위의 예제에서는 (12,0)의 도시와 (-6,3)의 도시가 가장 먼 유클리드 거리를 갖는다.도시 n개의 좌표가 주어지면 모든 두 도시 쌍의 거리 중 가장 먼 두 도시를 찾아라.",
    "input_description": "첫째 줄에 테스트 케이스의 수 T가 주어진다.각 테스트 케이스의 첫 줄엔 도시의 개수 n이 주어진다. (2 ≤ n ≤ 200,000)그 후 n줄에 걸쳐 각 도시의 x좌표와 y좌표가 주어진다. (-10,000,000 ≤ x, y ≤ 10,000,000)x, y는 항상 정수이며, 어떤 두 도시가 같은 점 위에 있는 경우는 없다.",
    "output_description": "테스트 케이스마다 가장 먼 두 점의 좌표를 출력한다.만일 그 두 점의 좌표가 각각 (x1, y1), (x2, y2)이라면 x1 y1 x2 y2를 출력하면 된다.가장 먼 거리를 갖는 두 점의 쌍이 여러 개라면 그 중 아무 것이나 출력해도 상관없다.",
    "examples": [
      {
        "input": "2\n4\n-100 -50\n20 -50\n-20 50\n100 50\n9\n-1 -1\n3 -3\n6 -6\n-3 -6\n12 0\n3 4\n-6 3\n0 9\n6 9",
        "output": "-100 -50 100 50\n-6 3 12 0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10254",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10256",
    "step_title": "문자열 알고리즘 2",
    "title": "돌연변이",
    "level": 19,
    "tags": [
      "자료 구조",
      "문자열",
      "트리",
      "트라이",
      "아호-코라식"
    ],
    "description": "인간의 DNA 구조는 A, C, G, T로 이루어진 하나의 긴 문자열로 표현할 수 있다.이때, 몇 몇 질병은 DNA 구조를 나타낸 문자열의 어떤 연속된 부분 문자열과 관련이 있다는 것이 밝혀져 있다. 만일 DNA가 특정 문자열을 부분 문자열로 가진다면 그 질병에 걸릴 가능성이 높다는 것이다. 이러한 특정 문자열을 마커(marker)라 한다.하지만 때때로 DNA 구조를 그대로 확인하는 것만으로는 질병과 관련된 마커를 확인할 수 없는 경우가 있다. 마커의 돌연변이 가능성 때문이다.마커의 돌연변이는 아래와 같이 일어난다.먼저, 마커를 세 부분으로 나눈다, 이때, 첫 부분과 세 번째 부분은 비어 있어도 된다.두 번째 부분을 뒤집는다.예를 들어 마커가 AGGT라면 아래와 같은 여섯 가지 경우가 가능하다.GAGT, GGAT, TGGA, AGGT, ATGG, AGTG어떤 사람의 DNA 구조와 마커가 주어졌을 때, DNA 내에 마커가 돌연변이의 형태를 포함하여 몇 번 출현하는지 세는 프로그램을 작성하라.단, 마커의 출현 위치는 서로 겹쳐도 된다. 예를 들어 DNA 구조가 ATGGAT이며 마커가 AGGT라면 답은 3이 된다. ATGG, TGGA, GGAT가 한 번씩 출현하기 때문이다.",
    "input_description": "첫 줄에 테스트 케이스의 수 T가 주어진다.각 테스트 케이스의 첫 줄엔 두 개의 정수 n과 m이 주어진다.이는 각각 DNA 문자열의 길이와 마커의 길이이다. (1 ≤ n ≤ 1,000,000, 1 ≤ m ≤ 100)두 번째 줄엔 DNA 구조가 주어진다.마지막 줄엔 마커가 주어진다.모든 DNA와 마커는 A,G,T,C로만 이루어진 문자열이다.",
    "output_description": "각 테스트 케이스마다 주어진 DNA 구조에 마커와 그 돌연변이가 몇 번 출현하는지 하나의 정수로 출력한다.만일 DNA 구조 내에 마커 또는 그 돌연변이가 한 번도 출현하지 않는다면 답은 0이 된다.",
    "examples": [
      {
        "input": "2\n6 4\nATGGAT\nAGGT\n6 4\nATGGAT\nAGCT",
        "output": "3\n0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10256",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 그래프 문제 기본 구조\nfrom collections import deque\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\n# BFS/DFS 구현\nvisited = [False] * (N + 1)\n\ndef bfs(start):\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        node = queue.popleft()\n        for next_node in graph[node]:\n            if not visited[next_node]:\n                visited[next_node] = True\n                queue.append(next_node)\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10430",
    "step_title": "입출력과 사칙연산",
    "title": "나머지",
    "level": 1,
    "tags": [
      "구현",
      "사칙연산",
      "수학"
    ],
    "description": "(A+B)%C는 ((A%C) + (B%C))%C 와 같을까?(A×B)%C는 ((A%C) × (B%C))%C 와 같을까?세 수 A, B, C가 주어졌을 때, 위의 네 가지 값을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 A, B, C가 순서대로 주어진다. (2 ≤ A, B, C ≤ 10000)",
    "output_description": "첫째 줄에 (A+B)%C, 둘째 줄에 ((A%C) + (B%C))%C, 셋째 줄에 (A×B)%C, 넷째 줄에 ((A%C) × (B%C))%C를 출력한다.",
    "examples": [
      {
        "input": "5 8 4",
        "output": "1\r\n1\r\n0\r\n0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10430",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "A, B, C = map(int, input().split())\nprint((A + B) % C)\nprint(((A % C) + (B % C)) % C)\nprint((A * B) % C)\nprint(((A % C) * (B % C)) % C)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 데이터 받기",
            "description": "문제에서 요구하는 데이터를 입력받습니다.",
            "code_pattern": "A = int(input())\nB = int(input())",
            "socratic_hint": "어떤 데이터를 입력받아야 하나요?",
            "hint": "input() 함수로 데이터를 받고, 필요하면 int()로 변환합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력하기",
            "description": "처리된 결과를 출력합니다.",
            "code_pattern": "print((A + B) % C)\nprint(((A % C) + (B % C)) % C)",
            "socratic_hint": "결과를 어떻게 출력하나요?",
            "hint": "print() 함수로 결과를 출력합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10531",
    "step_title": "고속 푸리에 변환",
    "title": "Golf Bot",
    "level": 20,
    "tags": [
      "수학",
      "고속 푸리에 변환"
    ],
    "description": "Do you like golf? I hate it. I hate golf so much that I decided to build the ultimate golf robot, a robot that will never miss a shot. I simply place it over the ball, choose the right direction and distance and, flawlessly, it will strike the ball across the air and into the hole. Golf will never be played again.Unfortunately, it doesn’t work as planned. So, here I am, standing in the green and preparing my first strike when I realize that the distance-selector knob built-in doesn’t have all the distance options! Not everything is lost, as I have 2 shots.Given my current robot, how many holes will I be able to complete in 2 strokes or less?",
    "input_description": "The first line has one integer: N, the number of different distances the Golf Bot can shoot. Each of the following N lines has one integer, ki, the distance marked in position i of the knob.Next line has one integer: M, the number of holes in this course. Each of the following M lines has one integer, dj, the distance from Golf Bot to hole j.",
    "output_description": "You should output a single integer, the number of holes Golf Bot will be able to complete. Golf Bot cannot shoot over a hole on purpose and then shoot backwards.",
    "examples": [
      {
        "input": "3\n1\n3\n5\n6\n2\n4\n5\n7\n8\n9",
        "output": "4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10531",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 수학 문제 기본 구조\ndef solve():\n    # 입력 처리\n    N = int(input())\n    \n    # 계산\n    result = N\n    \n    return result\n\nprint(solve())",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10773",
    "step_title": "스택, 큐, 덱 1",
    "title": "제로",
    "level": 7,
    "tags": [
      "구현",
      "자료 구조",
      "스택"
    ],
    "description": "나코더 기장 재민이는 동아리 회식을 준비하기 위해서 장부를 관리하는 중이다.재현이는 재민이를 도와서 돈을 관리하는 중인데, 애석하게도 항상 정신없는 재현이는 돈을 실수로 잘못 부르는 사고를 치기 일쑤였다.재현이는 잘못된 수를 부를 때마다 0을 외쳐서, 가장 최근에 재민이가 쓴 수를 지우게 시킨다.재민이는 이렇게 모든 수를 받아 적은 후 그 수의 합을 알고 싶어 한다. 재민이를 도와주자!",
    "input_description": "첫 번째 줄에 정수 K가 주어진다. (1 ≤ K ≤ 100,000)이후 K개의 줄에 정수가 1개씩 주어진다. 정수는 0에서 1,000,000 사이의 값을 가지며, 정수가 \"0\" 일 경우에는 가장 최근에 쓴 수를 지우고, 아닐 경우 해당 수를 쓴다.정수가 \"0\"일 경우에 지울 수 있는 수가 있음을 보장할 수 있다.",
    "output_description": "재민이가 최종적으로 적어 낸 수의 합을 출력한다. 최종적으로 적어낸 수의 합은 231-1보다 작거나 같은 정수이다.",
    "examples": [
      {
        "input": "4\n3\n0\n4\n0",
        "output": "0"
      },
      {
        "input": "10\n1\n3\n5\n4\n0\n0\n7\n0\n0\n6",
        "output": "7"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10773",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "K = int(input())\nstack = []\n\nfor _ in range(K):\n    num = int(input())\n    if num == 0:\n        if stack:\n            stack.pop()\n    else:\n        stack.append(num)\n\nprint(sum(stack))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10775",
    "step_title": "그리디 알고리즘 2",
    "title": "공항",
    "level": 14,
    "tags": [
      "자료 구조",
      "그리디 알고리즘",
      "분리 집합"
    ],
    "description": "오늘은 신승원의 생일이다.박승원은 생일을 맞아 신승원에게 인천국제공항을 선물로 줬다.공항에는 G개의 게이트가 있으며 각각은 1에서 G까지의 번호를 가지고 있다.공항에는 P개의 비행기가 순서대로 도착할 예정이며, 당신은 i번째 비행기를 1번부터 gi(1 ≤ gi≤ G) 번째 게이트중 하나에 영구적으로 도킹하려 한다. 비행기가 어느 게이트에도 도킹할 수 없다면 공항이 폐쇄되고, 이후 어떤 비행기도 도착할 수 없다.신승원은 가장 많은 비행기를 공항에 도킹시켜서 박승원을 행복하게 하고 싶어한다. 승원이는 비행기를 최대 몇 대 도킹시킬 수 있는가?",
    "input_description": "첫 번째 줄에는 게이트의 수 G (1 ≤ G ≤ 105)가 주어진다.두 번째 줄에는 비행기의 수 P (1 ≤ P ≤ 105)가 주어진다.이후 P개의 줄에 gi(1 ≤ gi≤ G) 가 주어진다.",
    "output_description": "승원이가 도킹시킬 수 있는 최대의 비행기 수를 출력한다.",
    "examples": [
      {
        "input": "4\n3\n4\n1\n1",
        "output": "2"
      },
      {
        "input": "4\n6\n2\n2\n3\n3\n4\n4",
        "output": "3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10775",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def find(x):\n    if parent[x] != x:\n        parent[x] = find(parent[x])\n    return parent[x]\n\nG = int(input())\nP = int(input())\n\nparent = list(range(G + 1))\ncount = 0\n\nfor _ in range(P):\n    g = int(input())\n    gate = find(g)\n    \n    if gate == 0:\n        break\n    \n    parent[gate] = gate - 1\n    count += 1\n\nprint(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10798",
    "step_title": "2차원 배열",
    "title": "세로읽기",
    "level": 5,
    "tags": [
      "구현",
      "문자열"
    ],
    "description": "아직 글을 모르는 영석이가 벽에 걸린 칠판에 자석이 붙어있는 글자들을 붙이는 장난감을 가지고 놀고 있다.이 장난감에 있는 글자들은 영어 대문자 ‘A’부터 ‘Z’, 영어 소문자 ‘a’부터 ‘z’, 숫자 ‘0’부터 ‘9’이다. 영석이는 칠판에 글자들을 수평으로 일렬로 붙여서 단어를 만든다. 다시 그 아래쪽에 글자들을 붙여서 또 다른 단어를 만든다. 이런 식으로 다섯 개의 단어를 만든다. 아래 그림 1은 영석이가 칠판에 붙여 만든 단어들의 예이다.A A B C D D\r\na f z z \r\n0 9 1 2 1\r\na 8 E W g 6\r\nP 5 h 3 k x<그림 1>한 줄의 단어는 글자들을 빈칸 없이 연속으로 나열해서 최대 15개의 글자들로 이루어진다. 또한 만들어진 다섯 개의 단어들의 글자 개수는 서로 다를 수 있다.심심해진 영석이는 칠판에 만들어진 다섯 개의 단어를 세로로 읽으려 한다. 세로로 읽을 때, 각 단어의 첫 번째 글자들을 위에서 아래로 세로로 읽는다. 다음에 두 번째 글자들을 세로로 읽는다. 이런 식으로 왼쪽에서 오른쪽으로 한 자리씩 이동 하면서 동일한 자리의 글자들을 세로로 읽어 나간다. 위의 그림 1의 다섯 번째 자리를 보면 두 번째 줄의 다섯 번째 자리의 글자는 없다. 이런 경우처럼 세로로 읽을 때 해당 자리의 글자가 없으면, 읽지 않고 그 다음 글자를 계속 읽는다. 그림 1의 다섯 번째 자리를 세로로 읽으면 D1gk로 읽는다.그림 1에서 영석이가 세로로 읽은 순서대로 글자들을 공백 없이 출력하면 다음과 같다:Aa0aPAf985Bz1EhCz2W3D1gkD6x칠판에 붙여진 단어들이 주어질 때, 영석이가 세로로 읽은 순서대로 글자들을 출력하는 프로그램을 작성하시오.",
    "input_description": "총 다섯줄의 입력이 주어진다. 각 줄에는 최소 1개, 최대 15개의 글자들이 빈칸 없이 연속으로 주어진다. 주어지는 글자는 영어 대문자 ‘A’부터 ‘Z’, 영어 소문자 ‘a’부터 ‘z’, 숫자 ‘0’부터 ‘9’ 중 하나이다. 각 줄의 시작과 마지막에 빈칸은 없다.",
    "output_description": "영석이가 세로로 읽은 순서대로 글자들을 출력한다. 이때, 글자들을 공백 없이 연속해서 출력한다.",
    "examples": [
      {
        "input": "ABCDE\r\nabcde\r\n01234\r\nFGHIJ\r\nfghij",
        "output": "Aa0FfBb1GgCc2HhDd3IiEe4Jj"
      },
      {
        "input": "AABCDD\r\nafzz\r\n09121\r\na8EWg6\r\nP5h3kx",
        "output": "Aa0aPAf985Bz1EhCz2W3D1gkD6x"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10798",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "lines = [input().ljust(15) for _ in range(5)]\nfor i in range(15):\n    for j in range(5):\n        if i < len(lines[j]) and lines[j][i] != ' ':\n            print(lines[j][i], end='')\nprint()",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "lines = [input().ljust(15) for _ in range(5)]로 입력을 처리합니다.",
            "code_pattern": "lines = [input().ljust(15) for _ in range(5)]",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "lines = [input().ljust(15) for _ in range(5)]",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "조건 판단",
            "description": "조건문을 사용하여 상황에 따라 다르게 처리합니다.",
            "code_pattern": "if i < len(lines[j]) and lines[j][i] != ' ':",
            "socratic_hint": "조건에 따라 다르게 처리하려면?",
            "hint": "if-else 문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(lines[j][i], end='')",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10807",
    "step_title": "1차원 배열",
    "title": "개수 세기",
    "level": 1,
    "tags": [
      "구현"
    ],
    "description": "총 N개의 정수가 주어졌을 때, 정수 v가 몇 개인지 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 정수의 개수 N(1 ≤ N ≤ 100)이 주어진다. 둘째 줄에는 정수가 공백으로 구분되어져있다. 셋째 줄에는 찾으려고 하는 정수 v가 주어진다. 입력으로 주어지는 정수와 v는 -100보다 크거나 같으며, 100보다 작거나 같다.",
    "output_description": "첫째 줄에 입력으로 주어진 N개의 정수 중에 v가 몇 개인지 출력한다.",
    "examples": [
      {
        "input": "11\r\n1 4 1 2 4 2 4 2 3 4 4\r\n2",
        "output": "3"
      },
      {
        "input": "11\r\n1 4 1 2 4 2 4 2 3 4 4\r\n5",
        "output": "0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10807",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nnumbers = []\nnumbers = list(map(int, input().split()))\nv = int(input())\ncount = 0\nfor num in numbers:\n    if num == v:\n        count = count + 1\nprint(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 데이터 받기",
            "description": "문제에서 요구하는 데이터를 입력받습니다.",
            "code_pattern": "N = int(input())\n    num = int(input())",
            "socratic_hint": "어떤 데이터를 입력받아야 하나요?",
            "hint": "input() 함수로 데이터를 받고, 필요하면 int()로 변환합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력하기",
            "description": "처리된 결과를 출력합니다.",
            "code_pattern": "print(count)",
            "socratic_hint": "결과를 어떻게 출력하나요?",
            "hint": "print() 함수로 결과를 출력합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "N = int(input())\nnumbers = list(map(int, input().split()))\nv = int(input())\nprint(numbers.count(v))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "반복 처리",
            "description": "for i in range(N):로 반복 작업을 수행합니다.",
            "code_pattern": "for i in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "정수 입력 받기",
            "description": "num = int(input())로 입력을 처리합니다.",
            "code_pattern": "num = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "정수 입력 받기",
            "description": "v = int(input())로 입력을 처리합니다.",
            "code_pattern": "v = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 5,
            "goal": "반복 처리",
            "description": "for num in numbers:로 반복 작업을 수행합니다.",
            "code_pattern": "for num in numbers:",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 6,
            "goal": "정수 입력 받기",
            "description": "v = int(input())로 입력을 처리합니다.",
            "code_pattern": "v = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 7,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(numbers.count(v))",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3",
        "solution_code": "N = int(input())\nnumbers = list(map(int, input().split()))\nv = int(input())\ncount = sum(1 for num in numbers if num == v)\nprint(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "v = int(input())로 입력을 처리합니다.",
            "code_pattern": "v = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "반복 처리",
            "description": "count = sum(1 for num in numbers if num == v)로 반복 작업을 수행합니다.",
            "code_pattern": "count = sum(1 for num in numbers if num == v)",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(count)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4: Counter 활용",
        "solution_code": "from collections import Counter\nN = int(input())\nnumbers = list(map(int, input().split()))\nv = int(input())\nprint(Counter(numbers)[v])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "Counter로 세기",
            "description": "Counter를 사용하여 각 값의 개수를 셉니다.",
            "code_pattern": "Counter(numbers)[v]",
            "socratic_hint": "값의 출현 횟수를 세려면?",
            "hint": "collections.Counter를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10809",
    "step_title": "문자열",
    "title": "알파벳 찾기",
    "level": 4,
    "tags": [
      "구현",
      "문자열"
    ],
    "description": "알파벳 소문자로만 이루어진 단어 S가 주어진다. 각각의 알파벳에 대해서, 단어에 포함되어 있는 경우에는 처음 등장하는 위치를, 포함되어 있지 않은 경우에는 -1을 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 단어 S가 주어진다. 단어의 길이는 100을 넘지 않으며, 알파벳 소문자로만 이루어져 있다.",
    "output_description": "각각의 알파벳에 대해서, a가 처음 등장하는 위치, b가 처음 등장하는 위치, ... z가 처음 등장하는 위치를 공백으로 구분해서 출력한다.만약, 어떤 알파벳이 단어에 포함되어 있지 않다면 -1을 출력한다. 단어의 첫 번째 글자는 0번째 위치이고, 두 번째 글자는 1번째 위치이다.",
    "examples": [
      {
        "input": "baekjoon",
        "output": "1 0 -1 -1 2 -1 -1 -1 -1 4 3 -1 -1 7 5 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10809",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "word = input()\nfor char in 'abcdefghijklmnopqrstuvwxyz':\n    print(word.find(char), end=' ')",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "word = input()\nfor char in 'abcdefghijklmnopqrstuvwxyz':\n    print(word.find(char), end=' ')",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: find 메서드",
        "solution_code": "S = input()\nfor c in 'abcdefghijklmnopqrstuvwxyz':\n    print(S.find(c), end=' ')",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "find로 위치 찾기",
            "description": "find() 메서드는 없으면 -1을 반환합니다.",
            "code_pattern": "S.find(c)",
            "socratic_hint": "문자 위치를 찾는 메서드는?",
            "hint": "find()를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3: 딕셔너리 활용",
        "solution_code": "S = input()\npos = {c: i for i, c in enumerate(S)}\nfor c in 'abcdefghijklmnopqrstuvwxyz':\n    print(pos.get(c, -1), end=' ')",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "딕셔너리로 위치 저장",
            "description": "각 문자의 첫 등장 위치를 딕셔너리에 저장합니다.",
            "code_pattern": "pos = {c: i for i, c in enumerate(S)}",
            "socratic_hint": "문자와 위치를 매핑하려면?",
            "hint": "딕셔너리 컴프리헨션을 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10810",
    "step_title": "1차원 배열",
    "title": "공 넣기",
    "level": 3,
    "tags": [
      "구현",
      "시뮬레이션"
    ],
    "description": "도현이는 바구니를 총 N개 가지고 있고, 각각의 바구니에는 1번부터 N번까지 번호가 매겨져 있다. 또, 1번부터 N번까지 번호가 적혀있는 공을 매우 많이 가지고 있다. 가장 처음 바구니에는 공이 들어있지 않으며, 바구니에는 공을 1개만 넣을 수 있다.도현이는 앞으로 M번 공을 넣으려고 한다. 도현이는 한 번 공을 넣을 때, 공을 넣을 바구니 범위를 정하고, 정한 바구니에 모두 같은 번호가 적혀있는 공을 넣는다. 만약, 바구니에 공이 이미 있는 경우에는 들어있는 공을 빼고, 새로 공을 넣는다. 공을 넣을 바구니는 연속되어 있어야 한다.공을 어떻게 넣을지가 주어졌을 때, M번 공을 넣은 이후에 각 바구니에 어떤 공이 들어 있는지 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N (1 ≤ N ≤ 100)과 M (1 ≤ M ≤ 100)이 주어진다.둘째 줄부터 M개의 줄에 걸쳐서 공을 넣는 방법이 주어진다. 각 방법은 세 정수 i j k로 이루어져 있으며, i번 바구니부터 j번 바구니까지에 k번 번호가 적혀져 있는 공을 넣는다는 뜻이다. 예를 들어, 2 5 6은 2번 바구니부터 5번 바구니까지에 6번 공을 넣는다는 뜻이다. (1 ≤ i ≤ j ≤ N, 1 ≤ k ≤ N)도현이는 입력으로 주어진 순서대로 공을 넣는다.",
    "output_description": "1번 바구니부터 N번 바구니에 들어있는 공의 번호를 공백으로 구분해 출력한다. 공이 들어있지 않은 바구니는 0을 출력한다.",
    "examples": [
      {
        "input": "5 4\r\n1 2 3\r\n3 4 4\r\n1 4 1\r\n2 2 2",
        "output": "1 2 1 1 0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10810",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N, M = map(int, input().split())\nbaskets = [0] * (N + 1)\nfor _ in range(M):\n    i, j, k = map(int, input().split())\n    for idx in range(i, j + 1):\n        baskets[idx] = k\nprint(' '.join(map(str, baskets[1:])))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "여러 값 입력 받기",
            "description": "N, M = map(int, input().split())로 입력을 처리합니다.",
            "code_pattern": "N, M = map(int, input().split())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "여러 값 입력 받기",
            "description": "i, j, k = map(int, input().split())로 입력을 처리합니다.",
            "code_pattern": "i, j, k = map(int, input().split())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(M):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(' '.join(map(str, baskets[1:])))",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10811",
    "step_title": "1차원 배열",
    "title": "바구니 뒤집기",
    "level": 4,
    "tags": [
      "구현",
      "시뮬레이션"
    ],
    "description": "도현이는 바구니를 총 N개 가지고 있고, 각각의 바구니에는 1번부터 N번까지 번호가 순서대로 적혀져 있다. 바구니는 일렬로 놓여져 있고, 가장 왼쪽 바구니를 1번째 바구니, 그 다음 바구니를 2번째 바구니, ..., 가장 오른쪽 바구니를 N번째 바구니라고 부른다.도현이는 앞으로 M번 바구니의 순서를 역순으로 만들려고 한다. 도현이는 한 번 순서를 역순으로 바꿀 때, 순서를 역순으로 만들 범위를 정하고, 그 범위에 들어있는 바구니의 순서를 역순으로 만든다.바구니의 순서를 어떻게 바꿀지 주어졌을 때, M번 바구니의 순서를 역순으로 만든 다음, 바구니에 적혀있는 번호를 가장 왼쪽 바구니부터 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N (1 ≤ N ≤ 100)과 M (1 ≤ M ≤ 100)이 주어진다.둘째 줄부터 M개의 줄에는 바구니의 순서를 역순으로 만드는 방법이 주어진다. 방법은 i j로 나타내고, 왼쪽으로부터 i번째 바구니부터 j번째 바구니의 순서를 역순으로 만든다는 뜻이다. (1 ≤ i ≤ j ≤ N)도현이는 입력으로 주어진 순서대로 바구니의 순서를 바꾼다.",
    "output_description": "모든 순서를 바꾼 다음에, 가장 왼쪽에 있는 바구니부터 바구니에 적혀있는 순서를 공백으로 구분해 출력한다.",
    "examples": [
      {
        "input": "5 4\r\n1 2\r\n3 4\r\n1 4\r\n2 2",
        "output": "3 4 1 2 5"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10811",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N, M = map(int, input().split())\nbaskets = list(range(N + 1))\nfor _ in range(M):\n    i, j = map(int, input().split())\n    baskets[i:j+1] = reversed(baskets[i:j+1])\nprint(' '.join(map(str, baskets[1:])))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "여러 값 입력 받기",
            "description": "N, M = map(int, input().split())로 입력을 처리합니다.",
            "code_pattern": "N, M = map(int, input().split())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "여러 값 입력 받기",
            "description": "i, j = map(int, input().split())로 입력을 처리합니다.",
            "code_pattern": "i, j = map(int, input().split())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(M):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(' '.join(map(str, baskets[1:])))",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10813",
    "step_title": "1차원 배열",
    "title": "공 바꾸기",
    "level": 4,
    "tags": [
      "구현",
      "시뮬레이션"
    ],
    "description": "도현이는 바구니를 총 N개 가지고 있고, 각각의 바구니에는 1번부터 N번까지 번호가 매겨져 있다. 바구니에는 공이 1개씩 들어있고, 처음에는 바구니에 적혀있는 번호와 같은 번호가 적힌 공이 들어있다.도현이는 앞으로 M번 공을 바꾸려고 한다. 도현이는 공을 바꿀 바구니 2개를 선택하고, 두 바구니에 들어있는 공을 서로 교환한다.공을 어떻게 바꿀지가 주어졌을 때, M번 공을 바꾼 이후에 각 바구니에 어떤 공이 들어있는지 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N (1 ≤ N ≤ 100)과 M (1 ≤ M ≤ 100)이 주어진다.둘째 줄부터 M개의 줄에 걸쳐서 공을 교환할 방법이 주어진다. 각 방법은 두 정수 i j로 이루어져 있으며, i번 바구니와 j번 바구니에 들어있는 공을 교환한다는 뜻이다. (1 ≤ i ≤ j ≤ N)도현이는 입력으로 주어진 순서대로 공을 교환한다.",
    "output_description": "1번 바구니부터 N번 바구니에 들어있는 공의 번호를 공백으로 구분해 출력한다.",
    "examples": [
      {
        "input": "5 4\r\n1 2\r\n3 4\r\n1 4\r\n2 2",
        "output": "3 1 4 2 5"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10813",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N, M = map(int, input().split())\nbaskets = list(range(N + 1))\nfor _ in range(M):\n    i, j = map(int, input().split())\n    baskets[i], baskets[j] = baskets[j], baskets[i]\nprint(' '.join(map(str, baskets[1:])))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "여러 값 입력 받기",
            "description": "N, M = map(int, input().split())로 입력을 처리합니다.",
            "code_pattern": "N, M = map(int, input().split())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "여러 값 입력 받기",
            "description": "i, j = map(int, input().split())로 입력을 처리합니다.",
            "code_pattern": "i, j = map(int, input().split())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(M):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(' '.join(map(str, baskets[1:])))",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10814",
    "step_title": "정렬",
    "title": "나이순 정렬",
    "level": 6,
    "tags": [
      "정렬",
      "집합과 맵"
    ],
    "description": "온라인 저지에 가입한 사람들의 나이와 이름이 가입한 순서대로 주어진다. 이때, 회원들을 나이가 증가하는 순으로, 나이가 같으면 먼저 가입한 사람이 앞에 오는 순서로 정렬하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 온라인 저지 회원의 수 N이 주어진다. (1 ≤ N ≤ 100,000)둘째 줄부터 N개의 줄에는 각 회원의 나이와 이름이 공백으로 구분되어 주어진다. 나이는 1보다 크거나 같으며, 200보다 작거나 같은 정수이고, 이름은 알파벳 대소문자로 이루어져 있고, 길이가 100보다 작거나 같은 문자열이다. 입력은 가입한 순서로 주어진다.",
    "output_description": "첫째 줄부터 총 N개의 줄에 걸쳐 온라인 저지 회원을 나이 순, 나이가 같으면 가입한 순으로 한 줄에 한 명씩 나이와 이름을 공백으로 구분해 출력한다.",
    "examples": [
      {
        "input": "3\r\n21 Junkyu\r\n21 Dohyun\r\n20 Sunyoung",
        "output": "20 Sunyoung\r\n21 Junkyu\r\n21 Dohyun"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10814",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nmembers = []\nfor i in range(N):\n    age, name = input().split()\n    members.append((int(age), name, i))\n\nmembers.sort(key=lambda x: (x[0], x[2]))\nfor age, name, _ in members:\n    print(age, name)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = int(input())\nmembers = []\nfor i in range(n):\n    line = input().split()\n    age = int(line[0])\n    name = line[1]\n    members.append((age, i, name))\nmembers.sort(key=lambda x: (x[0], x[1]))\nfor age, _, name in members:\n    print(age, name)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3",
        "solution_code": "n = int(input())\nmembers = []\nfor i in range(n):\n    line = input().split()\n    age = int(line[0])\n    name = line[1]\n    members.append((age, i, name))\nfor i in range(n-1):\n    for j in range(n-1-i):\n        if (members[j][0], members[j][1]) > (members[j+1][0], members[j+1][1]):\n            members[j], members[j+1] = members[j+1], members[j]\nfor age, _, name in members:\n    print(age, name)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 패스 횟수 제어",
            "description": "n-1번 반복하며 각 패스를 수행합니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "버블 정렬에서 몇 번의 패스가 필요한가요?",
            "hint": "n-1번의 패스가 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "내부 반복문: 인접 원소 비교",
            "description": "각 패스에서 인접한 두 원소를 비교합니다. 이미 정렬된 뒤쪽 부분은 제외합니다.",
            "code_pattern": "for j in range(n-1-i):",
            "socratic_hint": "각 패스에서 비교해야 할 원소의 범위는?",
            "hint": "n-1-i까지 비교합니다 (이미 정렬된 부분 제외)."
          },
          {
            "step_id": 4,
            "goal": "원소 교환",
            "description": "왼쪽 원소가 오른쪽 원소보다 크면 위치를 교환합니다.",
            "code_pattern": "if arr[j] > arr[j+1]:\n    arr[j], arr[j+1] = arr[j+1], arr[j]",
            "socratic_hint": "인접한 두 원소의 순서가 잘못되었을 때 어떻게 하나요?",
            "hint": "두 원소의 위치를 swap합니다."
          },
          {
            "step_id": 5,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4",
        "solution_code": "n = int(input())\nmembers = []\nfor i in range(n):\n    line = input().split()\n    age = int(line[0])\n    name = line[1]\n    members.append((age, i, name))\nfor i in range(n-1):\n    min_idx = i\n    for j in range(i+1, n):\n        if (members[j][0], members[j][1]) < (members[min_idx][0], members[min_idx][1]):\n            min_idx = j\n    members[i], members[min_idx] = members[min_idx], members[i]\nfor age, _, name in members:\n    print(age, name)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 정렬할 위치 선택",
            "description": "n-1번 반복하며 각 위치에 올 최솟값을 찾습니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "선택 정렬에서 몇 번의 선택이 필요한가요?",
            "hint": "n-1번의 선택이 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "최솟값 인덱스 초기화",
            "description": "현재 위치를 최솟값 인덱스로 가정합니다.",
            "code_pattern": "min_idx = i",
            "socratic_hint": "최솟값을 찾기 위한 초기값은?",
            "hint": "현재 위치 i를 초기값으로 설정합니다."
          },
          {
            "step_id": 4,
            "goal": "내부 반복문: 최솟값 찾기",
            "description": "현재 위치 이후의 원소들 중 최솟값의 인덱스를 찾습니다.",
            "code_pattern": "for j in range(i+1, n):\n    if arr[j] < arr[min_idx]:\n        min_idx = j",
            "socratic_hint": "정렬되지 않은 부분에서 최솟값을 어떻게 찾나요?",
            "hint": "i+1부터 끝까지 순회하며 최솟값 인덱스를 업데이트합니다."
          },
          {
            "step_id": 5,
            "goal": "원소 교환",
            "description": "찾은 최솟값을 현재 위치로 이동시킵니다.",
            "code_pattern": "arr[i], arr[min_idx] = arr[min_idx], arr[i]",
            "socratic_hint": "최솟값을 현재 위치로 가져오려면?",
            "hint": "현재 위치의 값과 최솟값을 swap합니다."
          },
          {
            "step_id": 6,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10815",
    "step_title": "집합과 맵",
    "title": "숫자 카드",
    "level": 6,
    "tags": [
      "자료 구조",
      "정렬",
      "이분 탐색",
      "집합과 맵",
      "해시를 사용한 집합과 맵"
    ],
    "description": "숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 가지고 있는지 아닌지를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 숫자 카드에 적혀있는 수는 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다. 두 숫자 카드에 같은 수가 적혀있는 경우는 없다.셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다. 넷째 줄에는 상근이가 가지고 있는 숫자 카드인지 아닌지를 구해야 할 M개의 정수가 주어지며, 이 수는 공백으로 구분되어져 있다. 이 수도 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다",
    "output_description": "첫째 줄에 입력으로 주어진 M개의 수에 대해서, 각 수가 적힌 숫자 카드를 상근이가 가지고 있으면 1을, 아니면 0을 공백으로 구분해 출력한다.",
    "examples": [
      {
        "input": "5\n6 3 2 10 -10\n8\n10 9 -5 2 3 4 5 -10",
        "output": "1 0 0 1 1 0 0 1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10815",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\ncards = set(map(int, input().split()))\nM = int(input())\nqueries = list(map(int, input().split()))\n\nresult = []\nfor q in queries:\n    if q in cards:\n        result.append('1')\n    else:\n        result.append('0')\n\nprint(' '.join(result))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = int(input())\ncards = set(map(int, input().split()))\nm = int(input())\nqueries = list(map(int, input().split()))\nresult = [1 if q in cards else 0 for q in queries]\nprint(' '.join(map(str, result)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3: 이분 탐색",
        "solution_code": "import bisect\nN = int(input())\ncards = sorted(map(int, input().split()))\nM = int(input())\nquery = list(map(int, input().split()))\nresult = []\nfor q in query:\n    idx = bisect.bisect_left(cards, q)\n    if idx < N and cards[idx] == q:\n        result.append(1)\n    else:\n        result.append(0)\nprint(' '.join(map(str, result)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "이분 탐색 사용",
            "description": "정렬 후 이분 탐색으로 존재 여부를 확인합니다.",
            "code_pattern": "bisect.bisect_left(cards, q)",
            "socratic_hint": "정렬된 리스트에서 빠르게 찾으려면?",
            "hint": "이분 탐색을 사용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4: 딕셔너리",
        "solution_code": "N = int(input())\ncards = {x: True for x in map(int, input().split())}\nM = int(input())\nquery = list(map(int, input().split()))\nprint(' '.join('1' if q in cards else '0' for q in query))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "딕셔너리로 O(1) 검색",
            "description": "딕셔너리는 평균 O(1)로 검색합니다.",
            "code_pattern": "cards = {x: True for x in ...}",
            "socratic_hint": "빠른 존재 확인을 위해서는?",
            "hint": "딕셔너리나 집합을 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10816",
    "step_title": "집합과 맵",
    "title": "숫자 카드 2",
    "level": 7,
    "tags": [
      "자료 구조",
      "정렬",
      "이분 탐색",
      "해시를 사용한 집합과 맵"
    ],
    "description": "숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 몇 개 가지고 있는지 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 숫자 카드에 적혀있는 수는 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다. 넷째 줄에는 상근이가 몇 개 가지고 있는 숫자 카드인지 구해야 할 M개의 정수가 주어지며, 이 수는 공백으로 구분되어져 있다. 이 수도 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.",
    "output_description": "첫째 줄에 입력으로 주어진 M개의 수에 대해서, 각 수가 적힌 숫자 카드를 상근이가 몇 개 가지고 있는지를 공백으로 구분해 출력한다.",
    "examples": [
      {
        "input": "10\n6 3 2 10 10 10 -10 -10 7 3\n8\n10 9 -5 2 3 4 5 -10",
        "output": "3 0 0 1 2 0 0 2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10816",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import Counter\n\nN = int(input())\ncards = list(map(int, input().split()))\nM = int(input())\nqueries = list(map(int, input().split()))\n\ncounter = Counter(cards)\nresult = [str(counter[q]) for q in queries]\nprint(' '.join(result))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10818",
    "step_title": "1차원 배열",
    "title": "최소, 최대",
    "level": 3,
    "tags": [
      "수학",
      "구현"
    ],
    "description": "N개의 정수가 주어진다. 이때, 최솟값과 최댓값을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 정수의 개수 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄에는 N개의 정수를 공백으로 구분해서 주어진다. 모든 정수는 -1,000,000보다 크거나 같고, 1,000,000보다 작거나 같은 정수이다.",
    "output_description": "첫째 줄에 주어진 정수 N개의 최솟값과 최댓값을 공백으로 구분해 출력한다.",
    "examples": [
      {
        "input": "5\r\n20 10 35 30 7",
        "output": "7 35"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10818",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nnumbers = []\nnumbers = list(map(int, input().split()))\nprint(min(numbers), max(numbers))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "N 입력",
            "description": "정수의 개수 N을 입력받습니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "몇 개의 정수를 입력받을지 먼저 알아야 합니다.",
            "hint": "N = int(input())"
          },
          {
            "step_id": 2,
            "goal": "빈 리스트 생성",
            "description": "정수들을 저장할 빈 리스트를 만듭니다.",
            "code_pattern": "numbers = []",
            "socratic_hint": "여러 정수를 저장할 공간을 만들려면?",
            "hint": "numbers = []"
          },
          {
            "step_id": 3,
            "goal": "N개 정수 입력받아 저장",
            "description": "N번 반복하면서 정수를 입력받아 리스트에 추가합니다.",
            "code_pattern": "for i in range(N):\n    num = int(input())\n    numbers.append(num)",
            "socratic_hint": "N번 반복하면서 입력받고 리스트에 추가하려면?",
            "hint": "for 반복문과 append()를 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "최솟값과 최댓값 찾기",
            "description": "min()과 max() 함수로 최솟값과 최댓값을 찾습니다.",
            "code_pattern": "min_value = min(numbers)\nmax_value = max(numbers)",
            "socratic_hint": "리스트에서 가장 작은 값과 큰 값을 구하려면?",
            "hint": "min()과 max() 함수를 사용합니다."
          },
          {
            "step_id": 5,
            "goal": "결과 출력",
            "description": "최솟값과 최댓값을 공백으로 구분하여 출력합니다.",
            "code_pattern": "print(min(numbers), max(numbers))",
            "socratic_hint": "두 값을 공백으로 구분하여 출력하려면?",
            "hint": "print(min_value, max_value)"
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: min/max 함수 직접 사용",
        "solution_code": "N = int(input())\nnumbers = list(map(int, input().split()))\nprint(min(numbers), max(numbers))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수를 입력받고 리스트로 변환합니다.",
            "code_pattern": "numbers = list(map(int, input().split()))",
            "socratic_hint": "여러 정수를 리스트로 입력받으려면?",
            "hint": "list(map(int, input().split()))을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "min/max 함수 사용",
            "description": "내장 함수를 사용하여 최솟값과 최댓값을 찾습니다.",
            "code_pattern": "min(numbers), max(numbers)",
            "socratic_hint": "리스트의 최솟값과 최댓값을 찾으려면?",
            "hint": "min()과 max() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3: 반복문으로 직접 탐색",
        "solution_code": "N = int(input())\nnumbers = list(map(int, input().split()))\nmin_val = numbers[0]\nmax_val = numbers[0]\nfor num in numbers:\n    if num < min_val:\n        min_val = num\n    if num > max_val:\n        max_val = num\nprint(min_val, max_val)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 및 초기화",
            "description": "입력을 받고 최솟값/최댓값을 첫 번째 원소로 초기화합니다.",
            "code_pattern": "min_val = numbers[0]\nmax_val = numbers[0]",
            "socratic_hint": "최솟값과 최댓값을 어떻게 초기화하나요?",
            "hint": "첫 번째 원소로 초기화합니다."
          },
          {
            "step_id": 2,
            "goal": "반복문으로 탐색",
            "description": "모든 원소를 확인하며 최솟값과 최댓값을 갱신합니다.",
            "code_pattern": "for num in numbers:\n    if num < min_val:\n        min_val = num",
            "socratic_hint": "모든 원소를 확인하며 최솟값을 찾으려면?",
            "hint": "for문과 if문을 사용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4: sorted 활용",
        "solution_code": "N = int(input())\nnumbers = sorted(map(int, input().split()))\nprint(numbers[0], numbers[-1])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정렬하여 찾기",
            "description": "정렬 후 첫 번째와 마지막 원소를 출력합니다.",
            "code_pattern": "numbers = sorted(map(int, input().split()))",
            "socratic_hint": "정렬로 최소/최대를 찾으려면?",
            "hint": "sorted()로 정렬 후 인덱스로 접근합니다."
          }
        ]
      },
      {
        "solution_id": 5,
        "solution_name": "풀이 5: heapq 활용",
        "solution_code": "import heapq\nN = int(input())\nnumbers = list(map(int, input().split()))\nheapq.heapify(numbers)\nmin_val = heapq.heappop(numbers)\nmax_val = max(numbers + [min_val])\nprint(min_val, max_val)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "힙으로 최소값",
            "description": "heapq로 최소값을 빠르게 찾습니다.",
            "code_pattern": "heapq.heapify(numbers)\nmin_val = heapq.heappop(numbers)",
            "socratic_hint": "힙으로 최소값을 찾으려면?",
            "hint": "heapq.heapify()와 heappop()을 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10830",
    "step_title": "분할 정복",
    "title": "행렬 제곱",
    "level": 12,
    "tags": [
      "수학",
      "분할 정복",
      "분할 정복을 이용한 거듭제곱",
      "선형대수학"
    ],
    "description": "크기가 N*N인 행렬 A가 주어진다. 이때, A의 B제곱을 구하는 프로그램을 작성하시오. 수가 매우 커질 수 있으니, A^B의 각 원소를 1,000으로 나눈 나머지를 출력한다.",
    "input_description": "첫째 줄에 행렬의 크기 N과 B가 주어진다. (2 ≤ N ≤  5, 1 ≤ B ≤ 100,000,000,000)둘째 줄부터 N개의 줄에 행렬의 각 원소가 주어진다. 행렬의 각 원소는 1,000보다 작거나 같은 자연수 또는 0이다.",
    "output_description": "첫째 줄부터 N개의 줄에 걸쳐 행렬 A를 B제곱한 결과를 출력한다.",
    "examples": [
      {
        "input": "2 5\r\n1 2\r\n3 4",
        "output": "69 558\r\n337 406"
      },
      {
        "input": "3 3\r\n1 2 3\r\n4 5 6\r\n7 8 9",
        "output": "468 576 684\r\n62 305 548\r\n656 34 412"
      },
      {
        "input": "5 10\r\n1 0 0 0 1\r\n1 0 0 0 1\r\n1 0 0 0 1\r\n1 0 0 0 1\r\n1 0 0 0 1",
        "output": "512 0 0 0 512\r\n512 0 0 0 512\r\n512 0 0 0 512\r\n512 0 0 0 512\r\n512 0 0 0 512"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10830",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def matrix_mult(A, B, N):\n    result = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            for k in range(N):\n                result[i][j] += A[i][k] * B[k][j]\n            result[i][j] %= 1000\n    return result\n\ndef matrix_power(M, B, N):\n    if B == 1:\n        return [[M[i][j] % 1000 for j in range(N)] for i in range(N)]\n    \n    half = matrix_power(M, B // 2, N)\n    if B % 2 == 0:\n        return matrix_mult(half, half, N)\n    else:\n        return matrix_mult(matrix_mult(half, half, N), M, N)\n\nN, B = map(int, input().split())\nM = []\nfor _ in range(N):\n    M.append(list(map(int, input().split())))\n\nresult = matrix_power(M, B, N)\nfor row in result:\n    print(' '.join(map(str, row)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10844",
    "step_title": "동적 계획법 1",
    "title": "쉬운 계단 수",
    "level": 10,
    "tags": [
      "다이나믹 프로그래밍"
    ],
    "description": "45656이란 수를 보자.이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.",
    "input_description": "첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.",
    "output_description": "첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.",
    "examples": [
      {
        "input": "1",
        "output": "9"
      },
      {
        "input": "2",
        "output": "17"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10844",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nMOD = 1000000000\n\ndp = [[0] * 10 for _ in range(N + 1)]\nfor i in range(1, 10):\n    dp[1][i] = 1\n\nfor i in range(2, N + 1):\n    for j in range(10):\n        if j > 0:\n            dp[i][j] += dp[i-1][j-1]\n        if j < 9:\n            dp[i][j] += dp[i-1][j+1]\n        dp[i][j] %= MOD\n\nprint(sum(dp[N]) % MOD)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10869",
    "step_title": "입출력과 사칙연산",
    "title": "사칙연산",
    "level": 1,
    "tags": [
      "구현",
      "사칙연산",
      "수학"
    ],
    "description": "두 자연수 A와 B가 주어진다. 이때, A+B, A-B, A*B, A/B(몫), A%B(나머지)를 출력하는 프로그램을 작성하시오.",
    "input_description": "두 자연수 A와 B가 주어진다. (1 ≤ A, B ≤ 10,000)",
    "output_description": "첫째 줄에 A+B, 둘째 줄에 A-B, 셋째 줄에 A*B, 넷째 줄에 A/B, 다섯째 줄에 A%B를 출력한다.",
    "examples": [
      {
        "input": "7 3",
        "output": "10\r\n4\r\n21\r\n2\r\n1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10869",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1: 단계별 출력",
        "solution_code": "A, B = map(int, input().split())\nprint(A + B)\nprint(A - B)\nprint(A * B)\nprint(A // B)\nprint(A % B)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "첫 번째 정수 A 입력",
            "description": "첫 번째 정수를 입력받아 A에 저장합니다.",
            "code_pattern": "A = int(input())",
            "socratic_hint": "첫 번째 수를 입력받으려면?",
            "hint": "A = int(input())을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "두 번째 정수 B 입력",
            "description": "두 번째 정수를 입력받아 B에 저장합니다.",
            "code_pattern": "B = int(input())",
            "socratic_hint": "두 번째 수를 입력받으려면?",
            "hint": "B = int(input())을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "덧셈 결과 출력",
            "description": "A + B를 출력합니다.",
            "code_pattern": "print(A + B)",
            "socratic_hint": "A + B를 출력하려면?",
            "hint": "print(A + B)를 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "뺄셈 결과 출력",
            "description": "A - B를 출력합니다.",
            "code_pattern": "print(A - B)",
            "socratic_hint": "A - B를 출력하려면?",
            "hint": "print(A - B)를 사용합니다."
          },
          {
            "step_id": 5,
            "goal": "곱셈 결과 출력",
            "description": "A × B를 출력합니다.",
            "code_pattern": "print(A * B)",
            "socratic_hint": "A × B를 출력하려면?",
            "hint": "print(A * B)를 사용합니다."
          },
          {
            "step_id": 6,
            "goal": "몫 출력",
            "description": "A를 B로 나눈 몫을 출력합니다.",
            "code_pattern": "print(A // B)",
            "socratic_hint": "A를 B로 나눈 몫을 구하려면?",
            "hint": "//는 정수 나눗셈(몫)입니다."
          },
          {
            "step_id": 7,
            "goal": "나머지 출력",
            "description": "A를 B로 나눈 나머지를 출력합니다.",
            "code_pattern": "print(A % B)",
            "socratic_hint": "A를 B로 나눈 나머지를 구하려면?",
            "hint": "%는 나머지 연산자입니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: 리스트 활용",
        "solution_code": "A, B = map(int, input().split())\nresults = [A+B, A-B, A*B, A//B, A%B]\nfor r in results:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "두 정수 입력받기",
            "description": "공백으로 구분된 두 정수를 한 번에 입력받습니다.",
            "code_pattern": "A, B = map(int, input().split())",
            "socratic_hint": "공백으로 구분된 두 수를 한 번에 입력받으려면?",
            "hint": "map(int, input().split())과 언패킹을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "모든 연산 결과를 리스트에 저장",
            "description": "다섯 가지 연산 결과를 리스트에 저장합니다.",
            "code_pattern": "results = [A+B, A-B, A*B, A//B, A%B]",
            "socratic_hint": "다섯 가지 연산 결과를 한 번에 저장하려면?",
            "hint": "리스트에 [덧셈, 뺄셈, 곱셈, 몫, 나머지] 순서로 저장합니다."
          },
          {
            "step_id": 3,
            "goal": "결과를 순서대로 출력",
            "description": "리스트의 각 요소를 한 줄씩 출력합니다.",
            "code_pattern": "for r in results:\n    print(r)",
            "socratic_hint": "리스트의 각 요소를 한 줄씩 출력하려면?",
            "hint": "for 반복문으로 리스트를 순회하며 출력합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10870",
    "step_title": "재귀",
    "title": "피보나치 수 5",
    "level": 4,
    "tags": [
      "수학",
      "구현"
    ],
    "description": "피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.이를 식으로 써보면 Fn= Fn-1+ Fn-2(n ≥ 2)가 된다.n=17일때 까지 피보나치 수를 써보면 다음과 같다.0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 n이 주어진다. n은 20보다 작거나 같은 자연수 또는 0이다.",
    "output_description": "첫째 줄에 n번째 피보나치 수를 출력한다.",
    "examples": [
      {
        "input": "10",
        "output": "55"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10870",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def fib(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n-1) + fib(n-2)\n\nN = int(input())\nprint(fib(N))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10871",
    "step_title": "1차원 배열",
    "title": "X보다 작은 수",
    "level": 1,
    "tags": [
      "구현"
    ],
    "description": "정수 N개로 이루어진 수열 A와 정수 X가 주어진다. 이때, A에서 X보다 작은 수를 모두 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N과 X가 주어진다. (1 ≤ N, X ≤ 10,000)둘째 줄에 수열 A를 이루는 정수 N개가 주어진다. 주어지는 정수는 모두 1보다 크거나 같고, 10,000보다 작거나 같은 정수이다.",
    "output_description": "X보다 작은 수를 입력받은 순서대로 공백으로 구분해 출력한다. X보다 작은 수는 적어도 하나 존재한다.",
    "examples": [
      {
        "input": "10 5\r\n1 10 4 9 2 3 8 5 7 6",
        "output": "1 4 2 3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10871",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N, X = map(int, input().split())\nnumbers = []\nnumbers = list(map(int, input().split()))\n# X보다 작은 수만 출력\nfor num in numbers:\n    if num < X:\n        print(num, end=' ')",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "N 입력",
            "description": "수의 개수 N을 입력받습니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "몇 개의 수를 입력받을지 입력하려면?",
            "hint": "N = int(input())"
          },
          {
            "step_id": 2,
            "goal": "X 입력",
            "description": "기준값 X를 입력받습니다.",
            "code_pattern": "X = int(input())",
            "socratic_hint": "비교할 기준값을 입력받으려면?",
            "hint": "X = int(input())"
          },
          {
            "step_id": 3,
            "goal": "빈 리스트 만들기",
            "description": "수를 저장할 빈 리스트를 만듭니다.",
            "code_pattern": "numbers = []",
            "socratic_hint": "여러 수를 저장할 공간을 만들려면?",
            "hint": "numbers = []로 빈 리스트를 만듭니다."
          },
          {
            "step_id": 4,
            "goal": "N개의 수 입력받기",
            "description": "반복문으로 N개의 수를 입력받아 리스트에 추가합니다.",
            "code_pattern": "for i in range(N):\n    num = int(input())\n    numbers.append(num)",
            "socratic_hint": "N번 반복하면서 수를 입력받아 리스트에 넣으려면?",
            "hint": "for 반복문과 append()를 사용합니다."
          },
          {
            "step_id": 5,
            "goal": "X보다 작은 수 찾기",
            "description": "리스트의 각 수를 확인하여 X보다 작으면 출력합니다.",
            "code_pattern": "for num in numbers:\n    if num < X:",
            "socratic_hint": "리스트의 각 수가 X보다 작은지 어떻게 확인하나요?",
            "hint": "for 반복문과 if 조건문을 사용합니다."
          },
          {
            "step_id": 6,
            "goal": "공백으로 구분하여 출력",
            "description": "X보다 작은 수를 공백으로 구분하여 한 줄에 출력합니다.",
            "code_pattern": "        print(num, end=' ')",
            "socratic_hint": "숫자들을 공백으로 구분하여 출력하려면?",
            "hint": "print(num, end=' ')를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: min/max 함수 직접 사용",
        "solution_code": "N = int(input())\nnumbers = list(map(int, input().split()))\nprint(max(numbers))\nprint(numbers.index(max(numbers)) + 1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수를 입력받고 리스트로 변환합니다.",
            "code_pattern": "numbers = list(map(int, input().split()))",
            "socratic_hint": "여러 정수를 리스트로 입력받으려면?",
            "hint": "list(map(int, input().split()))을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "min/max 함수 사용",
            "description": "내장 함수를 사용하여 최솟값과 최댓값을 찾습니다.",
            "code_pattern": "min(numbers), max(numbers)",
            "socratic_hint": "리스트의 최솟값과 최댓값을 찾으려면?",
            "hint": "min()과 max() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3: 반복문으로 직접 탐색",
        "solution_code": "N = int(input())\nnumbers = list(map(int, input().split()))\nmax_val = numbers[0]\nmax_idx = 0\nfor i in range(len(numbers)):\n    if numbers[i] > max_val:\n        max_val = numbers[i]\n        max_idx = i\nprint(max_val)\nprint(max_idx + 1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 및 초기화",
            "description": "입력을 받고 최솟값/최댓값을 첫 번째 원소로 초기화합니다.",
            "code_pattern": "min_val = numbers[0]\nmax_val = numbers[0]",
            "socratic_hint": "최솟값과 최댓값을 어떻게 초기화하나요?",
            "hint": "첫 번째 원소로 초기화합니다."
          },
          {
            "step_id": 2,
            "goal": "반복문으로 탐색",
            "description": "모든 원소를 확인하며 최솟값과 최댓값을 갱신합니다.",
            "code_pattern": "for num in numbers:\n    if num < min_val:\n        min_val = num",
            "socratic_hint": "모든 원소를 확인하며 최솟값을 찾으려면?",
            "hint": "for문과 if문을 사용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4: filter 활용",
        "solution_code": "N, X = map(int, input().split())\nnumbers = list(map(int, input().split()))\nresult = list(filter(lambda n: n < X, numbers))\nprint(' '.join(map(str, result)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "filter로 필터링",
            "description": "filter 함수로 조건에 맞는 원소만 선택합니다.",
            "code_pattern": "list(filter(lambda n: n < X, numbers))",
            "socratic_hint": "조건에 맞는 원소만 선택하려면?",
            "hint": "filter 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 5,
        "solution_name": "풀이 5: for문 간단히",
        "solution_code": "N, X = map(int, input().split())\nnumbers = list(map(int, input().split()))\nfor num in numbers:\n    if num < X:\n        print(num, end=' ')",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "for문으로 출력",
            "description": "조건을 만족하는 원소를 바로 출력합니다.",
            "code_pattern": "for num in numbers:\n    if num < X:\n        print(num, end=' ')",
            "socratic_hint": "조건에 맞으면 바로 출력하려면?",
            "hint": "for문과 if문을 조합합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10872",
    "step_title": "조합론",
    "title": "팩토리얼",
    "level": 3,
    "tags": [
      "수학",
      "구현"
    ],
    "description": "0보다 크거나 같은 정수 N이 주어진다. 이때, N!을 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 정수 N(0 ≤ N ≤ 12)이 주어진다.",
    "output_description": "첫째 줄에 N!을 출력한다.",
    "examples": [
      {
        "input": "10",
        "output": "3628800"
      },
      {
        "input": "0",
        "output": "1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10872",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nresult = 1\nfor i in range(1, N+1):\n    result *= i\nprint(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10926",
    "step_title": "입출력과 사칙연산",
    "title": "??!",
    "level": 1,
    "tags": [
      "구현"
    ],
    "description": "준하는 사이트에 회원가입을 하다가 joonas라는 아이디가 이미 존재하는 것을 보고 놀랐다. 준하는 놀람을 ??!로 표현한다. 준하가 가입하려고 하는 사이트에 이미 존재하는 아이디가 주어졌을 때, 놀람을 표현하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 준하가 가입하려고 하는 사이트에 이미 존재하는 아이디가 주어진다. 아이디는 알파벳 소문자로만 이루어져 있으며, 길이는 50자를 넘지 않는다.",
    "output_description": "첫째 줄에 준하의 놀람을 출력한다. 놀람은 아이디 뒤에 ??!를 붙여서 나타낸다.",
    "examples": [
      {
        "input": "joonas",
        "output": "joonas??!"
      },
      {
        "input": "baekjoon",
        "output": "baekjoon??!"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10926",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "name = input()\nprint(name + \"??!\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "name = input()로 입력을 처리합니다.",
            "code_pattern": "name = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(name + \"??!\")",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10950",
    "step_title": "반복문",
    "title": "A+B - 3",
    "level": 1,
    "tags": [
      "구현",
      "사칙연산",
      "수학"
    ],
    "description": "두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 테스트 케이스의 개수 T가 주어진다.각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 < A, B < 10)",
    "output_description": "각 테스트 케이스마다 A+B를 출력한다.",
    "examples": [
      {
        "input": "5\r\n1 1\r\n2 3\r\n3 4\r\n9 8\r\n5 2",
        "output": "2\r\n5\r\n7\r\n17\r\n7"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10950",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1: 기본 반복문",
        "solution_code": "T = int(input())\nfor _ in range(T):\n    A, B = map(int, input().split())\n    print(A + B)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "테스트 케이스 개수 입력",
            "description": "몇 번 반복할지 T를 입력받습니다.",
            "code_pattern": "T = int(input())",
            "socratic_hint": "반복 횟수를 입력받으려면?",
            "hint": "T = int(input())"
          },
          {
            "step_id": 2,
            "goal": "T번 반복 시작",
            "description": "for i in range(T)로 T번 반복합니다.",
            "code_pattern": "for i in range(T):",
            "socratic_hint": "T번 반복하려면?",
            "hint": "for i in range(T):"
          },
          {
            "step_id": 3,
            "goal": "매번 A 입력",
            "description": "반복문 안에서 A를 입력받습니다.",
            "code_pattern": "    A = int(input())",
            "socratic_hint": "반복할 때마다 첫 번째 수를 입력받으려면?",
            "hint": "반복문 안에서 A = int(input())"
          },
          {
            "step_id": 4,
            "goal": "매번 B 입력",
            "description": "B를 입력받습니다.",
            "code_pattern": "    B = int(input())",
            "socratic_hint": "두 번째 수를 입력받으려면?",
            "hint": "B = int(input())"
          },
          {
            "step_id": 5,
            "goal": "A + B 출력",
            "description": "두 수의 합을 출력합니다.",
            "code_pattern": "    print(A + B)",
            "socratic_hint": "합을 출력하려면?",
            "hint": "print(A + B)"
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: 리스트 컴프리헨션",
        "solution_code": "T = int(input())\nresults = [sum(map(int, input().split())) for _ in range(T)]\nfor r in results:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "테스트 케이스 개수 T 입력",
            "description": "반복할 횟수를 입력받습니다.",
            "code_pattern": "T = int(input())",
            "socratic_hint": "테스트 케이스 개수를 입력받으려면?",
            "hint": "T = int(input())을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "리스트 컴프리헨션으로 모든 결과 계산",
            "description": "한 번에 모든 입력을 받아 합을 계산하여 리스트에 저장합니다.",
            "code_pattern": "results = [sum(map(int, input().split())) for _ in range(T)]",
            "socratic_hint": "모든 입력을 한 번에 처리하려면?",
            "hint": "리스트 컴프리헨션을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "결과 출력",
            "description": "저장된 결과를 순서대로 출력합니다.",
            "code_pattern": "for r in results:\n    print(r)",
            "socratic_hint": "리스트의 각 요소를 출력하려면?",
            "hint": "for 반복문으로 순회합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3: map과 lambda",
        "solution_code": "T = int(input())\nlist(map(lambda _: print(sum(map(int, input().split()))), range(T)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "map으로 반복",
            "description": "map을 사용하여 각 테스트케이스를 처리합니다.",
            "code_pattern": "map(lambda _: print(sum(map(int, input().split()))), range(T))",
            "socratic_hint": "map으로 반복하며 출력하려면?",
            "hint": "lambda와 map을 조합합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10951",
    "step_title": "반복문",
    "title": "A+B - 4",
    "level": 1,
    "tags": [
      "구현",
      "사칙연산",
      "수학"
    ],
    "description": "두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.",
    "input_description": "입력은 여러 개의 테스트 케이스로 이루어져 있다.각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 < A, B < 10)",
    "output_description": "각 테스트 케이스마다 A+B를 출력한다.",
    "examples": [
      {
        "input": "1 1\r\n2 3\r\n3 4\r\n9 8\r\n5 2",
        "output": "2\r\n5\r\n7\r\n17\r\n7"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10951",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nfor line in sys.stdin:\n    A, B = map(int, line.split())\n    print(A + B)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "무한 반복 시작",
            "description": "while True:로 계속 반복합니다.",
            "code_pattern": "while True:",
            "socratic_hint": "끝없이 반복하려면?",
            "hint": "while True:"
          },
          {
            "step_id": 2,
            "goal": "예외 처리 시작",
            "description": "try: 블록으로 오류가 발생할 수 있는 코드를 감쌉니다.",
            "code_pattern": "    try:",
            "socratic_hint": "오류가 발생할 수 있는 코드를 안전하게 실행하려면?",
            "hint": "try-except를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "A 입력받기",
            "description": "A를 입력받습니다. 입력이 없으면 오류가 발생합니다.",
            "code_pattern": "        A = int(input())",
            "socratic_hint": "첫 번째 수를 입력받으려면?",
            "hint": "A = int(input())"
          },
          {
            "step_id": 4,
            "goal": "B 입력받기",
            "description": "B를 입력받습니다.",
            "code_pattern": "        B = int(input())",
            "socratic_hint": "두 번째 수를 입력받으려면?",
            "hint": "B = int(input())"
          },
          {
            "step_id": 5,
            "goal": "합 출력",
            "description": "A + B를 출력합니다.",
            "code_pattern": "        print(A + B)",
            "socratic_hint": "합을 출력하려면?",
            "hint": "print(A + B)"
          },
          {
            "step_id": 6,
            "goal": "예외 발생 시 종료",
            "description": "except: 블록에서 break로 반복을 종료합니다.",
            "code_pattern": "    except:\n        break",
            "socratic_hint": "오류가 발생하면 반복을 멈추려면?",
            "hint": "except: break"
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: try-except",
        "solution_code": "while True:\n    try:\n        A, B = map(int, input().split())\n        print(A + B)\n    except EOFError:\n        break",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "EOFError 처리",
            "description": "EOFError 예외를 잡아서 종료합니다.",
            "code_pattern": "except EOFError:\n    break",
            "socratic_hint": "EOF를 감지하려면?",
            "hint": "EOFError 예외를 처리합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10952",
    "step_title": "반복문",
    "title": "A+B - 5",
    "level": 1,
    "tags": [
      "구현",
      "사칙연산",
      "수학"
    ],
    "description": "두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.",
    "input_description": "입력은 여러 개의 테스트 케이스로 이루어져 있다.각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 < A, B < 10)입력의 마지막에는 0 두 개가 들어온다.",
    "output_description": "각 테스트 케이스마다 A+B를 출력한다.",
    "examples": [
      {
        "input": "1 1\r\n2 3\r\n3 4\r\n9 8\r\n5 2\r\n0 0",
        "output": "2\r\n5\r\n7\r\n17\r\n7"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10952",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "while True:\n    A, B = map(int, input().split())\n    if A == 0 and B == 0:\n        break\n    print(A + B)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "무한 반복 시작",
            "description": "while True:로 계속 반복합니다.",
            "code_pattern": "while True:",
            "socratic_hint": "종료 조건을 만날 때까지 반복하려면?",
            "hint": "while True:"
          },
          {
            "step_id": 2,
            "goal": "A 입력",
            "description": "A를 입력받습니다.",
            "code_pattern": "    A = int(input())",
            "socratic_hint": "첫 번째 수를 입력받으려면?",
            "hint": "A = int(input())"
          },
          {
            "step_id": 3,
            "goal": "B 입력",
            "description": "B를 입력받습니다.",
            "code_pattern": "    B = int(input())",
            "socratic_hint": "두 번째 수를 입력받으려면?",
            "hint": "B = int(input())"
          },
          {
            "step_id": 4,
            "goal": "종료 조건 확인",
            "description": "A == 0 and B == 0이면 break로 반복을 종료합니다.",
            "code_pattern": "    if A == 0 and B == 0:\n        break",
            "socratic_hint": "0 0이 입력되면 어떻게 멈추나요?",
            "hint": "if A == 0 and B == 0: break"
          },
          {
            "step_id": 5,
            "goal": "A + B 계산",
            "description": "두 수를 더합니다.",
            "code_pattern": "    result = A + B",
            "socratic_hint": "두 수를 더하려면?",
            "hint": "result = A + B"
          },
          {
            "step_id": 6,
            "goal": "결과 출력",
            "description": "합을 출력합니다.",
            "code_pattern": "    print(A + B)",
            "socratic_hint": "결과를 출력하려면?",
            "hint": "print(A + B)"
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: walrus 연산자",
        "solution_code": "while (nums := list(map(int, input().split()))) != [0, 0]:\n    print(sum(nums))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "walrus 연산자 사용",
            "description": ":= 연산자로 할당과 비교를 동시에 합니다.",
            "code_pattern": "while (nums := list(map(int, input().split()))) != [0, 0]:",
            "socratic_hint": "Python 3.8+ walrus 연산자는?",
            "hint": ":= 를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10986",
    "step_title": "누적 합",
    "title": "나머지 합",
    "level": 13,
    "tags": [
      "수학",
      "누적 합"
    ],
    "description": "수 N개 A1, A2, ..., AN이 주어진다. 이때, 연속된 부분 구간의 합이 M으로 나누어 떨어지는 구간의 개수를 구하는 프로그램을 작성하시오.즉, Ai+ ... + Aj(i ≤ j) 의 합이 M으로 나누어 떨어지는 (i, j) 쌍의 개수를 구해야 한다.",
    "input_description": "첫째 줄에 N과 M이 주어진다. (1 ≤ N ≤ 106, 2 ≤ M ≤ 103)둘째 줄에 N개의 수 A1, A2, ..., AN이 주어진다. (0 ≤ Ai≤ 109)",
    "output_description": "첫째 줄에 연속된 부분 구간의 합이 M으로 나누어 떨어지는 구간의 개수를 출력한다.",
    "examples": [
      {
        "input": "5 3\n1 2 3 1 2",
        "output": "7"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10986",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N, M = map(int, input().split())\nA = list(map(int, input().split()))\n\nprefix = [0] * (N + 1)\nfor i in range(N):\n    prefix[i+1] = (prefix[i] + A[i]) % M\n\ncount = [0] * M\nfor p in prefix:\n    count[p] += 1\n\nresult = 0\nfor c in count:\n    result += c * (c - 1) // 2\n\nprint(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10988",
    "step_title": "심화 1",
    "title": "팰린드롬인지 확인하기",
    "level": 3,
    "tags": [
      "구현",
      "문자열"
    ],
    "description": "알파벳 소문자로만 이루어진 단어가 주어진다. 이때, 이 단어가 팰린드롬인지 아닌지 확인하는 프로그램을 작성하시오.팰린드롬이란 앞으로 읽을 때와 거꾸로 읽을 때 똑같은 단어를 말한다.level, noon은 팰린드롬이고, baekjoon, online, judge는 팰린드롬이 아니다.",
    "input_description": "첫째 줄에 단어가 주어진다. 단어의 길이는 1보다 크거나 같고, 100보다 작거나 같으며, 알파벳 소문자로만 이루어져 있다.",
    "output_description": "첫째 줄에 팰린드롬이면 1, 아니면 0을 출력한다.",
    "examples": [
      {
        "input": "level",
        "output": "1"
      },
      {
        "input": "baekjoon",
        "output": "0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10988",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "word = input()\nprint(1 if word == word[::-1] else 0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "word = input()로 입력을 처리합니다.",
            "code_pattern": "word = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "조건 판단",
            "description": "조건문을 사용하여 상황에 따라 다르게 처리합니다.",
            "code_pattern": "print(1 if word == word[::-1] else 0)",
            "socratic_hint": "조건에 따라 다르게 처리하려면?",
            "hint": "if-else 문을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(1 if word == word[::-1] else 0)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10989",
    "step_title": "정렬",
    "title": "수 정렬하기 3",
    "level": 5,
    "tags": [
      "정렬"
    ],
    "description": "N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 수의 개수 N(1 ≤ N ≤ 10,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수가 주어진다. 이 수는 10,000보다 작거나 같은 자연수이다.",
    "output_description": "첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.",
    "examples": [
      {
        "input": "10\n5\n2\n3\n1\n4\n2\n3\n5\n1\n7",
        "output": "1\n1\n2\n2\n3\n3\n4\n5\n5\n7"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10989",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\ninput = sys.stdin.readline\n\nN = int(input())\ncount = [0] * 10001\n\nfor _ in range(N):\n    count[int(input())] += 1\n\nfor i in range(10001):\n    for _ in range(count[i]):\n        print(i)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor num in sorted(arr):\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\narr.sort()\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sort() 메서드로 정렬",
            "description": "arr.sort()로 리스트를 제자리에서 정렬합니다.",
            "code_pattern": "arr.sort()",
            "socratic_hint": "리스트를 제자리에서 정렬하는 메서드는?",
            "hint": ".sort() 메서드를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문을 사용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor i in range(n-1):\n    for j in range(n-1-i):\n        if arr[j] > arr[j+1]:\n            arr[j], arr[j+1] = arr[j+1], arr[j]\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 패스 횟수 제어",
            "description": "n-1번 반복하며 각 패스를 수행합니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "버블 정렬에서 몇 번의 패스가 필요한가요?",
            "hint": "n-1번의 패스가 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "내부 반복문: 인접 원소 비교",
            "description": "각 패스에서 인접한 두 원소를 비교합니다. 이미 정렬된 뒤쪽 부분은 제외합니다.",
            "code_pattern": "for j in range(n-1-i):",
            "socratic_hint": "각 패스에서 비교해야 할 원소의 범위는?",
            "hint": "n-1-i까지 비교합니다 (이미 정렬된 부분 제외)."
          },
          {
            "step_id": 4,
            "goal": "원소 교환",
            "description": "왼쪽 원소가 오른쪽 원소보다 크면 위치를 교환합니다.",
            "code_pattern": "if arr[j] > arr[j+1]:\n    arr[j], arr[j+1] = arr[j+1], arr[j]",
            "socratic_hint": "인접한 두 원소의 순서가 잘못되었을 때 어떻게 하나요?",
            "hint": "두 원소의 위치를 swap합니다."
          },
          {
            "step_id": 5,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      },
      {
        "solution_id": 5,
        "solution_name": "풀이 5",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor i in range(n-1):\n    min_idx = i\n    for j in range(i+1, n):\n        if arr[j] < arr[min_idx]:\n            min_idx = j\n    arr[i], arr[min_idx] = arr[min_idx], arr[i]\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 정렬할 위치 선택",
            "description": "n-1번 반복하며 각 위치에 올 최솟값을 찾습니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "선택 정렬에서 몇 번의 선택이 필요한가요?",
            "hint": "n-1번의 선택이 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "최솟값 인덱스 초기화",
            "description": "현재 위치를 최솟값 인덱스로 가정합니다.",
            "code_pattern": "min_idx = i",
            "socratic_hint": "최솟값을 찾기 위한 초기값은?",
            "hint": "현재 위치 i를 초기값으로 설정합니다."
          },
          {
            "step_id": 4,
            "goal": "내부 반복문: 최솟값 찾기",
            "description": "현재 위치 이후의 원소들 중 최솟값의 인덱스를 찾습니다.",
            "code_pattern": "for j in range(i+1, n):\n    if arr[j] < arr[min_idx]:\n        min_idx = j",
            "socratic_hint": "정렬되지 않은 부분에서 최솟값을 어떻게 찾나요?",
            "hint": "i+1부터 끝까지 순회하며 최솟값 인덱스를 업데이트합니다."
          },
          {
            "step_id": 5,
            "goal": "원소 교환",
            "description": "찾은 최솟값을 현재 위치로 이동시킵니다.",
            "code_pattern": "arr[i], arr[min_idx] = arr[min_idx], arr[i]",
            "socratic_hint": "최솟값을 현재 위치로 가져오려면?",
            "hint": "현재 위치의 값과 최솟값을 swap합니다."
          },
          {
            "step_id": 6,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      },
      {
        "solution_id": 6,
        "solution_name": "풀이 6: Counter 활용",
        "solution_code": "import sys\nfrom collections import Counter\ninput = sys.stdin.readline\nN = int(input())\ncounter = Counter(int(input()) for _ in range(N))\nfor num in sorted(counter.keys()):\n    for _ in range(counter[num]):\n        print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "Counter로 개수 세기",
            "description": "각 숫자의 출현 횟수를 셉니다.",
            "code_pattern": "counter = Counter(int(input()) for _ in range(N))",
            "socratic_hint": "숫자별 개수를 세려면?",
            "hint": "Counter를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10998",
    "step_title": "입출력과 사칙연산",
    "title": "A×B",
    "level": 1,
    "tags": [
      "구현",
      "사칙연산",
      "수학"
    ],
    "description": "두 정수 A와 B를 입력받은 다음, A×B를 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 A와 B가 주어진다. (0 < A, B < 10)",
    "output_description": "첫째 줄에 A×B를 출력한다.",
    "examples": [
      {
        "input": "1 2",
        "output": "2"
      },
      {
        "input": "3 4",
        "output": "12"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10998",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1: 각각 입력",
        "solution_code": "A = int(input())\nB = int(input())\nprint(A * B)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "A 입력받기",
            "description": "첫 번째 정수 A를 입력받습니다.",
            "code_pattern": "A = int(input())",
            "socratic_hint": "첫 번째 수를 입력받으려면?",
            "hint": "A = int(input())"
          },
          {
            "step_id": 2,
            "goal": "B 입력받기",
            "description": "두 번째 정수 B를 입력받습니다.",
            "code_pattern": "B = int(input())",
            "socratic_hint": "두 번째 수를 입력받으려면?",
            "hint": "B = int(input())"
          },
          {
            "step_id": 3,
            "goal": "A × B 출력",
            "description": "A와 B를 곱한 결과를 출력합니다.",
            "code_pattern": "print(A * B)",
            "socratic_hint": "곱셈 결과를 출력하려면?",
            "hint": "print(A * B)"
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: split 활용",
        "solution_code": "A, B = map(int, input().split())\nprint(A * B)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "한 줄에서 두 정수 입력받기",
            "description": "공백으로 구분된 두 정수를 한 번에 입력받습니다.",
            "code_pattern": "A, B = map(int, input().split())",
            "socratic_hint": "공백으로 구분된 두 정수를 한 번에 입력받으려면?",
            "hint": "A, B = map(int, input().split())을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "A × B 출력",
            "description": "A와 B를 곱한 결과를 출력합니다.",
            "code_pattern": "print(A * B)",
            "socratic_hint": "곱셈 결과를 출력하려면?",
            "hint": "print(A * B)를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3: 리스트 reduce",
        "solution_code": "from functools import reduce\nimport operator\nprint(reduce(operator.mul, map(int, input().split())))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "reduce로 곱셈",
            "description": "reduce를 사용하여 곱셈을 수행합니다.",
            "code_pattern": "reduce(operator.mul, ...)",
            "socratic_hint": "여러 값을 곱하려면?",
            "hint": "reduce를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4: 간단한 곱셈",
        "solution_code": "a, b = map(int, input().split())\nprint(a * b)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "두 정수를 입력받습니다.",
            "code_pattern": "a, b = map(int, input().split())",
            "socratic_hint": "입력받으려면?",
            "hint": "map과 split을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "곱셈 출력",
            "description": "a와 b를 곱한 결과를 출력합니다.",
            "code_pattern": "print(a * b)",
            "socratic_hint": "곱셈 결과를 출력하려면?",
            "hint": "print(a * b)를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "10999",
    "step_title": "세그먼트 트리 2",
    "title": "구간 합 구하기 2",
    "level": 17,
    "tags": [
      "세그먼트 트리",
      "느리게 갱신되는 세그먼트 트리",
      "자료 구조"
    ],
    "description": "어떤 N개의 수가 주어져 있다. 그런데 중간에 수의 변경이 빈번히 일어나고 그 중간에 어떤 부분의 합을 구하려 한다. 만약에 1,2,3,4,5 라는 수가 있고, 3번째부터 4번째 수에 6을 더하면 1, 2, 9, 10, 5가 되고, 여기서 2번째부터 5번째까지 합을 구하라고 한다면 26을 출력하면 되는 것이다. 그리고 그 상태에서 1번째부터 3번째 수에 2를 빼고 2번째부터 5번째까지 합을 구하라고 한다면 22가 될 것이다.",
    "input_description": "첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)과 M(1 ≤ M ≤ 10,000), K(1 ≤ K ≤ 10,000) 가 주어진다. M은 수의 변경이 일어나는 횟수이고, K는 구간의 합을 구하는 횟수이다. 그리고 둘째 줄부터 N+1번째 줄까지 N개의 수가 주어진다. 그리고 N+2번째 줄부터 N+M+K+1번째 줄까지 세 개의 정수 a, b, c 또는 a, b, c, d가 주어지는데, a가 1인 경우 b번째 수부터 c번째 수에 d를 더하고, a가 2인 경우에는 b번째 수부터 c번째 수의 합을 구하여 출력하면 된다.입력으로 주어지는 모든 수는 -263보다 크거나 같고, 263-1보다 작거나 같은 정수이다.",
    "output_description": "첫째 줄부터 K줄에 걸쳐 구한 구간의 합을 출력한다. 단, 정답은 -263보다 크거나 같고, 263-1보다 작거나 같은 정수이다.",
    "examples": [
      {
        "input": "5 2 2\n1\n2\n3\n4\n5\n1 3 4 6\n2 2 5\n1 1 3 -2\n2 2 5",
        "output": "26\n22"
      }
    ],
    "url": "https://www.acmicpc.net/problem/10999",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11001",
    "step_title": "동적 계획법 최적화 1",
    "title": "김치",
    "level": 20,
    "tags": [
      "다이나믹 프로그래밍",
      "분할 정복",
      "분할 정복을 사용한 최적화"
    ],
    "description": "최재현은 지지부진한 알앤이 진도에 분노해서, 구재현의 싸대기에 잘 익은 김치를 던지려고 한다.물론 김치를 만드는 것이 쉬운 일은 아니기 때문에, 갈수록 추워지는 가을날 최재현은 남도에 있는 한 김치 명장을 찾아갔다.김치 명장이 말한 \"좋은 김치\"의 조건은 :숙성 시간이 길수록 김치의 맛은 좋아진다.추운 날에는 김치가 얼기 때문에, 현재 온도가 높을수록 김치의 맛은 좋아진다.김치를 넣은 날 장독대의 가치는 김치의 맛에 영향을 준다.최재현은 이 말이 잘 와닿지 않는지, 계속 질문을 던졌다. 다행인지 불행인지, 김치 명장은 컴퓨터 공학과를 전공한 실력 있는 프로그래머이다. 때문에 김치의 맛을 조금 더 엄밀하게 정의했다.김치의 맛은, (숙성 시간) * (김치를 꺼낼 때의 온도) + (김치를 넣은 날 가치) 로 정의된다. 숙성 시간은, (김치를 꺼낸 날짜 - 김치를 넣은 날짜) 이며, 숙성 시간이 0일 수도 있다.겨울이 오기 때문에, 김치를 꺼낼 때의 온도는 감소한다. (Ti >= Ti+1)하지만 최재현은 그렇게 시간이 많지 않고, 솔직히 말해서 알앤이 파트너에게 묵은지로 싸대기를 때리는 건 좀 나쁜 거 같다고 생각해서, 숙성 시간이 D 이하인 범위 안에서 재현이에게 싸대기를 때리려고 한다.재현이에게는 매일의 온도와 장독대의 가치가 주어진다. 재현이가 던질 수 있는 가장 맛있는 김치싸대기의 값은 얼마가 될수 있을까?",
    "input_description": "첫 번째 줄에 날짜의 수와 시간 제한 N, D가 주어진다. (1 ≤ D ≤ N ≤ 100,000)두 번째 줄에 온도 Ti가 주어진다. N-1 이하의 정수 i에 대해서 Ti>= Ti+1을 만족하며, 109이하의 자연수이다.세 번째 줄에 가치 Vi가 주어진다. 109이하의 자연수이다.",
    "output_description": "가장 맛있는 김치싸대기의 값을 출력하라.",
    "examples": [
      {
        "input": "4 4\r\n23 22 21 20\r\n20 40 30 50",
        "output": "80"
      },
      {
        "input": "4 1\r\n23 22 21 20\r\n20 40 30 50",
        "output": "61"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11001",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11003",
    "step_title": "스택, 큐, 덱 2",
    "title": "최솟값 찾기",
    "level": 16,
    "tags": [
      "자료 구조",
      "우선순위 큐",
      "덱",
      "덱을 이용한 구간 최댓값 트릭"
    ],
    "description": "N개의 수 A1, A2, ..., AN과 L이 주어진다.Di= Ai-L+1~ Ai중의 최솟값이라고 할 때, D에 저장된 수를 출력하는 프로그램을 작성하시오. 이때, i ≤ 0 인 Ai는 무시하고 D를 구해야 한다.",
    "input_description": "첫째 줄에 N과 L이 주어진다. (1 ≤ L ≤ N ≤ 5,000,000)둘째 줄에는 N개의 수 Ai가 주어진다. (-109≤ Ai≤ 109)",
    "output_description": "첫째 줄에 Di를 공백으로 구분하여 순서대로 출력한다.",
    "examples": [
      {
        "input": "12 3\r\n1 5 2 3 6 2 3 7 3 5 2 6",
        "output": "1 1 1 2 2 2 2 2 3 3 2 2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11003",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\nN, L = map(int, input().split())\nA = list(map(int, input().split()))\n\ndq = deque()\nresult = []\n\nfor i in range(N):\n    while dq and dq[0][1] < i - L + 1:\n        dq.popleft()\n    \n    while dq and dq[-1][0] > A[i]:\n        dq.pop()\n    \n    dq.append((A[i], i))\n    result.append(dq[0][0])\n\nprint(' '.join(map(str, result)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11005",
    "step_title": "수학 1",
    "title": "진법 변환 2",
    "level": 5,
    "tags": [
      "수학",
      "구현"
    ],
    "description": "10진법 수 N이 주어진다. 이 수를 B진법으로 바꿔 출력하는 프로그램을 작성하시오.10진법을 넘어가는 진법은 숫자로 표시할 수 없는 자리가 있다. 이런 경우에는 다음과 같이 알파벳 대문자를 사용한다.A: 10, B: 11, ..., F: 15, ..., Y: 34, Z: 35",
    "input_description": "첫째 줄에 N과 B가 주어진다. (2 ≤ B ≤ 36) N은 10억보다 작거나 같은 자연수이다.",
    "output_description": "첫째 줄에 10진법 수 N을 B진법으로 출력한다.",
    "examples": [
      {
        "input": "60466175 36",
        "output": "ZZZZZ"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11005",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N, B = map(int, input().split())\nresult = []\nwhile N > 0:\n    remainder = N % B\n    if remainder < 10:\n        result.append(str(remainder))\n    else:\n        result.append(chr(ord('A') + remainder - 10))\n    N //= B\nprint(''.join(reversed(result)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "여러 값 입력 받기",
            "description": "N, B = map(int, input().split())로 입력을 처리합니다.",
            "code_pattern": "N, B = map(int, input().split())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "조건 판단",
            "description": "조건문을 사용하여 상황에 따라 다르게 처리합니다.",
            "code_pattern": "if remainder < 10:",
            "socratic_hint": "조건에 따라 다르게 처리하려면?",
            "hint": "if-else 문을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(''.join(reversed(result)))",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11012",
    "step_title": "스위핑",
    "title": "Egg",
    "level": 19,
    "tags": [
      "자료 구조",
      "세그먼트 트리",
      "스위핑",
      "오프라인 쿼리",
      "퍼시스턴트 세그먼트 트리"
    ],
    "description": "You are a president deeply loved by many folks in your country. Every time you go on a parade (which is your main job, what else should a president do), the folks would throw eggs at you — because you love eggs! The folks passionately send their eggs to you, and you always can catch the eggs. In fact, egg-catching is exactly what makes you look forward to the parade every day! A folk would throw an egg at you for each time your parade comes to his home. You are given n coordinates on a 2D-map, these are where the folks that will throw an egg at you each time they see you on a parade. Note that the coordinates may repeat, since several folks may live together. There are in total m days left in your term and the area to parade each day are set. A parade always takes place in an axis-parallel rectangle area, as stated clearly in the constitution and as the president you have no choice but to follow it. You are given m 2D-ranges [ℓ, r]×[b, t] describing the parades.",
    "input_description": "Input begins with an integer T (1 ≤ T ≤ 20) indicating the number of test cases. The first line of each test case contains two integers n (0 < n ≤ 10000) and m (0 ≤ m ≤ 50000) separated by a blank where n is the number of folks throwing eggs and m is the number of days left in your term. Each of the following n lines contains two integers x and y (0 ≤ x, y ≤ 105) indicating that there is a folk’s home located at (x, y). Then m more lines follow. Each of them contains four integer ℓ, r, b, t (0 ≤ ℓ ≤ r ≤ 105, 0 ≤ b ≤ t ≤ 105) separated by blanks. [ℓ, r] × [b, t] corresponds to a parade area.",
    "output_description": "For each test case, output the total sum of eggs you receive on one line.",
    "examples": [
      {
        "input": "2\r\n3 1\r\n3 5\r\n2 3\r\n1 1\r\n1 2 1 3\r\n3 2\r\n5 3\r\n2 2\r\n1 1\r\n1 2 1 3\r\n2 5 2 3",
        "output": "2\r\n4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11012",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11014",
    "step_title": "이분 매칭",
    "title": "컨닝 2",
    "level": 19,
    "tags": [
      "이분 매칭"
    ],
    "description": "최백준은 서강대학교에서 “컨닝의 기술”이라는 과목을 가르치고 있다. 이 과목은 상당히 까다롭기로 정평이 나있기 때문에, 몇몇 학생들은 시험을 보는 도중에 다른 사람의 답지를 베끼려 한다.시험은 N행, M열 크기의 직사각형 교실에서 이루어진다. 교실은 1×1 크기의 단위 정사각형으로 이루어져 있는데, 각 단위 정사각형은 자리 하나를 의미한다.최백준은 컨닝을 방지하기 위해서 다음과 같은 전략을 세웠다. 모든 학생은 자신의 왼쪽, 오른쪽, 왼쪽 대각선 위, 오른쪽 대각선 위, 이렇게 총 네 자리에 앉아있는 친구의 답지를 항상 베낀다고 가정한다. 따라서, 자리 배치는 모든 학생이 컨닝을 할 수 없도록 배치되어야 한다.위의 그림을 보자. A, C, D 혹은 E에 다른 학생을 앉히는 것은 좋은 생각이 아니다. 그 이유는 이미 앉아있는 학생이 그들의 답안지를 베낄 우려가 있기 때문이다. 하지만, B에 다른 학생을 앉힌다면, 두 학생은 서로의 답지를 베낄 수 없어 컨닝의 우려가 없다.위와 같이 컨닝이 불가능하도록 자리를 배치 하려는 최백준의 행동에 분노한 일부 학생들이 교실의 책상을 부셔버렸기 때문에, 일부 자리에는 학생이 앉을 수 없다.최백준은 교실의 모양이 주어졌을 때, 이 곳에서 아무도 컨닝을 할 수 없도록 학생을 배치하였을 경우에 교실에 배치할 수 있는 최대 학생 수가 몇 명인지 궁금해졌다. 최백준을 위해 이를 구하는 프로그램을 작성하라.",
    "input_description": "입력의 첫 줄에는 테스트케이스의 개수 C가 주어진다. 각각의 테스트 케이스는 아래와 같이 두 부분으로 이루어진다.첫 번째 부분에서는 교실의 세로길이 N과 가로길이 M이 한 줄에 주어진다. (1 ≤ M ≤ 80, 1 ≤ N ≤ 80)두 번째 부분에서는 정확하게 N줄이 주어진다. 그리고 각 줄은 M개의 문자로 이루어져있다. 모든 문자는‘.’(앉을 수 있는 자리) 또는‘x’(앉을 수 없는 자리, 소문자)로 구성된다.",
    "output_description": "각각의 테스트 케이스에 대해 그 교실에서 시험을 볼 수 있는 최대 학생의 수를 출력한다.",
    "examples": [
      {
        "input": "4\n2 3\n...\n...\n2 3\nx.x\nxxx\n2 3\nx.x\nx.x\n10 10\n....x.....\n..........\n..........\n..x.......\n..........\nx...x.x...\n.........x\n...x......\n........x.\n.x...x....",
        "output": "4\n1\n2\n46"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11014",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11021",
    "step_title": "반복문",
    "title": "A+B - 7",
    "level": 1,
    "tags": [
      "구현",
      "사칙연산",
      "수학"
    ],
    "description": "두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 테스트 케이스의 개수 T가 주어진다.각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 < A, B < 10)",
    "output_description": "각 테스트 케이스마다 \"Case #x: \"를 출력한 다음, A+B를 출력한다. 테스트 케이스 번호는 1부터 시작한다.",
    "examples": [
      {
        "input": "5\r\n1 1\r\n2 3\r\n3 4\r\n9 8\r\n5 2",
        "output": "Case #1: 2\r\nCase #2: 5\r\nCase #3: 7\r\nCase #4: 17\r\nCase #5: 7"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11021",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "T = int(input())\nfor i in range(1, T + 1):\n    A, B = map(int, input().split())\n    print(\"Case #\" + str(i) + \":\", A + B)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 데이터 받기",
            "description": "문제에서 요구하는 데이터를 입력받습니다.",
            "code_pattern": "T = int(input())\n    A = int(input())",
            "socratic_hint": "어떤 데이터를 입력받아야 하나요?",
            "hint": "input() 함수로 데이터를 받고, 필요하면 int()로 변환합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력하기",
            "description": "처리된 결과를 출력합니다.",
            "code_pattern": "    print(\"Case #\" + str(i) + \":\", A + B)",
            "socratic_hint": "결과를 어떻게 출력하나요?",
            "hint": "print() 함수로 결과를 출력합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "T = int(input())\ni = 1\nwhile i <= T:\n    A, B = map(int, input().split())\n    print(f\"Case #{i}: {A + B}\")\n    i += 1",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "T = int(input())로 입력을 처리합니다.",
            "code_pattern": "T = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "반복 처리",
            "description": "while i <= T:로 반복 작업을 수행합니다.",
            "code_pattern": "while i <= T:",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "정수 입력 받기",
            "description": "A = int(input())로 입력을 처리합니다.",
            "code_pattern": "A = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "정수 입력 받기",
            "description": "B = int(input())로 입력을 처리합니다.",
            "code_pattern": "B = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 5,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(\"Case #\" + str(i) + \":\", A + B)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11022",
    "step_title": "반복문",
    "title": "A+B - 8",
    "level": 1,
    "tags": [
      "구현",
      "사칙연산",
      "수학"
    ],
    "description": "두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 테스트 케이스의 개수 T가 주어진다.각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 < A, B < 10)",
    "output_description": "각 테스트 케이스마다 \"Case #x: A + B = C\" 형식으로 출력한다. x는 테스트 케이스 번호이고 1부터 시작하며, C는 A+B이다.",
    "examples": [
      {
        "input": "5\r\n1 1\r\n2 3\r\n3 4\r\n9 8\r\n5 2",
        "output": "Case #1: 1 + 1 = 2\r\nCase #2: 2 + 3 = 5\r\nCase #3: 3 + 4 = 7\r\nCase #4: 9 + 8 = 17\r\nCase #5: 5 + 2 = 7"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11022",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "T = int(input())\nfor i in range(1, T + 1):\n    A, B = map(int, input().split())\n    print(\"Case #\" + str(i) + \":\", A, \"+\", B, \"=\", A + B)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 데이터 받기",
            "description": "문제에서 요구하는 데이터를 입력받습니다.",
            "code_pattern": "T = int(input())\n    A = int(input())",
            "socratic_hint": "어떤 데이터를 입력받아야 하나요?",
            "hint": "input() 함수로 데이터를 받고, 필요하면 int()로 변환합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력하기",
            "description": "처리된 결과를 출력합니다.",
            "code_pattern": "    print(\"Case #\" + str(i) + \":\", A, \"+\", B, \"=\", A + B)",
            "socratic_hint": "결과를 어떻게 출력하나요?",
            "hint": "print() 함수로 결과를 출력합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "T = int(input())\ni = 1\nwhile i <= T:\n    A, B = map(int, input().split())\n    print(f\"Case #{i}: {A} + {B} = {A + B}\")\n    i += 1",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "T = int(input())로 입력을 처리합니다.",
            "code_pattern": "T = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "반복 처리",
            "description": "while i <= T:로 반복 작업을 수행합니다.",
            "code_pattern": "while i <= T:",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "정수 입력 받기",
            "description": "A = int(input())로 입력을 처리합니다.",
            "code_pattern": "A = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "정수 입력 받기",
            "description": "B = int(input())로 입력을 처리합니다.",
            "code_pattern": "B = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 5,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(\"Case #\" + str(i) + \":\", A, \"+\", B, \"=\", A + B)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11047",
    "step_title": "그리디 알고리즘 1",
    "title": "동전 0",
    "level": 7,
    "tags": [
      "그리디 알고리즘"
    ],
    "description": "준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai≤ 1,000,000, A1= 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)",
    "output_description": "첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.",
    "examples": [
      {
        "input": "10 4200\r\n1\r\n5\r\n10\r\n50\r\n100\r\n500\r\n1000\r\n5000\r\n10000\r\n50000",
        "output": "6"
      },
      {
        "input": "10 4790\r\n1\r\n5\r\n10\r\n50\r\n100\r\n500\r\n1000\r\n5000\r\n10000\r\n50000",
        "output": "12"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11047",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N, K = map(int, input().split())\ncoins = []\nfor _ in range(N):\n    coins.append(int(input()))\n\ncoins.reverse()\ncount = 0\n\nfor coin in coins:\n    if K >= coin:\n        count += K // coin\n        K %= coin\n\nprint(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11049",
    "step_title": "동적 계획법 2",
    "title": "행렬 곱셈 순서",
    "level": 13,
    "tags": [
      "다이나믹 프로그래밍"
    ],
    "description": "크기가 N×M인 행렬 A와 M×K인 B를 곱할 때 필요한 곱셈 연산의 수는 총 N×M×K번이다. 행렬 N개를 곱하는데 필요한 곱셈 연산의 수는 행렬을 곱하는 순서에 따라 달라지게 된다.예를 들어, A의 크기가 5×3이고, B의 크기가 3×2, C의 크기가 2×6인 경우에 행렬의 곱 ABC를 구하는 경우를 생각해보자.AB를 먼저 곱하고 C를 곱하는 경우 (AB)C에 필요한 곱셈 연산의 수는 5×3×2 + 5×2×6 = 30 + 60 = 90번이다.BC를 먼저 곱하고 A를 곱하는 경우 A(BC)에 필요한 곱셈 연산의 수는 3×2×6 + 5×3×6 = 36 + 90 = 126번이다.같은 곱셈이지만, 곱셈을 하는 순서에 따라서 곱셈 연산의 수가 달라진다.행렬 N개의 크기가 주어졌을 때, 모든 행렬을 곱하는데 필요한 곱셈 연산 횟수의 최솟값을 구하는 프로그램을 작성하시오. 입력으로 주어진 행렬의 순서를 바꾸면 안 된다.",
    "input_description": "첫째 줄에 행렬의 개수 N(1 ≤ N ≤ 500)이 주어진다.둘째 줄부터 N개 줄에는 행렬의 크기 r과 c가 주어진다. (1 ≤ r, c ≤ 500)항상 순서대로 곱셈을 할 수 있는 크기만 입력으로 주어진다.",
    "output_description": "첫째 줄에 입력으로 주어진 행렬을 곱하는데 필요한 곱셈 연산의 최솟값을 출력한다. 정답은 231-1 보다 작거나 같은 자연수이다. 또한, 최악의 순서로 연산해도 연산 횟수가 231-1보다 작거나 같다.",
    "examples": [
      {
        "input": "3\n5 3\n3 2\n2 6",
        "output": "90"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11049",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nmatrices = []\nfor _ in range(N):\n    r, c = map(int, input().split())\n    matrices.append((r, c))\n\ndp = [[0] * N for _ in range(N)]\n\nfor length in range(1, N):\n    for i in range(N - length):\n        j = i + length\n        dp[i][j] = float('inf')\n        for k in range(i, j):\n            cost = dp[i][k] + dp[k+1][j] + matrices[i][0] * matrices[k][1] * matrices[j][1]\n            dp[i][j] = min(dp[i][j], cost)\n\nprint(dp[0][N-1])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11050",
    "step_title": "조합론",
    "title": "이항 계수 1",
    "level": 5,
    "tags": [
      "수학",
      "구현",
      "조합론"
    ],
    "description": "자연수 \\(N\\)과 정수 \\(K\\)가 주어졌을 때 이항 계수 \\(\\binom{N}{K}\\)를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 \\(N\\)과 \\(K\\)가 주어진다. (1 ≤ \\(N\\) ≤ 10, 0 ≤ \\(K\\) ≤ \\(N\\))",
    "output_description": "\\(\\binom{N}{K}\\)를 출력한다.",
    "examples": [
      {
        "input": "5 2",
        "output": "10"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11050",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "A, B = map(int, input().split())\nprint(A * B)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "여러 값 입력 받기",
            "description": "A, B = map(int, input().split())로 입력을 처리합니다.",
            "code_pattern": "A, B = map(int, input().split())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(A * B)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11053",
    "step_title": "동적 계획법 1",
    "title": "가장 긴 증가하는 부분 수열",
    "level": 9,
    "tags": [
      "다이나믹 프로그래밍",
      "가장 긴 증가하는 부분 수열 문제"
    ],
    "description": "수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10,20, 10,30, 20,50} 이고, 길이는 4이다.",
    "input_description": "첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai≤ 1,000)",
    "output_description": "첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.",
    "examples": [
      {
        "input": "6\r\n10 20 10 30 20 50",
        "output": "4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11053",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nA = list(map(int, input().split()))\n\ndp = [1] * N\n\nfor i in range(1, N):\n    for j in range(i):\n        if A[j] < A[i]:\n            dp[i] = max(dp[i], dp[j] + 1)\n\nprint(max(dp))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11054",
    "step_title": "동적 계획법 1",
    "title": "가장 긴 바이토닉 부분 수열",
    "level": 12,
    "tags": [
      "다이나믹 프로그래밍"
    ],
    "description": "수열 S가 어떤 수 Sk를 기준으로 S1< S2< ... Sk-1< Sk> Sk+1> ... SN-1> SN을 만족한다면, 그 수열을 바이토닉 수열이라고 한다.예를 들어, {10, 20,30, 25, 20}과 {10, 20, 30,40}, {50, 40, 25, 10} 은 바이토닉 수열이지만,  {1, 2, 3, 2, 1, 2, 3, 2, 1}과 {10, 20, 30, 40, 20, 30} 은 바이토닉 수열이 아니다.수열 A가 주어졌을 때, 그 수열의 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 수열 A의 크기 N이 주어지고, 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ N ≤ 1,000, 1 ≤ Ai≤ 1,000)",
    "output_description": "첫째 줄에 수열 A의 부분 수열 중에서 가장 긴 바이토닉 수열의 길이를 출력한다.",
    "examples": [
      {
        "input": "10\n1 5 2 1 4 3 4 5 2 1",
        "output": "7"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11054",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nA = list(map(int, input().split()))\n\n# 증가 부분 수열\ninc = [1] * N\nfor i in range(N):\n    for j in range(i):\n        if A[j] < A[i]:\n            inc[i] = max(inc[i], inc[j] + 1)\n\n# 감소 부분 수열\ndec = [1] * N\nfor i in range(N - 1, -1, -1):\n    for j in range(i + 1, N):\n        if A[j] < A[i]:\n            dec[i] = max(dec[i], dec[j] + 1)\n\n# 바이토닉\nresult = 0\nfor i in range(N):\n    result = max(result, inc[i] + dec[i] - 1)\n\nprint(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11062",
    "step_title": "동적 계획법 2",
    "title": "카드 게임",
    "level": 13,
    "tags": [
      "다이나믹 프로그래밍",
      "게임 이론"
    ],
    "description": "근우와 명우는 재미있는 카드 게임을 하고 있다. N개의 카드가 일렬로 놓여 있다. 각 카드에는 점수가 적혀있다. 근우부터 시작하여 번갈아가면서 턴이 진행되는데 한 턴에는 가장 왼쪽에 있는 카드나 가장 오른쪽에 있는 카드를 가져갈 수 있다. 카드가 더 이상 남아있지 않을 때까지 턴은 반복된다. 게임의 점수는 자신이 가져간 카드에 적힌 수의 합이다.근우와 명우는 서로 자신의 점수를 가장 높이기 위해 최선의 전략으로 게임에 임한다. 놓여있는 카드의 개수 N과 카드가 놓여있는 상태가 주어졌을 때 근우가 얻는 점수를 구하는 프로그램을 작성하시오.예를 들어 카드가 [4, 3, 1, 2]로 놓여있다고 하자. 근우는 처음에 4가 적힌 카드를 가져가고, 명우는 3이 적힌 카드를 가져간다. 그리고 근우는 2가 적힌 카드를 가져가고, 명우는 마지막으로 1이 적힌 카드를 가져간다. 이때 근우와 명우는 최선의 전략으로 임했으며, 근우가 얻는 점수는 6이다.",
    "input_description": "입력의 첫 줄에는 테스트케이스의 수 T(1 ≤ T ≤ 50)가 주어진다.각 테스트케이스 마다 첫 줄에는 카드의 개수 N(1 ≤ N ≤ 1,000)이 주어진다. 두 번째 줄에는 N개의 자연수가 공백으로 구분되어 주어지는데, i번째로 주어지는 수는 왼쪽에서 i번째에 놓인 카드에 적힌 수를 의미한다. 카드에 적혀있는 수는 1이상 10,000이하다.",
    "output_description": "각 테스트케이스마다 근우와 명우가 최선의 전략으로 임할 때 근우가 얻게되는 점수를 줄로 구분하여 출력한다.",
    "examples": [
      {
        "input": "2\n4\n1 2 5 2\n9\n1 1 1 1 2 2 2 2 2",
        "output": "6\n8"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11062",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\ninput = sys.stdin.readline\n\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    cards = list(map(int, input().split()))\n    \n    dp = [[[-1] * 2 for _ in range(N)] for _ in range(N)]\n    \n    def solve(left, right, turn):\n        if left > right:\n            return 0\n        \n        if dp[left][right][turn] != -1:\n            return dp[left][right][turn]\n        \n        if turn == 0:\n            dp[left][right][turn] = max(\n                cards[left] + solve(left + 1, right, 1),\n                cards[right] + solve(left, right - 1, 1)\n            )\n        else:\n            dp[left][right][turn] = min(\n                solve(left + 1, right, 0),\n                solve(left, right - 1, 0)\n            )\n        \n        return dp[left][right][turn]\n    \n    print(solve(0, N - 1, 0))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11066",
    "step_title": "동적 계획법 2",
    "title": "파일 합치기",
    "level": 13,
    "tags": [
      "다이나믹 프로그래밍"
    ],
    "description": "소설가인 김대전은 소설을 여러 장(chapter)으로 나누어 쓰는데, 각 장은 각각 다른 파일에 저장하곤 한다. 소설의 모든 장을 쓰고 나서는 각 장이 쓰여진 파일을 합쳐서 최종적으로 소설의 완성본이 들어있는 한 개의 파일을 만든다. 이 과정에서 두 개의 파일을 합쳐서 하나의 임시파일을 만들고, 이 임시파일이나 원래의 파일을 계속 두 개씩 합쳐서 소설의 여러 장들이 연속이 되도록 파일을 합쳐나가고, 최종적으로는 하나의 파일로 합친다. 두 개의 파일을 합칠 때 필요한 비용(시간 등)이 두 파일 크기의 합이라고 가정할 때, 최종적인 한 개의 파일을 완성하는데 필요한 비용의 총 합을 계산하시오.예를 들어, C1, C2, C3, C4가 연속적인 네 개의 장을 수록하고 있는 파일이고, 파일 크기가 각각 40, 30, 30, 50 이라고 하자. 이 파일들을 합치는 과정에서, 먼저 C2와 C3를 합쳐서 임시파일 X1을 만든다. 이때 비용 60이 필요하다. 그 다음으로 C1과 X1을 합쳐 임시파일 X2를 만들면 비용 100이 필요하다. 최종적으로 X2와 C4를 합쳐 최종파일을 만들면 비용 150이 필요하다. 따라서, 최종의 한 파일을 만드는데 필요한 비용의 합은 60+100+150=310 이다. 다른 방법으로 파일을 합치면 비용을 줄일 수 있다. 먼저 C1과 C2를 합쳐 임시파일 Y1을 만들고, C3와 C4를 합쳐 임시파일 Y2를 만들고, 최종적으로 Y1과 Y2를 합쳐 최종파일을 만들 수 있다. 이때 필요한 총 비용은 70+80+150=300 이다.소설의 각 장들이 수록되어 있는 파일의 크기가 주어졌을 때, 이 파일들을 하나의 파일로 합칠 때 필요한 최소비용을 계산하는 프로그램을 작성하시오.",
    "input_description": "프로그램은 표준 입력에서 입력 데이터를 받는다. 프로그램의 입력은 T개의 테스트 데이터로 이루어져 있는데, T는 입력의 맨 첫 줄에 주어진다.각 테스트 데이터는 두 개의 행으로 주어지는데, 첫 행에는 소설을 구성하는 장의 수를 나타내는 양의 정수 K (3 ≤ K ≤ 500)가 주어진다. 두 번째 행에는 1장부터 K장까지 수록한 파일의 크기를 나타내는 양의 정수 K개가 주어진다. 파일의 크기는 10,000을 초과하지 않는다.",
    "output_description": "프로그램은 표준 출력에 출력한다. 각 테스트 데이터마다 정확히 한 행에 출력하는데, 모든 장을 합치는데 필요한 최소비용을 출력한다.",
    "examples": [
      {
        "input": "2\r\n4\r\n40 30 30 50\r\n15\r\n1 21 3 4 5 35 5 4 3 5 98 21 14 17 32",
        "output": "300\r\n864"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11066",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "T = int(input())\nfor _ in range(T):\n    K = int(input())\n    files = list(map(int, input().split()))\n    \n    # 누적합\n    prefix = [0]\n    for f in files:\n        prefix.append(prefix[-1] + f)\n    \n    dp = [[0] * K for _ in range(K)]\n    \n    for length in range(1, K):\n        for i in range(K - length):\n            j = i + length\n            dp[i][j] = float('inf')\n            for k in range(i, j):\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + prefix[j+1] - prefix[i])\n    \n    print(dp[0][K-1])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11111",
    "step_title": "네트워크 플로우 2",
    "title": "두부장수 장홍준 2",
    "level": 19,
    "tags": [
      "그래프 이론",
      "최대 유량",
      "격자 그래프",
      "최소 비용 최대 유량"
    ],
    "description": "장홍준은 참 특이한 두부장수이다. 세로크기 N, 가로크기 M인 두부판을 가지고 2x1짜리 두부로 잘라서 판다. 그런데, 두부판의 위치마다 등급이 다르다. 그리고 2x1짜리에 등급이 어떻게 매겨지느냐에 따라 두부의 값도 천차만별이 된다. 다음 등급표를 보자.위의 표는 2x1짜리 두부의 등급에 따라 매겨지는 두부의 가격표다. 예를 들어 “AC\" 두부의 가격은 7이고, ”DB\" 두부의 가격은 3이다.세로크기 N, 가로크기 M의 두부판이 주어진다. 각 칸마다 두부의 등급이 A, B, C, D, F로 매겨져 있다. 홍준이는 전체 두부가격의 합을 최대가 되게 두부를 자르려고 한다. 2x1짜리 두부로 잘라내고 남은 한 칸짜리 두부는 가격이 0이기 때문에 버린다. 홍준이를 도와 가격이 최대가 되게 두부판을 자르는 프로그램을 작성하시오.위 그림은 N=4, M=4 인 두부판의 한 예이다. 오른쪽 그림이 잘라낸 두부가격의 합을 최대로 한 것이다. 한 칸짜리는 쓸모없으므로 버린다.",
    "input_description": "첫째 줄에는 두부판의 세로크기 N, 가로크기 M이 주어진다. N, M은 1이상 50이하의 정수이다. 그 다음 N줄에 걸쳐 M개의 문자가 주어진다. 각 문자는 그 칸의 두부의 등급을 나타내며 A, B, C, D, F 중 하나로 주어진다.",
    "output_description": "첫째 줄에 잘라낸 두부가격 합의 최댓값을 출력한다.",
    "examples": [
      {
        "input": "4 4\nACFC\nFDAB\nBACF\nDBAC",
        "output": "37"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11111",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11191",
    "step_title": "수학 3",
    "title": "Xor Maximization",
    "level": 18,
    "tags": [
      "수학",
      "선형대수학",
      "가우스 소거법",
      "배타적 논리합 기저 (gf(2))"
    ],
    "description": "As you might have heard, Gunnar is an old and forgetful researcher. Most of his research is in security and he cares a bit too much about his own security, so for each website he has a different password. It would be very hard for him to remember all passwords, so for every website he only remembers the method he used to create the password.For one of the very important websites he started with a file containing a long list of non-negative integers. Since he very much likes the operation ⊕ (xor), his password is a xor of some integers in the list. Note that the operation xor is defined on boolean values as 0 ⊕ 0 = 1 ⊕ 1 = 0 and 0 ⊕ 1 = 1 ⊕ 0 = 1. We can then extend this definition to integers, namely we first write the two integers in binary and then do xor for each two corresponding bits in the numbers. For example the xor of 12 = (1100)2and 5 = (101)2is 9 = (1001)2. Instead of addition, we can use the operation xor when summing numbers and we call this modified sum xor-sum.Gunnar’s file contains a list of numbers and he selected a subset of the numbers such that its xor-sum is as large as possible. The resulting number was his password. Unfortunately, he forgot the algorithm to find the subset with the largest xor-sum, so he is asking you for help with restoring his password. Of course, he will not tell you for which website this password is.",
    "input_description": "The first line of input contains an integer n (1 ≤ n ≤ 100 000): the length of the list of numbers in Gunnar’s file. The second line contains n space separated integers a1, . . . , an(1 ≤ ai≤ 1018), the numbers in the file.",
    "output_description": "Output one line with the answer – the maximal number Gunnar can get by selecting a subset of the list of numbers and calculating the xor-sum of the subset.",
    "examples": [
      {
        "input": "3\r\n1 3 5",
        "output": "7"
      },
      {
        "input": "4\r\n2 6 4 8",
        "output": "14"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11191",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 수학 문제 기본 구조\ndef solve():\n    # 입력 처리\n    N = int(input())\n    \n    # 계산\n    result = N\n    \n    return result\n\nprint(solve())",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11279",
    "step_title": "우선순위 큐",
    "title": "최대 힙",
    "level": 9,
    "tags": [
      "자료 구조",
      "우선순위 큐"
    ],
    "description": "널리 잘 알려진 자료구조 중 최대 힙이 있다. 최대 힙을 이용하여 다음과 같은 연산을 지원하는 프로그램을 작성하시오.배열에 자연수 x를 넣는다.배열에서 가장 큰 값을 출력하고,그 값을 배열에서 제거한다.프로그램은 처음에 비어있는 배열에서 시작하게 된다.",
    "input_description": "첫째 줄에 연산의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 만약 x가 자연수라면 배열에 x라는 값을 넣는(추가하는) 연산이고, x가 0이라면 배열에서 가장 큰 값을 출력하고 그 값을 배열에서 제거하는 경우이다. 입력되는 자연수는 231보다 작다.",
    "output_description": "입력에서 0이 주어진 횟수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 가장 큰 값을 출력하라고 한 경우에는 0을 출력하면 된다.",
    "examples": [
      {
        "input": "13\n0\n1\n2\n0\n0\n3\n2\n1\n0\n0\n0\n0\n0",
        "output": "0\n2\n1\n3\n2\n1\n0\n0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11279",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nimport heapq\ninput = sys.stdin.readline\n\nN = int(input())\nheap = []\n\nfor _ in range(N):\n    x = int(input())\n    if x == 0:\n        if heap:\n            print(-heapq.heappop(heap))\n        else:\n            print(0)\n    else:\n        heapq.heappush(heap, -x)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11280",
    "step_title": "강한 연결 요소",
    "title": "2-SAT - 3",
    "level": 17,
    "tags": [
      "그래프 이론",
      "강한 연결 요소",
      "2-sat"
    ],
    "description": "2-SAT은 N개의 불리언 변수 \\(x_1, x_2, ..., x_n\\)가 있을 때, 2-CNF 식을 true로 만들기위해 \\(x_i\\)를 어떤 값으로 정해야하는지를 구하는 문제이다.2-CNF식은 \\( \\left( x \\lor y \\right) \\land \\left( \\lnot y \\lor z \\right) \\land \\left( x \\lor \\lnot z \\right) \\land \\left( z \\lor y \\right) \\) 와 같은 형태이다. 여기서 괄호로 묶인 식을 절(clause)라고 하는데, 절은 2개의 변수를 \\(\\lor\\)한 것으로 이루어져 있다. \\(\\lor\\)는 OR, \\(\\land\\)는 AND, \\(\\lnot\\)은 NOT을 나타낸다.변수의 개수 N과 절의 개수 M, 그리고 식 \\(f\\)가 주어졌을 때, 식 \\(f\\)를 true로 만들 수 있는지 없는지를 구하는 프로그램을 작성하시오.예를 들어, N = 3, M = 4이고, \\(f =  \\left( \\lnot x_1 \\lor x_2 \\right) \\land \\left( \\lnot x_2 \\lor x_3 \\right) \\land \\left( x_1 \\lor x_3 \\right) \\land \\left( x_3 \\lor x_2 \\right) \\) 인 경우에 \\(x_1\\)을 false, \\(x_2\\)을 false, \\(x_3\\)를 true로 정하면 식 \\(f\\)를 true로 만들 수 있다. 하지만, N = 1, M = 2이고, \\(f = \\left( x_1 \\lor x_1 \\right) \\land \\left( \\lnot x_1 \\lor \\lnot x_1 \\right) \\)인 경우에는 \\(x_1\\)에 어떤 값을 넣어도 식 f를 true로 만들 수 없다.",
    "input_description": "첫째 줄에 변수의 개수 N (1 ≤ N ≤ 10,000)과 절의 개수 M (1 ≤ M ≤ 100,000)이 주어진다. 둘째 줄부터 M개의 줄에는 절이 주어진다. 절은 두 정수 i와 j (1 ≤ |i|, |j| ≤ N)로 이루어져 있으며, i와 j가 양수인 경우에는 각각 \\(x_i\\), \\(x_j\\)를 나타내고, 음수인 경우에는 \\(\\lnot x_{-i}\\), \\(\\lnot x_{-j}\\)를 나타낸다.",
    "output_description": "첫째 줄에 식 \\(f\\)를 true로 만들 수 있으면 1을, 없으면 0을 출력한다.",
    "examples": [
      {
        "input": "3 4\r\n-1 2\r\n-2 3\r\n1 3\r\n3 2",
        "output": "1"
      },
      {
        "input": "1 2\r\n1 1\r\n-1 -1",
        "output": "0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11280",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\ndef dfs1(v):\n    visited[v] = True\n    for next_v in graph[v]:\n        if not visited[next_v]:\n            dfs1(next_v)\n    stack.append(v)\n\ndef dfs2(v, scc_num):\n    scc_id[v] = scc_num\n    for next_v in reverse_graph[v]:\n        if scc_id[next_v] == -1:\n            dfs2(next_v, scc_num)\n\nN, M = map(int, input().split())\n\ngraph = [[] for _ in range(2 * N + 1)]\nreverse_graph = [[] for _ in range(2 * N + 1)]\n\ndef get_node(x):\n    if x > 0:\n        return x\n    else:\n        return N + abs(x)\n\ndef get_not(x):\n    if x <= N:\n        return x + N\n    else:\n        return x - N\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[get_not(get_node(a))].append(get_node(b))\n    graph[get_not(get_node(b))].append(get_node(a))\n    reverse_graph[get_node(b)].append(get_not(get_node(a)))\n    reverse_graph[get_node(a)].append(get_not(get_node(b)))\n\nvisited = [False] * (2 * N + 1)\nstack = []\n\nfor i in range(1, 2 * N + 1):\n    if not visited[i]:\n        dfs1(i)\n\nscc_id = [-1] * (2 * N + 1)\nscc_num = 0\n\nwhile stack:\n    v = stack.pop()\n    if scc_id[v] == -1:\n        dfs2(v, scc_num)\n        scc_num += 1\n\n# 2-SAT 가능 여부 확인\npossible = True\nfor i in range(1, N + 1):\n    if scc_id[i] == scc_id[N + i]:\n        possible = False\n        break\n\nprint(1 if possible else 0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11281",
    "step_title": "강한 연결 요소",
    "title": "2-SAT - 4",
    "level": 18,
    "tags": [
      "그래프 이론",
      "강한 연결 요소",
      "역추적",
      "2-sat"
    ],
    "description": "2-SAT은 N개의 불리언 변수 \\(x_1, x_2, ..., x_n\\)가 있을 때, 2-CNF 식을 true로 만들기위해 \\(x_i\\)를 어떤 값으로 정해야하는지를 구하는 문제이다.2-CNF식은 \\( \\left( x \\lor y \\right) \\land \\left( \\lnot y \\lor z \\right) \\land \\left( x \\lor \\lnot z \\right) \\land \\left( z \\lor y \\right) \\) 와 같은 형태이다. 여기서 괄호로 묶인 식을 절(clause)라고 하는데, 절은 2개의 변수를 \\(\\lor\\)한 것으로 이루어져 있다. \\(\\lor\\)는 OR, \\(\\land\\)는 AND, \\(\\lnot\\)은 NOT을 나타낸다.변수의 개수 N과 절의 개수 M, 그리고 식 \\(f\\)가 주어졌을 때, 식 \\(f\\)를 true로 만들 수 있는지 없는지를 구하는 프로그램을 작성하시오.예를 들어, N = 3, M = 4이고, \\(f =  \\left( \\lnot x_1 \\lor x_2 \\right) \\land \\left( \\lnot x_2 \\lor x_3 \\right) \\land \\left( x_1 \\lor x_3 \\right) \\land \\left( x_3 \\lor x_2 \\right) \\) 인 경우에 \\(x_1\\)을 false, \\(x_2\\)을 false, \\(x_3\\)를 true로 정하면 식 \\(f\\)를 true로 만들 수 있다. 하지만, N = 1, M = 2이고, \\(f = \\left( x_1 \\lor x_1 \\right) \\land \\left( \\lnot x_1 \\lor \\lnot x_1 \\right) \\)인 경우에는 \\(x_1\\)에 어떤 값을 넣어도 식 f를 true로 만들 수 없다.",
    "input_description": "첫째 줄에 변수의 개수 N (1 ≤ N ≤ 10,000)과 절의 개수 M (1 ≤ M ≤ 100,000)이 주어진다. 둘째 줄부터 M개의 줄에는 절이 주어진다. 절은 두 정수 i와 j (1 ≤ |i|, |j| ≤ N)로 이루어져 있으며, i와 j가 양수인 경우에는 각각 \\(x_i\\), \\(x_j\\)를 나타내고, 음수인 경우에는 \\(\\lnot x_{-i}\\), \\(\\lnot x_{-j}\\)를 나타낸다.",
    "output_description": "첫째 줄에 식 \\(f\\)를 true로 만들 수 있으면 1을, 없으면 0을 출력한다.\\(f\\)를 true로 만들 수 있는 경우에는 둘째 줄에 식 \\(f\\)를 true로 만드는 \\(x_i\\)의 값을 \\(x_1\\)부터 순서대로 출력한다. true는 1, false는 0으로 출력한다.",
    "examples": [
      {
        "input": "3 4\r\n-1 2\r\n-2 3\r\n1 3\r\n3 2",
        "output": "1\r\n0 0 1"
      },
      {
        "input": "1 2\r\n1 1\r\n-1 -1",
        "output": "0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11281",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\ndef dfs1(v):\n    visited[v] = True\n    for next_v in graph[v]:\n        if not visited[next_v]:\n            dfs1(next_v)\n    stack.append(v)\n\ndef dfs2(v, scc_num):\n    scc_id[v] = scc_num\n    for next_v in reverse_graph[v]:\n        if scc_id[next_v] == -1:\n            dfs2(next_v, scc_num)\n\nN, M = map(int, input().split())\n\ngraph = [[] for _ in range(2 * N + 1)]\nreverse_graph = [[] for _ in range(2 * N + 1)]\n\ndef get_node(x):\n    if x > 0:\n        return x\n    else:\n        return N + abs(x)\n\ndef get_not(x):\n    if x <= N:\n        return x + N\n    else:\n        return x - N\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[get_not(get_node(a))].append(get_node(b))\n    graph[get_not(get_node(b))].append(get_node(a))\n    reverse_graph[get_node(b)].append(get_not(get_node(a)))\n    reverse_graph[get_node(a)].append(get_not(get_node(b)))\n\nvisited = [False] * (2 * N + 1)\nstack = []\n\nfor i in range(1, 2 * N + 1):\n    if not visited[i]:\n        dfs1(i)\n\nscc_id = [-1] * (2 * N + 1)\nscc_num = 0\n\nwhile stack:\n    v = stack.pop()\n    if scc_id[v] == -1:\n        dfs2(v, scc_num)\n        scc_num += 1\n\n# 2-SAT 가능 여부 확인\npossible = True\nfor i in range(1, N + 1):\n    if scc_id[i] == scc_id[N + i]:\n        possible = False\n        break\n\nprint(1 if possible else 0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11286",
    "step_title": "우선순위 큐",
    "title": "절댓값 힙",
    "level": 10,
    "tags": [
      "자료 구조",
      "우선순위 큐"
    ],
    "description": "절댓값 힙은 다음과 같은 연산을 지원하는 자료구조이다.배열에 정수 x (x ≠ 0)를 넣는다.배열에서 절댓값이 가장 작은 값을 출력하고, 그 값을 배열에서 제거한다. 절댓값이 가장 작은 값이 여러개일 때는, 가장 작은 수를 출력하고, 그 값을 배열에서 제거한다.프로그램은 처음에 비어있는 배열에서 시작하게 된다.",
    "input_description": "첫째 줄에 연산의 개수 N(1≤N≤100,000)이 주어진다. 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 만약 x가 0이 아니라면 배열에 x라는 값을 넣는(추가하는) 연산이고, x가 0이라면 배열에서 절댓값이 가장 작은 값을 출력하고 그 값을 배열에서 제거하는 경우이다. 입력되는 정수는 -231보다 크고, 231보다 작다.",
    "output_description": "입력에서 0이 주어진 회수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 절댓값이 가장 작은 값을 출력하라고 한 경우에는 0을 출력하면 된다.",
    "examples": [
      {
        "input": "18\n1\n-1\n0\n0\n0\n1\n1\n-1\n-1\n2\n-2\n0\n0\n0\n0\n0\n0\n0",
        "output": "-1\n1\n0\n-1\n-1\n1\n1\n-2\n2\n0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11286",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nimport heapq\ninput = sys.stdin.readline\n\nN = int(input())\nheap = []\n\nfor _ in range(N):\n    x = int(input())\n    if x == 0:\n        if heap:\n            print(heapq.heappop(heap)[1])\n        else:\n            print(0)\n    else:\n        heapq.heappush(heap, (abs(x), x))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11375",
    "step_title": "이분 매칭",
    "title": "열혈강호",
    "level": 17,
    "tags": [
      "이분 매칭"
    ],
    "description": "강호네 회사에는 직원이 N명이 있고, 해야할 일이 M개가 있다. 직원은 1번부터 N번까지 번호가 매겨져 있고, 일은 1번부터 M번까지 번호가 매겨져 있다.각 직원은 자신이 할 수 있는 일들 중 한 개의 일만 담당할 수 있고, 각각의 일을 담당하는 사람은 1명이어야 한다.각각의 직원이 할 수 있는 일의 목록이 주어졌을 때, M개의 일 중에서 최대 몇 개를 할 수 있는지 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 직원의 수 N과 일의 개수 M이 주어진다. (1 ≤ N, M ≤ 1,000)둘째 줄부터 N개의 줄의 i번째 줄에는 i번 직원이 할 수 있는 일의 개수와 할 수 있는 일의 번호가 주어진다.",
    "output_description": "첫째 줄에 강호네 회사에서 할 수 있는 일의 개수를 출력한다.",
    "examples": [
      {
        "input": "5 5\n2 1 2\n1 1\n2 2 3\n3 3 4 5\n1 1",
        "output": "4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11375",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def dfs(node):\n    if visited[node]:\n        return False\n    visited[node] = True\n    \n    for work in graph[node]:\n        if match[work] == -1 or dfs(match[work]):\n            match[work] = node\n            return True\n    \n    return False\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor i in range(1, N + 1):\n    data = list(map(int, input().split()))\n    for j in range(1, data[0] + 1):\n        graph[i].append(data[j])\n\nmatch = [-1] * (M + 1)\ncount = 0\n\nfor i in range(1, N + 1):\n    visited = [False] * (N + 1)\n    if dfs(i):\n        count += 1\n\nprint(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11376",
    "step_title": "이분 매칭",
    "title": "열혈강호 2",
    "level": 17,
    "tags": [
      "이분 매칭"
    ],
    "description": "강호네 회사에는 직원이 N명이 있고, 해야할 일이 M개가 있다. 직원은 1번부터 N번까지 번호가 매겨져 있고, 일은 1번부터 M번까지 번호가 매겨져 있다.각 직원은 자신이 할 수 있는 일들 중 최대 두 개의 일을 담당할 수 있고, 각각의 일을 담당하는 사람은 1명이어야 한다.각각의 직원이 할 수 있는 일의 목록이 주어졌을 때, M개의 일 중에서 최대 몇 개를 할 수 있는지 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 직원의 수 N과 일의 개수 M이 주어진다. (1 ≤ N, M ≤ 1,000)둘째 줄부터 N개의 줄의 i번째 줄에는 i번 직원이 할 수 있는 일의 개수와 할 수 있는 일의 번호가 주어진다.",
    "output_description": "첫째 줄에 강호네 회사에서 할 수 있는 일의 개수를 출력한다.",
    "examples": [
      {
        "input": "5 5\n2 1 2\n2 1 2\n2 1 2\n2 4 5\n0",
        "output": "4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11376",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def dfs(node):\n    if visited[node]:\n        return False\n    visited[node] = True\n    \n    for work in graph[node]:\n        if match[work] == -1 or dfs(match[work]):\n            match[work] = node\n            return True\n    \n    return False\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor i in range(1, N + 1):\n    data = list(map(int, input().split()))\n    for j in range(1, data[0] + 1):\n        graph[i].append(data[j])\n\nmatch = [-1] * (M + 1)\ncount = 0\n\nfor i in range(1, N + 1):\n    for _ in range(2):\n        visited = [False] * (N + 1)\n        if dfs(i):\n            count += 1\n\nprint(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11378",
    "step_title": "네트워크 플로우 1",
    "title": "열혈강호 4",
    "level": 18,
    "tags": [
      "그래프 이론",
      "최대 유량",
      "이분 매칭"
    ],
    "description": "강호네 회사에는 직원이 N명이 있고, 해야할 일이 M개가 있다. 직원은 1번부터 N번까지 번호가 매겨져 있고, 일은 1번부터 M번까지 번호가 매겨져 있다.각 직원은 자신이 할 수 있는 일들 중 한 개의 일만 담당할 수 있고, 각각의 일을 담당하는 사람은 1명이어야 한다. 여기서 지난달에 벌점을 X점 받은 사람은 일을 최대 X+1개까지 담당할 수 있다.예를 들어, 직원이 3명이고, 지난달에 1번 직원 민호가 벌점을 2점, 2번 직원 재필이가 벌점을 1점, 3번 직원 주현이가 벌점을 0점 받았다면, 1번 직원 민호는 일을 최대 3개, 2번 직원 재필이는 최대 2개, 3번 직원 주현이는 최대 1개까지 담당할 수 있다.각 직원은 자신이 지난달에 받은 벌점을 알지 못하고, 직원이 받은 벌점의 합 K만을 알고 있다. 강호는 이런 사실을 이용해서 벌점을 적절히 나눠서 최대한 일을 많이 할 수 있게 하려고 한다.예를 들어, 1번 직원이 1, 2, 3, 4, 5를 할 수 있고, 2, 3, 4번 직원이 1을 할 수 있고, 5번 직원이 1, 5를 할 수 있는 경우를 생각해보자.지난 달에 전직원이 받은 벌점의 합 K가 0이라면, 할 수 있는 일의 최대 개수는 3개이다. 1번 직원이 2를 하고, 2번 직원이 1을, 5번 직원이 5를 하면 된다.벌점의 합 K가 2인 경우에, 1번 직원이 1점, 5번 직원이 1점을 받았다고 하면, 일을 최대 4개 할 수 있다. 1번 직원과 5번 직원은 이제 일을 2개까지 담당할 수 있다. 1번 직원이 2와 3을, 5번 직원이 1과 5를 하면 총 4개의 일을 할 수 있다. 하지만, 강호가 벌점을 조작해 1번 직원이 2점을 받았다고 하면, 일은 최대 5개 할 수 있게 된다. 1번 직원은 일을 3개까지 담당할 수 있다. 따라서, 1번 직원이 2, 3, 4를 하고, 2번 직원이 1을, 5번 직원이 5를 하면 5개를 모두 할 수 있게 된다.벌점의 합 K가 3인 경우에는, 1번 직원에게 벌점을 모두 몰아주면 일을 5개 할 수 있다. 1번 직원은 벌점이 3점이기 때문에, 일을 총 4개까지 담당할 수 있다. 따라서, 1, 2, 3, 4를 모두 1번직원이 하고, 5번 직원이 5를 하면 총 5가지 일을 할 수 있게 된다.각각의 직원이 할 수 있는 일의 목록과 지난달 받은 벌점의 합 K가 주어졌을 때, M개의 일 중에서 최대 몇 개를 할 수 있는지 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 직원의 수 N과 일의 개수 M, 지난달에 받은 벌점의 합 K가 주어진다. (1 ≤ N, M ≤ 1,000, 1 ≤ K ≤ N)둘째 줄부터 N개의 줄의 i번째 줄에는 i번 직원이 할 수 있는 일의 개수와 할 수 있는 일의 번호가 주어진다.",
    "output_description": "첫째 줄에 강호네 회사에서 할 수 있는 일의 개수를 출력한다.",
    "examples": [
      {
        "input": "5 5 1\n5 1 2 3 4 5\n1 1\n1 1\n1 1\n2 1 5",
        "output": "4"
      },
      {
        "input": "5 5 2\n5 1 2 3 4 5\n1 1\n1 1\n1 1\n2 1 5",
        "output": "5"
      },
      {
        "input": "5 5 3\n5 1 2 3 4 5\n1 1\n1 1\n1 1\n2 1 5",
        "output": "5"
      },
      {
        "input": "5 5 5\n5 1 2 3 4 5\n1 1\n1 1\n1 1\n2 1 5",
        "output": "5"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11378",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11382",
    "step_title": "입출력과 사칙연산",
    "title": "꼬마 정민",
    "level": 1,
    "tags": [
      "구현",
      "사칙연산",
      "수학"
    ],
    "description": "꼬마 정민이는 이제 A + B 정도는 쉽게 계산할 수 있다. 이제 A + B + C를 계산할 차례이다!",
    "input_description": "첫 번째 줄에 A, B, C (1 ≤ A, B, C ≤ 1012)이 공백을 사이에 두고 주어진다.",
    "output_description": "A+B+C의 값을 출력한다.",
    "examples": [
      {
        "input": "77 77 7777",
        "output": "7931"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11382",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "A, B, C = map(int, input().split())\nprint(A + B + C)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "여러 값 입력 받기",
            "description": "A, B, C = map(int, input().split())로 입력을 처리합니다.",
            "code_pattern": "A, B, C = map(int, input().split())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(A + B + C)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11399",
    "step_title": "그리디 알고리즘 1",
    "title": "ATM",
    "level": 7,
    "tags": [
      "그리디 알고리즘",
      "정렬"
    ],
    "description": "인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 사람은 1번부터 N번까지 번호가 매겨져 있으며, i번 사람이 돈을 인출하는데 걸리는 시간은 Pi분이다.사람들이 줄을 서는 순서에 따라서, 돈을 인출하는데 필요한 시간의 합이 달라지게 된다. 예를 들어, 총 5명이 있고, P1= 3, P2= 1, P3= 4, P4= 3, P5= 2 인 경우를 생각해보자. [1, 2, 3, 4, 5] 순서로 줄을 선다면, 1번 사람은 3분만에 돈을 뽑을 수 있다. 2번 사람은 1번 사람이 돈을 뽑을 때 까지 기다려야 하기 때문에, 3+1 = 4분이 걸리게 된다. 3번 사람은 1번, 2번 사람이 돈을 뽑을 때까지 기다려야 하기 때문에, 총 3+1+4 = 8분이 필요하게 된다. 4번 사람은 3+1+4+3 = 11분, 5번 사람은 3+1+4+3+2 = 13분이 걸리게 된다. 이 경우에 각 사람이 돈을 인출하는데 필요한 시간의 합은 3+4+8+11+13 = 39분이 된다.줄을 [2, 5, 1, 4, 3] 순서로 줄을 서면, 2번 사람은 1분만에, 5번 사람은 1+2 = 3분, 1번 사람은 1+2+3 = 6분, 4번 사람은 1+2+3+3 = 9분, 3번 사람은 1+2+3+3+4 = 13분이 걸리게 된다. 각 사람이 돈을 인출하는데 필요한 시간의 합은 1+3+6+9+13 = 32분이다. 이 방법보다 더 필요한 시간의 합을 최소로 만들 수는 없다.줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어졌을 때, 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 사람의 수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어진다. (1 ≤ Pi≤ 1,000)",
    "output_description": "첫째 줄에 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 출력한다.",
    "examples": [
      {
        "input": "5\r\n3 1 4 3 2",
        "output": "32"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11399",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\ntimes = list(map(int, input().split()))\n\ntimes.sort()\ntotal = 0\n\nfor i in range(N):\n    total += times[i] * (N - i)\n\nprint(total)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = int(input())\ntimes = list(map(int, input().split()))\ntimes.sort()\ntotal = 0\ncumsum = 0\nfor t in times:\n    cumsum += t\n    total += cumsum\nprint(total)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3",
        "solution_code": "n = int(input())\ntimes = list(map(int, input().split()))\nfor i in range(n-1):\n    for j in range(n-1-i):\n        if times[j] > times[j+1]:\n            times[j], times[j+1] = times[j+1], times[j]\ntotal = 0\ncumsum = 0\nfor t in times:\n    cumsum += t\n    total += cumsum\nprint(total)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 패스 횟수 제어",
            "description": "n-1번 반복하며 각 패스를 수행합니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "버블 정렬에서 몇 번의 패스가 필요한가요?",
            "hint": "n-1번의 패스가 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "내부 반복문: 인접 원소 비교",
            "description": "각 패스에서 인접한 두 원소를 비교합니다. 이미 정렬된 뒤쪽 부분은 제외합니다.",
            "code_pattern": "for j in range(n-1-i):",
            "socratic_hint": "각 패스에서 비교해야 할 원소의 범위는?",
            "hint": "n-1-i까지 비교합니다 (이미 정렬된 부분 제외)."
          },
          {
            "step_id": 4,
            "goal": "원소 교환",
            "description": "왼쪽 원소가 오른쪽 원소보다 크면 위치를 교환합니다.",
            "code_pattern": "if arr[j] > arr[j+1]:\n    arr[j], arr[j+1] = arr[j+1], arr[j]",
            "socratic_hint": "인접한 두 원소의 순서가 잘못되었을 때 어떻게 하나요?",
            "hint": "두 원소의 위치를 swap합니다."
          },
          {
            "step_id": 5,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4",
        "solution_code": "n = int(input())\ntimes = list(map(int, input().split()))\nfor i in range(n-1):\n    min_idx = i\n    for j in range(i+1, n):\n        if times[j] < times[min_idx]:\n            min_idx = j\n    times[i], times[min_idx] = times[min_idx], times[i]\ntotal = 0\ncumsum = 0\nfor t in times:\n    cumsum += t\n    total += cumsum\nprint(total)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 정렬할 위치 선택",
            "description": "n-1번 반복하며 각 위치에 올 최솟값을 찾습니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "선택 정렬에서 몇 번의 선택이 필요한가요?",
            "hint": "n-1번의 선택이 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "최솟값 인덱스 초기화",
            "description": "현재 위치를 최솟값 인덱스로 가정합니다.",
            "code_pattern": "min_idx = i",
            "socratic_hint": "최솟값을 찾기 위한 초기값은?",
            "hint": "현재 위치 i를 초기값으로 설정합니다."
          },
          {
            "step_id": 4,
            "goal": "내부 반복문: 최솟값 찾기",
            "description": "현재 위치 이후의 원소들 중 최솟값의 인덱스를 찾습니다.",
            "code_pattern": "for j in range(i+1, n):\n    if arr[j] < arr[min_idx]:\n        min_idx = j",
            "socratic_hint": "정렬되지 않은 부분에서 최솟값을 어떻게 찾나요?",
            "hint": "i+1부터 끝까지 순회하며 최솟값 인덱스를 업데이트합니다."
          },
          {
            "step_id": 5,
            "goal": "원소 교환",
            "description": "찾은 최솟값을 현재 위치로 이동시킵니다.",
            "code_pattern": "arr[i], arr[min_idx] = arr[min_idx], arr[i]",
            "socratic_hint": "최솟값을 현재 위치로 가져오려면?",
            "hint": "현재 위치의 값과 최솟값을 swap합니다."
          },
          {
            "step_id": 6,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11401",
    "step_title": "분할 정복",
    "title": "이항 계수 3",
    "level": 15,
    "tags": [
      "수학",
      "정수론",
      "조합론",
      "분할 정복을 이용한 거듭제곱",
      "모듈로 곱셈 역원",
      "페르마의 소정리"
    ],
    "description": "자연수 \\(N\\)과 정수 \\(K\\)가 주어졌을 때 이항 계수 \\(\\binom{N}{K}\\)를 1,000,000,007로 나눈 나머지를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 \\(N\\)과 \\(K\\)가 주어진다. (1 ≤ \\(N\\) ≤ 4,000,000, 0 ≤ \\(K\\) ≤ \\(N\\))",
    "output_description": "\\(\\binom{N}{K}\\)를 1,000,000,007로 나눈 나머지를 출력한다.",
    "examples": [
      {
        "input": "5 2",
        "output": "10"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11401",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "A, B = map(int, input().split())\nprint(A * B)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "여러 값 입력 받기",
            "description": "A, B = map(int, input().split())로 입력을 처리합니다.",
            "code_pattern": "A, B = map(int, input().split())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(A * B)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11402",
    "step_title": "수학 3",
    "title": "이항 계수 4",
    "level": 17,
    "tags": [
      "수학",
      "다이나믹 프로그래밍",
      "정수론",
      "조합론",
      "뤼카 정리"
    ],
    "description": "자연수 \\(N\\)과 정수 \\(K\\)가 주어졌을 때 이항 계수 \\(\\binom{N}{K}\\)를 \\(M\\)으로 나눈 나머지를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 \\(N\\), \\(K\\)와 \\(M\\)이 주어진다. (1 ≤ \\(N\\) ≤ 1018, 0 ≤ \\(K\\) ≤ \\(N\\), 2 ≤ \\(M\\) ≤ 2,000, M은 소수)",
    "output_description": "\\(\\binom{N}{K}\\)를 \\(M\\)으로 나눈 나머지를 출력한다.",
    "examples": [
      {
        "input": "5 2 3",
        "output": "1"
      },
      {
        "input": "30 10 3",
        "output": "0"
      },
      {
        "input": "30 3 3",
        "output": "1"
      },
      {
        "input": "100 45 7",
        "output": "0"
      },
      {
        "input": "100 45 13",
        "output": "2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11402",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11404",
    "step_title": "최단 경로",
    "title": "플로이드",
    "level": 12,
    "tags": [
      "그래프 이론",
      "최단 경로",
      "플로이드–워셜"
    ],
    "description": "n(2 ≤ n ≤ 100)개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 m(1 ≤ m ≤ 100,000)개의 버스가 있다. 각 버스는 한 번 사용할 때 필요한 비용이 있다.모든 도시의 쌍 (A, B)에 대해서 도시 A에서 B로 가는데 필요한 비용의 최솟값을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 도시의 개수 n이 주어지고 둘째 줄에는 버스의 개수 m이 주어진다. 그리고 셋째 줄부터 m+2줄까지 다음과 같은 버스의 정보가 주어진다. 먼저 처음에는 그 버스의 출발 도시의 번호가 주어진다. 버스의 정보는 버스의 시작 도시 a, 도착 도시 b, 한 번 타는데 필요한 비용 c로 이루어져 있다. 시작 도시와 도착 도시가 같은 경우는 없다. 비용은 100,000보다 작거나 같은 자연수이다.시작 도시와 도착 도시를 연결하는 노선은 하나가 아닐 수 있다.",
    "output_description": "n개의 줄을 출력해야 한다. i번째 줄에 출력하는 j번째 숫자는 도시 i에서 j로 가는데 필요한 최소 비용이다. 만약, i에서 j로 갈 수 없는 경우에는 그 자리에 0을 출력한다.",
    "examples": [
      {
        "input": "5\n14\n1 2 2\n1 3 3\n1 4 1\n1 5 10\n2 4 2\n3 4 1\n3 5 1\n4 5 3\n3 5 10\n3 1 8\n1 4 2\n5 1 7\n3 4 2\n5 2 4",
        "output": "0 2 3 1 4\n12 0 15 2 5\n8 5 0 1 1\n10 7 13 0 3\n7 4 10 6 0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11404",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nM = int(input())\n\ndist = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n\nfor i in range(1, N + 1):\n    dist[i][i] = 0\n\nfor _ in range(M):\n    a, b, c = map(int, input().split())\n    dist[a][b] = min(dist[a][b], c)\n\nfor k in range(1, N + 1):\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\nfor i in range(1, N + 1):\n    for j in range(1, N + 1):\n        print(dist[i][j] if dist[i][j] != float('inf') else 0, end=' ')\n    print()",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11408",
    "step_title": "네트워크 플로우 2",
    "title": "열혈강호 5",
    "level": 18,
    "tags": [
      "그래프 이론",
      "최대 유량",
      "최소 비용 최대 유량"
    ],
    "description": "강호네 회사에는 직원이 N명이 있고, 해야 할 일이 M개가 있다. 직원은 1번부터 N번까지 번호가 매겨져 있고, 일은 1번부터 M번까지 번호가 매겨져 있다.각 직원은 자신이 할 수 있는 일들 중 한 개의 일만 담당할 수 있고, 각각의 일을 담당하는 사람은 1명이어야 한다.각각의 직원이 할 수 있는 일의 목록과 그 일을 할 때 강호가 지급해야 하는 월급이 주어졌을 때, M개의 일 중에서 최대 몇 개를 할 수 있는지, 그리고 그 때 강호가 지불해야 하는 월급의 최솟값을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 직원의 수 N과 일의 개수 M이 주어진다. (1 ≤ N, M ≤ 400)둘째 줄부터 N개의 줄의 i번째 줄에는 i번 직원이 할 수 있는 일의 개수와 할 수 있는 일의 번호와 그 일을 할 때 지급해야 하는 월급이 주어진다. 월급은 10,000보다 작거나 같은 자연수 또는 0이다.",
    "output_description": "첫째 줄에 강호네 회사에서 할 수 있는 일의 개수를 출력한다.둘째 줄에는 강호가 지급해야 하는 월급의 최솟값을 출력한다.",
    "examples": [
      {
        "input": "5 5\n2 1 3 2 2\n1 1 5\n2 2 1 3 7\n3 3 9 4 9 5 9\n1 1 0",
        "output": "4\n18"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11408",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11409",
    "step_title": "네트워크 플로우 2",
    "title": "열혈강호 6",
    "level": 18,
    "tags": [
      "그래프 이론",
      "최대 유량",
      "최소 비용 최대 유량"
    ],
    "description": "강호네 회사에는 직원이 N명이 있고, 해야 할 일이 M개가 있다. 직원은 1번부터 N번까지 번호가 매겨져 있고, 일은 1번부터 M번까지 번호가 매겨져 있다.각 직원은 자신이 할 수 있는 일들 중 한 개의 일만 담당할 수 있고, 각각의 일을 담당하는 사람은 1명이어야 한다.각각의 직원이 할 수 있는 일의 목록과 그 일을 할 때 강호가 지급해야 하는 월급이 주어졌을 때, M개의 일 중에서 최대 몇 개를 할 수 있는지, 그리고 그 때 강호가 지불해야 하는 월급의 최댓값을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 직원의 수 N과 일의 개수 M이 주어진다. (1 ≤ N, M ≤ 400)둘째 줄부터 N개의 줄의 i번째 줄에는 i번 직원이 할 수 있는 일의 개수와 할 수 있는 일의 번호와 그 일을 할 때 지급해야 하는 월급이 주어진다. 월급은 10,000보다 작거나 같은 자연수 또는 0이다.",
    "output_description": "첫째 줄에 강호네 회사에서 할 수 있는 일의 개수를 출력한다.둘째 줄에는 강호가 지급해야 하는 월급의 최댓값을 출력한다.",
    "examples": [
      {
        "input": "5 5\n2 1 3 2 2\n1 1 5\n2 2 1 3 7\n3 3 9 4 9 5 9\n1 1 0",
        "output": "4\n23"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11409",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11438",
    "step_title": "최소 공통 조상",
    "title": "LCA 2",
    "level": 16,
    "tags": [
      "자료 구조",
      "트리",
      "최소 공통 조상",
      "희소 배열"
    ],
    "description": "N(2 ≤ N ≤ 100,000)개의 정점으로 이루어진 트리가 주어진다. 트리의 각 정점은 1번부터 N번까지 번호가 매겨져 있으며, 루트는 1번이다.두 노드의 쌍 M(1 ≤ M ≤ 100,000)개가 주어졌을 때, 두 노드의 가장 가까운 공통 조상이 몇 번인지 출력한다.",
    "input_description": "첫째 줄에 노드의 개수 N이 주어지고, 다음 N-1개 줄에는 트리 상에서 연결된 두 정점이 주어진다. 그 다음 줄에는 가장 가까운 공통 조상을 알고싶은 쌍의 개수 M이 주어지고, 다음 M개 줄에는 정점 쌍이 주어진다.",
    "output_description": "M개의 줄에 차례대로 입력받은 두 정점의 가장 가까운 공통 조상을 출력한다.",
    "examples": [
      {
        "input": "15\n1 2\n1 3\n2 4\n3 7\n6 2\n3 8\n4 9\n2 5\n5 11\n7 13\n10 4\n11 15\n12 5\n14 7\n6\n6 11\n10 9\n2 6\n7 6\n8 13\n8 15",
        "output": "2\n4\n2\n1\n3\n1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11438",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nfrom collections import deque\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\nN = int(input())\ntree = [[] for _ in range(N + 1)]\n\nfor _ in range(N - 1):\n    a, b = map(int, input().split())\n    tree[a].append(b)\n    tree[b].append(a)\n\nMAX_LOG = 17\nparent = [[0] * (N + 1) for _ in range(MAX_LOG)]\ndepth = [0] * (N + 1)\n\ndef dfs(node, d):\n    depth[node] = d\n    for next_node in tree[node]:\n        if depth[next_node] == 0:\n            parent[0][next_node] = node\n            dfs(next_node, d + 1)\n\ndfs(1, 1)\n\nfor k in range(1, MAX_LOG):\n    for i in range(1, N + 1):\n        parent[k][i] = parent[k-1][parent[k-1][i]]\n\ndef lca(a, b):\n    if depth[a] > depth[b]:\n        a, b = b, a\n    \n    diff = depth[b] - depth[a]\n    for k in range(MAX_LOG):\n        if diff & (1 << k):\n            b = parent[k][b]\n    \n    if a == b:\n        return a\n    \n    for k in range(MAX_LOG - 1, -1, -1):\n        if parent[k][a] != parent[k][b]:\n            a = parent[k][a]\n            b = parent[k][b]\n    \n    return parent[0][a]\n\nM = int(input())\nfor _ in range(M):\n    a, b = map(int, input().split())\n    print(lca(a, b))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11444",
    "step_title": "분할 정복",
    "title": "피보나치 수 6",
    "level": 14,
    "tags": [
      "수학",
      "분할 정복을 이용한 거듭제곱"
    ],
    "description": "피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.이를 식으로 써보면 Fn= Fn-1+ Fn-2(n ≥ 2)가 된다.n=17일때 까지 피보나치 수를 써보면 다음과 같다.0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 n이 주어진다. n은 1,000,000,000,000,000,000보다 작거나 같은 자연수이다.",
    "output_description": "첫째 줄에 n번째 피보나치 수를 1,000,000,007으로 나눈 나머지를 출력한다.",
    "examples": [
      {
        "input": "1000",
        "output": "517691607"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11444",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def matrix_mult(A, B):\n    result = [[0, 0], [0, 0]]\n    for i in range(2):\n        for j in range(2):\n            for k in range(2):\n                result[i][j] += A[i][k] * B[k][j]\n            result[i][j] %= 1000000007\n    return result\n\ndef matrix_power(M, n):\n    if n == 1:\n        return M\n    \n    half = matrix_power(M, n // 2)\n    if n % 2 == 0:\n        return matrix_mult(half, half)\n    else:\n        return matrix_mult(matrix_mult(half, half), M)\n\nn = int(input())\nif n <= 2:\n    print(1)\nelse:\n    M = [[1, 1], [1, 0]]\n    result = matrix_power(M, n)\n    print(result[0][1])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11478",
    "step_title": "집합과 맵",
    "title": "서로 다른 부분 문자열의 개수",
    "level": 8,
    "tags": [
      "자료 구조",
      "문자열",
      "집합과 맵",
      "해시를 사용한 집합과 맵",
      "트리를 사용한 집합과 맵"
    ],
    "description": "문자열 S가 주어졌을 때, S의 서로 다른 부분 문자열의 개수를 구하는 프로그램을 작성하시오.부분 문자열은 S에서 연속된 일부분을 말하며, 길이가 1보다 크거나 같아야 한다.예를 들어, ababc의 부분 문자열은 a, b, a, b, c, ab, ba, ab, bc, aba, bab, abc, abab, babc, ababc가 있고, 서로 다른것의 개수는 12개이다.",
    "input_description": "첫째 줄에 문자열 S가 주어진다. S는 알파벳 소문자로만 이루어져 있고, 길이는 1,000 이하이다.",
    "output_description": "첫째 줄에 S의 서로 다른 부분 문자열의 개수를 출력한다.",
    "examples": [
      {
        "input": "ababc",
        "output": "12"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11478",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "S = input()\nsubstrings = set()\n\nfor i in range(len(S)):\n    for j in range(i + 1, len(S) + 1):\n        substrings.add(S[i:j])\n\nprint(len(substrings))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11479",
    "step_title": "문자열 알고리즘 2",
    "title": "서로 다른 부분 문자열의 개수 2",
    "level": 19,
    "tags": [
      "문자열",
      "접미사 배열과 LCP 배열"
    ],
    "description": "문자열 S가 주어졌을 때, S의 서로 다른 부분 문자열의 개수를 구하는 프로그램을 작성하시오.부분 문자열은 S에서 연속된 일부분을 말하며, 길이가 1보다 크거나 같아야 한다.예를 들어, ababc의 부분 문자열은 a, b, a, b, c, ab, ba, ab, bc, aba, bab, abc, abab, babc, ababc가 있고, 서로 다른것의 개수는 12개이다.",
    "input_description": "첫째 줄에 문자열 S가 주어진다. S는 알파벳 소문자로만 이루어져 있고, 길이는 1,000,000 이하이다.",
    "output_description": "첫째 줄에 S의 서로 다른 부분 문자열의 개수를 출력한다.",
    "examples": [
      {
        "input": "ababc",
        "output": "12"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11479",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11493",
    "step_title": "네트워크 플로우 2",
    "title": "동전 교환",
    "level": 20,
    "tags": [
      "그래프 이론",
      "최대 유량",
      "최소 비용 최대 유량"
    ],
    "description": "V의 집합과 간선 E의 집합으로 이루어진 양방향 그래프 G = ( V, E )가 주어진다. 이 그래프는 연결 그래프이다. 즉, 모든 정점쌍 간에 적어도 하나 이상의 경로가 존재한다. 각각의 정점들은 검정색 또는 흰색이다. 동전은 정점들 위에 하나씩 놓여 있는데 이 동전도 검정색 또는 흰색이다. 이 그래프에서 '동전 교환' 연산을 통해 인접한 정점 위에 있는 동전 2개의 위치를 서로 맞바꿀 수 있다. 아래 그림을 보면 이해 할 수 있을 것이다. (그림 1에서 네모의 색은 동전의 색깔이다.)그림 1. '동전 교환' 연산의 예 (2 <> 5, 5 <> 6, 1 <> 5)우리가 구하고자 하는 것은모든 검정색 동전을검정색 정점 위로, 모든 흰색 동전을흰색 정점 위로올리기 위해 필요한 '동전 교환' 연산의 최소 횟수이다.",
    "input_description": "입력의 첫줄에는 테스트 케이스의 수 T가 주어진다. 각 테스트 케이스의 첫줄에는 정수 n과 m (1 ≤ n ≤ 500, n-1 ≤ m ≤ n(n-1)/2 )이 주어진다. 여기서 n은 정점의 개수, m은 간선의 개수를 나타낸다. 정점은 1 ~ n의 번호를 가진다. n, m의 다음줄부터 m 줄에 걸쳐서 인접한 두 정점 x, y (1 ≤ x < y ≤ n)이 주어진다. 그 다음 줄에는 0 또는 1의 값을 가지는 n개의 정수가 주어진다. 여기서 i (1 ≤ i ≤ n)번째 정수는 정점 i의 색깔이다. 0은 검정색 1은 흰색이다. 그 다음 줄에도 0 또는 1의 값을 가지는 n개의 정수가 주어지고 여기서 i (1 ≤ i ≤ n)번째 정수는 정점 i위에 있는 동전의 색깔을 의미한다.",
    "output_description": "한 테스트케이스당 한 줄에 걸쳐 모든 동전과 정점의 색깔을 일치시키기 위해 필요한 최소 '동전 교환' 연산의 횟수를 출력하라.",
    "examples": [
      {
        "input": "3\r\n4 4\r\n1 2\r\n1 3\r\n2 4\r\n3 4\r\n0 1 1 0\r\n0 1 0 1\r\n6 7\r\n1 2\r\n1 5\r\n1 4\r\n2 3\r\n2 5\r\n4 5\r\n5 6\r\n1 1 0 0 0 0\r\n0 0 0 0 1 1\r\n6 5\r\n1 2\r\n2 3\r\n3 4\r\n4 5\r\n5 6\r\n1 0 1 1 0 0\r\n0 0 1 1 0 1",
        "output": "1\r\n3\r\n5"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11493",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11495",
    "step_title": "네트워크 플로우 1",
    "title": "격자 0 만들기",
    "level": 19,
    "tags": [
      "그래프 이론",
      "최대 유량",
      "격자 그래프"
    ],
    "description": "음수가 아닌 정수들의 격자가 주어진다. 당신은 이 격자에 다음 연산을 행할 수 있다.1. 격자에서 가로 또는 세로로 인접한 정수 2개를 고른다.2. 각 정수가 양수일 때 1 감소시킨다.다음 그림은 총 4개의 연속한 연산을 2*2 격자에 가해서 모든 정수를 0으로 만든 과정을 보여준다.위 예제에서는 모든 정수를 0으로 만들기 위해 4번의 연산을 행했다. 이보다 적은 횟수의 연산으로는 모든 정수를 0으로 만들 수 없다는 것을 쉽게 알 수 있다.격자가 주어졌을 때 모든 정수를 0으로 만들기 위해 필요한 최소 연산의 횟수를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 n과 m (2 ≤ n, m ≤ 50)이 주어지며, n은 격자의 행 개수, m은 격자의 열 개수를 나타낸다. 그 다음 n개의 줄에 각각 격자의 해당 행에 있는 m개의 정수가 열 순서대로 주어진다. 각 정수는 0 이상 1,000 이하이다.",
    "output_description": "각 테스트 케이스마다 필요한 연산의 최소 횟수를 한 줄에 출력한다.",
    "examples": [
      {
        "input": "2\r\n2 2\r\n1 3\r\n1 2\r\n2 4\r\n2 3 2 3\r\n1 2 1 1",
        "output": "4\r\n8"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11495",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11505",
    "step_title": "세그먼트 트리 1",
    "title": "구간 곱 구하기",
    "level": 15,
    "tags": [
      "세그먼트 트리",
      "자료 구조"
    ],
    "description": "어떤 N개의 수가 주어져 있다. 그런데 중간에 수의 변경이 빈번히 일어나고 그 중간에 어떤 부분의 곱을 구하려 한다. 만약에 1, 2, 3, 4, 5 라는 수가 있고, 3번째 수를 6으로 바꾸고 2번째부터 5번째까지 곱을 구하라고 한다면 240을 출력하면 되는 것이다. 그리고 그 상태에서 다섯 번째 수를 2로 바꾸고 3번째부터 5번째까지 곱을 구하라고 한다면 48이 될 것이다.",
    "input_description": "첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)과 M(1 ≤ M ≤ 10,000), K(1 ≤ K ≤ 10,000) 가 주어진다. M은 수의 변경이 일어나는 횟수이고, K는 구간의 곱을 구하는 횟수이다. 그리고 둘째 줄부터 N+1번째 줄까지 N개의 수가 주어진다. 그리고 N+2번째 줄부터 N+M+K+1 번째 줄까지 세 개의 정수 a,b,c가 주어지는데, a가 1인 경우 b번째 수를 c로 바꾸고 a가 2인 경우에는 b부터 c까지의 곱을 구하여 출력하면 된다.입력으로 주어지는 모든 수는 0보다 크거나 같고, 1,000,000보다 작거나 같은 정수이다.",
    "output_description": "첫째 줄부터 K줄에 걸쳐 구한 구간의 곱을 1,000,000,007로 나눈 나머지를 출력한다.",
    "examples": [
      {
        "input": "5 2 2\n1\n2\n3\n4\n5\n1 3 6\n2 2 5\n1 5 2\n2 3 5",
        "output": "240\n48"
      },
      {
        "input": "5 2 2\n1\n2\n3\n4\n5\n1 3 0\n2 2 5\n1 3 6\n2 2 5",
        "output": "0\n240"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11505",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\ninput = sys.stdin.readline\nMOD = 1000000007\n\nclass SegmentTree:\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [1] * (4 * self.n)\n        self.build(arr, 1, 0, self.n - 1)\n    \n    def build(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build(arr, node * 2, start, mid)\n            self.build(arr, node * 2 + 1, mid + 1, end)\n            self.tree[node] = (self.tree[node * 2] * self.tree[node * 2 + 1]) % MOD\n    \n    def update(self, node, start, end, idx, val):\n        if start == end:\n            self.tree[node] = val\n        else:\n            mid = (start + end) // 2\n            if idx <= mid:\n                self.update(node * 2, start, mid, idx, val)\n            else:\n                self.update(node * 2 + 1, mid + 1, end, idx, val)\n            self.tree[node] = (self.tree[node * 2] * self.tree[node * 2 + 1]) % MOD\n    \n    def query(self, node, start, end, left, right):\n        if left > end or right < start:\n            return 1\n        if left <= start and end <= right:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return (self.query(node * 2, start, mid, left, right) * \\\n                self.query(node * 2 + 1, mid + 1, end, left, right)) % MOD\n\nN, M, K = map(int, input().split())\narr = [int(input()) for _ in range(N)]\n\nseg = SegmentTree(arr)\n\nfor _ in range(M + K):\n    a, b, c = map(int, input().split())\n    if a == 1:\n        seg.update(1, 0, N - 1, b - 1, c)\n    else:\n        print(seg.query(1, 0, N - 1, b - 1, c - 1))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11650",
    "step_title": "정렬",
    "title": "좌표 정렬하기",
    "level": 6,
    "tags": [
      "정렬"
    ],
    "description": "2차원 평면 위의 점 N개가 주어진다. 좌표를 x좌표가 증가하는 순으로, x좌표가 같으면 y좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 점의 개수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 i번점의 위치 xi와 yi가 주어진다. (-100,000 ≤ xi, yi≤ 100,000) 좌표는 항상 정수이고, 위치가 같은 두 점은 없다.",
    "output_description": "첫째 줄부터 N개의 줄에 점을 정렬한 결과를 출력한다.",
    "examples": [
      {
        "input": "5\r\n3 4\r\n1 1\r\n1 -1\r\n2 2\r\n3 3",
        "output": "1 -1\r\n1 1\r\n2 2\r\n3 3\r\n3 4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11650",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\npoints = []\nfor _ in range(N):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\npoints.sort()\nfor x, y in points:\n    print(x, y)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = int(input())\npoints = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\npoints.sort()\nfor x, y in points:\n    print(x, y)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3",
        "solution_code": "n = int(input())\npoints = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\nfor i in range(n-1):\n    for j in range(n-1-i):\n        if points[j] > points[j+1]:\n            points[j], points[j+1] = points[j+1], points[j]\nfor x, y in points:\n    print(x, y)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 패스 횟수 제어",
            "description": "n-1번 반복하며 각 패스를 수행합니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "버블 정렬에서 몇 번의 패스가 필요한가요?",
            "hint": "n-1번의 패스가 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "내부 반복문: 인접 원소 비교",
            "description": "각 패스에서 인접한 두 원소를 비교합니다. 이미 정렬된 뒤쪽 부분은 제외합니다.",
            "code_pattern": "for j in range(n-1-i):",
            "socratic_hint": "각 패스에서 비교해야 할 원소의 범위는?",
            "hint": "n-1-i까지 비교합니다 (이미 정렬된 부분 제외)."
          },
          {
            "step_id": 4,
            "goal": "원소 교환",
            "description": "왼쪽 원소가 오른쪽 원소보다 크면 위치를 교환합니다.",
            "code_pattern": "if arr[j] > arr[j+1]:\n    arr[j], arr[j+1] = arr[j+1], arr[j]",
            "socratic_hint": "인접한 두 원소의 순서가 잘못되었을 때 어떻게 하나요?",
            "hint": "두 원소의 위치를 swap합니다."
          },
          {
            "step_id": 5,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4",
        "solution_code": "n = int(input())\npoints = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\nfor i in range(n-1):\n    min_idx = i\n    for j in range(i+1, n):\n        if points[j] < points[min_idx]:\n            min_idx = j\n    points[i], points[min_idx] = points[min_idx], points[i]\nfor x, y in points:\n    print(x, y)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 정렬할 위치 선택",
            "description": "n-1번 반복하며 각 위치에 올 최솟값을 찾습니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "선택 정렬에서 몇 번의 선택이 필요한가요?",
            "hint": "n-1번의 선택이 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "최솟값 인덱스 초기화",
            "description": "현재 위치를 최솟값 인덱스로 가정합니다.",
            "code_pattern": "min_idx = i",
            "socratic_hint": "최솟값을 찾기 위한 초기값은?",
            "hint": "현재 위치 i를 초기값으로 설정합니다."
          },
          {
            "step_id": 4,
            "goal": "내부 반복문: 최솟값 찾기",
            "description": "현재 위치 이후의 원소들 중 최솟값의 인덱스를 찾습니다.",
            "code_pattern": "for j in range(i+1, n):\n    if arr[j] < arr[min_idx]:\n        min_idx = j",
            "socratic_hint": "정렬되지 않은 부분에서 최솟값을 어떻게 찾나요?",
            "hint": "i+1부터 끝까지 순회하며 최솟값 인덱스를 업데이트합니다."
          },
          {
            "step_id": 5,
            "goal": "원소 교환",
            "description": "찾은 최솟값을 현재 위치로 이동시킵니다.",
            "code_pattern": "arr[i], arr[min_idx] = arr[min_idx], arr[i]",
            "socratic_hint": "최솟값을 현재 위치로 가져오려면?",
            "hint": "현재 위치의 값과 최솟값을 swap합니다."
          },
          {
            "step_id": 6,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11651",
    "step_title": "정렬",
    "title": "좌표 정렬하기 2",
    "level": 6,
    "tags": [
      "정렬"
    ],
    "description": "2차원 평면 위의 점 N개가 주어진다. 좌표를 y좌표가 증가하는 순으로, y좌표가 같으면 x좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 점의 개수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 i번점의 위치 xi와 yi가 주어진다. (-100,000 ≤ xi, yi≤ 100,000) 좌표는 항상 정수이고, 위치가 같은 두 점은 없다.",
    "output_description": "첫째 줄부터 N개의 줄에 점을 정렬한 결과를 출력한다.",
    "examples": [
      {
        "input": "5\r\n0 4\r\n1 2\r\n1 -1\r\n2 2\r\n3 3",
        "output": "1 -1\r\n1 2\r\n2 2\r\n3 3\r\n0 4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11651",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\npoints = []\nfor _ in range(N):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\npoints.sort(key=lambda p: (p[1], p[0]))\nfor x, y in points:\n    print(x, y)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = int(input())\npoints = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\npoints.sort(key=lambda p: (p[1], p[0]))\nfor x, y in points:\n    print(x, y)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3",
        "solution_code": "n = int(input())\npoints = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\nfor i in range(n-1):\n    for j in range(n-1-i):\n        if (points[j][1], points[j][0]) > (points[j+1][1], points[j+1][0]):\n            points[j], points[j+1] = points[j+1], points[j]\nfor x, y in points:\n    print(x, y)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 패스 횟수 제어",
            "description": "n-1번 반복하며 각 패스를 수행합니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "버블 정렬에서 몇 번의 패스가 필요한가요?",
            "hint": "n-1번의 패스가 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "내부 반복문: 인접 원소 비교",
            "description": "각 패스에서 인접한 두 원소를 비교합니다. 이미 정렬된 뒤쪽 부분은 제외합니다.",
            "code_pattern": "for j in range(n-1-i):",
            "socratic_hint": "각 패스에서 비교해야 할 원소의 범위는?",
            "hint": "n-1-i까지 비교합니다 (이미 정렬된 부분 제외)."
          },
          {
            "step_id": 4,
            "goal": "원소 교환",
            "description": "왼쪽 원소가 오른쪽 원소보다 크면 위치를 교환합니다.",
            "code_pattern": "if arr[j] > arr[j+1]:\n    arr[j], arr[j+1] = arr[j+1], arr[j]",
            "socratic_hint": "인접한 두 원소의 순서가 잘못되었을 때 어떻게 하나요?",
            "hint": "두 원소의 위치를 swap합니다."
          },
          {
            "step_id": 5,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4",
        "solution_code": "n = int(input())\npoints = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\nfor i in range(n-1):\n    min_idx = i\n    for j in range(i+1, n):\n        if (points[j][1], points[j][0]) < (points[min_idx][1], points[min_idx][0]):\n            min_idx = j\n    points[i], points[min_idx] = points[min_idx], points[i]\nfor x, y in points:\n    print(x, y)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 정렬할 위치 선택",
            "description": "n-1번 반복하며 각 위치에 올 최솟값을 찾습니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "선택 정렬에서 몇 번의 선택이 필요한가요?",
            "hint": "n-1번의 선택이 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "최솟값 인덱스 초기화",
            "description": "현재 위치를 최솟값 인덱스로 가정합니다.",
            "code_pattern": "min_idx = i",
            "socratic_hint": "최솟값을 찾기 위한 초기값은?",
            "hint": "현재 위치 i를 초기값으로 설정합니다."
          },
          {
            "step_id": 4,
            "goal": "내부 반복문: 최솟값 찾기",
            "description": "현재 위치 이후의 원소들 중 최솟값의 인덱스를 찾습니다.",
            "code_pattern": "for j in range(i+1, n):\n    if arr[j] < arr[min_idx]:\n        min_idx = j",
            "socratic_hint": "정렬되지 않은 부분에서 최솟값을 어떻게 찾나요?",
            "hint": "i+1부터 끝까지 순회하며 최솟값 인덱스를 업데이트합니다."
          },
          {
            "step_id": 5,
            "goal": "원소 교환",
            "description": "찾은 최솟값을 현재 위치로 이동시킵니다.",
            "code_pattern": "arr[i], arr[min_idx] = arr[min_idx], arr[i]",
            "socratic_hint": "최솟값을 현재 위치로 가져오려면?",
            "hint": "현재 위치의 값과 최솟값을 swap합니다."
          },
          {
            "step_id": 6,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11653",
    "step_title": "약수, 배수와 소수 1",
    "title": "소인수분해",
    "level": 5,
    "tags": [
      "수학",
      "정수론",
      "소수 판정",
      "소인수분해"
    ],
    "description": "정수 N이 주어졌을 때, 소인수분해하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 정수 N (1 ≤ N ≤ 10,000,000)이 주어진다.",
    "output_description": "N의 소인수분해 결과를 한 줄에 하나씩 오름차순으로 출력한다. N이 1인 경우 아무것도 출력하지 않는다.",
    "examples": [
      {
        "input": "72",
        "output": "2\n2\n2\n3\n3"
      },
      {
        "input": "3",
        "output": "3"
      },
      {
        "input": "6",
        "output": "2\n3"
      },
      {
        "input": "2",
        "output": "2"
      },
      {
        "input": "9991",
        "output": "97\n103"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11653",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nif N == 1:\n    pass\nelse:\n    i = 2\n    while i * i <= N:\n        while N % i == 0:\n            print(i)\n            N //= i\n        i += 1\n    if N > 1:\n        print(N)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11654",
    "step_title": "문자열",
    "title": "아스키 코드",
    "level": 1,
    "tags": [
      "구현"
    ],
    "description": "알파벳 소문자, 대문자, 숫자 0-9중 하나가 주어졌을 때, 주어진 글자의 아스키 코드값을 출력하는 프로그램을 작성하시오.",
    "input_description": "알파벳 소문자, 대문자, 숫자 0-9 중 하나가 첫째 줄에 주어진다.",
    "output_description": "입력으로 주어진 글자의 아스키 코드 값을 출력한다.",
    "examples": [
      {
        "input": "A",
        "output": "65"
      },
      {
        "input": "C",
        "output": "67"
      },
      {
        "input": "0",
        "output": "48"
      },
      {
        "input": "9",
        "output": "57"
      },
      {
        "input": "a",
        "output": "97"
      },
      {
        "input": "z",
        "output": "122"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11654",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "print(ord(input()))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "print(ord(input()))",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: format 활용",
        "solution_code": "c = input()\nprint(format(ord(c), 'd'))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "format으로 변환",
            "description": "format()을 사용하여 정수로 출력합니다.",
            "code_pattern": "format(ord(c), 'd')",
            "socratic_hint": "format으로 정수를 표현하려면?",
            "hint": "format(값, 'd')를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11657",
    "step_title": "최단 경로",
    "title": "타임머신",
    "level": 12,
    "tags": [
      "그래프 이론",
      "최단 경로",
      "벨만–포드"
    ],
    "description": "N개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 버스가 M개 있다. 각 버스는 A, B, C로 나타낼 수 있는데, A는 시작도시, B는 도착도시, C는 버스를 타고 이동하는데 걸리는 시간이다. 시간 C가 양수가 아닌 경우가 있다. C = 0인 경우는 순간 이동을 하는 경우, C < 0인 경우는 타임머신으로 시간을 되돌아가는 경우이다.1번 도시에서 출발해서 나머지 도시로 가는 가장 빠른 시간을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 도시의 개수 N (1 ≤ N ≤ 500), 버스 노선의 개수 M (1 ≤ M ≤ 6,000)이 주어진다. 둘째 줄부터 M개의 줄에는 버스 노선의 정보 A, B, C (1 ≤ A, B ≤ N, -10,000 ≤ C ≤ 10,000)가 주어진다.",
    "output_description": "만약 1번 도시에서 출발해 어떤 도시로 가는 과정에서 시간을 무한히 오래 전으로 되돌릴 수 있다면 첫째 줄에 -1을 출력한다. 그렇지 않다면 N-1개 줄에 걸쳐 각 줄에 1번 도시에서 출발해 2번 도시, 3번 도시, ..., N번 도시로 가는 가장 빠른 시간을 순서대로 출력한다. 만약 해당 도시로 가는 경로가 없다면 대신 -1을 출력한다.",
    "examples": [
      {
        "input": "3 4\r\n1 2 4\r\n1 3 3\r\n2 3 -1\r\n3 1 -2",
        "output": "4\r\n3"
      },
      {
        "input": "3 4\r\n1 2 4\r\n1 3 3\r\n2 3 -4\r\n3 1 -2",
        "output": "-1"
      },
      {
        "input": "3 2\r\n1 2 4\r\n1 2 3",
        "output": "3\r\n-1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11657",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\nedges = []\nfor _ in range(M):\n    a, b, c = map(int, input().split())\n    edges.append((a, b, c))\n\ndist = [float('inf')] * (N + 1)\ndist[1] = 0\n\n# N-1번 반복\nfor _ in range(N - 1):\n    for a, b, c in edges:\n        if dist[a] != float('inf') and dist[a] + c < dist[b]:\n            dist[b] = dist[a] + c\n\n# 음수 사이클 확인\nhas_negative_cycle = False\nfor a, b, c in edges:\n    if dist[a] != float('inf') and dist[a] + c < dist[b]:\n        has_negative_cycle = True\n        break\n\nif has_negative_cycle:\n    print(-1)\nelse:\n    for i in range(2, N + 1):\n        print(dist[i] if dist[i] != float('inf') else -1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11659",
    "step_title": "누적 합",
    "title": "구간 합 구하기 4",
    "level": 8,
    "tags": [
      "누적 합"
    ],
    "description": "수 N개가 주어졌을 때, i번째 수부터 j번째 수까지 합을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 수의 개수 N과 합을 구해야 하는 횟수 M이 주어진다. 둘째 줄에는 N개의 수가 주어진다. 수는 1,000보다 작거나 같은 자연수이다. 셋째 줄부터 M개의 줄에는 합을 구해야 하는 구간 i와 j가 주어진다.",
    "output_description": "총 M개의 줄에 입력으로 주어진 i번째 수부터 j번째 수까지 합을 출력한다.",
    "examples": [
      {
        "input": "5 3\n5 4 3 2 1\n1 3\n2 4\n5 5",
        "output": "12\n9\n1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11659",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\nnumbers = [0] + list(map(int, input().split()))\n\n# 누적합 배열\nprefix_sum = [0] * (N + 1)\nfor i in range(1, N + 1):\n    prefix_sum[i] = prefix_sum[i-1] + numbers[i]\n\nfor _ in range(M):\n    i, j = map(int, input().split())\n    print(prefix_sum[j] - prefix_sum[i-1])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11660",
    "step_title": "누적 합",
    "title": "구간 합 구하기 5",
    "level": 10,
    "tags": [
      "다이나믹 프로그래밍",
      "누적 합"
    ],
    "description": "N×N개의 수가 N×N 크기의 표에 채워져 있다. (x1, y1)부터 (x2, y2)까지 합을 구하는 프로그램을 작성하시오. (x, y)는 x행 y열을 의미한다.예를 들어, N = 4이고, 표가 아래와 같이 채워져 있는 경우를 살펴보자.1234234534564567여기서 (2, 2)부터 (3, 4)까지 합을 구하면 3+4+5+4+5+6 = 27이고, (4, 4)부터 (4, 4)까지 합을 구하면 7이다.표에 채워져 있는 수와 합을 구하는 연산이 주어졌을 때, 이를 처리하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 표의 크기 N과 합을 구해야 하는 횟수 M이 주어진다. (1 ≤ N ≤ 1024, 1 ≤ M ≤ 100,000) 둘째 줄부터 N개의 줄에는 표에 채워져 있는 수가 1행부터 차례대로 주어진다. 다음 M개의 줄에는 네 개의 정수 x1, y1, x2, y2 가 주어지며, (x1, y1)부터 (x2, y2)의 합을 구해 출력해야 한다. 표에 채워져 있는 수는 1,000보다 작거나 같은 자연수이다. (x1 ≤ x2, y1 ≤ y2)",
    "output_description": "총 M줄에 걸쳐 (x1, y1)부터 (x2, y2)까지 합을 구해 출력한다.",
    "examples": [
      {
        "input": "4 3\r\n1 2 3 4\r\n2 3 4 5\r\n3 4 5 6\r\n4 5 6 7\r\n2 2 3 4\r\n3 4 3 4\r\n1 1 4 4",
        "output": "27\r\n6\r\n64"
      },
      {
        "input": "2 4\r\n1 2\r\n3 4\r\n1 1 1 1\r\n1 2 1 2\r\n2 1 2 1\r\n2 2 2 2",
        "output": "1\r\n2\r\n3\r\n4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11660",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\narr = [[0] * (N + 1)]\nfor _ in range(N):\n    arr.append([0] + list(map(int, input().split())))\n\nprefix = [[0] * (N + 1) for _ in range(N + 1)]\n\nfor i in range(1, N + 1):\n    for j in range(1, N + 1):\n        prefix[i][j] = arr[i][j] + prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1]\n\nfor _ in range(M):\n    x1, y1, x2, y2 = map(int, input().split())\n    result = prefix[x2][y2] - prefix[x1-1][y2] - prefix[x2][y1-1] + prefix[x1-1][y1-1]\n    print(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11694",
    "step_title": "스프라그 그런디 정리",
    "title": "님 게임",
    "level": 19,
    "tags": [
      "게임 이론",
      "스프라그–그런디 정리"
    ],
    "description": "koosaga와 cubelover가 님 게임을 하고 있다. 님 게임은 돌을 차곡 차곡 위로 쌓아올린 돌 더미 k개를 이용한다. 각각의 돌 더미에는 한 개 이상의 돌이 있다. 두 사람은 서로 턴을 번갈아가면서 님 게임을 진행한다. 각 사람의 턴이 되면, 돌이 있는 돌 더미를 하나 선택하고, 그 돌 더미에서 돌을 하나 이상 제거한다. 전체 돌 더미에서 마지막 돌을 제거하는 사람이 게임을 지게 된다.게임은 koosaga가 먼저 시작한다. 두 사람이 최적의 방법으로 게임을 진행했을 때, 이기는 사람을 출력한다.",
    "input_description": "첫째 줄에 돌 더미의 개수 N (1 ≤ N ≤ 100)이 주어진다.둘째 줄에는 각 돌 더미에 쌓여있는 돌의 개수 Pi(1 ≤ Pi≤ 2×109)가 주어진다.",
    "output_description": "koosaga가 이기는 경우에는 'koosaga'를, cubelover가 이기는 경우에는 'cubelover'를 출력한다.",
    "examples": [
      {
        "input": "1\n1",
        "output": "cubelover"
      },
      {
        "input": "1\n2",
        "output": "koosaga"
      },
      {
        "input": "2\n1 1",
        "output": "koosaga"
      },
      {
        "input": "2\n1 2",
        "output": "koosaga"
      },
      {
        "input": "2\n2 2",
        "output": "cubelover"
      },
      {
        "input": "4\n1 2 3 4",
        "output": "koosaga"
      },
      {
        "input": "6\n9 8 9 8 9 9",
        "output": "cubelover"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11694",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11710",
    "step_title": "네트워크 플로우 3",
    "title": "Cost Performance Flow",
    "level": 23,
    "tags": [
      "최대 유량",
      "기하학",
      "수학",
      "최소 비용 최대 유량",
      "그래프 이론"
    ],
    "description": "Yayoi is a professional of money saving. Yayoi does not select items just because they are cheap; her motto is “cost performance”. This is one of the reasons why she is good at cooking with bean sprouts. Due to her saving skill, Yayoi often receives requests to save various costs. This time, her task is optimization of “network flow”.Network flow is a problem on graph theory. Now, we consider a directed graph G = (V, E), where V = {1, 2, . . . , |V|} is a vertex set and E ⊂ V × V is an edge set. Each edge e in E has a capacity u(e) and a cost c(e). For two vertices s and t, a function fs,t: E → R, where R is the set of real numbers, is called an s-t flow if the following conditions hold:For all e in E, fs,t is non-negative and no more than u(e). Namely, 0 ≤ fs,t(e) ≤ u(e) holds.For all v in V \\ {s, t}, the sum of fs,tof out-edges from v equals the sum of fs,tof in-edges to v. Namely, ∑e=(u,v)∈Efs,t(e) = ∑e=(v,w)∈Efs,t(e) holds.Here, we define flow F(fs,t) and cost C(fs,t) of fs,t as F(fs,t) = ∑e=(s,v)∈Efs,t(e) − ∑e=(u,s)∈Efs,t(e) and C(fs,t) = ∑e∈Efs,t(e)c(e), respectively.Usually, optimization of network flow is defined as cost minimization under the maximum flow. However, Yayoi’s motto is “cost performance”. She defines a balanced function B(fs,t) for s-t flow as the sum of the square of the cost C(fs,t) and the difference between the maximum flow M = maxf : s-t flowF(f) and the flow F(fs,t), i.e. B(fs,t) = C(fs,t)2+ (M − F(fs,t))2. Then, Yayoi considers that the best cost performance flow yields the minimum of B(fs,t).Your task is to write a program for Yayoi calculating B(f∗s,t) for the best cost performance flow f∗s,t.",
    "input_description": "The input consists of a single test case. The first line gives two integers separated by a single space: the number of vertices N (2 ≤ N ≤ 100) and the number of edges M (1 ≤ M ≤ 1,000). The second line gives two integers separated by a single space: two vertices s and t (1 ≤ s, t ≤ N, s , t). The i-th line of the following M lines describes the i-th edges as four integers ai, bi, ui, and ci: the i-th edge from ai(1 ≤ ai≤ N) to bi(1 ≤ bi≤ N) has the capacity ui(1 ≤ ui≤ 100) and the cost ci(1 ≤ ci≤ 100) . You can assume that ai, bifor all 1 ≤ i ≤ M, and ai, ajor bi, bjif i, j for all 1 ≤ i, j ≤ M.",
    "output_description": "Display B(f∗s,t), the minimum of balanced function under s-t flow, as a fraction in a line. More precisely, output “u/d”, where u is the numerator and d is the denominator of B(f∗s,t), respectively. Note that u and d must be non-negative integers and relatively prime, i.e. the greatest common divisor of u and d is 1. You can assume that the answers for all the test cases are rational numbers.",
    "examples": [
      {
        "input": "2 1\r\n1 2\r\n1 2 1 1",
        "output": "1/2"
      },
      {
        "input": "3 3\r\n1 2\r\n1 2 1 1\r\n1 3 3 1\r\n3 2 3 2",
        "output": "10/1"
      },
      {
        "input": "3 3\r\n1 2\r\n1 2 1 1\r\n1 3 7 1\r\n3 2 7 1",
        "output": "45/1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11710",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 수학 문제 기본 구조\ndef solve():\n    # 입력 처리\n    N = int(input())\n    \n    # 계산\n    result = N\n    \n    return result\n\nprint(solve())",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11717",
    "step_title": "스프라그 그런디 정리",
    "title": "Wall Making Game",
    "level": 19,
    "tags": [
      "다이나믹 프로그래밍",
      "게임 이론",
      "스프라그–그런디 정리"
    ],
    "description": "The game Wall Making Game, a two-player board game, is all the rage.This game is played on an H × W board. Each cell of the board is one of empty, marked, or wall. At the beginning of the game, there is no wall on the board.In this game, two players alternately move as follows:A player chooses one of the empty cells (not marked and not wall). If the player can’t choose a cell, he loses.Towards each of the four directions (upper, lower, left, and right) from the chosen cell, the player changes cells (including the chosen cell) to walls until the player first reaches a wall or the outside of the board.Note that marked cells cannot be chosen in step 1, but they can be changed to walls in step 2.Fig.1 shows an example of a move in which a player chooses the cell at the third row and the fourth column.fig.1: An example of a move in Wall Making Game.Your task is to write a program that determines which player wins the game if the two players play optimally from a given initial board.",
    "input_description": "The first line of the input consists of two integers H and W (1 ≤ H, W ≤ 20), where H and W are the height and the width of the board respectively. The following H lines represent the initial board. Each of the H lines consists of W characters.The j-th character of the i-th line is ‘.’ if the cell at the j-th column of the i-th row is empty, or ‘X’ if the cell is marked.",
    "output_description": "Print “First” (without the quotes) in a line if the first player wins the given game. Otherwise, print “Second” (also without the quotes) in a line.",
    "examples": [
      {
        "input": "2 2\r\n..\r\n..",
        "output": "Second"
      },
      {
        "input": "2 2\r\nX.\r\n..",
        "output": "First"
      },
      {
        "input": "4 5\r\nX....\r\n...X.\r\n.....\r\n.....",
        "output": "First"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11717",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11718",
    "step_title": "문자열",
    "title": "그대로 출력하기",
    "level": 3,
    "tags": [
      "구현",
      "문자열"
    ],
    "description": "입력 받은 대로 출력하는 프로그램을 작성하시오.",
    "input_description": "입력이 주어진다. 입력은 최대 100줄로 이루어져 있고, 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져 있다. 각 줄은 100글자를 넘지 않으며, 빈 줄은 주어지지 않는다. 또, 각 줄은 공백으로 시작하지 않고, 공백으로 끝나지 않는다.",
    "output_description": "입력받은 그대로 출력한다.",
    "examples": [
      {
        "input": "Hello\r\nBaekjoon\r\nOnline Judge",
        "output": "Hello\r\nBaekjoon\r\nOnline Judge"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11718",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nprint(sys.stdin.read(), end='')",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "import sys\nprint(sys.stdin.read(), end='')",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11720",
    "step_title": "문자열",
    "title": "숫자의 합",
    "level": 2,
    "tags": [
      "구현",
      "수학",
      "문자열"
    ],
    "description": "N개의 숫자가 공백 없이 쓰여있다. 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 숫자의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄에 숫자 N개가 공백없이 주어진다.",
    "output_description": "입력으로 주어진 숫자 N개의 합을 출력한다.",
    "examples": [
      {
        "input": "1\r\n1",
        "output": "1"
      },
      {
        "input": "5\r\n54321",
        "output": "15"
      },
      {
        "input": "25\r\n7000000000000000000000000",
        "output": "7"
      },
      {
        "input": "11\r\n10987654321",
        "output": "46"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11720",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nnumbers = input()\ntotal = sum(int(digit) for digit in numbers)\nprint(total)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: map 활용",
        "solution_code": "N = int(input())\nprint(sum(map(int, input())))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문자열을 바로 map",
            "description": "문자열을 map(int, ...)로 바로 변환합니다.",
            "code_pattern": "sum(map(int, input()))",
            "socratic_hint": "문자열의 각 숫자를 더하려면?",
            "hint": "map(int, 문자열)을 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3: for문",
        "solution_code": "N = int(input())\ns = input()\ntotal = 0\nfor digit in s:\n    total += int(digit)\nprint(total)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "for문으로 순회",
            "description": "각 문자를 순회하며 정수로 변환하여 더합니다.",
            "code_pattern": "for digit in s:\n    total += int(digit)",
            "socratic_hint": "각 문자를 처리하려면?",
            "hint": "for문으로 순회합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4: 리스트 컴프리헨션",
        "solution_code": "N = int(input())\nprint(sum([int(d) for d in input()]))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "리스트 컴프리헨션",
            "description": "리스트 컴프리헨션으로 각 문자를 변환합니다.",
            "code_pattern": "[int(d) for d in input()]",
            "socratic_hint": "각 문자를 정수 리스트로 만들려면?",
            "hint": "리스트 컴프리헨션을 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11723",
    "step_title": "동적 계획법 3",
    "title": "집합",
    "level": 6,
    "tags": [
      "구현",
      "집합과 맵",
      "비트마스킹"
    ],
    "description": "비어있는 공집합 S가 주어졌을 때, 아래 연산을 수행하는 프로그램을 작성하시오.add x: S에 x를 추가한다. (1 ≤ x ≤ 20) S에 x가 이미 있는 경우에는 연산을 무시한다.remove x: S에서 x를 제거한다. (1 ≤ x ≤ 20) S에 x가 없는 경우에는 연산을 무시한다.check x: S에 x가 있으면 1을, 없으면 0을 출력한다. (1 ≤ x ≤ 20)toggle x: S에 x가 있으면 x를 제거하고, 없으면 x를 추가한다. (1 ≤ x ≤ 20)all: S를 {1, 2, ..., 20} 으로 바꾼다.empty: S를 공집합으로 바꾼다.",
    "input_description": "첫째 줄에 수행해야 하는 연산의 수 M (1 ≤ M ≤ 3,000,000)이 주어진다.둘째 줄부터 M개의 줄에 수행해야 하는 연산이 한 줄에 하나씩 주어진다.",
    "output_description": "check연산이 주어질때마다, 결과를 출력한다.",
    "examples": [
      {
        "input": "26\nadd 1\nadd 2\ncheck 1\ncheck 2\ncheck 3\nremove 2\ncheck 1\ncheck 2\ntoggle 3\ncheck 1\ncheck 2\ncheck 3\ncheck 4\nall\ncheck 10\ncheck 20\ntoggle 10\nremove 20\ncheck 10\ncheck 20\nempty\ncheck 1\ntoggle 1\ncheck 1\ntoggle 1\ncheck 1",
        "output": "1\n1\n0\n1\n0\n1\n0\n1\n0\n1\n1\n0\n0\n0\n1\n0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11723",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\ninput = sys.stdin.readline\n\nM = int(input())\nS = set()\n\nfor _ in range(M):\n    cmd = input().split()\n    \n    if cmd[0] == 'add':\n        S.add(int(cmd[1]))\n    elif cmd[0] == 'remove':\n        S.discard(int(cmd[1]))\n    elif cmd[0] == 'check':\n        print(1 if int(cmd[1]) in S else 0)\n    elif cmd[0] == 'toggle':\n        x = int(cmd[1])\n        if x in S:\n            S.remove(x)\n        else:\n            S.add(x)\n    elif cmd[0] == 'all':\n        S = set(range(1, 21))\n    elif cmd[0] == 'empty':\n        S = set()",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11725",
    "step_title": "트리",
    "title": "트리의 부모 찾기",
    "level": 9,
    "tags": [
      "그래프 이론",
      "그래프 탐색",
      "트리",
      "너비 우선 탐색",
      "깊이 우선 탐색"
    ],
    "description": "루트 없는 트리가 주어진다. 이때, 트리의 루트를 1이라고 정했을 때, 각 노드의 부모를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 노드의 개수 N (2 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N-1개의 줄에 트리 상에서 연결된 두 정점이 주어진다.",
    "output_description": "첫째 줄부터 N-1개의 줄에 각 노드의 부모 노드 번호를 2번 노드부터 순서대로 출력한다.",
    "examples": [
      {
        "input": "7\r\n1 6\r\n6 3\r\n3 5\r\n4 1\r\n2 4\r\n4 7",
        "output": "4\r\n6\r\n1\r\n3\r\n1\r\n4"
      },
      {
        "input": "12\r\n1 2\r\n1 3\r\n2 4\r\n3 5\r\n3 6\r\n4 7\r\n4 8\r\n5 9\r\n5 10\r\n6 11\r\n6 12",
        "output": "1\r\n1\r\n2\r\n3\r\n3\r\n4\r\n4\r\n5\r\n5\r\n6\r\n6"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11725",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\ngraph = [[] for _ in range(N + 1)]\nparent = [0] * (N + 1)\n\nfor _ in range(N - 1):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\nqueue = deque([1])\nvisited = [False] * (N + 1)\nvisited[1] = True\n\nwhile queue:\n    node = queue.popleft()\n    for next_node in graph[node]:\n        if not visited[next_node]:\n            visited[next_node] = True\n            parent[next_node] = node\n            queue.append(next_node)\n\nfor i in range(2, N + 1):\n    print(parent[i])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11729",
    "step_title": "재귀",
    "title": "하노이 탑 이동 순서",
    "level": 11,
    "tags": [
      "재귀"
    ],
    "description": "세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 큰 순서대로 쌓여있다. 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다.쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.이 작업을 수행하는데 필요한 이동 순서를 출력하는 프로그램을 작성하라. 단, 이동 횟수는 최소가 되어야 한다.아래 그림은 원판이 5개인 경우의 예시이다.",
    "input_description": "첫째 줄에 첫 번째 장대에 쌓인 원판의 개수 N (1 ≤ N ≤ 20)이 주어진다.",
    "output_description": "첫째 줄에 옮긴 횟수 K를 출력한다.두 번째 줄부터 수행 과정을 출력한다. 두 번째 줄부터 K개의 줄에 걸쳐 두 정수 A B를 빈칸을 사이에 두고 출력하는데, 이는 A번째 탑의 가장 위에 있는 원판을 B번째 탑의 가장 위로 옮긴다는 뜻이다.",
    "examples": [
      {
        "input": "3",
        "output": "7\n1 3\n1 2\n3 2\n1 3\n2 1\n2 3\n1 3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11729",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def hanoi(n, start, end, aux):\n    if n == 1:\n        moves.append((start, end))\n        return\n    \n    hanoi(n - 1, start, aux, end)\n    moves.append((start, end))\n    hanoi(n - 1, aux, end, start)\n\nN = int(input())\nmoves = []\nhanoi(N, 1, 3, 2)\n\nprint(len(moves))\nfor start, end in moves:\n    print(start, end)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11758",
    "step_title": "기하 2",
    "title": "CCW",
    "level": 11,
    "tags": [
      "기하학"
    ],
    "description": "2차원 좌표 평면 위에 있는 점 3개 P1, P2, P3가 주어진다. P1, P2, P3를 순서대로 이은 선분이 어떤 방향을 이루고 있는지 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 P1의 (x1, y1), 둘째 줄에 P2의 (x2, y2), 셋째 줄에 P3의 (x3, y3)가 주어진다. (-10,000 ≤ x1, y1, x2, y2, x3, y3≤ 10,000) 모든 좌표는 정수이다. P1, P2, P3의 좌표는 서로 다르다.",
    "output_description": "P1, P2, P3를 순서대로 이은 선분이 반시계 방향을 나타내면 1, 시계 방향이면 -1, 일직선이면 0을 출력한다.",
    "examples": [
      {
        "input": "1 1\n5 5\n7 3",
        "output": "-1"
      },
      {
        "input": "1 1\n3 3\n5 5",
        "output": "0"
      },
      {
        "input": "1 1\n7 3\n5 5",
        "output": "1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11758",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "x1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\n\nccw = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1)\n\nif ccw > 0:\n    print(1)\nelif ccw < 0:\n    print(-1)\nelse:\n    print(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11779",
    "step_title": "동적 계획법과 최단거리 역추적",
    "title": "최소비용 구하기 2",
    "level": 13,
    "tags": [
      "그래프 이론",
      "최단 경로",
      "데이크스트라",
      "역추적"
    ],
    "description": "n(1≤n≤1,000)개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 m(1≤m≤100,000)개의 버스가 있다. 우리는 A번째 도시에서 B번째 도시까지 가는데 드는 버스 비용을 최소화 시키려고 한다. 그러면 A번째 도시에서 B번째 도시 까지 가는데 드는 최소비용과 경로를 출력하여라. 항상 시작점에서 도착점으로의 경로가 존재한다.",
    "input_description": "첫째 줄에 도시의 개수 n(1≤n≤1,000)이 주어지고 둘째 줄에는 버스의 개수 m(1≤m≤100,000)이 주어진다. 그리고 셋째 줄부터 m+2줄까지 다음과 같은 버스의 정보가 주어진다. 먼저 처음에는 그 버스의 출발 도시의 번호가 주어진다. 그리고 그 다음에는 도착지의 도시 번호가 주어지고 또 그 버스 비용이 주어진다. 버스 비용은 0보다 크거나 같고, 100,000보다 작은 정수이다.그리고 m+3째 줄에는 우리가 구하고자 하는 구간 출발점의 도시번호와 도착점의 도시번호가 주어진다.",
    "output_description": "첫째 줄에 출발 도시에서 도착 도시까지 가는데 드는 최소 비용을 출력한다.둘째 줄에는 그러한 최소 비용을 갖는 경로에 포함되어있는 도시의 개수를 출력한다. 출발 도시와 도착 도시도 포함한다.셋째 줄에는 최소 비용을 갖는 경로를 방문하는 도시 순서대로 출력한다. 경로가 여러가지인 경우 아무거나 하나 출력한다.",
    "examples": [
      {
        "input": "5\n8\n1 2 2\n1 3 3\n1 4 1\n1 5 10\n2 4 2\n3 4 1\n3 5 1\n4 5 3\n1 5",
        "output": "4\n3\n1 3 5"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11779",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import heapq\nimport sys\ninput = sys.stdin.readline\n\nn = int(input())\nm = int(input())\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    graph[a].append((b, c))\n\nstart, end = map(int, input().split())\n\ndist = [float('inf')] * (n + 1)\nparent = [-1] * (n + 1)\ndist[start] = 0\n\npq = [(0, start)]\n\nwhile pq:\n    d, now = heapq.heappop(pq)\n    \n    if d > dist[now]:\n        continue\n    \n    for next_node, cost in graph[now]:\n        new_cost = d + cost\n        if new_cost < dist[next_node]:\n            dist[next_node] = new_cost\n            parent[next_node] = now\n            heapq.heappush(pq, (new_cost, next_node))\n\npath = []\nnode = end\nwhile node != -1:\n    path.append(node)\n    node = parent[node]\npath.reverse()\n\nprint(dist[end])\nprint(len(path))\nprint(' '.join(map(str, path)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11780",
    "step_title": "동적 계획법과 최단거리 역추적",
    "title": "플로이드 2",
    "level": 14,
    "tags": [
      "그래프 이론",
      "최단 경로",
      "플로이드–워셜",
      "역추적"
    ],
    "description": "n(1 ≤ n ≤ 100)개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 m(1 ≤ m ≤ 100,000)개의 버스가 있다. 각 버스는 한 번 사용할 때 필요한 비용이 있다.모든 도시의 쌍 (A, B)에 대해서 도시 A에서 B로 가는데 필요한 비용의 최솟값을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 도시의 개수 n이 주어지고 둘째 줄에는 버스의 개수 m이 주어진다. 그리고 셋째 줄부터 m+2줄까지 다음과 같은 버스의 정보가 주어진다. 먼저 처음에는 그 버스의 출발 도시의 번호가 주어진다. 버스의 정보는 버스의 시작 도시 a, 도착 도시 b, 한 번 타는데 필요한 비용 c로 이루어져 있다. 시작 도시와 도착 도시가 같은 경우는 없다. 비용은 100,000보다 작거나 같은 자연수이다.",
    "output_description": "먼저, n개의 줄을 출력해야 한다. i번째 줄에 출력하는 j번째 숫자는 도시 i에서 j로 가는데 필요한 최소 비용이다. 만약, i에서 j로 갈 수 없는 경우에는 그 자리에 0을 출력한다.그 다음에는 n×n개의 줄을 출력해야 한다. i×n+j번째 줄에는 도시 i에서 도시 j로 가는 최소 비용에 포함되어 있는 도시의 개수 k를 출력한다. 그 다음, 도시 i에서 도시 j로 가는 경로를 공백으로 구분해 출력한다. 이때, 도시 i와 도시 j도 출력해야 한다. 만약, i에서 j로 갈 수 없는 경우에는 0을 출력한다.",
    "examples": [
      {
        "input": "5\n14\n1 2 2\n1 3 3\n1 4 1\n1 5 10\n2 4 2\n3 4 1\n3 5 1\n4 5 3\n3 5 10\n3 1 8\n1 4 2\n5 1 7\n3 4 2\n5 2 4",
        "output": "0 2 3 1 4\n12 0 15 2 5\n8 5 0 1 1\n10 7 13 0 3\n7 4 10 6 0\n0\n2 1 2\n2 1 3\n2 1 4\n3 1 3 5\n4 2 4 5 1\n0\n5 2 4 5 1 3\n2 2 4\n3 2 4 5\n2 3 1\n3 3 5 2\n0\n2 3 4\n2 3 5\n3 4 5 1\n3 4 5 2\n4 4 5 1 3\n0\n2 4 5\n2 5 1\n2 5 2\n3 5 1 3\n3 5 2 4\n0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11780",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\ninput = sys.stdin.readline\nINF = float('inf')\n\nn = int(input())\nm = int(input())\n\ndist = [[INF] * (n + 1) for _ in range(n + 1)]\nnext_node = [[0] * (n + 1) for _ in range(n + 1)]\n\nfor i in range(1, n + 1):\n    dist[i][i] = 0\n\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    if dist[a][b] > c:\n        dist[a][b] = c\n        next_node[a][b] = b\n\nfor k in range(1, n + 1):\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if dist[i][j] > dist[i][k] + dist[k][j]:\n                dist[i][j] = dist[i][k] + dist[k][j]\n                next_node[i][j] = next_node[i][k]\n\nfor i in range(1, n + 1):\n    for j in range(1, n + 1):\n        print(0 if dist[i][j] == INF else dist[i][j], end=' ')\n    print()\n\nfor i in range(1, n + 1):\n    for j in range(1, n + 1):\n        if dist[i][j] == INF or i == j:\n            print(0)\n        else:\n            path = []\n            cur = i\n            while cur != j:\n                path.append(cur)\n                cur = next_node[cur][j]\n            path.append(j)\n            print(len(path), *path)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11866",
    "step_title": "스택, 큐, 덱 1",
    "title": "요세푸스 문제 0",
    "level": 7,
    "tags": [
      "구현",
      "자료 구조",
      "큐"
    ],
    "description": "요세푸스 문제는 다음과 같다.1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 <3, 6, 2, 7, 5, 1, 4>이다.N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N과 K가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 1,000)",
    "output_description": "예제와 같이 요세푸스 순열을 출력한다.",
    "examples": [
      {
        "input": "7 3",
        "output": "<3, 6, 2, 7, 5, 1, 4>"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11866",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import deque\n\nN, K = map(int, input().split())\nqueue = deque(range(1, N + 1))\nresult = []\n\nwhile queue:\n    for _ in range(K - 1):\n        queue.append(queue.popleft())\n    result.append(queue.popleft())\n\nprint('<' + ', '.join(map(str, result)) + '>')",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11868",
    "step_title": "스프라그 그런디 정리",
    "title": "님 게임 2",
    "level": 17,
    "tags": [
      "게임 이론",
      "스프라그–그런디 정리"
    ],
    "description": "koosaga와 cubelover가 님 게임을 하고 있다. 님 게임은 돌을 차곡 차곡 위로 쌓아올린 돌 더미 k개를 이용한다. 각각의 돌 더미에는 한 개 이상의 돌이 있다. 두 사람은 서로 턴을 번갈아가면서 님 게임을 진행한다. 각 사람의 턴이 되면, 돌이 있는 돌 더미를 하나 선택하고, 그 돌 더미에서 돌을 하나 이상 제거한다. 전체 돌 더미에서 마지막 돌을 제거하는 사람이 게임을 이기게 된다.게임은 koosaga가 먼저 시작한다. 두 사람이 최적의 방법으로 게임을 진행했을 때, 이기는 사람을 출력한다.",
    "input_description": "첫째 줄에 돌 더미의 개수 N (1 ≤ N ≤ 100)이 주어진다.둘째 줄에는 각 돌 더미에 쌓여있는 돌의 개수 Pi(1 ≤ Pi≤ 109)가 주어진다.",
    "output_description": "koosaga가 이기는 경우에는 'koosaga'를, cubelover가 이기는 경우에는 'cubelover'를 출력한다.",
    "examples": [
      {
        "input": "1\r\n1",
        "output": "koosaga"
      },
      {
        "input": "1\r\n2",
        "output": "koosaga"
      },
      {
        "input": "2\r\n1 1",
        "output": "cubelover"
      },
      {
        "input": "2\r\n1 2",
        "output": "koosaga"
      },
      {
        "input": "2\r\n2 2",
        "output": "cubelover"
      },
      {
        "input": "4\r\n1 2 3 4",
        "output": "koosaga"
      },
      {
        "input": "6\r\n9 8 9 8 9 9",
        "output": "cubelover"
      },
      {
        "input": "3\r\n2 4 6",
        "output": "cubelover"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11868",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "11933",
    "step_title": "트리와 쿼리",
    "title": "공장들",
    "level": 22,
    "tags": [
      "트리",
      "분할 정복",
      "최소 공통 조상",
      "centroid",
      "센트로이드 분할",
      "트리 압축"
    ],
    "description": "IOI 왕국에서 0 이상 N−1 이하의 번호가 붙은 N개의 도시들이 있습니다. 이들 도시들은 양방향으로 통행이 가능한 N−1개의 도로로 연결되어 있습니다. 여러분은 이러한 도로들을 몇 개 통과하여 어떤 서로 다른 두 다시 사이도 이동할 수 있습니다.IOI 왕국에는 특별한 제품들을 생산하는 많은 회사들이 있습니다. 각 회사는 단 한 종류의 제품만 생산하며, 어떤 두 회사도 같은 종류의 제품을 생산하지 않습니다. 각 도시는 한 개 이상의 공장을 가지고 있습니다. 각 공장은 도시들 중 하나에 지어져 있습니다. 같은 도시에 두 개 이상의 회사가 공장을 가지고 있을 수도 있습니다.가끔 어떤 회사는 또다른 회사의 제품이 필요할 때가 있습니다. 회사 CA가 회사 CB의 제품이 필요하다고 가정해 봅시다. (CA≠CB) 이 경우, 그들은 CB에서 CA로 제품을 운반해야 합니다. 이를 위해 회사 CB의 아무 공장에서 회사 CA의 아무 공장으로 제품을 운반하면 됩니다. 그들은 공장들 사이의 거리를 최소화하기 위하여 공장들을 적절히 선택해야 합니다.우선, 도시들의 수와 IOI 왕국의 도로의 정보가 주어집니다. 그 다음, Q개의 질의가 주어집니다. 각 질의는 다음과 같은 형태로 주어집니다: Xj,0,⋯,Xj,Sj−1번 도시들에 공장을 가지고 있는 회사 Uj는 Yj,0,⋯,Yj,Tj−1번 도시들에 공장을 가지고 있는 회사 Vj의 제품이 필요합니다. 각 질의마다, 제품을 운반하기 위해 필요한 최소 거리를 반환하는 프로그램을 작성하세요.",
    "input_description": "첫 번째 줄에 두 개의 정수 N과 Q가 공백을 사이로 두고 주어집니다. 이는 IOI 왕국에 N개의 도시가 있고, 여러분의 프로그램에게 Q개의 질의가 주어진다는 것을 의미합니다.다음 (N−1)개의 줄 중 (i+1)번째 줄 (0 ≤ i ≤ N−2)에는 세 개의 정수 Ai, Bi, Di가 공백을 사이로 두고 주어집니다. 이것은 도시 Ai와 도시 Bi를 잇는 길이가 Di인 도로가 있다는 것을 의미합니다.다음 3Q개 줄 중에서 j번째 질의의 정보는 (3j+1)번째 줄부터 (3j+3)번째 줄까지 (0 ≤ j ≤ Q−1) 주어집니다.(3j+1)번째 줄 (0 ≤ j ≤ Q−1)에는 두 개의 정수 Sj와 Tj가 공백을 사이로 두고 주어집니다. 이것은 회사 Uj와 회사 Vj각각 Sj개와 Tj개의 도시에 공장을 두고 있다는 것을 의미합니다.(3j+2)번째 줄 (0 ≤ j ≤ Q−1)에는 Sj개의 정수 Xj,0,⋯,Xj,Sj−1이 공백을 사이로 두고 주어집니다. 이것은 회사 Uj가 도시 Xj,0,⋯,Xj,Sj−1에 공장을 두고 있다는 것을 의미합니다.(3j+3)번째 줄 (0 ≤ j ≤ Q−1)에는 Tj개의 정수 Yj,0,⋯,Yj,Tj−1이 공백을 사이로 두고 주어집니다. 이것은 회사 Vj가 도시 Yj,0,⋯,Yj,Tj−1에 공장을 두고 있다는 것을 의미합니다.모든 입력 데이터는 다음 조건을 만족합니다.2 ≤ N ≤ 500 000.1 ≤ Q ≤ 100 000.0 ≤ Ai≤ N − 1 (0 ≤ i ≤ N − 2).0 ≤ Bi≤ N − 1 (0 ≤ i ≤ N − 2).1 ≤ Di≤ 100 000 000 (0 ≤ i ≤ N − 2).Ai≠ Bi(1 ≤ i ≤ N − 2).여러분은 도로들을 통해 한 도시에서 다른 모든 도시로 이동할 수 있습니다.1 ≤ Sj≤ N − 1 (0 ≤ j ≤ Q − 1).0 ≤ Xj,k≤ N − 1 (0 ≤ j ≤ Q − 1, 0 ≤ k ≤ Sj− 1).1 ≤ Tj≤ N − 1 (0 ≤ j ≤ Q − 1).0 ≤ Yj,k≤ N − 1 (0 ≤ j ≤ Q − 1, 0 ≤ k ≤ Tj − 1).Xj,0, Xj,1, . . . , Xj,Sj−1, Yj,0, Yj,1, . . . , Yj,Tj−1은 서로 다릅니다 (0 ≤ j ≤ Q − 1).S0+ S1+ · · · + SQ−1≤ 1 000 000.T0+ T1+ · · · + TQ−1≤ 1 000 000.",
    "output_description": "각각의 질의에 대한 답을 한 줄에 하나씩 차례대로 출력합니다",
    "examples": [
      {
        "input": "7 3\n0 1 4\n1 2 4\n2 3 5\n2 4 6\n4 5 5\n1 6 3\n2 2\n0 6\n3 4\n3 2\n0 1 3\n4 6\n1 1\n2\n5",
        "output": "12\n3\n11"
      }
    ],
    "url": "https://www.acmicpc.net/problem/11933",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 그래프 문제 기본 구조\nfrom collections import deque\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\n# BFS/DFS 구현\nvisited = [False] * (N + 1)\n\ndef bfs(start):\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        node = queue.popleft()\n        for next_node in graph[node]:\n            if not visited[next_node]:\n                visited[next_node] = True\n                queue.append(next_node)\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "12015",
    "step_title": "이분 탐색",
    "title": "가장 긴 증가하는 부분 수열 2",
    "level": 14,
    "tags": [
      "이분 탐색",
      "가장 긴 증가하는 부분 수열 문제"
    ],
    "description": "수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10,20, 10,30, 20,50} 이고, 길이는 4이다.",
    "input_description": "첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai≤ 1,000,000)",
    "output_description": "첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.",
    "examples": [
      {
        "input": "6\r\n10 20 10 30 20 50",
        "output": "4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/12015",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from bisect import bisect_left\n\nN = int(input())\nA = list(map(int, input().split()))\n\nlis = []\n\nfor num in A:\n    pos = bisect_left(lis, num)\n    if pos == len(lis):\n        lis.append(num)\n    else:\n        lis[pos] = num\n\nprint(len(lis))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "12144",
    "step_title": "네트워크 플로우 3",
    "title": "영어와 프랑스어 (Large)",
    "level": 22,
    "tags": [
      "그래프 이론",
      "자료 구조",
      "문자열",
      "집합과 맵",
      "해시를 사용한 집합과 맵",
      "최대 유량",
      "최대 유량 최소 컷 정리"
    ],
    "description": "영선이의 부모님은 집에서 영어와 프랑스어를 이용해 영선이와 대화한다. 영선이는 많은 단어를 들었지만, 어떤 단어가 프랑스어이고 어떤 단어가 영어인지는 모른다.영선이는 영어로 이루어진 문장 하나와 프랑스어로 이루어진 문장 하나를 알고있다. 그리고, 영어인지 프랑스어인지 모르는 문장을 여러 개 알고 있다.단어가 영어 문장에서 나타났으면 이 단어는 영어이고, 프랑스어 문장에서 나타났으면 이 단어는 프랑스어이다.영선이가 들은 모든 문장이 주어졌을 때, 영어이면서 프랑스어인 단어의 최소 개수를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 테스트 케이스의 개수 T가 주어진다. (1 ≤ T ≤ 25)각 테스트 케이스의 첫째 줄에는 문장의 개수 N이 주어진다. (2 ≤ N ≤ 200) 둘째 줄부터 N개의 줄에는 문장이 주어진다.문장은 단어로 이루어져 있으며, 단어는 공백으로 구분되어져 있다. 단어는 알파벳 소문자로만 이루어져 있고, 길이는 10을 넘지 않는다.첫 번째 문장은 영어 문장이고, 두 번째 문장은 프랑스어 문장이다. 나머지 문장은 어떤 언어인지 알 수 없는 문장이다.첫 두 문장은 각각 최대 1,000개의 단어로 이루어져 있고, 나머지 문장은 최대 10개의 단어로 이루어져 있다.",
    "output_description": "각각의 테스트 케이스 마다 영어이면서 프랑스어인 단어의 최소 개수를 출력한다.",
    "examples": [
      {
        "input": "4\n2\nhe loves to eat baguettes\nil aime manger des baguettes\n4\na b c d e\nf g h i j\na b c i j\nf g h d e\n4\nhe drove into a cul de sac\nelle a conduit sa voiture\nil a conduit dans un cul de sac\nil mange pendant que il conduit sa voiture\n6\nadieu joie de vivre je ne regrette rien\nadieu joie de vivre je ne regrette rien\na b c d e\nf g h i j\na b c i j\nf g h d e",
        "output": "Case #1: 1\nCase #2: 4\nCase #3: 3\nCase #4: 8"
      }
    ],
    "url": "https://www.acmicpc.net/problem/12144",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "12456",
    "step_title": "그리디 알고리즘 2",
    "title": "모닝커피 (Large)",
    "level": 16,
    "tags": [
      "자료 구조",
      "그리디 알고리즘",
      "우선순위 큐"
    ],
    "description": "호토 코코아(이하, 코코아)는 아침의 하루를 커피를 마시는 것으로 시작한다.코코아의 찬장에는N종류의 커피가 있고,i번의 커피는ci잔 분이 남아있으며, 오늘부터 유통기한까지ti일 남았다. 그녀는 i번 (1 ≤i≤N) 종류의 커피를 1잔 마시면,si만큼의 만족도를 얻는다. 유통기한이 지난 커피는 마실 수 없다. (그러나, 딱ti일째에는 그 커피를 마실 수 있다.)예를 들어,ti=1인 경우, 오늘 중에 그 커피를 마시던가, 버리던가 해야 한다.코코아는 커피를 하루에 한잔, 아침에밖에 마시지 않는다. 찬장에 커피가 하나도 없으면, 만족도를 얻을수 없다. 오늘부터 시작해서 커피를 마시는 것으로,K일에 코코아가 얻을수 있는 만족도 합계의 최대를 구하라.",
    "input_description": "입력의 제일 첫 줄은 테스트케이스 T이다, 그 뒤로 T개의 테스트 케이스가 입력된다. 각각의 테스트케이스는 1개의 공백으로 구분된 2개의 양의 정수가 포함된 행으로 시작한다.  첫 정수는 커피의 종류 N을 의미하며, 다음 정수는 최대로 얻을 수 있는 만족도를 계산할 날짜인 K를 의미한다. 그 뒤에 N개의 커피 종류에 대한 남아있는 커피 개수, 유통기한, 만족도를 아래의 포맷으로 입력받는다.ci ti si값의 범위1 ≤T≤ 1001 ≤ci≤ K1 ≤ti≤ K1 ≤si≤ 10001 ≤N≤ 1001 ≤K≤ 2 * 1012(32bit 정수형을 초과하는 것에 주의)",
    "output_description": "각 테스트 케이스마다Case #X: Y을 1행씩 출력한다, X는 테스트 케이스의 번호, Y는 만족도 합계의 최대를 표시한다.",
    "examples": [
      {
        "input": "3\r\n2 3\r\n2 2 2\r\n3 3 1\r\n2 3\r\n1 3 2\r\n1 3 1\r\n5 5\r\n5 5 1\r\n4 4 2\r\n3 3 3\r\n2 2 4\r\n1 1 5",
        "output": "Case #1: 5\r\nCase #2: 3\r\nCase #3: 15"
      }
    ],
    "url": "https://www.acmicpc.net/problem/12456",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "12634",
    "step_title": "네트워크 플로우 3",
    "title": "Stock Charts (Large)",
    "level": 19,
    "tags": [
      "이분 매칭"
    ],
    "description": "You're in the middle of writing your newspaper's end-of-year economics summary, and you've decided that you want to show a number of charts to demonstrate how different stocks have performed over the course of the last year. You've already decided that you want to show the price ofndifferent stocks, all at the samekpoints of the year.Asimple chartof one stock's price would draw lines between the points (0, price0), (1, price1), ... , (k-1, pricek-1), where priceiis the price of the stock at theith point in time.In order to save space, you have invented the concept of anoverlaid chart. An overlaid chart is the combination of one or more simple charts, and shows the prices of multiple stocks (simply drawing a line for each one). In order to avoid confusion between the stocks shown in a chart, the lines in an overlaid chart may not cross or touch.Given a list ofnstocks' prices at each ofktime points, determine the minimum number of overlaid charts you need to show all of the stocks' prices.",
    "input_description": "The first line of input will contain a single integerT, the number of test cases. After this will followTtest cases on different lines, each of the form:n k\r\nprice0,0price0,1... price0,k-1price1,0price1,1... price1,k-1...\r\npricen-1,0pricen-1,1... pricen-1,k-1Where pricei,jis an integer, the price of theith stock at timej.Limits1 ≤T≤ 1002 ≤k≤ 250 ≤ pricei,j≤ 10000001 ≤n≤ 100",
    "output_description": "For each test case, a single line containing \"Case #X: Y\", whereXis the number of the test-case (1-indexed) andYis the minimum number of overlaid charts needed to show the prices of all of the stocks.",
    "examples": [
      {
        "input": "3\r\n3 4\r\n1 2 3 4\r\n2 3 4 6\r\n6 5 4 3\r\n3 3\r\n5 5 5\r\n4 4 6\r\n4 5 4\r\n5 2\r\n1 1\r\n2 2\r\n5 4\r\n4 4\r\n4 1",
        "output": "Case #1: 2\r\nCase #2: 3\r\nCase #3: 2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/12634",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "12776",
    "step_title": "그리디 알고리즘 2",
    "title": "Swap Space",
    "level": 17,
    "tags": [
      "그리디 알고리즘",
      "정렬"
    ],
    "description": "You administer a large cluster of computers with hard drives that use various file system types to store data. You recently decided to unify the file systems to the same type. That is quite a challenge since all the drives are currently in use, all of them are filled with important data to the limits of their capacities, and you cannot afford to lose any of the data. Moreover, reformatting a drive to use a new file system may significantly change the drive’s capacity. To make the reformat possible, you will have to buy an extra hard drive. Obviously, you want to save money by minimizing the size of such extra storage.You can reformat the drives in any order. Prior to reformatting a drive, you must move all data from that drive to one or more other drives, splitting the data if necessary. After a drive is reformatted, you can immediately start using it to store data from other drives. It is not necessary to put all the data on the same drives they originally started on – in fact, this might even be impossible if some of the drives have smaller capacity with the new file system. It is also allowed for some data to end up on the extra drive.As an example, suppose you have four drives A, B, C, and D with drive capacities 6, 1, 3, and 3 GB. Under the new file system, the capacities become 6, 7, 5, and 5 GB, respectively. If you buy only 1 GB of extra space, you can move the data from drive B there and then reformat drive B. Now you have 7 GB free on drive B, so you can move the 6 GB from drive A there and reformat drive A. Finally, you move the six total gigabytes from drives C and D to drive A, and reformat C and D.",
    "input_description": "The input begins with a line containing one integer n (1 ≤ n ≤ 106), which is the number of drives in your cluster. Following this are n lines, each describing a drive as two integers a and b, where a is the capacity with the old file system and b is the capacity with the new file system.All capacities are given in gigabytes and satisfy 1 ≤ a, b ≤ 109. (One thousand petabytes should be enough for everyone, right?)",
    "output_description": "Display the total extra capacity in gigabytes you must buy to reformat the drives.",
    "examples": [
      {
        "input": "4\r\n6 6\r\n1 7\r\n3 5\r\n3 5",
        "output": "1"
      },
      {
        "input": "4\r\n2 2\r\n3 3\r\n5 1\r\n5 10",
        "output": "5"
      }
    ],
    "url": "https://www.acmicpc.net/problem/12776",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor num in sorted(arr):\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\narr.sort()\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sort() 메서드로 정렬",
            "description": "arr.sort()로 리스트를 제자리에서 정렬합니다.",
            "code_pattern": "arr.sort()",
            "socratic_hint": "리스트를 제자리에서 정렬하는 메서드는?",
            "hint": ".sort() 메서드를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문을 사용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor i in range(n-1):\n    for j in range(n-1-i):\n        if arr[j] > arr[j+1]:\n            arr[j], arr[j+1] = arr[j+1], arr[j]\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 패스 횟수 제어",
            "description": "n-1번 반복하며 각 패스를 수행합니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "버블 정렬에서 몇 번의 패스가 필요한가요?",
            "hint": "n-1번의 패스가 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "내부 반복문: 인접 원소 비교",
            "description": "각 패스에서 인접한 두 원소를 비교합니다. 이미 정렬된 뒤쪽 부분은 제외합니다.",
            "code_pattern": "for j in range(n-1-i):",
            "socratic_hint": "각 패스에서 비교해야 할 원소의 범위는?",
            "hint": "n-1-i까지 비교합니다 (이미 정렬된 부분 제외)."
          },
          {
            "step_id": 4,
            "goal": "원소 교환",
            "description": "왼쪽 원소가 오른쪽 원소보다 크면 위치를 교환합니다.",
            "code_pattern": "if arr[j] > arr[j+1]:\n    arr[j], arr[j+1] = arr[j+1], arr[j]",
            "socratic_hint": "인접한 두 원소의 순서가 잘못되었을 때 어떻게 하나요?",
            "hint": "두 원소의 위치를 swap합니다."
          },
          {
            "step_id": 5,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      },
      {
        "solution_id": 5,
        "solution_name": "풀이 5",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor i in range(n-1):\n    min_idx = i\n    for j in range(i+1, n):\n        if arr[j] < arr[min_idx]:\n            min_idx = j\n    arr[i], arr[min_idx] = arr[min_idx], arr[i]\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 정렬할 위치 선택",
            "description": "n-1번 반복하며 각 위치에 올 최솟값을 찾습니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "선택 정렬에서 몇 번의 선택이 필요한가요?",
            "hint": "n-1번의 선택이 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "최솟값 인덱스 초기화",
            "description": "현재 위치를 최솟값 인덱스로 가정합니다.",
            "code_pattern": "min_idx = i",
            "socratic_hint": "최솟값을 찾기 위한 초기값은?",
            "hint": "현재 위치 i를 초기값으로 설정합니다."
          },
          {
            "step_id": 4,
            "goal": "내부 반복문: 최솟값 찾기",
            "description": "현재 위치 이후의 원소들 중 최솟값의 인덱스를 찾습니다.",
            "code_pattern": "for j in range(i+1, n):\n    if arr[j] < arr[min_idx]:\n        min_idx = j",
            "socratic_hint": "정렬되지 않은 부분에서 최솟값을 어떻게 찾나요?",
            "hint": "i+1부터 끝까지 순회하며 최솟값 인덱스를 업데이트합니다."
          },
          {
            "step_id": 5,
            "goal": "원소 교환",
            "description": "찾은 최솟값을 현재 위치로 이동시킵니다.",
            "code_pattern": "arr[i], arr[min_idx] = arr[min_idx], arr[i]",
            "socratic_hint": "최솟값을 현재 위치로 가져오려면?",
            "hint": "현재 위치의 값과 최솟값을 swap합니다."
          },
          {
            "step_id": 6,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "12789",
    "step_title": "스택, 큐, 덱 1",
    "title": "도키도키 간식드리미",
    "level": 8,
    "tags": [
      "자료 구조",
      "스택"
    ],
    "description": "인하대학교 학생회에서는 중간, 기말고사 때마다 시험 공부에 지친 학우들을 위해 간식을 나눠주는 간식 드리미 행사를 실시한다. 승환이는 시험 기간이 될 때마다 간식을 받을 생각에 두근두근 설레서 시험 공부에 집중을 못 한다. 이번 중간고사에서도 역시 승환이는 설레는 가슴을 안고 간식을 받기 위해 미리 공지된 장소에 시간 맞춰 도착했다. 그런데 이게 무슨 날벼락인가! 그 곳에는 이미 모든 학생들이 모여있었고, 승환이는 마지막 번호표를 받게 되었다. 설상가상으로 몇몇 양심에 털이 난 학생들이 새치기를 거듭한 끝에 대기열의 순서마저 엉망이 되고 말았다. 간식을 나눠주고 있던 인규는 학우들의 터져 나오는 불만에 번호표 순서로만 간식을 줄 수 있다고 말했다.그제야 학생들이 순서대로 줄을 서려고 했지만 공간이 너무 협소해서 마음대로 이동할 수 없었다. 다행히도 대기열의 왼쪽에는 1열로 설 수 있는 공간이 존재하여 이 공간을 잘 이용하면 모두가 순서대로 간식을 받을 수 있을지도 모른다. 자칫 간식을 못 받게 될지도 모른다는 위기감을 느낀 승환이는 자신의 컴퓨터 알고리즘적 지식을 활용해 과연 모든 사람들이 순서대로 간식을 받을 수 있는지 확인하는 프로그램을 만들기로 했다. 만약 불가능 하다면 승환이는 이번 중간고사를 망치게 될 것 이고 가능하다면 힘을 얻어 중간고사를 잘 볼 수 있을지도 모른다.사람들은 현재 1열로 줄을 서있고, 맨 앞의 사람만 이동이 가능하다. 인규는 번호표 순서대로만 통과할 수 있는 라인을 만들어 두었다. 이 라인과 대기열의 맨 앞 사람 사이에는 한 사람씩 1열이 들어갈 수 있는 공간이 있다. 현재 대기열의 사람들은 이 공간으로 올 수 있지만 반대는 불가능하다. 승환이를 도와 프로그램을 완성하라.현재 간식 배부 공간을 그림으로 나타내면 다음과 같다.위 예제는 다음 그림과 같이 움직였을 때 모두가 순서대로 간식을 받을 수 있다..",
    "input_description": "입력의 첫째 줄에는 현재 승환이의 앞에 서 있는 학생들의 수N(1 ≤N≤ 1,000,자연수)이 주어진다.다음 줄에는 승환이 앞에 서있는 모든 학생들의 번호표(1,2,...,N) 순서가 앞에서부터 뒤 순서로 주어진다.",
    "output_description": "승환이가 무사히 간식을 받을 수 있으면 \"Nice\"(따옴표는 제외)를 출력하고 그렇지 않다면 \"Sad\"(따옴표는 제외)를 출력한다.",
    "examples": [
      {
        "input": "5\r\n5 4 1 3 2",
        "output": "Nice"
      }
    ],
    "url": "https://www.acmicpc.net/problem/12789",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nline = list(map(int, input().split()))\n\nstack = []\ncurrent = 1\n\nfor student in line:\n    if student == current:\n        current += 1\n    else:\n        stack.append(student)\n    \n    while stack and stack[-1] == current:\n        stack.pop()\n        current += 1\n\nif not stack:\n    print(\"Nice\")\nelse:\n    print(\"Sad\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "12795",
    "step_title": "동적 계획법 최적화 1",
    "title": "반평면 땅따먹기",
    "level": 21,
    "tags": [
      "자료 구조",
      "세그먼트 트리",
      "볼록 껍질을 이용한 최적화",
      "리–차오 트리"
    ],
    "description": "어려서부터 땅따먹기를 곧잘 즐기던 구사과는, 땅따먹기로 입신의 경지에 다다르게 되었다. 그래서 구사과는 자신만이 할 수 있는 새로운 땅따먹기 게임을 만들었는데, 이름하여 반평면 땅따먹기이다.반평면 땅따먹기의 규칙은 땅따먹기보다 좀 더 간단하다. 땅따먹기 특이점을 넘긴 능력을 보유한 구사과는 땅따먹기에서만큼은 뭐든지 할 수 있다. 이를테면 무한히 먼 곳으로부터 손가락으로 돌을 쳐 무한히 멀리 직선으로 날아가도록 할 수 있다. 반평면 땅따먹기는 이 능력을 이용한 게임으로, 구사과가 점령하는 돌을 쳐서 날릴 때마다 그 자취인 직선을 기준으로 나뉘는 두 영역 중 (0, -∞)를 포함하는 쪽 전부를 점령하게 된다.무한한 2차원 평면 위에서 게임을 하던 구사과는 문득 현재 자신이 점령한 땅의 모양에 관해서 궁금해졌다. 하지만 땅따먹기 이외에는 젬병인 구사과는 정작 자신이 점령한 땅에 대해서는 잘 알지 못했다. 높은 곳을 좋아하는 구사과는 종종 자신이 점령한 땅 중 해당 x좌표에서 가장 높은 y좌표가 몇인지 알고 싶었다.우수한 프로그래머인 당신만이 구사과의 유일한 희망이다. 구사과가 게임을 진행한 정보가 주어질 때 이를 토대로 구사과의 궁금증을 해결해주자!",
    "input_description": "첫 줄에는 게임을 진행한 정보의 개수Q(1 ≤Q≤ 200,000)이 주어지며, 이어서Q줄에 걸쳐 각 정보가 주어진다. 각 줄의 첫 번째 숫자가 1일 경우 이어서 2개의 정수a,b(|a| ≤ 1,000,000, |b| ≤ 1,000,000,000,000)가 주어지며 이는 구사과가 y =ax +b형태의 직선을 따라 돌을 날렸음을 의미한다. 각 줄의 첫 번째 숫자가 2일 경우 이어서 1개의 정수x(|x| ≤ 1,000,000,000,000)이 주어지며, 이는 구사과가 현재까지 점령한 땅 중 해당 x 좌표에서 가장 높은 y값을 궁금해함을 의미한다. 첫 번째 정보는 무조건 1로 시작함이 보장된다.",
    "output_description": "모든 구사과의 궁금증에 대하여 해당하는 y값을 한 줄에 걸쳐 하나씩 출력한다.",
    "examples": [
      {
        "input": "4\n1 1 2\n1 2 3\n2 -100\n2 100",
        "output": "-98\n203"
      }
    ],
    "url": "https://www.acmicpc.net/problem/12795",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "12844",
    "step_title": "세그먼트 트리 2",
    "title": "XOR",
    "level": 18,
    "tags": [
      "자료 구조",
      "세그먼트 트리",
      "느리게 갱신되는 세그먼트 트리"
    ],
    "description": "크기가 N인 수열 A0, A1, ..., AN-1이 주어졌을 때, 다음 두 종류의 쿼리를 수행해보자.1 i j k: Ai, Ai+1, ..., Aj에 k를 xor한다.2 i j: Ai, Ai+1, ..., Aj를 모두 xor한 다음 출력한다.",
    "input_description": "첫 번째 줄에 수열의 크기 N이 주어진다.두 번째 줄에는 A0, A1, ..., AN-1이 차례대로 주어지며, 공백 한 칸으로 구분되어져 있다.세 번째 줄에는 쿼리의 개수 M이 주어지고, 다음 M개의 줄에 쿼리가 한 줄에 하나씩 주어진다.",
    "output_description": "2번 쿼리의 결과를 모두 출력한다.",
    "examples": [
      {
        "input": "5\n1 2 3 4 5\n3\n2 0 4\n1 2 4 9\n2 0 4",
        "output": "1\n8"
      }
    ],
    "url": "https://www.acmicpc.net/problem/12844",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "12852",
    "step_title": "동적 계획법과 최단거리 역추적",
    "title": "1로 만들기 2",
    "level": 11,
    "tags": [
      "다이나믹 프로그래밍",
      "그래프 이론",
      "그래프 탐색",
      "역추적"
    ],
    "description": "정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.X가 3으로 나누어 떨어지면, 3으로 나눈다.X가 2로 나누어 떨어지면, 2로 나눈다.1을 뺀다.정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.",
    "input_description": "첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 자연수 N이 주어진다.",
    "output_description": "첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.둘째 줄에는 N을 1로 만드는 방법에 포함되어 있는 수를 공백으로 구분해서 순서대로 출력한다. 정답이 여러 가지인 경우에는 아무거나 출력한다.",
    "examples": [
      {
        "input": "2",
        "output": "1\n2 1"
      },
      {
        "input": "10",
        "output": "3\n10 9 3 1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/12852",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\ndp = [0] * (N + 1)\npath = [0] * (N + 1)\n\nfor i in range(2, N + 1):\n    dp[i] = dp[i-1] + 1\n    path[i] = i - 1\n    \n    if i % 2 == 0 and dp[i//2] + 1 < dp[i]:\n        dp[i] = dp[i//2] + 1\n        path[i] = i // 2\n    \n    if i % 3 == 0 and dp[i//3] + 1 < dp[i]:\n        dp[i] = dp[i//3] + 1\n        path[i] = i // 3\n\nprint(dp[N])\n\nresult = []\ncurr = N\nwhile curr > 0:\n    result.append(curr)\n    curr = path[curr]\n\nprint(' '.join(map(str, result)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "12857",
    "step_title": "평방 분할",
    "title": "홍준이는 문자열을 좋아해",
    "level": 19,
    "tags": [
      "자료 구조",
      "해싱",
      "해시를 사용한 집합과 맵",
      "제곱근 분할법",
      "문자열",
      "트리를 사용한 집합과 맵",
      "두 포인터",
      "집합과 맵"
    ],
    "description": "홍준이는 문자열을 좋아합니다. 그래서 문자열과 관련된 여러 문제들을 고민하고 있습니다.그 중 하나는 문자열 S가 주어졌을 때, 어떤 두 문자열 A와 B를 모두 포함하는 S의 연속 부분 문자열 중 가장 길이가 짧은 것을 구하는 문제입니다. 홍준이는 똑똑해서 이 문제를 금방 풀어버렸습니다. 그래서 한층 더 어려운 문제를 생각하였습니다. 두 문자열 A와 B가 질문 Q번 들어올 때에는 어떻게 빠르게 답을 구할 수 있을지 고민하던 홍준이는 너무 어려워서 A와 B의 길이가 짧다면 빨리 풀 수 있을 것으로 생각하고 있습니다.홍준이를 도와 문제를 해결하는 프로그램을 작성하세요.",
    "input_description": "첫째 줄에 길이가 5만 이하인 문자열 S가 주어집니다.둘째 줄에 0 이상 10만 이하인 하나의 정수 Q가 주어집니다.셋째 줄부터 Q개의 줄에 걸쳐 길이가 1 이상 4 이하인 두 문자열 A와 B가 주어집니다.모든 문자들은 영문 알파벳 소문자로 구성되어 있습니다.",
    "output_description": "Q개의 줄에 걸쳐 각각의 두 문자열 A와 B를 부분 문자열로 가지는 S의 연속 부분 문자열의 최소 길이를 출력합니다. 만약 그런 연속 부분 문자열이 존재하지 않는다면 -1을 출력합니다.",
    "examples": [
      {
        "input": "xudyhduxyz\r\n3\r\nxyz xyz\r\ndyh xyz\r\ndzy xyz",
        "output": "3\r\n8\r\n-1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/12857",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "12865",
    "step_title": "동적 계획법 1",
    "title": "평범한 배낭",
    "level": 11,
    "tags": [
      "다이나믹 프로그래밍",
      "배낭 문제"
    ],
    "description": "이 문제는 아주 평범한 배낭에 관한 문제이다.한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.",
    "input_description": "첫 줄에 물품의 수 N(1 ≤ N ≤ 100)과 준서가 버틸 수 있는 무게 K(1 ≤ K ≤ 100,000)가 주어진다. 두 번째 줄부터 N개의 줄에 거쳐 각 물건의 무게 W(1 ≤ W ≤ 100,000)와 해당 물건의 가치 V(0 ≤ V ≤ 1,000)가 주어진다.입력으로 주어지는 모든 수는 정수이다.",
    "output_description": "한 줄에 배낭에 넣을 수 있는 물건들의 가치합의 최댓값을 출력한다.",
    "examples": [
      {
        "input": "4 7\n6 13\n4 8\n3 6\n5 12",
        "output": "14"
      }
    ],
    "url": "https://www.acmicpc.net/problem/12865",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N, K = map(int, input().split())\nitems = []\nfor _ in range(N):\n    w, v = map(int, input().split())\n    items.append((w, v))\n\ndp = [0] * (K + 1)\n\nfor w, v in items:\n    for j in range(K, w - 1, -1):\n        dp[j] = max(dp[j], dp[j - w] + v)\n\nprint(dp[K])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "12899",
    "step_title": "세그먼트 트리 1",
    "title": "데이터 구조",
    "level": 17,
    "tags": [
      "자료 구조",
      "세그먼트 트리",
      "이분 탐색"
    ],
    "description": "자연수를 저장하는 데이터베이스 S에 대해 다음의 쿼리를 처리합시다.유형 1 : S에 자연수 X를 추가한다.유형 2 : S에 포함된 숫자 중 X번째로 작은 수를 응답하고 그 수를 삭제한다.",
    "input_description": "첫째 줄에 사전에 있는 쿼리의 수 N 이 주어집니다. (1 ≤ N ≤ 2,000,000)둘째 줄부터 N개의 줄에 걸쳐 각 쿼리를 나타내는 2개의 정수 T X가 주어집니다.T가 1이라면 S에 추가할 X가 주어지는 것입니다. (1 ≤ X ≤ 2,000,000)T가 2라면 X는 S에서 삭제해야 할 몇 번째로 작은 수인지를 나타냅니다. S에 최소 X개의 원소가 있음이 보장됩니다.",
    "output_description": "유형 2의 쿼리 개수만큼의 줄에 각 쿼리에 대한 답을 출력합니다.",
    "examples": [
      {
        "input": "5\r\n1 11\r\n1 29\r\n1 89\r\n2 2\r\n2 2",
        "output": "29\r\n89"
      }
    ],
    "url": "https://www.acmicpc.net/problem/12899",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13018",
    "step_title": "해 구성하기",
    "title": "특이한 수열",
    "level": 12,
    "tags": [
      "수학",
      "애드 혹",
      "정수론",
      "해 구성하기"
    ],
    "description": "이 문제는 특이한 수열 A를 찾는 문제이다. 특이한 수열의 성질은 다음과 같다.수열 A의 길이는 n1이상 n이하의 정수가 빠짐없이 모두 등장해야 하며, 각 수는 한번만 등장해야함1 ≤ i ≤ n 인 i에 대해 gcd(i, A[i]) > 1 을 만족하는 i가 정확히 k개여야함n, k 가 주어졌을 때, 특이한 수열을 아무거나 하나 구해보자.",
    "input_description": "첫째 줄에 n, k (1 ≤ n ≤ 105, 0 ≤ k ≤ n)가 주어진다.",
    "output_description": "첫째 줄에 문제의 조건을 만족하는 특이한 수열 A를 출력한다. 답이 여러 가지가 있다면 그 중 아무거나 출력해도 된다. 만약 조건을 만족하는 특이한 수열이 없다면 \"Impossible\" 을 출력한다.",
    "examples": [
      {
        "input": "1 1",
        "output": "Impossible"
      },
      {
        "input": "4 2",
        "output": "2 1 3 4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13018",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "n, k = map(int, input().split())\n\nresult = list(range(1, n + 1))\n\ncount = 0\nfor i in range(1, n + 1):\n    if count < k:\n        if i % 2 == 0 and i < n:\n            result[i - 1], result[i] = result[i], result[i - 1]\n            count += 1\n\nprint(' '.join(map(str, result)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13034",
    "step_title": "스프라그 그런디 정리",
    "title": "다각형 게임",
    "level": 18,
    "tags": [
      "게임 이론",
      "스프라그–그런디 정리"
    ],
    "description": "N개의 꼭짓점으로 이루어진 볼록 다각형이 있다. 다각형의 내각은 모두 180보다 작다. 꼭짓점은 1부터 N번까지 시계 방향으로 번호가 매겨져 있다.성관이와 홍준이는 다각형에서 게임을 하려고 한다. 성관이가 먼저 턴을 갖는다.각 턴마다 플레이어는 두 꼭짓점을 고르고, 선분을 긋는다 (변과 일치해도 된다). 이때, 이미 그려져 있는 선분과 교차하면 안 된다 (선분의 끝 점에서 겹치는 것도 교차하는 것이다). 더 이상 선분을 그릴 수 없는 사람이 게임을 패배한다.N이 주어진다. 두 사람이 최적의 방법으로 게임했을 때, 누가 이기는지 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N (3 ≤ N ≤ 1,000) 이 주어진다.",
    "output_description": "성관이가 이기면 1, 홍준이가 이기면 2를 출력한다.",
    "examples": [
      {
        "input": "3",
        "output": "1"
      },
      {
        "input": "4",
        "output": "1"
      },
      {
        "input": "15",
        "output": "2"
      },
      {
        "input": "191",
        "output": "2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13034",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13161",
    "step_title": "네트워크 플로우 1",
    "title": "분단의 슬픔",
    "level": 20,
    "tags": [
      "그래프 이론",
      "최대 유량",
      "최대 유량 최소 컷 정리"
    ],
    "description": "UCPC에는 N명의 사람이 있다. 먼 옛날 쇼킹핫치킨에 대한 논쟁에서 시작된 이념의 대립으로 UCPC에는 kriii를 따르는 쇼킹핫진보 진영 A와, august14를 따르는 쇼킹핫보수 진영 B의 두 진영이 존재한다. 모든 사람은 둘 중 한 진영에 소속되어 있으며, 두 진영에 동시에 들어가는 것은 불가능하다.i번 사람과 j번 사람에 대해 서로 다른 진영에 들어가게 될 경우 슬픈 정도 w[i, j]가 주어진다. 일부 사람들은 쇼킹핫에 관한 자신의 철학이 강해 무조건 A진영에 들어가는 사람도 있고, 무조건 B진영에 들어가는 사람도 있다. 물론 치킨은 무엇이든 옳으므로 두 진영 어디에 가든 상관없는 사람도 있다.N명의 사람들이 적절히 두 진영에 나누어 들어갈 때, 슬픔 정도의 합이 최소가 되게 하라.",
    "input_description": "첫 번째 줄에는 UCPC 구성원의 수 N(1 ≤ N ≤ 500)이 주어진다. 두 번째 줄에는 N개의 정수가 주어지는데, i번째 수가 1이면 i번 사람은 무조건 A진영에 들어가야 함을, 2라면 무조건 B진영에 들어가야 함을, 0이면 어느 진영에 들어가든지 상관 없다는 것을 의미한다.세 번째 줄부터 N개의 줄에 걸쳐 i번 사람과 j번 사람이 다른 진영에 들어갈 때의 슬픔 정도 w[i, j]가 주어진다. (i+2)번째 줄에 j번째 수는 w[i, j]를 의미한다. 주어지는 입력은 항상 w[i, j]=w[j, i]를 만족하고, w[i, i]=0이다. w[i, j]는 1,000보다 크지 않은 음이 아닌 정수이다.",
    "output_description": "첫 줄에 N명의 사람이 A, B 두 진영에 적절히 들어가 슬픈 정도의 합이 최소가 될 때의 슬픔 정도의 합을 출력한다. 두 번째 줄에는 슬픈 정도의 합이 최소가 될 때 A진영에 들어가는 사람들의 번호를 공백으로 구분하여 출력하고, 세 번째 줄에는 슬픈 정도의 합이 최소가 될 때 B진영에 들어가는 사람들의 번호를 공백으로 구분하여 출력한다. 만약 한 진영에 사람이 한 명도 들어가지 않은 경우 빈 줄을 출력한다. 가능한 경우가 여러 가지인 경우 그중 아무거나 하나 출력한다.",
    "examples": [
      {
        "input": "5\n0 1 0 2 2\n0 1 1 1 1\n1 0 1 1 1\n1 1 0 1 1\n1 1 1 0 1\n1 1 1 1 0",
        "output": "4\n2\n1 3 4 5"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13161",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13188",
    "step_title": "동적 계획법 5",
    "title": "Kangaroo",
    "level": 23,
    "tags": [
      "다이나믹 프로그래밍"
    ],
    "description": "A garden is composed of a row of N cells numbered from 1 to N. Initially, all cells contain plants. A kangaroo arrived in the garden in cell numbered cs. Then he jumps from cell to cell, eating the plants as he goes. He will always finish in cell numbered cf, after visiting each of the N cells exactly once, including cs and cf. Obviously, the kangaroo will make N-1 jumps.The kangaroo doesn't want to be caught, so after each jump he changes the direction in which he jumps next: if he is currently in cell numbered current after he jumped there from a cell numbered prev, and will jump from current to cell numbered next, then:if prev < current, then next < current; else,if current < prev, then current < next.Knowing the number N of cells in the garden, the starting cell cs from where the kangaroo starts to eat plants and the final cell cf where the kangaroo finishes, you should calculate the number of distinct routes the kangaroo can take while jumping through the garden.",
    "input_description": "The input will contain three space separated positive integers N, cs, cf.2 ≤ N ≤ 20001 ≤ cs ≤ N1 ≤ cf ≤ Ncs ≠ cfAny route is uniquely determined by the order in which cells are visited.We guarantee that for each test there is at least one route which follow the rules.The kangaroo can start jumping in any direction from cs.",
    "output_description": "In the output you should write a single integer, the number of distinct routes the kangaroo can take modulo 1000000007 (109+ 7).",
    "examples": [
      {
        "input": "4 2 3",
        "output": "2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13188",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13241",
    "step_title": "약수, 배수와 소수 2",
    "title": "최소공배수",
    "level": 6,
    "tags": [
      "수학",
      "정수론",
      "유클리드 호제법"
    ],
    "description": "정수 B에 0보다 큰 정수인 N을 곱해 정수 A를 만들 수 있다면, A는 B의 배수이다.예:10은 5의 배수이다 (5*2 = 10)10은 10의 배수이다(10*1 = 10)6은 1의 배수이다(1*6 = 6)20은 1, 2, 4,5,10,20의 배수이다.다른 예:2와 5의 최소공배수는 10이고, 그 이유는 2와 5보다 작은 공배수가 없기 때문이다.10과 20의 최소공배수는 20이다.5와 3의 최소공배수는 15이다.당신은 두 수에 대하여 최소공배수를 구하는 프로그램을 작성 하는 것이 목표이다.",
    "input_description": "한 줄에 두 정수 A와 B가 공백으로 분리되어 주어진다.50%의 입력 중 A와 B는 1000(103)보다 작다. 다른 50%의 입력은 1000보다 크고 100000000(108)보다 작다.추가: 큰 수 입력에 대하여 변수를 64비트 정수로 선언하시오. C/C++에서는 long long int를 사용하고, Java에서는 long을 사용하시오.",
    "output_description": "A와 B의 최소공배수를 한 줄에 출력한다.",
    "examples": [
      {
        "input": "1 1",
        "output": "1"
      },
      {
        "input": "3 5",
        "output": "15"
      },
      {
        "input": "1 123",
        "output": "123"
      },
      {
        "input": "121 199",
        "output": "24079"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13241",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "A, B = map(int, input().split())\nprint(A * B)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "여러 값 입력 받기",
            "description": "A, B = map(int, input().split())로 입력을 처리합니다.",
            "code_pattern": "A, B = map(int, input().split())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(A * B)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13261",
    "step_title": "동적 계획법 최적화 1",
    "title": "탈옥",
    "level": 20,
    "tags": [
      "다이나믹 프로그래밍",
      "분할 정복",
      "분할 정복을 사용한 최적화"
    ],
    "description": "총 L개의 칸이 일렬로 놓여져 있는 감옥이 있다. 각각의 칸은 1번부터 L번까지 번호가 매겨져 있다. i번 방에는 죄수가 한 명 들어있으며, 그 죄수의 탈옥력(탈옥을 할 수 있는 능력을 수치로 나타낸 것)은 Ci이다.가장 이상적인 감시 방법은 각각의 칸을 감시하는 간수가 한 명씩 있는 것이고, 각각의 간수가 죄수를 한 명씩 감시하는 것이다. 하지만, 예산 문제 때문에 이 감옥에는 간수를 최대 G명 고용할 수 있다. 우리는 탈옥 위험도를 최소로 하게 간수를 고용하고 배치하려고 한다.각각의 간수는 인접한 칸을 감시해야 한다. i번 칸의 탈옥 위험도 Ri는 탈옥력 Ci와 i번 칸을 감시하는 간수가 감시하고 있는 죄수의 수를 곱한 값이다. 감옥의 탈옥 위험도는 모든 칸의 탈옥 위험도 Ri를 더한 값이다.L과 G, 그리고 각 칸에 들어있는 죄수의 탈옥력 Ci가 주어졌을 때, 탈옥 위험도의 최솟값을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 감옥의 크기 L(1 ≤ L ≤ 8000)과 간수의 수 G(1 ≤ G ≤ 800)이 주어진다.둘째 줄에는 Ci가 주어진다. (1 ≤ Ci≤ 109)",
    "output_description": "첫째 줄에 탈옥 위험도의 최솟값을 출력한다.",
    "examples": [
      {
        "input": "6 3\r\n11 11 11 24 26 100",
        "output": "299"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13261",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13263",
    "step_title": "동적 계획법 최적화 1",
    "title": "나무 자르기",
    "level": 19,
    "tags": [
      "다이나믹 프로그래밍",
      "볼록 껍질을 이용한 최적화"
    ],
    "description": "높이가 a1, a2, ..., an인 나무 n개를 전기톱을 이용해서 자르려고 한다.i번 나무에 전기톱을 사용할 때 마다 그 나무의 높이는 1만큼 감소한다. 전기톱은 사용할 때 마다 충전해야 한다. 전기톱을 충전하는 비용은 완전히 자른 나무의 번호에 영향을 받는다. 즉, 높이가 0이 되어버린 나무의 번호에 영향을 받는다. 완전히 잘려진 나무의 번호 중 최댓값이 i이면, 전기톱을 충전하는 비용은 bi이다. 완전히 잘려진 나무가 없다면 전기톱은 충전할 수가 없다. 가장 처음에 전기톱은 충전되어져 있다.나무의 높이 ai와 각각의 나무에 대한 충전 비용 bi가 주어졌을 때, 모든 나무를 완전히 자르는데 (높이를 0으로 만드는데) 필요한 충전 비용의 최솟값을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 n(1 ≤ n ≤ 100,000)이 주어진다. 둘째 줄에는 a1, a2, ..., an이, 셋째 줄에는 b1, b2, ..., bn이 주어진다. (1 ≤ ai≤ 109, 0 ≤ bi≤ 109)a1= 1이고, bn= 0이며, a1< a2< ... < an, b1> b2> ... > bn을 만족한다.",
    "output_description": "나무를 완전히 자르는 충전 비용의 최솟값을 출력한다.",
    "examples": [
      {
        "input": "5\r\n1 2 3 4 5\r\n5 4 3 2 0",
        "output": "25"
      },
      {
        "input": "6\r\n1 2 3 10 20 30\r\n6 5 4 3 2 0",
        "output": "138"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13263",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13275",
    "step_title": "문자열 알고리즘 2",
    "title": "가장 긴 팰린드롬 부분 문자열",
    "level": 16,
    "tags": [
      "문자열",
      "매내처"
    ],
    "description": "문자열 S의 부분 문자열 중에서 팰린드롬인 것 중 가장 긴 것의 길이를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 문자열 S가 주어진다. S는 알파벳 소문자로만 이루어져 있으며 길이는 1보다 크거나 같고, 100,000보다 작거나 같다.",
    "output_description": "가장 긴 팰린드롬 부분 문자열의 길이를 출력한다.",
    "examples": [
      {
        "input": "abcd",
        "output": "1"
      },
      {
        "input": "abab",
        "output": "3"
      },
      {
        "input": "dcabccd",
        "output": "2"
      },
      {
        "input": "abcba",
        "output": "5"
      },
      {
        "input": "aaaaa",
        "output": "5"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13275",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "word = input()\nprint(1 if word == word[::-1] else 0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "word = input()로 입력을 처리합니다.",
            "code_pattern": "word = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "조건 판단",
            "description": "조건문을 사용하여 상황에 따라 다르게 처리합니다.",
            "code_pattern": "print(1 if word == word[::-1] else 0)",
            "socratic_hint": "조건에 따라 다르게 처리하려면?",
            "hint": "if-else 문을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(1 if word == word[::-1] else 0)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13305",
    "step_title": "그리디 알고리즘 1",
    "title": "주유소",
    "level": 8,
    "tags": [
      "그리디 알고리즘"
    ],
    "description": "어떤 나라에 N개의 도시가 있다. 이 도시들은 일직선 도로 위에 있다. 편의상 일직선을 수평 방향으로 두자. 제일 왼쪽의 도시에서 제일 오른쪽의 도시로 자동차를 이용하여 이동하려고 한다. 인접한 두 도시 사이의 도로들은 서로 길이가 다를 수 있다. 도로 길이의 단위는 km를 사용한다.처음 출발할 때 자동차에는 기름이 없어서 주유소에서 기름을 넣고 출발하여야 한다. 기름통의 크기는 무제한이어서 얼마든지 많은 기름을 넣을 수 있다. 도로를 이용하여 이동할 때 1km마다 1리터의 기름을 사용한다. 각 도시에는 단 하나의 주유소가 있으며, 도시 마다 주유소의 리터당 가격은 다를 수 있다. 가격의 단위는 원을 사용한다.예를 들어, 이 나라에 다음 그림처럼 4개의 도시가 있다고 하자. 원 안에 있는 숫자는 그 도시에 있는 주유소의 리터당 가격이다. 도로 위에 있는 숫자는 도로의 길이를 표시한 것이다.제일 왼쪽 도시에서 6리터의 기름을 넣고, 더 이상의 주유 없이 제일 오른쪽 도시까지 이동하면 총 비용은 30원이다. 만약 제일 왼쪽 도시에서 2리터의 기름을 넣고(2×5 = 10원) 다음 번 도시까지 이동한 후 3리터의 기름을 넣고(3×2 = 6원) 다음 도시에서 1리터의 기름을 넣어(1×4 = 4원) 제일 오른쪽 도시로 이동하면, 총 비용은 20원이다. 또 다른 방법으로 제일 왼쪽 도시에서 2리터의 기름을 넣고(2×5 = 10원) 다음 번 도시까지 이동한 후 4리터의 기름을 넣고(4×2 = 8원) 제일 오른쪽 도시까지 이동하면, 총 비용은 18원이다.각 도시에 있는 주유소의 기름 가격과, 각 도시를 연결하는 도로의 길이를 입력으로 받아 제일 왼쪽 도시에서 제일 오른쪽 도시로 이동하는 최소의 비용을 계산하는 프로그램을 작성하시오.",
    "input_description": "표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 도시의 개수를 나타내는 정수 N(2 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 인접한 두 도시를 연결하는 도로의 길이가 제일 왼쪽 도로부터 N-1개의 자연수로 주어진다. 다음 줄에는 주유소의 리터당 가격이 제일 왼쪽 도시부터 순서대로 N개의 자연수로 주어진다. 제일 왼쪽 도시부터 제일 오른쪽 도시까지의 거리는 1이상 1,000,000,000 이하의 자연수이다. 리터당 가격은 1 이상 1,000,000,000 이하의 자연수이다.",
    "output_description": "표준 출력으로 제일 왼쪽 도시에서 제일 오른쪽 도시로 가는 최소 비용을 출력한다.",
    "examples": [
      {
        "input": "4\n2 3 1\n5 2 4 1",
        "output": "18"
      },
      {
        "input": "4\n3 3 4\n1 1 1 1",
        "output": "10"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13305",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\ndistances = list(map(int, input().split()))\nprices = list(map(int, input().split()))\n\nmin_price = prices[0]\ntotal_cost = 0\n\nfor i in range(N - 1):\n    min_price = min(min_price, prices[i])\n    total_cost += min_price * distances[i]\n\nprint(total_cost)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13306",
    "step_title": "유니온 파인드 2",
    "title": "트리",
    "level": 17,
    "tags": [
      "자료 구조",
      "분리 집합",
      "오프라인 쿼리"
    ],
    "description": "트리 T는 아래 그림 1과 같은 구조를 가지고 있으며 원은 ‘정점’이라 하고, 정점과 정점을 연결하는 선을 ‘에지’라 한다. 특히 가장 위에 위치한 정점을 ‘루트’라 하는데 오직 하나만 있다. N개의 정점들은 숫자 1부터 N으로 표현하고 루트는 항상 1이다.두 정점 v와 w를 연결하는 경로는 정점들의 순서리스트 (v0, v1, ..., vm)로, 정점 vi와 vi+1은 에지로 연결되고 v0= v, vm= w이다. 트리에서는 임의의 두 정점 v와 w 사이에 항상 두 정점을 연결하는 경로가 오직 하나만 존재한다. 예를 들어, 그림 1에서 정점 3과 11 사이의 유일한 경로는 (3, 4, 1, 7, 11)이다.그림 1각 정점 v에서 루트 r과 연결하는 유일한 경로 P에 대해서 정점 v와 에지로 연결된 정점 중에서 P상에 있는 정점을 v의 ‘부모 정점’이라고 한다. 예를 들어, 그림 1에서 4, 7, 9의 부모 정점은 1이고, 2와 11의 부모 정점은 7이다.트리 T에서 어떤 두 정점을 연결하는 에지를 제거하면 그 두 정점 외에도 경로가 존재하지 않는 정점 쌍이 있을 수 있다. 여러분은 “정점 v와 w를 연결하는 경로가 존재하는가?”와 같은 질의에 답해야 한다. 예를 들어, 그림 1에서 7과 11 사이의 에지를 제거하면 8과 5를 연결하는 경로는 존재하지 않는다.트리 정보가 주어지고, 에지의 제거 정보와 질의가 임의의 순서로 주어질 때, 작업을 순서대로 수행하며 질의에 대한 답을 출력하는 프로그램을 작성하시오.",
    "input_description": "표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 트리의 정점의 개수와 질의의 개수를 나타내는 두 정수 N과 Q (1 ≤ N, Q ≤ 200,000)가 주어진다. 다음 N-1개의 줄의 i번째 줄에는 정점 i+1의 부모 정점을 나타내는 정수 a가 주어진다 (1 ≤ a ≤ N). 다음 (N-1)+Q개의 줄 중에서 N-1개는 (1)의 형태로, Q개는 (2)의 형태로 주어진다. (1) 두 정수 x와 b가 주어진다(x = 0, 2 ≤ b ≤ N). 이것은 b의 부모 정점과 b를 연결하는 에지를 제거함을 의미한다. 각 줄의 b는 모두 다르다. (2) 세 정수 x, c, d가 주어진다 (x = 1, 1 ≤ c, d ≤ N). 이것은 c와 d를 연결하는 경로가 존재하는 지 묻는 질의를 의미한다.",
    "output_description": "표준 출력으로 질의에 대한 답을 순서대로 Q개의 줄에 출력한다. 각 줄마다 경로가 존재하면YES를 아니면NO를 출력한다.",
    "examples": [
      {
        "input": "3 3\n1\n1\n1 2 3\n0 3\n1 2 3\n1 1 2\n0 2",
        "output": "YES\nNO\nYES"
      },
      {
        "input": "11 5\n7\n4\n1\n9\n11\n1\n11\n1\n3\n7\n0 11\n1 8 5\n1 3 9\n0 10\n0 9\n0 7\n1 2 7\n0 5\n1 1 10\n0 8\n0 6\n0 2\n1 1 3\n0 3\n0 4",
        "output": "NO\nYES\nYES\nNO\nYES"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13306",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13322",
    "step_title": "문자열 알고리즘 2",
    "title": "접두사 배열",
    "level": 5,
    "tags": [
      "구현",
      "문자열",
      "애드 혹"
    ],
    "description": "접미사 배열(suffix array)이란, 어떤 문자열의 모든 접미사를 사전 순으로 정렬한 뒤, 각 접미사의 시작 위치를 기록한 배열을 의미한다. 예를 들어 'banana' 라는 문자열에 대해 접미사 배열을 구한다면 아래와 같다문자열의 모든 접미사는 아래와 같다.banana, anana, nana, ana, na, a위 접미사들을 사전 순으로 정렬하면 아래와 같다.a, ana, anana, banana, na, nana각 접미사의 원래 문자열에서의 시작 인덱스를 기록하면 아래와 같다.5, 3, 1, 0, 4, 2따라서 문자열 'banana'의 접미사 배열은 { 5, 3, 1, 0, 4, 2 } 가 된다.연세대학교의 PS 동아리 모르고리즘 회원 택희와 남규는 문자열 문제 하나를 같이 풀어보고 있었다. 다음은 그 과정에서 있었던 대화의 일부를 발췌한 것이다.택희 : 이거 그냥 suffix array 구해놓고 풀면 되겠는데?남규 : suffix array면.. 접미사 배열 구하고 뒤집으면 되나?택희 : ??남규 : ??택희 : suffix가 접미사인데?남규 : 아 맞네.. 접두사로 착각했네.택희 : 근데 그럼 접두사 배열은 어떻게 구하지?남규 : 그러게?택희 : 문자열 뒤집고 suffix array 구하면 되나? 아닌데..?택희와 남규는 혼란에 빠졌다.혼란스러워하는 택희와 남규를 위해 접두사 배열을 구해 줄 프로그램을 작성해 보자.",
    "input_description": "첫 줄에 알파벳 소문자로 이루어진 문자열 S가 주어진다. (1 ≤ |S| ≤ 100000)",
    "output_description": "|S|줄에 걸쳐, 문자열 S의 모든 접두사를 사전 순으로 정렬했을 때, 목록의 첫 접두사부터 마지막 접두사까지 각 접두사가 끝나는 인덱스를 순서대로 출력한다. 문자열의 인덱스는 0부터 시작한다.",
    "examples": [
      {
        "input": "ab",
        "output": "0\r\n1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13322",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13323",
    "step_title": "동적 계획법 최적화 2",
    "title": "BOJ 수열 1",
    "level": 23,
    "tags": [
      "다이나믹 프로그래밍",
      "자료 구조",
      "우선순위 큐",
      "함수 개형을 이용한 최적화"
    ],
    "description": "수열 A1, A2.. AN이 주어진다.B1< B2< ... < BN을 만족하면서, |B1- A1| + |B2- A2| ... |BN- AN| 을 최소화하는 수열 B가 존재할 때, 당신은 그러한 값의 가능한 최솟값을 출력해야 한다.수열 A와 B는 정수로만 이루어진 수열이고, 수열 B의 원소는 32비트 정수형 범위 안에 들어있어야 한다.",
    "input_description": "첫 번째 줄에 N이 주어진다. (N ≤ 1,000,000) 두 번째 줄에 수열 A의 원소가 순서대로 주어진다. (0 ≤ Ai≤ 2 × 109)",
    "output_description": "가능한 |B1- A1| + |B2- A2| ... |BN- AN| 값의 최소를 출력한다.",
    "examples": [
      {
        "input": "7\r\n9 4 8 20 14 15 18",
        "output": "13"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13323",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13332",
    "step_title": "네트워크 플로우 3",
    "title": "Project Team",
    "level": 21,
    "tags": [
      "서큘레이션",
      "최대 유량",
      "그래프 이론"
    ],
    "description": "A team composed of m members is going to carry out a project in n contiguous working days. You are helping the team to set up the vacation schedules of the members. Every member is bound to work for at least p and at most p′ working days for the project and, in particular, the number of team members required to work on the i-th working day is between qiand qi′, inclusive, for i = 1, … , n. Also, each member has a series of vacation plans(d1,[r1, r1′]), (d2,[r2, r2′]), … , (dk,[rk, rk′]),which indicate that the member wants to take at least divacation days from the working-day period [ri, ri′] for each i = 1, … , k, and wants to work on a day not included in the union of the period [ri, ri′] over all i, i.e., ⋃ki=1{r: ri≤ r ≤ ri′}. Note that the vacation days are presumably not fixed in a vacation plan. If a member has a vacation plan (2,[7,9]) for instance, he/she may take a two-day vacation {7,8}, {7,9}, {8,9}, or happily a three-day vacation {7,8,9}; whereas for some vacation plans, say (2,[3,4]), the vacation days are fixed.Given the information on the project team and the vacation plans for the team members, you are to write a computer program that determines if it is possible to assign vacation days to each of the members in a way that everyone is happy, subject to the aforementioned constraints. Such an assignment of vacation days is called a vacation schedule. It is assumed that the members are indexed from 1 to m.For example, suppose you are given m = 3, n = 5, and (p, p′) = (2, 3), as well as (qi, qi′) for working day i ∈ {1, … ,5} shown in the table below (left) and the vacation plans for member j ∈ {1,2,3} shown in the table (center). You can make vacation schedules of the members that satisfy all the constraints, as shown in the table below (right).",
    "input_description": "Your program is to read from standard input. The first line of the input contains four positive integers m, n, p and p′ whose meaning has been described above, where m ≤ 100, n ≤ 100, and p ≤ p′ ≤ n. In the following n lines, each line contains two positive integers qiand qi′ for i = 1 to n, where qi≤ qi′ ≤ m for all i. Then, m lines follow, where the j-th line contains the vacation plans for the member j. The vacation plans of a member, denoted by (d1,[r1, r1′]), (d2,[r2, r2′]), … , (dk,[rk, rk′]) , is represented by a sequence of 3k + 1 positive integers as follows: k, d1, r1, r1′, d2, r2, r2′, …, dk, rk, rk′. The number of vacation plans of a member is no more than 20. You may assume that ri≤ ri′ ≤ n and di≤ ri′ − ri+ 1 for all i ∈ {1, … , k}, r1< r2< ⋯ < rk, and moreover two periods [ra, ra′] and [rb, rb′] are disjoint whenever a ≠ b, i.e., they do not contain a common working day if a ≠ b and a, b ∈ {1, … , k}.",
    "output_description": "Your program is to write to standard output. The first line must contain an integer indicating whether or not there exist vacation schedules of the team members that satisfy all the constraints. If yes, the integer must be 1; otherwise -1. When and only when the first line is 1, it must follow m lines containing, one by one, the vacation schedules for member j = 1 to m, where the vacation schedule of a member is described by the number of vacation days followed by the vacation days in ascending order.",
    "examples": [
      {
        "input": "3 5 2 3\r\n2 2\r\n2 3\r\n1 2\r\n1 3\r\n1 2\r\n1 2 1 3\r\n2 2 2 3 1 4 5\r\n1 2 3 5",
        "output": "1\r\n2 1 3\r\n3 2 3 5\r\n2 4 5"
      },
      {
        "input": "3 5 3 4\r\n2 3\r\n2 3\r\n2 3\r\n2 3\r\n2 3\r\n1 1 2 2\r\n1 1 3 3\r\n1 1 2 3",
        "output": "-1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13332",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13392",
    "step_title": "동적 계획법 4",
    "title": "방법을 출력하지 않는 숫자 맞추기",
    "level": 15,
    "tags": [
      "다이나믹 프로그래밍"
    ],
    "description": "아래 그림과 같이 N개의 회전이 가능한 숫자 나사가 아래위로 연결되어 있다. 가장 위에 있는 숫자나사는 숫자나사 1이고 가장 아래에 있는 숫자나사는 숫자나사 N이다. 모든 숫자나사는 각각 10개의 면을 가지고 있고, 각 면에는 오른쪽 방향으로 0, 1, 2, 3, …, 9까지의 숫자가 하나씩 순서대로 적혀 있다. 하나의 숫자나사를 왼쪽으로 회전 시키면, 이 나사보다 아래에 위치한 모든 나사는 같이 따라서 돌게 되지만, 나사를 오른쪽으로 회전시키면, 다른 나사는 함께 돌지는 않는다. 정면에서 보아 위에서부터 아래쪽으로 숫자를 읽어 내려간다고 할 때, 현재의 상태에서 가장 적은 칸수의 움직임으로 원하는 숫자를 만들기 위한 방법을 출력하는 프로그램을 작성하라.예를 들어 세 개의 숫자나사가 주어졌을 때, 정면에서 보는 현재 상태가 326이고 원하는 상태는 446이라면 최소 회전 칸수는 4이다. 먼저 숫자나사 1을 왼쪽으로 한 칸 돌리면 437이 되고, 숫자나사 2를 역시 왼쪽으로 한 칸 돌리면 448이 되며, 마지막으로 숫자나사 3을 오른쪽으로 두 칸 돌리면 446이 된다.",
    "input_description": "첫째 줄에는 숫자나사의 개수 N이 주어지고, 둘째 줄에는 현재의 상태가, 셋째 줄에는 원하는 상태가 주어진다. N은 3 이상이고 10,000 이하이다.",
    "output_description": "첫째 줄에는 현재 상태에서 원하는 상태로 도달하는데 필요한 최소 회전 칸수를 출력한다.",
    "examples": [
      {
        "input": "3\n326\n446",
        "output": "4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13392",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13448",
    "step_title": "동적 계획법 4",
    "title": "SW 역량 테스트",
    "level": 18,
    "tags": [
      "다이나믹 프로그래밍",
      "그리디 알고리즘",
      "정렬",
      "배낭 문제"
    ],
    "description": "SW 역량 테스트는 총 T분동안 진행되며 N개의 문제가 나온다. 대회가 진행되는 동안 아무 때나 소스 코드를 제출할 수 있다.i번 문제를 t분에 맞춘 경우에는 Mi-t*Pi점을 받게 된다. 이 테스트에 응시한 백준이가 i번 문제를 푸는데 걸리는 시간은 Ri분이다.백준이가 얻을 수 있는 점수의 최댓값을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N과 T가 주어진다. (1 ≤ N ≤ 50, 1 ≤ T ≤ 100,000)둘째 줄에는 Mi, 셋째 줄에는 Pi, 넷째 줄에는 Ri가 주어진다. (1 ≤ Mi, Pi, Ri≤ 100,000)",
    "output_description": "백준이가 얻을 수 있는 점수의 최댓값을 출력한다.",
    "examples": [
      {
        "input": "1 74\r\n502\r\n2\r\n47",
        "output": "408"
      },
      {
        "input": "2 40000\r\n100000 100000\r\n1 100000\r\n50000 30000",
        "output": "0"
      },
      {
        "input": "3 75\r\n250 500 1000\r\n2 4 8\r\n25 25 25",
        "output": "1200"
      },
      {
        "input": "3 30\r\n100 100 100000\r\n1 1 100\r\n15 15 30",
        "output": "97000"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13448",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor num in sorted(arr):\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\narr.sort()\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sort() 메서드로 정렬",
            "description": "arr.sort()로 리스트를 제자리에서 정렬합니다.",
            "code_pattern": "arr.sort()",
            "socratic_hint": "리스트를 제자리에서 정렬하는 메서드는?",
            "hint": ".sort() 메서드를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문을 사용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor i in range(n-1):\n    for j in range(n-1-i):\n        if arr[j] > arr[j+1]:\n            arr[j], arr[j+1] = arr[j+1], arr[j]\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 패스 횟수 제어",
            "description": "n-1번 반복하며 각 패스를 수행합니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "버블 정렬에서 몇 번의 패스가 필요한가요?",
            "hint": "n-1번의 패스가 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "내부 반복문: 인접 원소 비교",
            "description": "각 패스에서 인접한 두 원소를 비교합니다. 이미 정렬된 뒤쪽 부분은 제외합니다.",
            "code_pattern": "for j in range(n-1-i):",
            "socratic_hint": "각 패스에서 비교해야 할 원소의 범위는?",
            "hint": "n-1-i까지 비교합니다 (이미 정렬된 부분 제외)."
          },
          {
            "step_id": 4,
            "goal": "원소 교환",
            "description": "왼쪽 원소가 오른쪽 원소보다 크면 위치를 교환합니다.",
            "code_pattern": "if arr[j] > arr[j+1]:\n    arr[j], arr[j+1] = arr[j+1], arr[j]",
            "socratic_hint": "인접한 두 원소의 순서가 잘못되었을 때 어떻게 하나요?",
            "hint": "두 원소의 위치를 swap합니다."
          },
          {
            "step_id": 5,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      },
      {
        "solution_id": 5,
        "solution_name": "풀이 5",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor i in range(n-1):\n    min_idx = i\n    for j in range(i+1, n):\n        if arr[j] < arr[min_idx]:\n            min_idx = j\n    arr[i], arr[min_idx] = arr[min_idx], arr[i]\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 정렬할 위치 선택",
            "description": "n-1번 반복하며 각 위치에 올 최솟값을 찾습니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "선택 정렬에서 몇 번의 선택이 필요한가요?",
            "hint": "n-1번의 선택이 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "최솟값 인덱스 초기화",
            "description": "현재 위치를 최솟값 인덱스로 가정합니다.",
            "code_pattern": "min_idx = i",
            "socratic_hint": "최솟값을 찾기 위한 초기값은?",
            "hint": "현재 위치 i를 초기값으로 설정합니다."
          },
          {
            "step_id": 4,
            "goal": "내부 반복문: 최솟값 찾기",
            "description": "현재 위치 이후의 원소들 중 최솟값의 인덱스를 찾습니다.",
            "code_pattern": "for j in range(i+1, n):\n    if arr[j] < arr[min_idx]:\n        min_idx = j",
            "socratic_hint": "정렬되지 않은 부분에서 최솟값을 어떻게 찾나요?",
            "hint": "i+1부터 끝까지 순회하며 최솟값 인덱스를 업데이트합니다."
          },
          {
            "step_id": 5,
            "goal": "원소 교환",
            "description": "찾은 최솟값을 현재 위치로 이동시킵니다.",
            "code_pattern": "arr[i], arr[min_idx] = arr[min_idx], arr[i]",
            "socratic_hint": "최솟값을 현재 위치로 가져오려면?",
            "hint": "현재 위치의 값과 최솟값을 swap합니다."
          },
          {
            "step_id": 6,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13505",
    "step_title": "문자열 알고리즘 1",
    "title": "두 수 XOR",
    "level": 18,
    "tags": [
      "자료 구조",
      "트리",
      "트라이"
    ],
    "description": "N개의 수가 주어졌을 때, XOR한 값이 가장 큰 두 수를 찾는 프로그램을 작성하시오.즉, A1, A2, ..., AN중에서 i ≠ j이면서 AiXOR Aj가 가장 큰 것을 찾아야 한다.",
    "input_description": "첫째 줄에 N (2 ≤ N ≤ 100,000)이 주어진다.둘째 줄에는 N개의 수가 주어진다. 입력으로 주어지는 수는 1,000,000,000보다 작거나 같은 음이 아닌 정수이다.",
    "output_description": "첫째 줄에 XOR한 값이 가장 큰 두 수의 XOR한 결과를 출력한다.",
    "examples": [
      {
        "input": "5\r\n1 2 3 4 5",
        "output": "7"
      },
      {
        "input": "5\r\n0 1 0 1 0",
        "output": "1"
      },
      {
        "input": "6\r\n1 2 4 8 16 32",
        "output": "48"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13505",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 그래프 문제 기본 구조\nfrom collections import deque\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\n# BFS/DFS 구현\nvisited = [False] * (N + 1)\n\ndef bfs(start):\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        node = queue.popleft()\n        for next_node in graph[node]:\n            if not visited[next_node]:\n                visited[next_node] = True\n                queue.append(next_node)\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13510",
    "step_title": "트리와 쿼리",
    "title": "트리와 쿼리 1",
    "level": 20,
    "tags": [
      "자료 구조",
      "트리",
      "세그먼트 트리",
      "Heavy-light 분할"
    ],
    "description": "N개의 정점으로 이루어진 트리(무방향 사이클이 없는 연결 그래프)가 있다. 정점은 1번부터 N번까지 번호가 매겨져 있고, 간선은 1번부터 N-1번까지 번호가 매겨져 있다.아래의 두 쿼리를 수행하는 프로그램을 작성하시오.1 i c: i번 간선의 비용을 c로 바꾼다.2 u v: u에서 v로 가는 단순 경로에 존재하는 비용 중에서 가장 큰 것을 출력한다.",
    "input_description": "첫째 줄에 N (2 ≤ N ≤ 100,000)이 주어진다.둘째 줄부터 N-1개의 줄에는 i번 간선이 연결하는 두 정점 번호 u와 v와 비용 w가 주어진다.다음 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.다음 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.간선의 비용은 항상 1,000,000보다 작거나 같은 자연수이다.",
    "output_description": "각각의 2번 쿼리의 결과를 순서대로 한 줄에 하나씩 출력한다.",
    "examples": [
      {
        "input": "3\n1 2 1\n2 3 2\n3\n2 1 2\n1 1 3\n2 1 2",
        "output": "1\n3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13510",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 그래프 문제 기본 구조\nfrom collections import deque\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\n# BFS/DFS 구현\nvisited = [False] * (N + 1)\n\ndef bfs(start):\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        node = queue.popleft()\n        for next_node in graph[node]:\n            if not visited[next_node]:\n                visited[next_node] = True\n                queue.append(next_node)\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13511",
    "step_title": "최소 공통 조상",
    "title": "트리와 쿼리 2",
    "level": 18,
    "tags": [
      "자료 구조",
      "트리",
      "최소 공통 조상",
      "희소 배열"
    ],
    "description": "N개의 정점으로 이루어진 트리(무방향 사이클이 없는 연결 그래프)가 있다. 정점은 1번부터 N번까지 번호가 매겨져 있고, 간선은 1번부터 N-1번까지 번호가 매겨져 있다.아래의 두 쿼리를 수행하는 프로그램을 작성하시오.1 u v: u에서 v로 가는 경로의 비용을 출력한다.2 u v k: u에서 v로 가는 경로에 존재하는 정점 중에서 k번째 정점을 출력한다. k는 u에서 v로 가는 경로에 포함된 정점의 수보다 작거나 같다.",
    "input_description": "첫째 줄에 N (2 ≤ N ≤ 100,000)이 주어진다.둘째 줄부터 N-1개의 줄에는 i번 간선이 연결하는 두 정점 번호 u와 v와 간선의 비용 w가 주어진다.다음 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.다음 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.간선의 비용은 항상 1,000,000보다 작거나 같은 자연수이다.",
    "output_description": "각각의 쿼리의 결과를 순서대로 한 줄에 하나씩 출력한다.",
    "examples": [
      {
        "input": "6\r\n1 2 1\r\n2 4 1\r\n2 5 2\r\n1 3 1\r\n3 6 2\r\n2\r\n1 4 6\r\n2 4 6 4",
        "output": "5\r\n3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13511",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nfrom math import log2\ninput = sys.stdin.readline\n\nN = int(input())\nMAX_LOG = int(log2(N)) + 1\n\ntree = [[] for _ in range(N + 1)]\ndepth = [0] * (N + 1)\nparent = [[0] * MAX_LOG for _ in range(N + 1)]\n\nfor _ in range(N - 1):\n    a, b = map(int, input().split())\n    tree[a].append(b)\n    tree[b].append(a)\n\ndef dfs(node, par, d):\n    depth[node] = d\n    parent[node][0] = par\n    \n    for next_node in tree[node]:\n        if next_node != par:\n            dfs(next_node, node, d + 1)\n\ndfs(1, 0, 0)\n\nfor j in range(1, MAX_LOG):\n    for i in range(1, N + 1):\n        parent[i][j] = parent[parent[i][j-1]][j-1]\n\ndef lca(a, b):\n    if depth[a] < depth[b]:\n        a, b = b, a\n    \n    diff = depth[a] - depth[b]\n    for i in range(MAX_LOG):\n        if diff & (1 << i):\n            a = parent[a][i]\n    \n    if a == b:\n        return a\n    \n    for i in range(MAX_LOG - 1, -1, -1):\n        if parent[a][i] != parent[b][i]:\n            a = parent[a][i]\n            b = parent[b][i]\n    \n    return parent[a][0]\n\nM = int(input())\nfor _ in range(M):\n    a, b = map(int, input().split())\n    print(lca(a, b))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13513",
    "step_title": "트리와 쿼리",
    "title": "트리와 쿼리 4",
    "level": 23,
    "tags": [
      "자료 구조",
      "트리",
      "집합과 맵",
      "트리를 사용한 집합과 맵",
      "분할 정복",
      "centroid",
      "센트로이드 분할"
    ],
    "description": "N개의 정점으로 이루어진 트리(무방향 사이클이 없는 연결 그래프)가 있다. 정점은 1번부터 N번까지 번호가 매겨져 있고, 간선은 1번부터 N-1번까지 번호가 매겨져 있다. 가장 처음에 모든 정점의 색은 흰색이다.아래의 두 쿼리를 수행하는 프로그램을 작성하시오.1 i: i번 정점의 색을 바꾼다. (흰색 -> 검정색, 검정색 -> 흰색)2: 모든 흰색 정점 a와 b에 대해서, 가장 먼 거리를 출력한다. 이때, a와 b는 같아도 된다. 만약, 흰색 정점이 없다면 -1을 출력한다.",
    "input_description": "첫째 줄에 N (2 ≤ N ≤ 100,000)이 주어진다.둘째 줄부터 N-1개의 줄에는 i번 간선이 연결하는 두 정점 번호 u와 v와 간선의 거리 w가 주어진다.다음 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.다음 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.간선의 거리는 항상 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.",
    "output_description": "각각의 2번 쿼리의 결과를 순서대로 한 줄에 하나씩 출력한다.",
    "examples": [
      {
        "input": "3\r\n1 2 1\r\n1 3 1\r\n7\r\n2\r\n1 1\r\n2\r\n1 2\r\n2\r\n1 3\r\n2",
        "output": "2\r\n2\r\n0\r\n-1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13513",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 그래프 문제 기본 구조\nfrom collections import deque\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\n# BFS/DFS 구현\nvisited = [False] * (N + 1)\n\ndef bfs(start):\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        node = queue.popleft()\n        for next_node in graph[node]:\n            if not visited[next_node]:\n                visited[next_node] = True\n                queue.append(next_node)\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13514",
    "step_title": "트리와 쿼리",
    "title": "트리와 쿼리 5",
    "level": 22,
    "tags": [
      "자료 구조",
      "트리",
      "집합과 맵",
      "트리를 사용한 집합과 맵",
      "우선순위 큐",
      "분할 정복",
      "centroid",
      "센트로이드 분할"
    ],
    "description": "N개의 정점으로 이루어진 트리(무방향 사이클이 없는 연결 그래프)가 있다. 정점은 1번부터 N번까지 번호가 매겨져 있고, 간선은 1번부터 N-1번까지 번호가 매겨져 있다. 가장 처음에 모든 정점의 색은 검정색이다.아래의 두 쿼리를 수행하는 프로그램을 작성하시오.1 i: i번 정점의 색을 바꾼다. (흰색 -> 검정색, 검정색 -> 흰색)2 v: 모든 흰색 정점 u와 v까지의 거리 중에서 가장 가까운 거리를 출력한다. 이때, u와 v는 같아도 된다. v가 흰색이면 정답은 0이다. 트리에 흰색 정점이 없으면 -1을 출력한다.",
    "input_description": "첫째 줄에 N (2 ≤ N ≤ 100,000)이 주어진다.둘째 줄부터 N-1개의 줄에는 i번 간선이 연결하는 두 정점 번호 u와 v가 주어진다.다음 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.다음 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.",
    "output_description": "각각의 2번 쿼리의 결과를 순서대로 한 줄에 하나씩 출력한다.",
    "examples": [
      {
        "input": "10\r\n1 2\r\n1 3\r\n2 4\r\n1 5\r\n1 6\r\n4 7\r\n7 8\r\n5 9\r\n1 10\r\n10\r\n1 6\r\n1 6\r\n1 6\r\n2 3\r\n1 1\r\n1 1\r\n2 3\r\n2 10\r\n2 4\r\n2 6",
        "output": "2\r\n2\r\n2\r\n3\r\n0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13514",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 그래프 문제 기본 구조\nfrom collections import deque\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\n# BFS/DFS 구현\nvisited = [False] * (N + 1)\n\ndef bfs(start):\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        node = queue.popleft()\n        for next_node in graph[node]:\n            if not visited[next_node]:\n                visited[next_node] = True\n                queue.append(next_node)\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13517",
    "step_title": "세그먼트 트리 3",
    "title": "트리와 쿼리 8",
    "level": 22,
    "tags": [
      "자료 구조",
      "트리",
      "세그먼트 트리",
      "최소 공통 조상",
      "퍼시스턴트 세그먼트 트리"
    ],
    "description": "N개의 정점으로 이루어진 트리(무방향 사이클이 없는 연결 그래프)가 있다. 정점은 1번부터 N번까지 번호가 매겨져 있고, 간선은 1번부터 N-1번까지 번호가 매겨져 있다. 정점은 가중치를 가지고 있다.아래의 쿼리를 수행하는 프로그램을 작성하시오.u v k: u에서 v로 가는 경로에 존재하는 정점의 가중치 중에서 k번째 작은 가중치를 출력한다.",
    "input_description": "첫째 줄에 N (2 ≤ N ≤ 100,000)이 주어진다.둘째 줄에는 정점의 가중치가 1번 정점부터 순서대로 주어진다.셋째 줄부터 N-1개의 줄에는 i번 간선이 연결하는 두 정점 번호 u와 v가 주어진다.다음 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.다음 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.정점의 가중치는 항상 1,000,000보다 작거나 같은 자연수이다.",
    "output_description": "각각의 쿼리의 결과를 순서대로 한 줄에 하나씩 출력한다.",
    "examples": [
      {
        "input": "8\r\n105 2 9 3 8 5 7 7\r\n1 2\r\n1 3\r\n1 4\r\n3 5\r\n3 6\r\n3 7\r\n4 8\r\n5\r\n2 5 1\r\n2 5 2\r\n2 5 3\r\n2 5 4\r\n7 8 2",
        "output": "2\r\n8\r\n9\r\n105\r\n7"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13517",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 그래프 문제 기본 구조\nfrom collections import deque\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\n# BFS/DFS 구현\nvisited = [False] * (N + 1)\n\ndef bfs(start):\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        node = queue.popleft()\n        for next_node in graph[node]:\n            if not visited[next_node]:\n                visited[next_node] = True\n                queue.append(next_node)\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13519",
    "step_title": "트리와 쿼리",
    "title": "트리와 쿼리 10",
    "level": 23,
    "tags": [
      "자료 구조",
      "트리",
      "세그먼트 트리",
      "느리게 갱신되는 세그먼트 트리",
      "Heavy-light 분할",
      "최대 부분 배열 문제"
    ],
    "description": "N개의 정점으로 이루어진 트리(무방향 사이클이 없는 연결 그래프)가 있다. 정점은 1번부터 N번까지 번호가 매겨져 있고, 간선은 1번부터 N-1번까지 번호가 매겨져 있다. 정점은 가중치를 가지고 있다.아래의 두 쿼리를 수행하는 프로그램을 작성하시오.1 u v: u에서 v로 가는 경로에서 최대 연속합(비어있을 수도 있기 때문에 정답은 0보다 크거나 같다)을 구해 출력한다.2 u v w: u에서 v로 가는 경로 상에 있는 모든 정점의 가중치를 w로 바꾼다.",
    "input_description": "첫째 줄에 N (2 ≤ N ≤ 100,000)이 주어진다.둘째 줄에는 정점의 가중치가 1번 정점부터 순서대로 주어진다.셋째 줄부터 N-1개의 줄에는 i번 간선이 연결하는 두 정점 번호 u와 v가 주어진다.다음 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.다음 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.정점의 가중치는 절댓값이 10,000보다 작거나 같은 정수이다.",
    "output_description": "각각의 쿼리의 결과를 순서대로 한 줄에 하나씩 출력한다.",
    "examples": [
      {
        "input": "5\r\n-3 -2 1 2 3\r\n1 2\r\n2 3\r\n1 4\r\n4 5\r\n3\r\n1 2 5\r\n2 3 4 2\r\n1 2 5",
        "output": "5\r\n9"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13519",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 그래프 문제 기본 구조\nfrom collections import deque\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\n# BFS/DFS 구현\nvisited = [False] * (N + 1)\n\ndef bfs(start):\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        node = queue.popleft()\n        for next_node in graph[node]:\n            if not visited[next_node]:\n                visited[next_node] = True\n                queue.append(next_node)\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13544",
    "step_title": "세그먼트 트리 2",
    "title": "수열과 쿼리 3",
    "level": 18,
    "tags": [
      "자료 구조",
      "정렬",
      "세그먼트 트리",
      "머지 소트 트리"
    ],
    "description": "길이가 N인 수열 A1, A2, ..., AN이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.i j k: Ai, Ai+1, ..., Aj로 이루어진 부분 수열 중에서 k보다 큰 원소의 개수를 출력한다.",
    "input_description": "첫째 줄에 수열의 크기 N (1 ≤ N ≤ 100,000)이 주어진다.둘째 줄에는 A1, A2, ..., AN이 주어진다. (1 ≤ Ai≤ 109)셋째 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.넷째 줄부터 M개의 줄에는 a, b, c가 주어진다. a, b, c를 이용해 쿼리를 만들어야 한다.i = a xor last_ansj = b xor last_ansk = c xor last_anslast_ans는 이전 쿼리의 정답이며, 가장 처음에는 0이다. xor한 결과는 1 ≤ i ≤ j ≤ n, 1 ≤ k ≤ 109을 만족한다.",
    "output_description": "각각의 쿼리마다 정답을 한 줄에 하나씩 출력한다.",
    "examples": [
      {
        "input": "5\n5 1 2 3 4\n3\n2 4 1\n6 6 6\n1 5 2",
        "output": "2\n0\n3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13544",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor num in sorted(arr):\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\narr.sort()\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sort() 메서드로 정렬",
            "description": "arr.sort()로 리스트를 제자리에서 정렬합니다.",
            "code_pattern": "arr.sort()",
            "socratic_hint": "리스트를 제자리에서 정렬하는 메서드는?",
            "hint": ".sort() 메서드를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문을 사용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor i in range(n-1):\n    for j in range(n-1-i):\n        if arr[j] > arr[j+1]:\n            arr[j], arr[j+1] = arr[j+1], arr[j]\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 패스 횟수 제어",
            "description": "n-1번 반복하며 각 패스를 수행합니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "버블 정렬에서 몇 번의 패스가 필요한가요?",
            "hint": "n-1번의 패스가 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "내부 반복문: 인접 원소 비교",
            "description": "각 패스에서 인접한 두 원소를 비교합니다. 이미 정렬된 뒤쪽 부분은 제외합니다.",
            "code_pattern": "for j in range(n-1-i):",
            "socratic_hint": "각 패스에서 비교해야 할 원소의 범위는?",
            "hint": "n-1-i까지 비교합니다 (이미 정렬된 부분 제외)."
          },
          {
            "step_id": 4,
            "goal": "원소 교환",
            "description": "왼쪽 원소가 오른쪽 원소보다 크면 위치를 교환합니다.",
            "code_pattern": "if arr[j] > arr[j+1]:\n    arr[j], arr[j+1] = arr[j+1], arr[j]",
            "socratic_hint": "인접한 두 원소의 순서가 잘못되었을 때 어떻게 하나요?",
            "hint": "두 원소의 위치를 swap합니다."
          },
          {
            "step_id": 5,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      },
      {
        "solution_id": 5,
        "solution_name": "풀이 5",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor i in range(n-1):\n    min_idx = i\n    for j in range(i+1, n):\n        if arr[j] < arr[min_idx]:\n            min_idx = j\n    arr[i], arr[min_idx] = arr[min_idx], arr[i]\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 정렬할 위치 선택",
            "description": "n-1번 반복하며 각 위치에 올 최솟값을 찾습니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "선택 정렬에서 몇 번의 선택이 필요한가요?",
            "hint": "n-1번의 선택이 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "최솟값 인덱스 초기화",
            "description": "현재 위치를 최솟값 인덱스로 가정합니다.",
            "code_pattern": "min_idx = i",
            "socratic_hint": "최솟값을 찾기 위한 초기값은?",
            "hint": "현재 위치 i를 초기값으로 설정합니다."
          },
          {
            "step_id": 4,
            "goal": "내부 반복문: 최솟값 찾기",
            "description": "현재 위치 이후의 원소들 중 최솟값의 인덱스를 찾습니다.",
            "code_pattern": "for j in range(i+1, n):\n    if arr[j] < arr[min_idx]:\n        min_idx = j",
            "socratic_hint": "정렬되지 않은 부분에서 최솟값을 어떻게 찾나요?",
            "hint": "i+1부터 끝까지 순회하며 최솟값 인덱스를 업데이트합니다."
          },
          {
            "step_id": 5,
            "goal": "원소 교환",
            "description": "찾은 최솟값을 현재 위치로 이동시킵니다.",
            "code_pattern": "arr[i], arr[min_idx] = arr[min_idx], arr[i]",
            "socratic_hint": "최솟값을 현재 위치로 가져오려면?",
            "hint": "현재 위치의 값과 최솟값을 swap합니다."
          },
          {
            "step_id": 6,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13546",
    "step_title": "평방 분할",
    "title": "수열과 쿼리 4",
    "level": 22,
    "tags": [
      "오프라인 쿼리",
      "제곱근 분할법",
      "mo's"
    ],
    "description": "1보다 크거나 같고, K보다 작거나 같은 수로 이루어져 있는 길이가 N인 수열 A1, A2, ..., AN이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.l r: max{|x − y| : l ≤ x, y ≤ r and Ax= Ay} 을 출력한다.",
    "input_description": "첫째 줄에 수열의 크기 N (1 ≤ N ≤ 100,000), K (1 ≤ K ≤ 100,000)가 주어진다.둘째 줄에는 A1, A2, ..., AN이 주어진다. (1 ≤ Ai≤ K)셋째 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.넷째 줄부터 M개의 줄에는 쿼리 l, r가 한 줄에 하나씩 주어진다. (1 ≤ l ≤ r ≤ n)",
    "output_description": "각각의 쿼리마다 정답을 한 줄에 하나씩 출력한다.",
    "examples": [
      {
        "input": "7 7\n4 5 6 6 5 7 4\n5\n6 6\n5 6\n3 5\n3 7\n1 7",
        "output": "0\n0\n1\n1\n6"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13546",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13547",
    "step_title": "평방 분할",
    "title": "수열과 쿼리 5",
    "level": 19,
    "tags": [
      "오프라인 쿼리",
      "mo's"
    ],
    "description": "길이가 N인 수열 A1, A2, ..., AN이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.i j: Ai, Ai+1, ..., Aj에 존재하는 서로 다른 수의 개수를 출력한다.",
    "input_description": "첫째 줄에 수열의 크기 N (1 ≤ N ≤ 100,000)이 주어진다.둘째 줄에는 A1, A2, ..., AN이 주어진다. (1 ≤ Ai≤ 1,000,000)셋째 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.넷째 줄부터 M개의 줄에는 쿼리 i, j가 한 줄에 하나씩 주어진다. (1 ≤ i ≤ j ≤ N)",
    "output_description": "각각의 쿼리마다 정답을 한 줄에 하나씩 출력한다.",
    "examples": [
      {
        "input": "5\r\n1 1 2 1 3\r\n3\r\n1 5\r\n2 4\r\n3 5",
        "output": "3\r\n2\r\n3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13547",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13548",
    "step_title": "평방 분할",
    "title": "수열과 쿼리 6",
    "level": 20,
    "tags": [
      "오프라인 쿼리",
      "mo's"
    ],
    "description": "길이가 N인 수열 A1, A2, ..., AN이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.i j: Ai, Ai+1, ..., Aj에 가장 많이 등장하는 수가 몇 번 등장했는지 출력한다.",
    "input_description": "첫째 줄에 수열의 크기 N (1 ≤ N ≤ 100,000)이 주어진다.둘째 줄에는 A1, A2, ..., AN이 주어진다. (1 ≤ Ai≤ 100,000)셋째 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.넷째 줄부터 M개의 줄에는 쿼리 i, j가 한 줄에 하나씩 주어진다. (1 ≤ i ≤ j ≤ n)",
    "output_description": "각각의 쿼리마다 정답을 한 줄에 하나씩 출력한다.",
    "examples": [
      {
        "input": "5\r\n1 2 1 3 3\r\n3\r\n1 3\r\n2 3\r\n1 5",
        "output": "2\r\n1\r\n2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13548",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13549",
    "step_title": "최단 경로",
    "title": "숨바꼭질 3",
    "level": 11,
    "tags": [
      "그래프 이론",
      "그래프 탐색",
      "너비 우선 탐색",
      "최단 경로",
      "데이크스트라",
      "0-1 너비 우선 탐색"
    ],
    "description": "수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 0초 후에 2*X의 위치로 이동하게 된다.수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.",
    "input_description": "첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.",
    "output_description": "수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.",
    "examples": [
      {
        "input": "5 17",
        "output": "2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13549",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import heapq\n\nN, K = map(int, input().split())\n\nif N == K:\n    print(0)\nelse:\n    dist = [float('inf')] * 100001\n    dist[N] = 0\n    heap = [(0, N)]\n    \n    while heap:\n        time, pos = heapq.heappop(heap)\n        \n        if pos == K:\n            print(time)\n            break\n        \n        if time > dist[pos]:\n            continue\n        \n        # 순간이동 (시간 0)\n        if pos * 2 <= 100000 and dist[pos] < dist[pos * 2]:\n            dist[pos * 2] = dist[pos]\n            heapq.heappush(heap, (dist[pos * 2], pos * 2))\n        \n        # 걷기 (시간 1)\n        for next_pos in [pos - 1, pos + 1]:\n            if 0 <= next_pos <= 100000 and dist[pos] + 1 < dist[next_pos]:\n                dist[next_pos] = dist[pos] + 1\n                heapq.heappush(heap, (dist[next_pos], next_pos))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13713",
    "step_title": "문자열 알고리즘 2",
    "title": "문자열과 쿼리",
    "level": 16,
    "tags": [
      "문자열",
      "z"
    ],
    "description": "문자열 S = S1S2...SN이 주어진다. 함수 F(i)는 S와 S1S2...Si의 가장 긴 공통 접미사의 길이로 정의된다.예를 들어, S = \"zaaxbaacbaa\"인 경우에, F(1) = 0, F(2) = 1, F(3) = 2이다.문자열 S와 쿼리 M개가 주어졌을 때, 각각의 쿼리에 대해서, F(i)를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 문자열 S가 주어진다. (1 ≤ N ≤ 1,000,000)둘째 줄에 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 100,000)셋째 줄부터 M개의 줄에 각각의 쿼리 i가 주어진다. (1 ≤ i ≤ n)",
    "output_description": "각각의 쿼리 i에 대해서, F(i)를 출력한다.",
    "examples": [
      {
        "input": "zaaxbaacbaa\n11\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11",
        "output": "0\n1\n2\n0\n0\n1\n3\n0\n0\n1\n11"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13713",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13725",
    "step_title": "동적 계획법 최적화 2",
    "title": "RNG",
    "level": 24,
    "tags": [
      "수학",
      "고속 푸리에 변환",
      "다항식을 이용한 선형점화식 계산"
    ],
    "description": "로또를 좋아하는 cubelover는 로또 자동 제출 프로그램에 사용할 랜덤 숫자 생성기(RNG)를 만들기로 했다.cubelover의 RNG는 아래와 같은 형태의 선형 재귀식으로 나타낼 수 있다.Ai= (Ai−1× C1+ Ai−2× C2+ ... + Ai−k× Ck) mod 104857601, (i > k)N과 A1, A2, ..., Ak, 그리고 C1, C2, ..., Ck가 주어졌을 때, AN을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 k와 N (1 ≤ k ≤ 30,000, 1 ≤ N ≤ 1018)이 주어진다.둘째 줄에는 A1, A2, ..., Ak가 셋째 줄에는 C1, C2, ..., Ck가 주어진다. (0 ≤ Ai, Ci< 104857601)",
    "output_description": "첫째 줄에 AN을 출력한다.",
    "examples": [
      {
        "input": "3 5\r\n1 2 3\r\n4 5 6",
        "output": "139"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13725",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 수학 문제 기본 구조\ndef solve():\n    # 입력 처리\n    N = int(input())\n    \n    # 계산\n    result = N\n    \n    return result\n\nprint(solve())",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13909",
    "step_title": "약수, 배수와 소수 2",
    "title": "창문 닫기",
    "level": 6,
    "tags": [
      "수학",
      "정수론"
    ],
    "description": "서강대학교 컴퓨터공학과 실습실 R912호에는 현재 N개의 창문이 있고 또 N명의 사람이 있다. 1번째 사람은 1의 배수 번째 창문을 열려 있으면 닫고 닫혀 있으면 연다.  2번째 사람은 2의 배수 번째 창문을 열려 있으면 닫고 닫혀 있으면 연다. 이러한 행동을 N번째 사람까지 진행한 후 열려 있는 창문의 개수를 구하라. 단, 처음에 모든 창문은 닫혀 있다.예를 들어 현재 3개의 창문이 있고 3명의 사람이 있을 때,1번째 사람은 1의 배수인 1,2,3번 창문을 연다. (1, 1, 1)2번째 사람은 2의 배수인 2번 창문을 닫는다. (1, 0, 1)3번째 사람은 3의 배수인 3번 창문을 닫는다. (1, 0, 0)결과적으로 마지막에 열려 있는 창문의 개수는 1개 이다.",
    "input_description": "첫 번째 줄에는 창문의 개수와 사람의 수 N(1 ≤ N ≤ 2,100,000,000)이 주어진다.",
    "output_description": "마지막에 열려 있는 창문의 개수를 출력한다.",
    "examples": [
      {
        "input": "3",
        "output": "1"
      },
      {
        "input": "24",
        "output": "4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13909",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nprint(int(N**0.5))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13913",
    "step_title": "동적 계획법과 최단거리 역추적",
    "title": "숨바꼭질 4",
    "level": 12,
    "tags": [
      "그래프 이론",
      "그래프 탐색",
      "너비 우선 탐색",
      "역추적"
    ],
    "description": "수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.",
    "input_description": "첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.",
    "output_description": "첫째 줄에 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.둘째 줄에 어떻게 이동해야 하는지 공백으로 구분해 출력한다.",
    "examples": [
      {
        "input": "5 17",
        "output": "4\r\n5 10 9 18 17"
      },
      {
        "input": "5 17",
        "output": "4\r\n5 4 8 16 17"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13913",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import deque\n\nN, K = map(int, input().split())\n\nif N == K:\n    print(0)\n    print(N)\nelse:\n    visited = [-1] * 100001\n    queue = deque([N])\n    visited[N] = N\n    \n    while queue:\n        pos = queue.popleft()\n        \n        if pos == K:\n            path = []\n            curr = K\n            while curr != N:\n                path.append(curr)\n                curr = visited[curr]\n            path.append(N)\n            path.reverse()\n            \n            print(len(path) - 1)\n            print(' '.join(map(str, path)))\n            break\n        \n        for next_pos in [pos - 1, pos + 1, pos * 2]:\n            if 0 <= next_pos <= 100000 and visited[next_pos] == -1:\n                visited[next_pos] = pos\n                queue.append(next_pos)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13925",
    "step_title": "세그먼트 트리 3",
    "title": "수열과 쿼리 13",
    "level": 21,
    "tags": [
      "자료 구조",
      "세그먼트 트리",
      "느리게 갱신되는 세그먼트 트리"
    ],
    "description": "길이가 N인 수열 A1, A2, ..., AN이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.1 x y v: Ai= (Ai+ v) % MOD를 수행한다. (x ≤ i ≤ y)2 x y v: Ai= (Ai× v) % MOD를 수행한다. (x ≤ i ≤ y)3 x y v: Ai= v를 수행한다. (x ≤ i ≤ y)4 x y: (ΣAi) % MOD를 출력한다. (x ≤ i ≤ y)여기서 MOD는 항상 109+7이며, %는 나머지 연산을 의미한다.",
    "input_description": "첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 100,000)둘째 줄에는 A1, A2, ..., AN이 주어진다. (1 ≤ Ai≤ 109)셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 100,000)넷째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. (1 ≤ x ≤ y ≤ N, 1 ≤ v ≤ 109)",
    "output_description": "4번 쿼리에 대해서 정답을 한 줄에 하나씩 순서대로 출력한다.",
    "examples": [
      {
        "input": "4\r\n1 2 3 4\r\n4\r\n4 1 4\r\n1 1 3 10\r\n2 2 4 2\r\n4 1 4",
        "output": "10\r\n69"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13925",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13974",
    "step_title": "동적 계획법 최적화 1",
    "title": "파일 합치기 2",
    "level": 19,
    "tags": [
      "다이나믹 프로그래밍",
      "크누스 최적화"
    ],
    "description": "소설가인 김대전은 소설을 여러 장(chapter)으로 나누어 쓰는데, 각 장은 각각 다른 파일에 저장하곤 한다. 소설의 모든 장을 쓰고 나서는 각 장이 쓰여진 파일을 합쳐서 최종적으로 소설의 완성본이 들어있는 한 개의 파일을 만든다. 이 과정에서 두 개의 파일을 합쳐서 하나의 임시파일을 만들고, 이 임시파일이나 원래의 파일을 계속 두 개씩 합쳐서 소설의 여러 장들이 연속이 되도록 파일을 합쳐나가고, 최종적으로는 하나의 파일로 합친다. 두 개의 파일을 합칠 때 필요한 비용(시간 등)이 두 파일 크기의 합이라고 가정할 때, 최종적인 한 개의 파일을 완성하는데 필요한 비용의 총 합을 계산하시오.예를 들어, C1, C2, C3, C4가 연속적인 네 개의 장을 수록하고 있는 파일이고, 파일 크기가 각각 40, 30, 30, 50 이라고 하자. 이 파일들을 합치는 과정에서, 먼저 C2와 C3를 합쳐서 임시파일 X1을 만든다. 이때 비용 60이 필요하다. 그 다음으로 C1과 X1을 합쳐 임시파일 X2를 만들면 비용 100이 필요하다. 최종적으로 X2와 C4를 합쳐 최종파일을 만들면 비용 150이 필요하다. 따라서, 최종의 한 파일을 만드는데 필요한 비용의 합은 60+100+150=310 이다. 다른 방법으로 파일을 합치면 비용을 줄일 수 있다. 먼저 C1과 C2를 합쳐 임시파일 Y1을 만들고, C3와 C4를 합쳐 임시파일 Y2를 만들고, 최종적으로 Y1과 Y2를 합쳐 최종파일을 만들 수 있다. 이때 필요한 총 비용은 70+80+150=300 이다.소설의 각 장들이 수록되어 있는 파일의 크기가 주어졌을 때, 이 파일들을 하나의 파일로 합칠 때 필요한 최소비용을 계산하는 프로그램을 작성하시오.",
    "input_description": "프로그램은 표준 입력에서 입력 데이터를 받는다. 프로그램의 입력은 T개의 테스트 데이터로 이루어져 있는데, T는 입력의 맨 첫 줄에 주어진다.각 테스트 데이터는 두 개의 행으로 주어지는데, 첫 행에는 소설을 구성하는 장의 수를 나타내는 양의 정수 K (3 ≤ K ≤ 5,000)가 주어진다. 두 번째 행에는 1장부터 K장까지 수록한 파일의 크기를 나타내는 양의 정수 K개가 주어진다. 파일의 크기는 10,000을 초과하지 않는다.",
    "output_description": "프로그램은 표준 출력에 출력한다. 각 테스트 데이터마다 정확히 한 행에 출력하는데, 모든 장을 합치는데 필요한 최소비용을 출력한다.",
    "examples": [
      {
        "input": "2\r\n4\r\n40 30 30 50\r\n15\r\n1 21 3 4 5 35 5 4 3 5 98 21 14 17 32",
        "output": "300\r\n864"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13974",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13975",
    "step_title": "그리디 알고리즘 2",
    "title": "파일 합치기 3",
    "level": 12,
    "tags": [
      "자료 구조",
      "그리디 알고리즘",
      "우선순위 큐"
    ],
    "description": "소설가인 김대전은 소설을 여러 장(chapter)으로 나누어 쓰는데, 각 장은 각각 다른 파일에 저장하곤 한다. 소설의 모든 장을 쓰고 나서는 각 장이 쓰여진 파일을 합쳐서 최종적으로 소설의 완성본이 들어있는 한 개의 파일을 만든다. 이 과정에서 두 개의 파일을 합쳐서 하나의 임시파일을 만들고, 이 임시파일이나 원래의 파일을 계속 두 개씩 합쳐서 파일을 합쳐나가고, 최종적으로는 하나의 파일로 합친다. 두 개의 파일을 합칠 때 필요한 비용(시간 등)이 두 파일 크기의 합이라고 가정할 때, 최종적인 한 개의 파일을 완성하는데 필요한 비용의 총 합을 계산하시오.예를 들어, C1, C2, C3, C4가 네 개의 장을 수록하고 있는 파일이고, 파일 크기가 각각 40, 30, 30, 50 이라고 하자. 이 파일들을 합치는 과정에서, 먼저 C2와 C3를 합쳐서 임시파일 X1을 만든다. 이때 비용 60이 필요하다. 그 다음으로 C1과 X1을 합쳐 임시파일 X2를 만들면 비용 100이 필요하다. 최종적으로 X2와 C4를 합쳐 최종파일을 만들면 비용 150이 필요하다. 따라서, 최종의 한 파일을 만드는데 필요한 비용의 합은 60+100+150=310 이다. 다른 방법으로 파일을 합치면 비용을 줄일 수 있다. 먼저 C1과 C2를 합쳐 임시파일 Y1을 만들고, C3와 C4를 합쳐 임시파일 Y2를 만들고, 최종적으로 Y1과 Y2를 합쳐 최종파일을 만들 수 있다. 이때 필요한 총 비용은 70+80+150=300 이다.소설의 각 장들이 수록되어 있는 파일의 크기가 주어졌을 때, 이 파일들을 하나의 파일로 합칠 때 필요한 최소비용을 계산하는 프로그램을 작성하시오.",
    "input_description": "프로그램은 표준 입력에서 입력 데이터를 받는다. 프로그램의 입력은 T개의 테스트 데이터로 이루어져 있는데, T는 입력의 맨 첫 줄에 주어진다.각 테스트 데이터는 두 개의 행으로 주어지는데, 첫 행에는 소설을 구성하는 장의 수를 나타내는 양의 정수 K (3 ≤ K ≤ 1,000,000)가 주어진다. 두 번째 행에는 1장부터 K장까지 수록한 파일의 크기를 나타내는 양의 정수 K개가 주어진다. 파일의 크기는 10,000을 초과하지 않는다.",
    "output_description": "프로그램은 표준 출력에 출력한다. 각 테스트 데이터마다 정확히 한 행에 출력하는데, 모든 장을 합치는데 필요한 최소비용을 출력한다.",
    "examples": [
      {
        "input": "2\r\n4\r\n40 30 30 50\r\n15\r\n1 21 3 4 5 35 5 4 3 5 98 21 14 17 32",
        "output": "300\r\n826"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13975",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import heapq\n\nT = int(input())\nfor _ in range(T):\n    K = int(input())\n    files = list(map(int, input().split()))\n    \n    heapq.heapify(files)\n    total = 0\n    \n    while len(files) > 1:\n        first = heapq.heappop(files)\n        second = heapq.heappop(files)\n        merged = first + second\n        total += merged\n        heapq.heappush(files, merged)\n    \n    print(total)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13976",
    "step_title": "동적 계획법 4",
    "title": "타일 채우기 2",
    "level": 16,
    "tags": [
      "수학",
      "다이나믹 프로그래밍",
      "분할 정복을 이용한 거듭제곱"
    ],
    "description": "3×N 크기의 벽을 2×1, 1×2 크기의 타일로 채우는 경우의 수를 구해보자.",
    "input_description": "첫째 줄에 N(1 ≤ N ≤ 1,000,000,000,000,000,000)이 주어진다.",
    "output_description": "첫째 줄에 경우의 수를 1,000,000,007로 나눈 나머지를 출력한다.",
    "examples": [
      {
        "input": "2",
        "output": "3"
      },
      {
        "input": "100",
        "output": "436252889"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13976",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "13977",
    "step_title": "수학 2",
    "title": "이항 계수와 쿼리",
    "level": 16,
    "tags": [
      "수학",
      "정수론",
      "조합론",
      "분할 정복을 이용한 거듭제곱",
      "모듈로 곱셈 역원",
      "페르마의 소정리"
    ],
    "description": "\\(M\\)개의 자연수 \\(N\\)과 정수 \\(K\\)가 주어졌을 때 이항 계수 \\(\\binom{N}{K}\\)를 1,000,000,007로 나눈 나머지를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 \\(M\\)이 주어진다. (1 ≤ \\(M\\) ≤ 100,000)둘째 줄부터 \\(M\\)개의 줄에 \\(N\\)과 \\(K\\)가 주어진다. (1 ≤ \\(N\\) ≤ 4,000,000, 0 ≤ \\(K\\) ≤ \\(N\\))",
    "output_description": "총 \\(M\\)개의 줄에 \\(\\binom{N}{K}\\)를 1,000,000,007로 나눈 나머지를 출력한다.",
    "examples": [
      {
        "input": "5\r\n5 2\r\n5 3\r\n10 5\r\n20 10\r\n10 0",
        "output": "10\r\n10\r\n252\r\n184756\r\n1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/13977",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "MOD = 1000000007\n\ndef pow_mod(a, b, mod):\n    result = 1\n    a %= mod\n    while b > 0:\n        if b % 2 == 1:\n            result = (result * a) % mod\n        a = (a * a) % mod\n        b //= 2\n    return result\n\ndef mod_inverse(a, mod):\n    return pow_mod(a, mod - 2, mod)\n\nMAX_N = 4000001\nfactorial = [1] * MAX_N\nfor i in range(1, MAX_N):\n    factorial[i] = (factorial[i-1] * i) % MOD\n\ndef comb(n, r):\n    if r > n or r < 0:\n        return 0\n    return (factorial[n] * mod_inverse(factorial[r], MOD) % MOD * \n            mod_inverse(factorial[n-r], MOD)) % MOD\n\nM = int(input())\nfor _ in range(M):\n    N, K = map(int, input().split())\n    print(comb(N, K))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "14002",
    "step_title": "동적 계획법과 최단거리 역추적",
    "title": "가장 긴 증가하는 부분 수열 4",
    "level": 12,
    "tags": [
      "다이나믹 프로그래밍",
      "역추적"
    ],
    "description": "수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10,20, 10,30, 20,50} 이고, 길이는 4이다.",
    "input_description": "첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai≤ 1,000)",
    "output_description": "첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.둘째 줄에는 가장 긴 증가하는 부분 수열을 출력한다. 그러한 수열이 여러가지인 경우 아무거나 출력한다.",
    "examples": [
      {
        "input": "6\r\n10 20 10 30 20 50",
        "output": "4\r\n10 20 30 50"
      }
    ],
    "url": "https://www.acmicpc.net/problem/14002",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nA = list(map(int, input().split()))\n\ndp = [1] * N\nprev = [-1] * N\n\nfor i in range(1, N):\n    for j in range(i):\n        if A[j] < A[i] and dp[j] + 1 > dp[i]:\n            dp[i] = dp[j] + 1\n            prev[i] = j\n\nmax_length = max(dp)\nmax_index = dp.index(max_length)\n\nresult = []\nidx = max_index\nwhile idx != -1:\n    result.append(A[idx])\n    idx = prev[idx]\n\nresult.reverse()\n\nprint(max_length)\nprint(' '.join(map(str, result)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "14003",
    "step_title": "동적 계획법과 최단거리 역추적",
    "title": "가장 긴 증가하는 부분 수열 5",
    "level": 16,
    "tags": [
      "이분 탐색",
      "역추적",
      "가장 긴 증가하는 부분 수열 문제"
    ],
    "description": "수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10,20, 10,30, 20,50} 이고, 길이는 4이다.",
    "input_description": "첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (-1,000,000,000 ≤ Ai≤ 1,000,000,000)",
    "output_description": "첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.둘째 줄에는 정답이 될 수 있는 가장 긴 증가하는 부분 수열을 출력한다.",
    "examples": [
      {
        "input": "6\r\n10 20 10 30 20 50",
        "output": "4\r\n10 20 30 50"
      }
    ],
    "url": "https://www.acmicpc.net/problem/14003",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from bisect import bisect_left\n\nN = int(input())\nA = list(map(int, input().split()))\n\nlis = []\nindices = []\n\nfor i, num in enumerate(A):\n    pos = bisect_left(lis, num)\n    if pos == len(lis):\n        lis.append(num)\n    else:\n        lis[pos] = num\n    indices.append((pos, num))\n\nprint(len(lis))\n\n# 역추적\nresult = []\nlength = len(lis) - 1\n\nfor i in range(N - 1, -1, -1):\n    if indices[i][0] == length:\n        result.append(indices[i][1])\n        length -= 1\n\nresult.reverse()\nprint(' '.join(map(str, result)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "14215",
    "step_title": "기하 1: 직사각형과 삼각형",
    "title": "세 막대",
    "level": 3,
    "tags": [
      "수학",
      "구현",
      "기하학"
    ],
    "description": "영선이는 길이가 a, b, c인 세 막대를 가지고 있고, 각 막대의 길이를 마음대로 줄일 수 있다.영선이는 세 막대를 이용해서 아래 조건을 만족하는 삼각형을 만들려고 한다.각 막대의 길이는 양의 정수이다세 막대를 이용해서 넓이가 양수인 삼각형을 만들 수 있어야 한다.삼각형의 둘레를 최대로 해야 한다.a, b, c가 주어졌을 때, 만들 수 있는 가장 큰 둘레를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 a, b, c (1 ≤ a, b, c ≤ 100)가 주어진다.",
    "output_description": "첫째 줄에 만들 수 있는 가장 큰 삼각형의 둘레를 출력한다.",
    "examples": [
      {
        "input": "1 2 3",
        "output": "5"
      },
      {
        "input": "2 2 2",
        "output": "6"
      },
      {
        "input": "1 100 1",
        "output": "3"
      },
      {
        "input": "41 64 16",
        "output": "113"
      }
    ],
    "url": "https://www.acmicpc.net/problem/14215",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "sides = sorted(map(int, input().split()))\nif sides[0] + sides[1] > sides[2]:\n    print(sum(sides))\nelse:\n    print(2 * (sides[0] + sides[1]) - 1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "여러 값 입력 받기",
            "description": "sides = sorted(map(int, input().split()))로 입력을 처리합니다.",
            "code_pattern": "sides = sorted(map(int, input().split()))",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "조건 판단",
            "description": "조건문을 사용하여 상황에 따라 다르게 처리합니다.",
            "code_pattern": "if sides[0] + sides[1] > sides[2]:",
            "socratic_hint": "조건에 따라 다르게 처리하려면?",
            "hint": "if-else 문을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(sum(sides))",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "14268",
    "step_title": "세그먼트 트리 2",
    "title": "회사 문화 2",
    "level": 18,
    "tags": [
      "그래프 이론",
      "자료 구조",
      "트리",
      "세그먼트 트리",
      "느리게 갱신되는 세그먼트 트리",
      "오일러 경로 테크닉",
      "차분 배열 트릭"
    ],
    "description": "영선회사에는 매우 좋은 문화가 있는데, 바로 상사가 직속 부하를 칭찬하면 그 부하가 부하의 직속 부하를 연쇄적으로 칭찬하는 내리 칭찬이 있다. 즉, 상사가 한 직속 부하를 칭찬하면 그 부하의 모든 부하들이 칭찬을 받는다.모든 칭찬에는 칭찬의 정도를 의미하는 수치가 있는데, 이 수치 또한 부하들에게 똑같이 칭찬 받는다.이번에는 내리 칭찬이 실시간으로 일어날 것이다.입력으로 아래와 같은 쿼리가 주어질 것이다.1 i w: i번째 직원이 직속 상사로부터 w만큼 칭찬을 받는다. (2 ≤ i ≤ n, 1 ≤ w ≤ 1,000)2 i: i번째 직원이 칭찬을 받은 정도를 출력한다.직속 상사와 직속 부하관계에 대해 주어지고, 쿼리가 주어졌을 때 2번 쿼리에 따라 출력한다.",
    "input_description": "첫째 줄에는 회사의 직원 수 n명, 쿼리의 개수 m이 주어진다. 직원은 1번부터 n번까지 번호가 매겨져 있다. (2 ≤ n, m ≤ 100,000)둘째 줄에는 직원 n명의 직속 상사의 번호가 주어진다. 직속 상사의 번호는 자신의 번호보다 작으며, 최종적으로 1번이 사장이다. 1번의 경우, 상사가 없으므로 -1이 입력된다.다음 m줄에는 위와 같이 쿼리가 주어진다. 사장은 상사가 없으므로 칭찬을 받지 않는다.",
    "output_description": "2번 쿼리가 주어질 때마다, 알맞게 출력하시오.",
    "examples": [
      {
        "input": "5 5\n-1 1 2 3 4\n1 2 2\n1 3 4\n1 5 6\n2 5\n2 3",
        "output": "12\n6"
      }
    ],
    "url": "https://www.acmicpc.net/problem/14268",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 그래프 문제 기본 구조\nfrom collections import deque\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\n# BFS/DFS 구현\nvisited = [False] * (N + 1)\n\ndef bfs(start):\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        node = queue.popleft()\n        for next_node in graph[node]:\n            if not visited[next_node]:\n                visited[next_node] = True\n                queue.append(next_node)\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "14287",
    "step_title": "세그먼트 트리 2",
    "title": "회사 문화 3",
    "level": 18,
    "tags": [
      "자료 구조",
      "트리",
      "세그먼트 트리",
      "오일러 경로 테크닉"
    ],
    "description": "영선회사에는 매우 좋은 문화가 있는데, 바로 상사가 직속 부하를 칭찬하면 그 부하가 부하의 직속 부하를 연쇄적으로 칭찬하는 내리 칭찬이 있다. 즉, 상사가 한 직속 부하를 칭찬하면 그 부하의 모든 부하들이 칭찬을 받는다.이러한 내리 칭찬은 회사에 가장 큰 장점이 되었고, 사장 영선이는 이 장점을 이용하기 위하여 단 하루만 반대로 하기로 했다. 즉, 부하가 상사를 칭찬하면, 그 위로 쭉 사장까지 모두 칭찬을 받는다.칭찬에 대한 정보는 실시간으로 주어진다.입력으로 아래와 같은 쿼리가 주어질 것이다.1 i w: i번째 직원이 직속 부하 중 한 명으로부터 w만큼 칭찬을 받는다. (1 ≤ i ≤ n, 1 ≤ w ≤ 1,000) 부하가 없다면 입력으로 들어오지 않는다.2 i: i번째 직원이 칭찬을 받은 정도를 출력한다. (1 ≤ i ≤ n)직속 상사와 직속 부하관계에 대해 주어지고, 쿼리가 주어졌을 때 2번 쿼리에 따라 출력하시오.",
    "input_description": "첫째 줄에는 회사의 직원 수 n명, 쿼리의 개수 m이 주어진다. 직원은 1번부터 n번까지 번호가 매겨져 있다. (2 ≤ n, m ≤ 100,000)둘째 줄에는 직원 n명의 직속 상사의 번호가 주어진다. 직속 상사의 번호는 자신의 번호보다 작으며, 최종적으로 1번이 사장이다. 1번의 경우, 상사가 없으므로 -1이 입력된다.다음 m줄에는 쿼리가 한 줄에 하나씩 주어진다.",
    "output_description": "2번 쿼리가 주어질 때마다, 알맞게 출력하시오.",
    "examples": [
      {
        "input": "5 6\n-1 1 2 3 4\n1 2 2\n1 3 4\n1 4 6\n2 5\n2 3\n2 1",
        "output": "0\n10\n12"
      }
    ],
    "url": "https://www.acmicpc.net/problem/14287",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 그래프 문제 기본 구조\nfrom collections import deque\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\n# BFS/DFS 구현\nvisited = [False] * (N + 1)\n\ndef bfs(start):\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        node = queue.popleft()\n        for next_node in graph[node]:\n            if not visited[next_node]:\n                visited[next_node] = True\n                queue.append(next_node)\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "14288",
    "step_title": "세그먼트 트리 2",
    "title": "회사 문화 4",
    "level": 18,
    "tags": [
      "자료 구조",
      "트리",
      "세그먼트 트리",
      "느리게 갱신되는 세그먼트 트리",
      "오일러 경로 테크닉",
      "차분 배열 트릭"
    ],
    "description": "영선회사에는 매우 좋은 문화가 있는데, 바로 상사가 직속 부하를 칭찬하면 그 부하가 부하의 직속 부하를 연쇄적으로 칭찬하는 내리 칭찬이 있다. 즉, 상사가 한 직속 부하를 칭찬하면 그 부하의 모든 부하들이 칭찬을 받는다.이러한 내리 칭찬은 회사에 가장 큰 장점이 되었고, 사장 영선이는 이 장점을 이용하기 위하여 근무 시간 도중 도중 칭찬의 방향을 바꿀 것이다. 가장 처음에는 부하 직원 방향이다.칭찬에 대한 정보는 실시간으로 주어진다.입력으로 아래와 같은 쿼리가 주어질 것이다.1 i w: i번째 직원이 직속 상사로부터 w만큼 칭찬을 받는다. 만약, 칭찬의 방향이 상사 방향이라면, i번째 직원이 직속 부하 중 한 명으로부터 w만큼 칭찬을 받는다. (1 ≤ i ≤ n, 1 ≤ w ≤ 1,000)2 i: i번째 직원이 칭찬을 받은 정도를 출력한다.3: 칭찬의 방향이 부하 직원 방향이면 상사 방향으로, 상사 방향이면 부하 직원 방향으로 바꾼다.직속 상사와 직속 부하관계에 대해 주어지고, 쿼리가 주어졌을 때 2번 쿼리에 따라 출력하시오.",
    "input_description": "첫째 줄에는 회사의 직원 수 n명, 쿼리의 개수 m이 주어진다. 직원은 1번부터 n번까지 번호가 매겨져 있다. (2 ≤ n, m ≤ 100,000)둘째 줄에는 직원 n명의 직속 상사의 번호가 주어진다. 직속 상사의 번호는 자신의 번호보다 작으며, 최종적으로 1번이 사장이다. 1번의 경우, 상사가 없으므로 -1이 입력된다.다음 m줄에는 쿼리가 한 줄에 하나씩 주어진다.",
    "output_description": "2번 쿼리가 주어질 때마다, 알맞게 출력하시오.",
    "examples": [
      {
        "input": "5 8\n-1 1 2 3 4\n1 2 2\n3\n1 3 4\n3\n1 4 6\n2 5\n2 3\n2 1",
        "output": "8\n6\n4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/14288",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 그래프 문제 기본 구조\nfrom collections import deque\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\n# BFS/DFS 구현\nvisited = [False] * (N + 1)\n\ndef bfs(start):\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        node = queue.popleft()\n        for next_node in graph[node]:\n            if not visited[next_node]:\n                visited[next_node] = True\n                queue.append(next_node)\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "14425",
    "step_title": "집합과 맵",
    "title": "문자열 집합",
    "level": 7,
    "tags": [
      "자료 구조",
      "문자열",
      "집합과 맵",
      "해시를 사용한 집합과 맵",
      "트리를 사용한 집합과 맵"
    ],
    "description": "총 N개의 문자열로 이루어진 집합 S가 주어진다.입력으로 주어지는 M개의 문자열 중에서 집합 S에 포함되어 있는 것이 총 몇 개인지 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 문자열의 개수 N과 M (1 ≤ N ≤ 10,000, 1 ≤ M ≤ 10,000)이 주어진다.다음 N개의 줄에는 집합 S에 포함되어 있는 문자열들이 주어진다.다음 M개의 줄에는 검사해야 하는 문자열들이 주어진다.입력으로 주어지는 문자열은 알파벳 소문자로만 이루어져 있으며, 길이는 500을 넘지 않는다. 집합 S에 같은 문자열이 여러 번 주어지는 경우는 없다.",
    "output_description": "첫째 줄에 M개의 문자열 중에 총 몇 개가 집합 S에 포함되어 있는지 출력한다.",
    "examples": [
      {
        "input": "5 11\nbaekjoononlinejudge\nstartlink\ncodeplus\nsundaycoding\ncodingsh\nbaekjoon\ncodeplus\ncodeminus\nstartlink\nstarlink\nsundaycoding\ncodingsh\ncodinghs\nsondaycoding\nstartrink\nicerink",
        "output": "4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/14425",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N, M = map(int, input().split())\nstring_set = set()\nfor _ in range(N):\n    string_set.add(input())\n\ncount = 0\nfor _ in range(M):\n    if input() in string_set:\n        count += 1\n\nprint(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "14464",
    "step_title": "그리디 알고리즘 2",
    "title": "소가 길을 건너간 이유 4",
    "level": 15,
    "tags": [
      "자료 구조",
      "그리디 알고리즘",
      "정렬",
      "우선순위 큐"
    ],
    "description": "농부 존의 소들은 효율적으로 길을 건너는 방법을 터득하고 있다. 그들은 길 건너기의 달인인 닭의 도움을 받기로 했다.안타깝게도 닭은 매우 바쁜 동물이라, 소를 도와줄 시간이 별로 없다. 농장에 C마리(1 ≤ C ≤ 20,000)의 닭이 있고, 1번부터 C번까지 번호가 붙어 있다. i번 닭은 정확히 Ti초에만 소를 도와줄 수 있다. 하지만 닭은 길 건너기의 달인이므로 소를 데리고도 순식간에 길을 건널 수 있다. 소는 할 일이 없어서 여유롭게 길을 건널 수 있다. 소는 총 N마리(1 ≤ N ≤ 20,000)가 있고, 마찬가지로 1번부터 N번까지 번호가 붙어 있다. j번 소는 Aj초부터 Bj초까지 길을 건널 수 있다. j번 소가 i번 닭의 도움을 받아 길을 건너려면  Aj≤ Ti≤ Bj를 만족해야 한다.소는 최대 한 마리의 닭에게만 도움을 받을 수 있고, 닭 역시 최대 한 마리의 소만 도와줄 수 있다. 도움을 받을 수 있는 소가 최대 몇 마리인지 구해보자.",
    "input_description": "첫 줄에 C와 N이 주어진다. 다음 C줄에는 T1…TC가 주어지고, 그 다음 N줄에는 Aj와 Bj(Aj≤ Bj)가 주어진다. A, B, T는 모두 최대 1,000,000,000인 음이 아닌 정수이고, 같을 수도 있다.",
    "output_description": "도움을 받을 수 있는 소가 최대 몇 마리인지 출력한다.",
    "examples": [
      {
        "input": "5 4\r\n7\r\n8\r\n6\r\n2\r\n9\r\n2 5\r\n4 9\r\n0 3\r\n8 13",
        "output": "3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/14464",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "c, n = map(int, input().split())\nchickens = [int(input()) for _ in range(c)]\ncows = []\nfor _ in range(n):\n    a, b = map(int, input().split())\n    cows.append((a, b))\n\nchickens.sort()\ncows.sort(key=lambda x: (x[1], x[0]))\n\ncount = 0\nused = [False] * c\n\nfor a, b in cows:\n    for i in range(c):\n        if not used[i] and a <= chickens[i] <= b:\n            used[i] = True\n            count += 1\n            break\n\nprint(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor num in sorted(arr):\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3",
        "solution_code": "c, n = map(int, input().split())\nchickens = []\nfor _ in range(c):\n    chickens.append(int(input()))\n\ncows = []\nfor _ in range(n):\n    a, b = map(int, input().split())\n    cows.append((a, b))\n\nchickens.sort()\ncows.sort(key=lambda x: (x[1], x[0]))\n\ncount = 0\nused = [False] * c\n\nfor a, b in cows:\n    for i in range(c):\n        if not used[i] and a <= chickens[i] <= b:\n            used[i] = True\n            count += 1\n            break\n\nprint(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 패스 횟수 제어",
            "description": "n-1번 반복하며 각 패스를 수행합니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "버블 정렬에서 몇 번의 패스가 필요한가요?",
            "hint": "n-1번의 패스가 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "내부 반복문: 인접 원소 비교",
            "description": "각 패스에서 인접한 두 원소를 비교합니다. 이미 정렬된 뒤쪽 부분은 제외합니다.",
            "code_pattern": "for j in range(n-1-i):",
            "socratic_hint": "각 패스에서 비교해야 할 원소의 범위는?",
            "hint": "n-1-i까지 비교합니다 (이미 정렬된 부분 제외)."
          },
          {
            "step_id": 4,
            "goal": "원소 교환",
            "description": "왼쪽 원소가 오른쪽 원소보다 크면 위치를 교환합니다.",
            "code_pattern": "if arr[j] > arr[j+1]:\n    arr[j], arr[j+1] = arr[j+1], arr[j]",
            "socratic_hint": "인접한 두 원소의 순서가 잘못되었을 때 어떻게 하나요?",
            "hint": "두 원소의 위치를 swap합니다."
          },
          {
            "step_id": 5,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "14565",
    "step_title": "수학 2",
    "title": "역원(Inverse) 구하기",
    "level": 14,
    "tags": [
      "수학",
      "정수론",
      "모듈로 곱셈 역원",
      "확장 유클리드 호제법"
    ],
    "description": "집합 Zn을 0부터 n-1까지의 정수 집합이라고 하자. Zn ∋ a, b, c 일 때, (a+b) mod n = 0이면 b는 a의 덧셈역이라고 하고 (a*c) mod n = 1이면 c는 a의 곱셈역이라고 한다.정수 N, A가 주어졌을 때 Zn에서의 A의 덧셈역과 곱셈역을 구하시오.단, 곱셈역을 구할 수 없으면 -1을 출력한다.",
    "input_description": "첫 번째 줄에 N(2 ≤ N ≤ 1012)과 A(1 ≤ A < N)이 주어진다.",
    "output_description": "첫 번째 줄에 A의 N에 대한 덧셈역과 곱셈역을 한 줄에 공백으로 구분하여 출력한다.",
    "examples": [
      {
        "input": "26 11",
        "output": "15 19"
      },
      {
        "input": "100 20",
        "output": "80 -1"
      },
      {
        "input": "32760247633 22801763489",
        "output": "9958484144 12390598440"
      }
    ],
    "url": "https://www.acmicpc.net/problem/14565",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def extended_gcd(a, b):\n    if b == 0:\n        return a, 1, 0\n    gcd, x1, y1 = extended_gcd(b, a % b)\n    x = y1\n    y = x1 - (a // b) * y1\n    return gcd, x, y\n\ndef mod_inverse(a, m):\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd != 1:\n        return None\n    return (x % m + m) % m\n\nA, B = map(int, input().split())\ninv = mod_inverse(A, B)\nif inv is None:\n    print(-1)\nelse:\n    print(inv)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "14601",
    "step_title": "해 구성하기",
    "title": "샤워실 바닥 깔기 (Large)",
    "level": 16,
    "tags": [
      "구현",
      "분할 정복",
      "재귀"
    ],
    "description": "오늘은 민규가 훈련소에 입소하는 날이다. 모든 행사를 마치고 생활관으로 돌아와서 쉬려는데 갑자기 교관이 들어오더니 민규의 이름을 부르는 것이 아닌가. 당황한 채로 따라갔더니 이번엔 김준서를 아느냐고 물어보았다. 그 녀석이 샤워실 바닥을 깔았는데, 배수구 위치까지 막아버렸다면서 같은 학교 출신인 민규가 다시 깔라는 것이었다.어떻게 타일을 깔지 고민하던 민규는 샤워실의 구조가 정사각형이면서 한 변의 길이가 2의 제곱수라는 사실을 알아냈다. 준서는 여기까지만 고려해서 2x2 크기의 타일로 바닥을 전부 채운 것 같은데, 문제는 이렇게 하면 배수구가 있어야 할 위치를 비울 수가 없다는 것이다. 이런저런 방법을 생각하다가 4칸을 차지하는 정사각형 타일 대신 3칸을 차지하는 ㄱ자 모양의 타일을 사용하면 될 것 같다는 느낌을 받았다.그런데 ㄱ자 타일을 어떻게 채워야 할까? 생각하다 지친 민규는 여러분에게 이 방법을 찾아달라고 부탁했다. 첫날부터 생활관에서 밤을 새우는 일이 없도록 여러분이 도와주자.",
    "input_description": "첫 번째 줄에는 바닥의 한 변의 길이를 표현하는 자연수 K(1 ≤ K ≤ 7) 가 주어진다. 이때 바닥의 크기는 2K가 됨에 유의하라. 두 번째 줄에는 배수구의 위치를 나타내는 자연수 x, y (1 ≤ x, y ≤ 2K)가 공백으로 분리돼서 주어진다. 이때 가장 왼쪽 아래가 (1, 1), 가장 오른쪽 위가 (2K, 2K)이다.",
    "output_description": "각 타일마다 고유한 번호를 매긴 타일의 배치도를 출력한다. 각 타일의 번호에는 19000 이하의 자연수만을 사용해야 한다. 배수구가 있는 위치는 -1로 표시한다. 가능한 답 중 하나만 출력하면 된다.만약 알맞게 타일을 배치하는 방법이 존재하지 않는다면 -1을 출력한다.",
    "examples": [
      {
        "input": "1\r\n2 2",
        "output": "1 -1\r\n1 1"
      },
      {
        "input": "2\r\n1 1",
        "output": "4 4 5 5\r\n4 3 3 5\r\n1 1 3 2\r\n-1 1 2 2"
      },
      {
        "input": "2\r\n3 2",
        "output": "4 4 5 5\r\n4 3 3 5\r\n1 3 -1 2\r\n1 1 2 2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/14601",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "14636",
    "step_title": "동적 계획법 최적화 1",
    "title": "Money for Nothing",
    "level": 22,
    "tags": [
      "다이나믹 프로그래밍",
      "기하학",
      "분할 정복",
      "분할 정복을 사용한 최적화"
    ],
    "description": "In this problem you will be solving one of the most profound challenges of humans across the world since the beginning of time – how to make lots of money.You are a middleman in the widget market. Your job is to buy widgets from widget producer companies and sell them to widget consumer companies. Each widget consumer company has an open request for one widget per day, until some end date, and a price at which it is willing to buy the widgets. On the other hand, each widget producer company has a start date at which it can start delivering widgets and a price at which it will deliver each widget.Due to fair competition laws, you can sign a contract with only one producer company and only one consumer company. You will buy widgets from the producer company, one per day, starting on the day it can start delivering, and ending on the date specified by the consumer company. On each of those days you earn the difference between the producer’s selling price and the consumer’s buying price.Your goal is to choose the consumer company and the producer company that will maximize your profits.",
    "input_description": "The first line of input contains two integers m and n (1 ≤ m, n ≤ 500 000) denoting the number of producer and consumer companies in the market, respectively. It is followed by m lines, the i th of which contains two integers piand di(1 ≤ pi, di≤ 109), the price (in dollars) at which the i th producer sells one widget and the day on which the first widget will be available from this company. Then follow n lines, the j th of which contains two integers qjand ej(1 ≤ qj, ej≤ 109), the price (in dollars) at which the j th consumer is willing to buy widgets and the day immediately after the day on which the last widget has to be delivered to this company.",
    "output_description": "Display the maximum total number of dollars you can earn. If there is no way to sign contracts that gives you any profit, display 0.",
    "examples": [
      {
        "input": "2 2\r\n1 3\r\n2 1\r\n3 5\r\n7 2",
        "output": "5"
      },
      {
        "input": "1 2\r\n10 10\r\n9 11\r\n11 9",
        "output": "0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/14636",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "14681",
    "step_title": "조건문",
    "title": "사분면 고르기",
    "level": 1,
    "tags": [
      "구현",
      "기하학"
    ],
    "description": "흔한 수학 문제 중 하나는 주어진 점이 어느 사분면에 속하는지 알아내는 것이다. 사분면은 아래 그림처럼 1부터 4까지 번호를 갖는다. \"Quadrant n\"은 \"제n사분면\"이라는 뜻이다.예를 들어, 좌표가 (12, 5)인 점 A는 x좌표와 y좌표가 모두 양수이므로 제1사분면에 속한다. 점 B는 x좌표가 음수이고 y좌표가 양수이므로 제2사분면에 속한다.점의 좌표를 입력받아 그 점이 어느 사분면에 속하는지 알아내는 프로그램을 작성하시오. 단, x좌표와 y좌표는 모두 양수나 음수라고 가정한다.",
    "input_description": "첫 줄에는 정수 x가 주어진다. (−1000 ≤ x ≤ 1000; x ≠ 0) 다음 줄에는 정수 y가 주어진다. (−1000 ≤ y ≤ 1000; y ≠ 0)",
    "output_description": "점 (x, y)의 사분면 번호(1, 2, 3, 4 중 하나)를 출력한다.",
    "examples": [
      {
        "input": "12\n5",
        "output": "1"
      },
      {
        "input": "9\n-13",
        "output": "4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/14681",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "x = int(input())\ny = int(input())\nif x > 0 and y > 0:\n    print(1)\nelif x < 0 and y > 0:\n    print(2)\nelif x < 0 and y < 0:\n    print(3)\nelse:\n    print(4)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "x 좌표 입력",
            "description": "x 좌표를 입력받습니다.",
            "code_pattern": "x = int(input())",
            "socratic_hint": "x 좌표를 입력받으려면?",
            "hint": "x = int(input())"
          },
          {
            "step_id": 2,
            "goal": "y 좌표 입력",
            "description": "y 좌표를 입력받습니다.",
            "code_pattern": "y = int(input())",
            "socratic_hint": "y 좌표를 입력받으려면?",
            "hint": "y = int(input())"
          },
          {
            "step_id": 3,
            "goal": "x와 y의 부호 확인",
            "description": "x > 0, x < 0, y > 0, y < 0을 확인하여 사분면을 판단합니다.",
            "code_pattern": "if x > 0 and y > 0:  # 1사분면\nelif x < 0 and y > 0:  # 2사분면\nelif x < 0 and y < 0:  # 3사분면\nelse:  # 4사분면",
            "socratic_hint": "x와 y의 부호(+/-)에 따라 사분면이 결정됩니다.",
            "hint": "(+,+)는 1사분면, (-,+)는 2사분면, (-,-)는 3사분면, (+,-)는 4사분면"
          },
          {
            "step_id": 4,
            "goal": "1, 2사분면 판정",
            "description": "x > 0이고 y > 0이면 1, x < 0이고 y > 0이면 2를 출력합니다.",
            "code_pattern": "if x > 0 and y > 0:\n    print(1)\nelif x < 0 and y > 0:\n    print(2)",
            "socratic_hint": "1사분면과 2사분면의 조건은?",
            "hint": "y가 양수일 때, x가 양수면 1사분면, 음수면 2사분면"
          },
          {
            "step_id": 5,
            "goal": "3, 4사분면 판정",
            "description": "x < 0이고 y < 0이면 3, 나머지는 4를 출력합니다.",
            "code_pattern": "elif x < 0 and y < 0:\n    print(3)\nelse:\n    print(4)",
            "socratic_hint": "3사분면과 4사분면의 조건은?",
            "hint": "y가 음수일 때, x가 음수면 3사분면, 양수면 4사분면"
          }
        ]
      }
    ]
  },
  {
    "problem_id": "14725",
    "step_title": "문자열 알고리즘 1",
    "title": "개미굴",
    "level": 13,
    "tags": [
      "자료 구조",
      "문자열",
      "트리",
      "집합과 맵",
      "트라이"
    ],
    "description": "개미는(뚠뚠) 오늘도(뚠뚠) 열심히(뚠뚠) 일을 하네.개미는 아무말도 하지 않지만 땀을 뻘뻘 흘리면서 매일 매일을 살길 위해서 열심히 일을 하네.한 치 앞도(뚠뚠) 모르는(뚠뚠) 험한 이 세상(뚠뚠) 그렇지만(뚠뚠) 오늘도 행복한 개미들!우리의 천재 공학자 윤수는 이 개미들이 왜 행복한지 궁금해졌다.행복의 비결이 개미가 사는 개미굴에 있다고 생각한 윤수는 개미굴의 구조를 알아보기 위해 로봇 개미를 만들었다.로봇 개미는 센서가 있어 개미굴의 각 층에 먹이가 있는 방을 따라 내려가다 더 이상 내려갈 수 없으면 그 자리에서 움직이지 않고 신호를 보낸다.이 신호로 로봇 개미는 개미굴 각 층을 따라 내려오면서 알게 된 각 방에 저장된 먹이 정보를 윤수한테 알려줄 수 있다.로봇 개미 개발을 완료한 윤수는 개미굴 탐사를 앞두고 로봇 개미를 테스트 해보기 위해 위 그림의 개미굴에 로봇 개미를 투입했다. 로봇 개미의 수는 각 개미굴의 저장소를 모두 확인할 수 있을 만큼 넣는다.다음은 로봇 개미들이 윤수에게 보내준 정보다.KIWI BANANAKIWI APPLEAPPLE APPLEAPPLE BANANA KIWI공백을 기준으로 왼쪽부터 순서대로 로봇 개미가 각 층마다 지나온 방에 있는 먹이 이름을 뜻한다.윤수는 로봇 개미들이 보내준 정보를 바탕으로 다음과 같이 개미굴의 구조를 손으로 그려봤다.APPLE\r\n--APPLE\r\n--BANANA\r\n----KIWI\r\nKIWI\r\n--APPLE\r\n--BANANA개미굴의 각 층은 \"--\" 로 구분을 하였다. 또 같은 층에 여러 개의 방이 있을 때에는 사전 순서가 앞서는 먹이 정보가 먼저 나온다.우리의 천재 공학자 윤수는 복잡한 개미굴들을 일일이 손으로 그리기 힘들어 우리에게 그려달라고 부탁했다.한치 앞도 모르는 험한 이세상 그렇지만 오늘도 행복한 개미들!행복의 비결을 알기 위해 윤수를 도와 개미굴이 어떤 구조인지 확인해보자.",
    "input_description": "첫 번째 줄은 로봇 개미가 각 층을 따라 내려오면서 알게 된 먹이의 정보 개수 N (1 ≤ N ≤ 1000)개가 주어진다.두 번째 줄부터 N+1 번째 줄까지, 각 줄의 시작은 로봇 개미 한마리가 보내준 먹이 정보 개수 K (1 ≤ K ≤ 15)가 주어진다.다음 K개의 입력은 로봇 개미가 왼쪽부터 순서대로 각 층마다 지나온 방에 있는 먹이 정보이며 먹이 이름 길이 t는 1 ≤ t ≤ 15를 만족한다. 먹이 정보는 알파벳 대문자로만 이루어져 있다.",
    "output_description": "개미굴의 시각화된 구조를 출력하여라.개미굴의 각 층을 \"--\" 로 구분하며, 같은 층에 여러개의 방이 있을 때에는 사전 순서가 앞서는 먹이 정보가 먼저 나온다.최상위 굴을 포함하여 하나의 굴에서 개미굴이 여러개로 나뉠 때 먹이 종류별로 최대 한 번만 나올 수 있다.",
    "examples": [
      {
        "input": "3\n2 B A\n4 A B C D\n2 A C",
        "output": "A\n--B\n----C\n------D\n--C\nB\n--A"
      },
      {
        "input": "4\n2 KIWI BANANA\n2 KIWI APPLE\n2 APPLE APPLE\n3 APPLE BANANA KIWI",
        "output": "APPLE\n--APPLE\n--BANANA\n----KIWI\nKIWI\n--APPLE\n--BANANA"
      }
    ],
    "url": "https://www.acmicpc.net/problem/14725",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n    \n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end\n\nN = int(input())\ntrie = Trie()\n\nfor _ in range(N):\n    word = input().strip()\n    trie.insert(word)\n\nM = int(input())\nfor _ in range(M):\n    query = input().strip()\n    print(1 if trie.search(query) else 0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "14750",
    "step_title": "네트워크 플로우 1",
    "title": "Jerry and Tom",
    "level": 19,
    "tags": [
      "그래프 이론",
      "기하학",
      "최대 유량",
      "선분 교차 판정"
    ],
    "description": "Naughty mouse Jerry and his friend mice sometimes visit a vacant house to play the famous children game ‘hide and seek’ and also to adjust the length of their teeth by gnawing furniture and chairs left there. If we look down the house from the sky the boundary of it composes an orthogonal polygon parallel to the xy-axes as shown in the figure below. In other words, every wall of the house is either horizontal or vertical.Tom, a threatening cat to them, sometimes appears in the house while they are enjoying the game. In that case Jerry and his friends should hide into the rat’s holes at the bottom on the walls. There are two rules which must be held for them to hide into the holes:Each hole can afford at most k mice.Each mouse can enter the hole which can be seen by it. In other words, a mouse cannot enter the hole which is hidden by any wall. (That is, if the connecting line between a mouse and a hole intersects either any wall or any corner point of the house, the hole is considered hidden from the mouse.)For example, consider a situation where three mice and three holes are in the house as shown in Figure E.1. Each circle on the boundary denotes a hole. Assuming that k = 1, i.e., only one mouse is allowed to hide into each hole, with the situation shown in the left figure, when Tom appears all the three mice can hide. But for the case shown in the right figure it is impossible for all the mice to hide.Figure E.1: Illustration to show two situations: 1. All mice can hide (left) and 2. They cannot (right)You can assume:Every mouse is strictly inside the house, which means that no mouse is on the wallEvery hole is on the wall.No two holes locate at the same spot.No two mice locate at the same spot.Given a situation explained above, you are to write a program which determines whether all the mice can hide or not.",
    "input_description": "Your program is to read from standard input. The input starts with a line containing four integers, n, k, h, and m, where n(1 ≤ n ≤ 1,000) is the number of the corner points of a house, k(1 ≤ k ≤ 5) the maximum number of mice each hole can afford, h(1 ≤ h ≤ 50) the number of holes, m(1 ≤ m ≤ k ∙ h) the number of mice. In each of the following n lines, each coordinate of the corner points of the house is given in counter clockwise order. Each point is represented by two integers separated by a single space, which are the x- coordinate and the y-coordinate of the point, respectively. Each coordinate is given as an integer between -109and 109, inclusively. In each of the following h lines, two integers x and y are given, which represent the coordinate (x, y) of each hole. In each of the following m lines, two integers x and y are given, which represent the coordinate (x, y) of each mouse.",
    "output_description": "Your program is to write to standard output. Print exactly one line for the input. Print Possible if all the mice can hide into the rat’s holes holding the constraints explained above. Otherwise print Impossible.",
    "examples": [
      {
        "input": "6 1 3 3\r\n0 0\r\n100 0\r\n100 50\r\n40 50\r\n40 70\r\n0 70\r\n0 55\r\n55 50\r\n80 50\r\n15 65\r\n90 10\r\n92 10",
        "output": "Possible"
      },
      {
        "input": "6 1 3 3\r\n0 0\r\n100 0\r\n100 50\r\n40 50\r\n40 70\r\n0 70\r\n0 55\r\n55 50\r\n80 50\r\n15 65\r\n90 10\r\n30 66",
        "output": "Impossible"
      }
    ],
    "url": "https://www.acmicpc.net/problem/14750",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "14751",
    "step_title": "동적 계획법 최적화 1",
    "title": "Leftmost Segment",
    "level": 21,
    "tags": [
      "기하학",
      "이분 탐색",
      "볼록 껍질",
      "볼록 껍질을 이용한 최적화"
    ],
    "description": "There are two distinct horizontal lines hupperand hlowerin the xy-coordinate plane and n line segments connecting them. One endpoint of each segment lies on hupperand the other on hlower. All endpoints of the segments are distinct. All segments are numbered from 1 to n. Consider a horizontal line hilocated between hupperand hlower, which will be given by a query. The line hicrosses all segments definitely. We want to know which segment intersects at the leftmost with hi. You can observe that the leftmost intersection point between the segments and a query line may lie on one or more segments since two or more segments may intersect at a single point. In that case, the leftmost segment is defined as the segment which has the leftmost endpoint on hupper.For example, 5 segments and 3 query lines are given in the plane as shown in the figure below. The leftmost segment that intersects with a query line of y = 2.0 is 2 and the leftmost segment that intersects with a query line of y = 4.0 is 3. The query line of y = 6.25 crosses the intersection point between the segments 3 and 4, hence the leftmost segment is 4 by definition.Given n segments connecting two horizontal lines and m queries, you are to write a program to find the leftmost segment that intersects with each query line.Note that two or more segments may intersect at a single point. You should be also careful of round-off errors caused by the computer representation of real numbers.",
    "input_description": "Your program is to read from standard input. The input starts with a line containing two integers, maxY and minY (-1,000 ≤ minY < maxY ≤ 1,000), where maxY and minY represent the y-coordinates of the upper horizontal line and the lower horizontal line, respectively. The next line contains an integer n (1 ≤ n ≤ 100,000) which is the number of segments connecting two horizontal lines. All segments are numbered from 1 to n in order given as the input. In the following n lines, each line contains two integers upperX and lowX (-500,000 ≤ upperX, lowX ≤ 500,000) which represent the x-coordinates of the upper endpoint and the lower endpoint of a line segment, respectively. All endpoints are distinct. The next line contains an integer m (1 ≤ m ≤ 100,000) which is the number of queries. In the following m lines, each line contains a y-coordinate given for the query horizontal line, which is a real number between minY and maxY exclusive and the number of digits after the decimal point is 1 or more and 3 or less.",
    "output_description": "Your program is to write to standard output. Print exactly one line for each query in order given as the input. The line should contain the leftmost segment number which intersects with the query horizontal line.",
    "examples": [
      {
        "input": "10 0\r\n5\r\n5 12\r\n9 0\r\n4 3\r\n1 8\r\n12 9\r\n3\r\n6.25\r\n4.0\r\n2.0",
        "output": "4\r\n3\r\n2"
      },
      {
        "input": "5 -5\r\n4\r\n0 0\r\n1 1\r\n2 2\r\n3 4\r\n3\r\n0.0\r\n2.05\r\n-3.275",
        "output": "1\r\n1\r\n1"
      },
      {
        "input": "3 0\r\n3\r\n6 7\r\n8 5\r\n2 11\r\n3\r\n1.0\r\n1.499\r\n1.501",
        "output": "2\r\n2\r\n3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/14751",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "14832",
    "step_title": "네트워크 플로우 3",
    "title": "Dice Straight (Large)",
    "level": 21,
    "tags": [
      "두 포인터",
      "이분 매칭"
    ],
    "description": "You have a special set ofNsix-sided dice, each of which has six different positive integers on its faces. Different dice may have different numberings.You want to arrange some or all of the dice in a row such that the faces on top form astraight(that is, they show consecutive integers). For each die, you can choose which face is on top.How long is the longest straight that can be formed in this way?",
    "input_description": "The first line of the input gives the number of test cases,T.Ttest cases follow. Each test case begins with one line withN, the number of dice. Then,Nmore lines follow; each of them has six positive integersDij. The j-th number on the i-th of these lines gives the number on the j-th face of the i-th die.Limits1 ≤T≤ 100.1 ≤Dij≤ 106for all i, j.1 ≤N≤ 50000.The sum ofNacross all test cases ≤ 200000.",
    "output_description": "For each test case, output one line containingCase #x: y, wherexis the test case number (starting from 1) andyis the length of the longest straight that can be formed.",
    "examples": [
      {
        "input": "3\r\n4\r\n4 8 15 16 23 42\r\n8 6 7 5 30 9\r\n1 2 3 4 55 6\r\n2 10 18 36 54 86\r\n2\r\n1 2 3 4 5 6\r\n60 50 40 30 20 10\r\n3\r\n1 2 3 4 5 6\r\n1 2 3 4 5 6\r\n1 4 2 6 5 3",
        "output": "Case #1: 4\r\nCase #2: 1\r\nCase #3: 3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/14832",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "14888",
    "step_title": "백트래킹",
    "title": "연산자 끼워넣기",
    "level": 10,
    "tags": [
      "브루트포스 알고리즘",
      "백트래킹"
    ],
    "description": "N개의 수로 이루어진 수열 A1, A2, ..., AN이 주어진다. 또, 수와 수 사이에 끼워넣을 수 있는 N-1개의 연산자가 주어진다. 연산자는 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷)으로만 이루어져 있다.우리는 수와 수 사이에 연산자를 하나씩 넣어서, 수식을 하나 만들 수 있다. 이때, 주어진 수의 순서를 바꾸면 안 된다.예를 들어, 6개의 수로 이루어진 수열이 1, 2, 3, 4, 5, 6이고, 주어진 연산자가 덧셈(+) 2개, 뺄셈(-) 1개, 곱셈(×) 1개, 나눗셈(÷) 1개인 경우에는 총 60가지의 식을 만들 수 있다. 예를 들어, 아래와 같은 식을 만들 수 있다.1+2+3-4×5÷61÷2+3+4-5×61+2÷3×4-5+61÷2×3-4+5+6식의 계산은 연산자 우선 순위를 무시하고 앞에서부터 진행해야 한다. 또, 나눗셈은 정수 나눗셈으로 몫만 취한다. 음수를 양수로 나눌 때는 C++14의 기준을 따른다. 즉, 양수로 바꾼 뒤 몫을 취하고, 그 몫을 음수로 바꾼 것과 같다. 이에 따라서, 위의 식 4개의 결과를 계산해보면 아래와 같다.1+2+3-4×5÷6 = 11÷2+3+4-5×6 = 121+2÷3×4-5+6 = 51÷2×3-4+5+6 = 7N개의 수와 N-1개의 연산자가 주어졌을 때, 만들 수 있는 식의 결과가 최대인 것과 최소인 것을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 수의 개수 N(2 ≤ N ≤ 11)가 주어진다. 둘째 줄에는 A1, A2, ..., AN이 주어진다. (1 ≤ Ai≤ 100) 셋째 줄에는 합이 N-1인 4개의 정수가 주어지는데, 차례대로 덧셈(+)의 개수, 뺄셈(-)의 개수, 곱셈(×)의 개수, 나눗셈(÷)의 개수이다.",
    "output_description": "첫째 줄에 만들 수 있는 식의 결과의 최댓값을, 둘째 줄에는 최솟값을 출력한다. 연산자를 어떻게 끼워넣어도 항상 -10억보다 크거나 같고, 10억보다 작거나 같은 결과가 나오는 입력만 주어진다. 또한, 앞에서부터 계산했을 때, 중간에 계산되는 식의 결과도 항상 -10억보다 크거나 같고, 10억보다 작거나 같다.",
    "examples": [
      {
        "input": "2\n5 6\n0 0 1 0",
        "output": "30\n30"
      },
      {
        "input": "3\n3 4 5\n1 0 1 0",
        "output": "35\n17"
      },
      {
        "input": "6\n1 2 3 4 5 6\n2 1 1 1",
        "output": "54\n-24"
      }
    ],
    "url": "https://www.acmicpc.net/problem/14888",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def backtrack(idx, result):\n    global max_val, min_val\n    \n    if idx == N:\n        max_val = max(max_val, result)\n        min_val = min(min_val, result)\n        return\n    \n    for i in range(4):\n        if ops[i] > 0:\n            ops[i] -= 1\n            if i == 0:\n                backtrack(idx + 1, result + numbers[idx])\n            elif i == 1:\n                backtrack(idx + 1, result - numbers[idx])\n            elif i == 2:\n                backtrack(idx + 1, result * numbers[idx])\n            else:\n                backtrack(idx + 1, int(result / numbers[idx]))\n            ops[i] += 1\n\nN = int(input())\nnumbers = list(map(int, input().split()))\nops = list(map(int, input().split()))\n\nmax_val = -1e9\nmin_val = 1e9\n\nbacktrack(1, numbers[0])\n\nprint(max_val)\nprint(min_val)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "14889",
    "step_title": "백트래킹",
    "title": "스타트와 링크",
    "level": 10,
    "tags": [
      "브루트포스 알고리즘",
      "백트래킹"
    ],
    "description": "오늘은 스타트링크에 다니는 사람들이 모여서 축구를 해보려고 한다. 축구는 평일 오후에 하고 의무 참석도 아니다. 축구를 하기 위해 모인 사람은 총 N명이고 신기하게도 N은 짝수이다. 이제 N/2명으로 이루어진 스타트 팀과 링크 팀으로 사람들을 나눠야 한다.BOJ를 운영하는 회사 답게 사람에게 번호를 1부터 N까지로 배정했고, 아래와 같은 능력치를 조사했다. 능력치 Sij는 i번 사람과 j번 사람이 같은 팀에 속했을 때, 팀에 더해지는 능력치이다. 팀의 능력치는 팀에 속한 모든 쌍의 능력치 Sij의 합이다. Sij는 Sji와 다를 수도 있으며, i번 사람과 j번 사람이 같은 팀에 속했을 때, 팀에 더해지는 능력치는 Sij와 Sji이다.N=4이고, S가 아래와 같은 경우를 살펴보자.i\\j12341123245637124345예를 들어, 1, 2번이 스타트 팀, 3, 4번이 링크 팀에 속한 경우에 두 팀의 능력치는 아래와 같다.스타트 팀: S12+ S21= 1 + 4 = 5링크 팀: S34+ S43= 2 + 5 = 71, 3번이 스타트 팀, 2, 4번이 링크 팀에 속하면, 두 팀의 능력치는 아래와 같다.스타트 팀: S13+ S31= 2 + 7 = 9링크 팀: S24+ S42= 6 + 4 = 10축구를 재미있게 하기 위해서 스타트 팀의 능력치와 링크 팀의 능력치의 차이를 최소로 하려고 한다. 위의 예제와 같은 경우에는 1, 4번이 스타트 팀, 2, 3번 팀이 링크 팀에 속하면 스타트 팀의 능력치는 6, 링크 팀의 능력치는 6이 되어서 차이가 0이 되고 이 값이 최소이다.",
    "input_description": "첫째 줄에 N(4 ≤ N ≤ 20, N은 짝수)이 주어진다. 둘째 줄부터 N개의 줄에 S가 주어진다. 각 줄은 N개의 수로 이루어져 있고, i번 줄의 j번째 수는 Sij이다. Sii는 항상 0이고, 나머지 Sij는 1보다 크거나 같고, 100보다 작거나 같은 정수이다.",
    "output_description": "첫째 줄에 스타트 팀과 링크 팀의 능력치의 차이의 최솟값을 출력한다.",
    "examples": [
      {
        "input": "4\r\n0 1 2 3\r\n4 0 5 6\r\n7 1 0 2\r\n3 4 5 0",
        "output": "0"
      },
      {
        "input": "6\r\n0 1 2 3 4 5\r\n1 0 2 3 4 5\r\n1 2 0 3 4 5\r\n1 2 3 0 4 5\r\n1 2 3 4 0 5\r\n1 2 3 4 5 0",
        "output": "2"
      },
      {
        "input": "8\r\n0 5 4 5 4 5 4 5\r\n4 0 5 1 2 3 4 5\r\n9 8 0 1 2 3 1 2\r\n9 9 9 0 9 9 9 9\r\n1 1 1 1 0 1 1 1\r\n8 7 6 5 4 0 3 2\r\n9 1 9 1 9 1 0 9\r\n6 5 4 3 2 1 9 0",
        "output": "1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/14889",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def backtrack(idx, count):\n    global min_diff\n    \n    if count == N // 2:\n        start = sum(S[i][j] for i in team for j in team)\n        link = sum(S[i][j] for i in range(N) if i not in team for j in range(N) if j not in team)\n        min_diff = min(min_diff, abs(start - link))\n        return\n    \n    for i in range(idx, N):\n        team.append(i)\n        backtrack(i + 1, count + 1)\n        team.pop()\n\nN = int(input())\nS = []\nfor _ in range(N):\n    S.append(list(map(int, input().split())))\n\nteam = []\nmin_diff = float('inf')\nbacktrack(0, 0)\nprint(min_diff)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "14894",
    "step_title": "세그먼트 트리 3",
    "title": "퀵 소트 cnt++",
    "level": 21,
    "tags": [
      "자료 구조",
      "세그먼트 트리",
      "분할 정복",
      "퍼시스턴트 세그먼트 트리"
    ],
    "description": "구사과는 N개의 서로 다른 양의 정수를 정렬하기 위해 아래와 같은 C++ 코드를 작성했다.long long cnt = 0;\r\nvector<int> sort(vector<int> &a) {\r\n    vector<int> less, greater;\r\n    if (a.size() <= 1) return a;\r\n    int pivot = a[(a.size()-1)/2];\r\n    int n = a.size();\r\n    for (int i=0; i<n; i++) {\r\n        cnt += 1;\r\n        if (a[i] < pivot) {\r\n            less.push_back(a[i]);\r\n        } else if (a[i] > pivot) {\r\n            greater.push_back(a[i]);\r\n        }\r\n    }\r\n    sort(less); sort(greater);\r\n    vector<int> ans;\r\n    ans.insert(ans.end(), less.begin(), less.end());\r\n    ans.push_back(pivot);\r\n    ans.insert(ans.end(), greater.begin(), greater.end());\r\n    return ans;\r\n}서로 다른 자연수 N개로 이루어진 배열A가 주어졌을 때, 이를sort함수를 이용해서 정렬했을 때,cnt에 들어있는 값을 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 N(1 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에는 배열 A에 들어있는 수가 공백으로 구분해 주어진다. 주어지는 수는 1부터 N까지의 수로 이루어진 순열이다.",
    "output_description": "입력으로 주어진 수를sort함수를 이용해 정렬했을 때,cnt에 들어있는 값을 출력한다.",
    "examples": [
      {
        "input": "5\r\n4 3 5 1 2",
        "output": "11"
      }
    ],
    "url": "https://www.acmicpc.net/problem/14894",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "14908",
    "step_title": "그리디 알고리즘 2",
    "title": "구두 수선공",
    "level": 15,
    "tags": [
      "그리디 알고리즘",
      "정렬"
    ],
    "description": "지금 구두 수선공에게는 손님으로부터 주문 받고 제작해야 할 작업이 N개 쌓여있다. 구두 수선공은 하루에 한 작업만 수행할 수 있고, i번째 작업을 완료하는 데 Ti일이 걸린다. 이때 Ti는 정수이고 1 ≤ Ti≤ 1000이다.i번째 작업을 시작하기 전에 하루가 지연될 때마다 구두 수선공은 보상금 Si센트를 지불해야 한다. 이때 Si는 정수이고 1 ≤ Si≤ 10000이다. 구두 수선공을 돕기 위해 최저 보상금을 지불하는 작업 순서를 정해야 한다.하루에 2개 이상의 작업을 동시에 수행할 수 없다. 작업 i를 수행하고 있는 경우, 작업 i를 마칠 때 까지 작업 i 외의 다른 작업을 수행할 수 없다.",
    "input_description": "1 ≤ N ≤ 1000 범위의 정수 N이 첫 번째 줄에 주어진다. 다음 N개 줄에 걸쳐서 첫 번째 열에는 T1… TN이 입력되며, 두 번째 열에는 S1… SN이 주어진다.",
    "output_description": "최소 보상금을 지불하는 작업 순서를 출력해야 한다. 모든 작업은 입력에서의 번호(1~N)로 표시해야 한다. 모든 정수는 한 줄로 표시해야 하며, 각 작업은 공백 문자로 구분한다. 여러 가지 해답이 나올 수 있다면 오름차순 정렬에 의해 가장 첫 번째 해답을 출력한다.",
    "examples": [
      {
        "input": "4\r\n3 4\r\n1 1000\r\n2 2\r\n5 5",
        "output": "2 1 3 4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/14908",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor num in sorted(arr):\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\narr.sort()\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sort() 메서드로 정렬",
            "description": "arr.sort()로 리스트를 제자리에서 정렬합니다.",
            "code_pattern": "arr.sort()",
            "socratic_hint": "리스트를 제자리에서 정렬하는 메서드는?",
            "hint": ".sort() 메서드를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문을 사용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor i in range(n-1):\n    for j in range(n-1-i):\n        if arr[j] > arr[j+1]:\n            arr[j], arr[j+1] = arr[j+1], arr[j]\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 패스 횟수 제어",
            "description": "n-1번 반복하며 각 패스를 수행합니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "버블 정렬에서 몇 번의 패스가 필요한가요?",
            "hint": "n-1번의 패스가 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "내부 반복문: 인접 원소 비교",
            "description": "각 패스에서 인접한 두 원소를 비교합니다. 이미 정렬된 뒤쪽 부분은 제외합니다.",
            "code_pattern": "for j in range(n-1-i):",
            "socratic_hint": "각 패스에서 비교해야 할 원소의 범위는?",
            "hint": "n-1-i까지 비교합니다 (이미 정렬된 부분 제외)."
          },
          {
            "step_id": 4,
            "goal": "원소 교환",
            "description": "왼쪽 원소가 오른쪽 원소보다 크면 위치를 교환합니다.",
            "code_pattern": "if arr[j] > arr[j+1]:\n    arr[j], arr[j+1] = arr[j+1], arr[j]",
            "socratic_hint": "인접한 두 원소의 순서가 잘못되었을 때 어떻게 하나요?",
            "hint": "두 원소의 위치를 swap합니다."
          },
          {
            "step_id": 5,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      },
      {
        "solution_id": 5,
        "solution_name": "풀이 5",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor i in range(n-1):\n    min_idx = i\n    for j in range(i+1, n):\n        if arr[j] < arr[min_idx]:\n            min_idx = j\n    arr[i], arr[min_idx] = arr[min_idx], arr[i]\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 정렬할 위치 선택",
            "description": "n-1번 반복하며 각 위치에 올 최솟값을 찾습니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "선택 정렬에서 몇 번의 선택이 필요한가요?",
            "hint": "n-1번의 선택이 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "최솟값 인덱스 초기화",
            "description": "현재 위치를 최솟값 인덱스로 가정합니다.",
            "code_pattern": "min_idx = i",
            "socratic_hint": "최솟값을 찾기 위한 초기값은?",
            "hint": "현재 위치 i를 초기값으로 설정합니다."
          },
          {
            "step_id": 4,
            "goal": "내부 반복문: 최솟값 찾기",
            "description": "현재 위치 이후의 원소들 중 최솟값의 인덱스를 찾습니다.",
            "code_pattern": "for j in range(i+1, n):\n    if arr[j] < arr[min_idx]:\n        min_idx = j",
            "socratic_hint": "정렬되지 않은 부분에서 최솟값을 어떻게 찾나요?",
            "hint": "i+1부터 끝까지 순회하며 최솟값 인덱스를 업데이트합니다."
          },
          {
            "step_id": 5,
            "goal": "원소 교환",
            "description": "찾은 최솟값을 현재 위치로 이동시킵니다.",
            "code_pattern": "arr[i], arr[min_idx] = arr[min_idx], arr[i]",
            "socratic_hint": "최솟값을 현재 위치로 가져오려면?",
            "hint": "현재 위치의 값과 최솟값을 swap합니다."
          },
          {
            "step_id": 6,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "15311",
    "step_title": "해 구성하기",
    "title": "약 팔기",
    "level": 16,
    "tags": [
      "수학",
      "애드 혹",
      "해 구성하기"
    ],
    "description": "약장수 강욱이는 오늘도 약을 판다. 짬에서 나오는 Vibe로 화려한 언변을 구사하는 강욱이는 최고의 약장수이다. 하지만 이런 그에게도 고민거리가 하나 있으니...동규라는 단골 손님이 있는데, 그는 매일 약을 $1$알에서 $100$만알 사이의 랜덤한 자연수 개수만큼 원했다. 주문을 받은 강욱이는 약 상자에서 한 알씩 약을 세서 꺼내주곤 했는데, 그것이 답답했던 동규는 강욱이에게 매번 화를 냈던 것이다.이러다 동규가 자기를 때리지 않을까 무서웠던 강욱이는 동규가 원하는 만큼의 약을 빨리 건네주기 위한 방법을 고민하기 시작했다. 그는 곧 소싯적에 공부했던Algorithm을 이용해 다음과 같은 방법을 생각해 냈다.'약 봉지 여러 개에 각각 적절한 수의 알약을 담아서 일렬로 늘어 놓은 뒤, 동규가 약을 $k$알 달라고 하면 총 $k$알의 약이 들어있는 어떤 연속한 구간의 약 봉지들을 한 번에 집어 주면 되겠군!'아쉽게도, 강욱이의 약 판매대는 봉지를 일렬로 최대 2000개까지만 올려놓을 수 있다. 강욱이는 적은 수의 봉지에 알약을 적절히 담아서 동규가 $100$만 이하의 어떤 수를 부르든 그 수에 해당하는 만큼의 약을 줄 수 있었으면 한다. 하지만 물리 공부를 하느라Algorithm공부를 열심히 하지 못한 강욱이는 어떻게 할지 몰라 쩔쩔매고 있다. 강욱이를 도와주자!",
    "input_description": "첫 번째 줄에 동규의 최대 약 요구량을 나타내는 정수 N ($=1\\, 000\\, 000$) 이 주어진다.",
    "output_description": "첫 번째 줄에는 필요한 약봉지의 개수 K ($1 \\le K \\le 2\\, 000$) 를 출력한다.두 번째 줄에는 왼쪽부터 순서대로 각 약봉지에 들어있어야 하는 약의 수를 출력한다. 각 봉지에는 $1$알 이상 $100$만알 이하의 약이 있어야 한다.",
    "examples": [
      {
        "input": "6",
        "output": "3\r\n1 3 2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/15311",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\n\nboxes = []\npower = 1\nremaining = N\n\nwhile remaining > 0:\n    if power <= remaining:\n        boxes.append(power)\n        remaining -= power\n        power *= 2\n    else:\n        boxes.append(remaining)\n        remaining = 0\n\nprint(len(boxes))\nprint(' '.join(map(str, boxes)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "15439",
    "step_title": "조합론",
    "title": "베라의 패션",
    "level": 2,
    "tags": [
      "구현",
      "조합론",
      "수학"
    ],
    "description": "베라는 상의 N 벌과 하의 N 벌이 있다. i 번째 상의와 i 번째 하의는 모두 색상 i를 가진다. N 개의 색상은 모두 서로 다르다.상의와 하의가 서로 다른 색상인 조합은 총 몇 가지일까?",
    "input_description": "입력은 아래와 같이 주어진다.N",
    "output_description": "상의와 하의가 서로 다른 색상인 조합의 가짓수를 출력한다.",
    "examples": [
      {
        "input": "1",
        "output": "0"
      },
      {
        "input": "2",
        "output": "2"
      },
      {
        "input": "5",
        "output": "20"
      }
    ],
    "url": "https://www.acmicpc.net/problem/15439",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nprint(N * (N-1))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "15552",
    "step_title": "반복문",
    "title": "빠른 A+B",
    "level": 2,
    "tags": [
      "구현",
      "사칙연산",
      "수학"
    ],
    "description": "본격적으로 for문 문제를 풀기 전에 주의해야 할 점이 있다. 입출력 방식이 느리면 여러 줄을 입력받거나 출력할 때 시간초과가 날 수 있다는 점이다.C++을 사용하고 있고cin/cout을 사용하고자 한다면,cin.tie(NULL)과sync_with_stdio(false)를 둘 다 적용해 주고,endl대신 개행문자(\\n)를 쓰자. 단, 이렇게 하면 더 이상scanf/printf/puts/getchar/putchar등 C의 입출력 방식을 사용하면 안 된다.Java를 사용하고 있다면,Scanner와System.out.println대신BufferedReader와BufferedWriter를 사용할 수 있다.BufferedWriter.flush는 맨 마지막에 한 번만 하면 된다.Python을 사용하고 있다면,input대신sys.stdin.readline을 사용할 수 있다. 단, 이때는 맨 끝의 개행문자까지 같이 입력받기 때문에 문자열을 저장하고 싶을 경우.rstrip()을 추가로 해 주는 것이 좋다.또한 입력과 출력 스트림은 별개이므로, 테스트케이스를 전부 입력받아서 저장한 뒤 전부 출력할 필요는 없다. 테스트케이스를 하나 받은 뒤 하나 출력해도 된다.자세한 설명 및 다른 언어의 경우는이 글에 설명되어 있다.이 블로그 글에서 BOJ의 기타 여러 가지 팁을 볼 수 있다.",
    "input_description": "첫 줄에 테스트케이스의 개수 T가 주어진다. T는 최대 1,000,000이다. 다음 T줄에는 각각 두 정수 A와 B가 주어진다. A와 B는 1 이상, 1,000 이하이다.",
    "output_description": "각 테스트케이스마다 A+B를 한 줄에 하나씩 순서대로 출력한다.",
    "examples": [
      {
        "input": "5\r\n1 1\r\n12 34\r\n5 500\r\n40 60\r\n1000 1000",
        "output": "2\r\n46\r\n505\r\n100\r\n2000"
      }
    ],
    "url": "https://www.acmicpc.net/problem/15552",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\ninput = sys.stdin.readline\nT = int(input())\nfor _ in range(T):\n    A, B = map(int, input().split())\n    print(A + B)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "필요한 모듈 임포트",
            "description": "프로그램 실행에 필요한 모듈을 임포트합니다.",
            "code_pattern": "import sys",
            "socratic_hint": "빠른 입력을 위해 어떤 모듈을 사용하나요?",
            "hint": "sys.stdin을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "정수 입력 받기",
            "description": "T = int(input())로 입력을 처리합니다.",
            "code_pattern": "T = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "여러 값 입력 받기",
            "description": "A, B = map(int, input().split())로 입력을 처리합니다.",
            "code_pattern": "A, B = map(int, input().split())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(T):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 5,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(A + B)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "15572",
    "step_title": "동적 계획법 5",
    "title": "블록 4",
    "level": 22,
    "tags": [
      "다이나믹 프로그래밍",
      "다항식을 이용한 선형점화식 계산"
    ],
    "description": "여러 가지 블록들을 이용하여 직사각형 모양을 만들려고 한다. 우리에게는 1 ×N블록, 2 ×N블록, ...,N×N블록이 무한하게 있다. 이 블록들을 사용하여N×M모양을 만들고 싶다. 만들 수 있는 총 방법의 수를 1999로 나눈 나머지를 구하여라.",
    "input_description": "첫 번째 줄에N과M이 입력된다. (1 ≤N≤ 103, 1 ≤M≤ 1010)",
    "output_description": "총 가능한 경우의 수를 1999로 나눈 나머지를 출력한다.",
    "examples": [
      {
        "input": "2 12",
        "output": "732"
      }
    ],
    "url": "https://www.acmicpc.net/problem/15572",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "15576",
    "step_title": "고속 푸리에 변환",
    "title": "큰 수 곱셈 (2)",
    "level": 20,
    "tags": [
      "수학",
      "고속 푸리에 변환"
    ],
    "description": "두 정수 A와 B가 주어졌을 때, 두 수의 곱을 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 정수 A와 B가 주어진다. 두 정수는 0보다 크거나 같은 정수이며, 0을 제외한 정수는 0으로 시작하지 않으며, 수의 앞에 불필요한 0이 있는 경우도 없다. 또한, 수의 길이는 300,000자리를 넘지 않는다.",
    "output_description": "두 수의 곱을 출력한다.",
    "examples": [
      {
        "input": "1 2",
        "output": "2"
      },
      {
        "input": "3 4",
        "output": "12"
      },
      {
        "input": "893724358493284 238947328947329",
        "output": "213553048277135320552236238436"
      }
    ],
    "url": "https://www.acmicpc.net/problem/15576",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "A, B = map(int, input().split())\nprint(A * B)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "여러 값 입력 받기",
            "description": "A, B = map(int, input().split())로 입력을 처리합니다.",
            "code_pattern": "A, B = map(int, input().split())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(A * B)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "15646",
    "step_title": "세그먼트 트리 3",
    "title": "농부 후안은 바리스타입니다",
    "level": 17,
    "tags": [
      "자료 구조",
      "세그먼트 트리",
      "차분 배열 트릭",
      "다차원 세그먼트 트리"
    ],
    "description": "농부 후안은 바리스타입니다. 후안은N×M크기의 커피 농장을 소유하고 있습니다. 후안은Q번 농장에 씨앗을 심거나 심은 씨앗의 영양의 합을 확인할 것입니다. 후안은 자신의 농장을 관리해줄 자동화 시스템이 필요합니다. 후안을 도와줍시다. 프로그램은 다음과 같은 두 동작을 수행해야 합니다.씨앗 심기 : x 좌표가 [x1,x2]에 포함되고 y 좌표가 [y1,y2]에 포함되는 모든 위치에 영양이d인 씨앗을 1개 심습니다.씨앗 개수 확인하기 : (x,y) 위치에 심은 씨앗의 영양의 합을 확인합니다.",
    "input_description": "N,M,Q가 첫 줄에 주어집니다. (1 ≤N,M≤ 5000, 0 ≤Q≤ 2 × 105)Q개의 줄 동안 수행해야 하는 동작이 주어집니다.첫 번째로 주어지는 숫자가 1이면 이는 씨앗을 심는 동작임을 뜻하며, 5개의 수 x1, y1, x2, y2, d가 주어집니다. (1 ≤x1≤x2≤N, 1 ≤y1≤y2≤M,  - 109≤d≤ 109)첫 번째로 주어지는 숫자가 2이면 이는 씨앗의 영양의 합을 확인하는 동작임을 뜻하며, 2개의 수x와y가 주어집니다. (1 ≤x≤N, 1 ≤y≤M)",
    "output_description": "모든 씨앗 개수를 확인하는 동작에 대해, 각각의 결과를 한 줄마다 출력합니다.",
    "examples": [
      {
        "input": "3 5 2\r\n1 1 1 3 5 2\r\n2 3 3",
        "output": "2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/15646",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "15647",
    "step_title": "트리에서의 동적 계획법",
    "title": "로스팅하는 엠마도 바리스타입니다",
    "level": 16,
    "tags": [
      "다이나믹 프로그래밍",
      "그래프 이론",
      "그래프 탐색",
      "트리",
      "트리에서의 다이나믹 프로그래밍",
      "트리에서의 전방향 다이나믹 프로그래밍"
    ],
    "description": "로스팅하는 엠마는 바리스타입니다. 엠마는N개의 정점을 가진 트리 형태의 농장 연결 시스템을 구축한 상태입니다. 트리의 정점은 1번부터 N번까지 번호가 매겨져 있습니다. 각각의 간선은 그 농장에서 다른 농장으로 이동할 수 있음을 뜻하며, 간선의 가중치는 이동 거리를 뜻합니다.엠마는 한 개의 농장을 정해 농장 옆에 로스팅 시설을 마련하려고 합니다. 이때, 다른 농장에서 로스팅 시설까지의 거리의 합들을 알아야, 효율적으로 로스팅 시설의 위치를 정할 수 있을 것입니다. 그러므로 각각의 농장마다 다른 농장들에서 그 농장으로 가는 최단 거리들의 합을 구해줍시다.",
    "input_description": "첫째 줄에N이 입력됩니다. (1 ≤N≤ 3 × 105)N-1 줄 동안 세 수u,v와d가 주어집니다. 이는u번째 농장과v번째 농장은 서로 연결되어 있으며, 그 거리는d임을 뜻합니다. (1 ≤u,v≤N, 1 ≤d≤ 5)주어지는 그래프는 트리입니다.",
    "output_description": "N개의 줄 동안 각각의 농장에 대해 다른 농장들에서 그 농장으로 가는 최단 거리들의 합을 출력합니다.",
    "examples": [
      {
        "input": "10\r\n1 2 1\r\n2 3 1\r\n2 4 1\r\n4 7 1\r\n4 8 1\r\n4 5 1\r\n1 6 1\r\n6 9 1\r\n6 10 1",
        "output": "19\r\n17\r\n25\r\n19\r\n27\r\n23\r\n27\r\n27\r\n31\r\n31"
      }
    ],
    "url": "https://www.acmicpc.net/problem/15647",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\nN = int(input())\ntree = [[] for _ in range(N + 1)]\n\nfor _ in range(N - 1):\n    a, b, c = map(int, input().split())\n    tree[a].append((b, c))\n    tree[b].append((a, c))\n\nmax_dist = [0] * (N + 1)\n\ndef dfs(node, parent):\n    max1 = max2 = 0\n    \n    for child, dist in tree[node]:\n        if child != parent:\n            child_max = dfs(child, node)\n            temp = child_max + dist\n            \n            if temp > max1:\n                max2 = max1\n                max1 = temp\n            elif temp > max2:\n                max2 = temp\n    \n    max_dist[node] = max1 + max2\n    return max1\n\ndfs(1, -1)\nprint(min(max_dist[1:N+1]))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "15648",
    "step_title": "세그먼트 트리 3",
    "title": "추출하는 폴도 바리스타입니다",
    "level": 17,
    "tags": [
      "다이나믹 프로그래밍",
      "자료 구조",
      "세그먼트 트리"
    ],
    "description": "추출하는 폴은 바리스타입니다. 폴에게는 커피콩N개가 순서대로 주어집니다. 폴은 이 중 몇 개를 골라서 추출할 예정입니다. 이때, 최종 결과물의 질이 좋아야 할 것입니다. 결과물의 질이 좋기 위해서는, 커피콩들의 종류(정수로 표현됩니다.)로 이루어진 수열의 부분수열을A라고 하면, 2 이상의 모든 i 에 대해Ai- 1≡Ai(modk) 나Ai- 1-d≤Ai≤Ai- 1+d를 만족함을 뜻합니다.폴을 위해서 질이 좋은 커피 추출물 중 가장 많은 커피콩을 고를 때 그 개수를 구해주세요.",
    "input_description": "첫째 줄에N,k와d가 주어집니다. (1 ≤N≤ 5 × 105, 1 ≤k,d≤ 5 × 105)N개의 커피콩의 순서와 각각의 번호를 나타내는 길이N의 배열S가 다음 줄에 주어집니다. (1 ≤Si≤ 5 × 105)",
    "output_description": "질이 좋은 커피 추출물 중 가장 많은 커피콩을 고를 때 그 개수를 출력합니다.",
    "examples": [
      {
        "input": "9 7 2\r\n1 5 12 10 8 6 4 4 3",
        "output": "8"
      }
    ],
    "url": "https://www.acmicpc.net/problem/15648",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "15649",
    "step_title": "백트래킹",
    "title": "N과 M (1)",
    "level": 8,
    "tags": [
      "백트래킹"
    ],
    "description": "자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열",
    "input_description": "첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)",
    "output_description": "한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.수열은 사전 순으로 증가하는 순서로 출력해야 한다.",
    "examples": [
      {
        "input": "3 1",
        "output": "1\r\n2\r\n3"
      },
      {
        "input": "4 2",
        "output": "1 2\r\n1 3\r\n1 4\r\n2 1\r\n2 3\r\n2 4\r\n3 1\r\n3 2\r\n3 4\r\n4 1\r\n4 2\r\n4 3"
      },
      {
        "input": "4 4",
        "output": "1 2 3 4\r\n1 2 4 3\r\n1 3 2 4\r\n1 3 4 2\r\n1 4 2 3\r\n1 4 3 2\r\n2 1 3 4\r\n2 1 4 3\r\n2 3 1 4\r\n2 3 4 1\r\n2 4 1 3\r\n2 4 3 1\r\n3 1 2 4\r\n3 1 4 2\r\n3 2 1 4\r\n3 2 4 1\r\n3 4 1 2\r\n3 4 2 1\r\n4 1 2 3\r\n4 1 3 2\r\n4 2 1 3\r\n4 2 3 1\r\n4 3 1 2\r\n4 3 2 1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/15649",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def backtrack(arr):\n    if len(arr) == M:\n        print(' '.join(map(str, arr)))\n        return\n    \n    for i in range(1, N+1):\n        if i not in arr:\n            arr.append(i)\n            backtrack(arr)\n            arr.pop()\n\nN, M = map(int, input().split())\nbacktrack([])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "15650",
    "step_title": "백트래킹",
    "title": "N과 M (2)",
    "level": 8,
    "tags": [
      "백트래킹"
    ],
    "description": "자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열고른 수열은 오름차순이어야 한다.",
    "input_description": "첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)",
    "output_description": "한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.수열은 사전 순으로 증가하는 순서로 출력해야 한다.",
    "examples": [
      {
        "input": "3 1",
        "output": "1\r\n2\r\n3"
      },
      {
        "input": "4 2",
        "output": "1 2\r\n1 3\r\n1 4\r\n2 3\r\n2 4\r\n3 4"
      },
      {
        "input": "4 4",
        "output": "1 2 3 4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/15650",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def backtrack(arr, start):\n    if len(arr) == M:\n        print(' '.join(map(str, arr)))\n        return\n    \n    for i in range(start, N+1):\n        arr.append(i)\n        backtrack(arr, i+1)\n        arr.pop()\n\nN, M = map(int, input().split())\nbacktrack([], 1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "15651",
    "step_title": "백트래킹",
    "title": "N과 M (3)",
    "level": 8,
    "tags": [
      "백트래킹"
    ],
    "description": "자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.1부터 N까지 자연수 중에서 M개를 고른 수열같은 수를 여러 번 골라도 된다.",
    "input_description": "첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 7)",
    "output_description": "한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.수열은 사전 순으로 증가하는 순서로 출력해야 한다.",
    "examples": [
      {
        "input": "3 1",
        "output": "1\r\n2\r\n3"
      },
      {
        "input": "4 2",
        "output": "1 1\r\n1 2\r\n1 3\r\n1 4\r\n2 1\r\n2 2\r\n2 3\r\n2 4\r\n3 1\r\n3 2\r\n3 3\r\n3 4\r\n4 1\r\n4 2\r\n4 3\r\n4 4"
      },
      {
        "input": "3 3",
        "output": "1 1 1\r\n1 1 2\r\n1 1 3\r\n1 2 1\r\n1 2 2\r\n1 2 3\r\n1 3 1\r\n1 3 2\r\n1 3 3\r\n2 1 1\r\n2 1 2\r\n2 1 3\r\n2 2 1\r\n2 2 2\r\n2 2 3\r\n2 3 1\r\n2 3 2\r\n2 3 3\r\n3 1 1\r\n3 1 2\r\n3 1 3\r\n3 2 1\r\n3 2 2\r\n3 2 3\r\n3 3 1\r\n3 3 2\r\n3 3 3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/15651",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def backtrack(arr):\n    if len(arr) == M:\n        print(' '.join(map(str, arr)))\n        return\n    \n    for i in range(1, N+1):\n        arr.append(i)\n        backtrack(arr)\n        arr.pop()\n\nN, M = map(int, input().split())\nbacktrack([])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "15652",
    "step_title": "백트래킹",
    "title": "N과 M (4)",
    "level": 8,
    "tags": [
      "백트래킹"
    ],
    "description": "자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.1부터 N까지 자연수 중에서 M개를 고른 수열같은 수를 여러 번 골라도 된다.고른 수열은 비내림차순이어야 한다.길이가 K인 수열 A가 A1≤ A2≤ ... ≤ AK-1≤ AK를 만족하면, 비내림차순이라고 한다.",
    "input_description": "첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)",
    "output_description": "한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.수열은 사전 순으로 증가하는 순서로 출력해야 한다.",
    "examples": [
      {
        "input": "3 1",
        "output": "1\r\n2\r\n3"
      },
      {
        "input": "4 2",
        "output": "1 1\r\n1 2\r\n1 3\r\n1 4\r\n2 2\r\n2 3\r\n2 4\r\n3 3\r\n3 4\r\n4 4"
      },
      {
        "input": "3 3",
        "output": "1 1 1\r\n1 1 2\r\n1 1 3\r\n1 2 2\r\n1 2 3\r\n1 3 3\r\n2 2 2\r\n2 2 3\r\n2 3 3\r\n3 3 3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/15652",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def backtrack(arr, start):\n    if len(arr) == M:\n        print(' '.join(map(str, arr)))\n        return\n    \n    for i in range(start, N + 1):\n        arr.append(i)\n        backtrack(arr, i)\n        arr.pop()\n\nN, M = map(int, input().split())\nbacktrack([], 1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "15678",
    "step_title": "스택, 큐, 덱 2",
    "title": "연세워터파크",
    "level": 16,
    "tags": [
      "다이나믹 프로그래밍",
      "자료 구조",
      "세그먼트 트리",
      "우선순위 큐",
      "덱",
      "덱을 이용한 구간 최댓값 트릭",
      "덱을 이용한 다이나믹 프로그래밍"
    ],
    "description": "(연세대학교 도서관, 2016년 7월)연세대학교에서는 매년 여름 깜짝 워터파크를 개장한다. 이 워터파크가 발생할 장소는 알 수 없지만, 보통 도서관이나 서문 쪽에 주로 개장한다는 사실만이 알려져 있다.워터파크 개장을 막는 것이 힘들다고 판단한 학교에서는 차라리 학생들이 워터파크를 더 즐길 수 있도록 정수 Ki(-109≤ Ki≤ 109)가 쓰여진 징검다리 N개를 놓아 두었다. 수업이 끝나고 친구들과 집에 가던 준호는 문득 이 징검다리를 이용해 여러 명이 즐길 수 있는 재미있는 게임을 하나 생각해냈다.각 사람은 시작점으로 쓸 징검다리 하나를 아무 것이나 하나 고른다.시작점에서 출발한 뒤 계속 점프하여 징검다리를 몇 개든 마음대로 밟은 뒤, 나오고 싶을 때 나온다. 시작점에서 바로 나오는 것도 가능하다.시작점을 포함해, 밟은 모든 징검다리에 쓰여진 정수의 합이 가장 큰 사람이 이긴다.이 규칙에 따라 게임을 하던 준호는, 제자리 점프를 이용해 10억점을 만드는 친구를 본 뒤 규칙을 좀 더 추가하기로 하였다. 추가된 규칙은 아래와 같다.N개의 모든 징검다리에 순서대로 1 ~ N의 번호를 붙인다. U번 징검다리에서 V번 징검다리로 점프하기 위해서는, U와 V의 차이가 미리 정해진 값 D 이하여야 한다.어떤 징검다리도 두 번 이상(한 번을 넘게) 밟을 수는 없다.이제 다시 게임을 진행하려 한다. 이 게임에서 준호는 최대 몇 점을 얻을 수 있을까?",
    "input_description": "첫 줄에 징검다리의 수 N과 문제에서 설명한 D가 주어진다. (2 ≤ N ≤ 105, 1 ≤ D ≤ N-1)이어 N개의 정수로, 각 징검다리에 쓰인 수 Ki가 1번 징검다리부터 N번 징검다리까지 순서대로 주어진다. (-109≤ Ki≤ 109)",
    "output_description": "가능한 최대 점수를 출력한다.",
    "examples": [
      {
        "input": "10 2\n2 7 -5 -4 10 -5 -5 -5 30 -10",
        "output": "40"
      },
      {
        "input": "3 2\n-4 -2 -7",
        "output": "-2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/15678",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import deque\n\nN, D = map(int, input().split())\nA = list(map(int, input().split()))\n\ndp = [float('-inf')] * N\ndp[0] = A[0]\ndq = deque([0])\n\nfor i in range(1, N):\n    while dq and dq[0] < i - D:\n        dq.popleft()\n    \n    if dq:\n        dp[i] = max(A[i], dp[dq[0]] + A[i])\n    else:\n        dp[i] = A[i]\n    \n    while dq and dp[dq[-1]] <= dp[i]:\n        dq.pop()\n    \n    dq.append(i)\n\nprint(max(dp))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "15681",
    "step_title": "트리에서의 동적 계획법",
    "title": "트리와 쿼리",
    "level": 11,
    "tags": [
      "다이나믹 프로그래밍",
      "그래프 이론",
      "그래프 탐색",
      "트리",
      "깊이 우선 탐색",
      "트리에서의 다이나믹 프로그래밍"
    ],
    "description": "간선에 가중치와 방향성이 없는 임의의 루트 있는 트리가 주어졌을 때, 아래의 쿼리에 답해보도록 하자.정점 U를 루트로 하는 서브트리에 속한 정점의 수를 출력한다.만약 이 문제를 해결하는 데에 어려움이 있다면, 하단의 힌트에 첨부한 문서를 참고하자.",
    "input_description": "트리의 정점의 수 N과 루트의 번호 R, 쿼리의 수 Q가 주어진다. (2 ≤ N ≤ 105, 1 ≤ R ≤ N, 1 ≤ Q ≤ 105)이어 N-1줄에 걸쳐, U V의 형태로 트리에 속한 간선의 정보가 주어진다. (1 ≤ U, V ≤ N, U ≠ V)이는 U와 V를 양 끝점으로 하는 간선이 트리에 속함을 의미한다.이어 Q줄에 걸쳐, 문제에 설명한 U가 하나씩 주어진다. (1 ≤ U ≤ N)입력으로 주어지는 트리는 항상 올바른 트리임이 보장된다.",
    "output_description": "Q줄에 걸쳐 각 쿼리의 답을 정수 하나로 출력한다.",
    "examples": [
      {
        "input": "9 5 3\r\n1 3\r\n4 3\r\n5 4\r\n5 6\r\n6 7\r\n2 3\r\n9 6\r\n6 8\r\n5\r\n4\r\n8",
        "output": "9\r\n4\r\n1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/15681",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\ndef dfs(node):\n    size[node] = 1\n    for child in tree[node]:\n        if size[child] == 0:\n            size[node] += dfs(child)\n    return size[node]\n\nN, R, Q = map(int, input().split())\ntree = [[] for _ in range(N + 1)]\nsize = [0] * (N + 1)\n\nfor _ in range(N - 1):\n    U, V = map(int, input().split())\n    tree[U].append(V)\n    tree[V].append(U)\n\ndfs(R)\n\nfor _ in range(Q):\n    U = int(input())\n    print(size[U])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "15718",
    "step_title": "수학 2",
    "title": "돌아온 떡파이어",
    "level": 18,
    "tags": [
      "수학",
      "정수론",
      "조합론",
      "중국인의 나머지 정리",
      "뤼카 정리"
    ],
    "description": "떡파이어의 불로장생의 비밀은 바로 떡국이다.떡파이어는 떡국을 먹은 그릇의 개수만큼 나이를 먹는다. 그들은 매일 떡국을 먹는데, 떡국을 먹는대로 바로 소화가 가능하기 때문에 하루에 얼마든지 원하는 만큼 떡국을 먹을 수 있다. 그러나 전에 떡국을 얼마나 먹었든지, 그들은 기구하게도 떡국을 하루라도 먹지 않으면 생을 마감하게 된다.어느 날, 디디는 어떤 떡파이어가 M째날에 N세로 생을 마감하기까지 어떤 생을 살아왔는지 알고 싶어서, 그의 나이를 먹는 과정의 경우의 수를 세려고 한다. 그렇지만, 떡파이어의 나이가 많을 수록 그 경우의 수는 무수히 많아지기 때문에 디디는 곤란해하고 있다.그런 디디를 위해 M째날에 N세로 생을 마감한 떡파이어가 나이를 먹는 과정의 경우의 수를 세는 프로그램을 작성해야 한다.떡파이어의 나이는 0세부터 시작된다.N = 3, M = 3,일때를 예로 들면,첫째 날 1개 둘째 날 2개, 셋째 날 0개첫째 날 2개 둘째 날 1개, 셋째 날 0개총 경우의 수는 2이다.",
    "input_description": "첫째 줄에 테스트 케이스의 수 T(1 ≤ T ≤ 1000)가 주어진다.각 테스트 케이스는 한 줄로 이루어져 있으며, 정수 N(0 ≤ N ≤ 109)과 M(1 ≤ M ≤ 109)이 공백으로 구분되어 주어진다.",
    "output_description": "각 테스트 케이스마다 한 줄에 하나씩 나이를 먹는 방법의 가짓 수를 100007로 나눈 나머지를 출력하시오. 100007은 일반적이지 않은 나눗수임에 유의하라.",
    "examples": [
      {
        "input": "1\r\n3 3",
        "output": "2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/15718",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 수학 문제 기본 구조\ndef solve():\n    # 입력 처리\n    N = int(input())\n    \n    # 계산\n    result = N\n    \n    return result\n\nprint(solve())",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "15894",
    "step_title": "기하 1: 직사각형과 삼각형",
    "title": "수학은 체육과목 입니다",
    "level": 3,
    "tags": [
      "사칙연산",
      "수학"
    ],
    "description": "성원이는 수학을 정말 못 하는 고등학생이다. 수학을 못하는 대신 근성과 팔 힘이 뛰어난 성원이는 수학 시험에서 수학 지식을 사용하지 않고 근성과 체력을 사용해 문제를 푼다. 지난 시험에서는 아래 사진에 나와있는 문제를 근성과 체력을 사용해 열심히 풀었지만 사진에서 볼 수 있듯이 틀려버리고 말았다!결국 이 문제는 틀려버렸지만 성원이는 여전히 자신의 체력에 강한 자신감을 갖고 있다. 어떤 어려운 문제가 나와도 이런 식으로 근성과 체력을 사용하면 다 풀 수 있으니 이 방법은 최고의 방법이라고 생각하고 있다.성원이의 친구 형석이는 근성과 체력으로 수학 문제를 푸는 것은 굉장히 무식한 방법이라고 생각한다. 형석이는 수학을 공부하면 문제를 훨씬 빨리 풀 수 있다는 것을 알려주기 위해 위 사진에 나와있는 문제를 갖고 성원이와 퀴즈 내기를 하기로 했다. 위 사진의 문제를 다시 정리하면 아래와 같다.\"한 변의 길이가 1인 정사각형을 아래 그림과 같이 겹치지 않게 빈틈없이 계속 붙여 나간다. 가장 아랫부분의 정사각형이 n개가 되었을 때, 실선으로 이루어진 도형의 둘레의 길이를 구하시오.\"가장 아랫부분의 정사각형 개수가 주어지면 그에 해당하는 답을 출력하는 프로그램을 만들어 형석이를 도와주자!",
    "input_description": "첫 번째 줄에 가장 아랫부분의 정사각형 개수 n이 주어진다. (1 ≤ n ≤ 109)",
    "output_description": "첫 번째 줄에 형석이가 말해야 하는 답을 출력한다.",
    "examples": [
      {
        "input": "1",
        "output": "4"
      },
      {
        "input": "3",
        "output": "12"
      }
    ],
    "url": "https://www.acmicpc.net/problem/15894",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "n = int(input())\nprint(n * 4)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "n = int(input())로 입력을 처리합니다.",
            "code_pattern": "n = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(n * 4)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "15899",
    "step_title": "세그먼트 트리 2",
    "title": "트리와 색깔",
    "level": 19,
    "tags": [
      "자료 구조",
      "정렬",
      "트리",
      "세그먼트 트리",
      "오일러 경로 테크닉",
      "머지 소트 트리"
    ],
    "description": "1부터 N까지의 번호가 부여된 N개의 정점과 N-1개의 간선으로 구성된 트리가 있다. 이 트리의 루트는 1번 정점이며, 임의의 한 정점과 다른 정점 사이의 경로가 반드시 한 개 존재한다.트리의 각 정점은 특정 색깔을 가지고 있다. 편의상 색깔은 1 이상 C 이하의 자연수로 표현된다. 이때, 질의 f(v,c)를 다음과 같이 정의하자.f(v, c) : 정점 v가 루트인 부트리(sub-tree)에서 색깔이 c 이하인 정점의 개수M개의 질의 f(vi, ci)가 주어질 때, 각 질의에 대한 답을 계산하는 프로그램을 작성하시오.",
    "input_description": "첫 번째 줄에 정점의 수를 나타내는 N(1 ≤ N ≤ 2×105), 질의의 개수를 나타내는 M(1 ≤ M ≤ 2×105), 정점의 색깔 종류를 나타내는 C(1 ≤ C ≤ N)가 공백 하나를 사이에 두고 차례로 주어진다.두 번째 줄에는 각 정점의 색깔을 나타내는 N개의 정수가 공백으로 구분되어 순서대로 주어진다. 첫 번째 수는 1번 정점의 색깔이며, ..., N 번째 수는 N번 정점의 색깔이다.세 번째 줄부터 N-1개의 줄에 걸쳐서 트리를 이루는 각 간선의 정보가 주어진다. 각 간선의 정보는 해당 간선을 이루는 서로 다른 두 정점의 번호로 구성된다. 각 정점의 번호는 1 이상 N 이하의 자연수이다.이후, 이어서 M개의 줄에 걸쳐서 i번째 줄에 i번째 질의의 정보 vi, ci가 공백으로 구분되어 주어진다. vi는 1 이상 N 이하의 정점 번호를 나타낸다. ci는 1 이상 C 이하의 색깔 정보를 나타낸다.",
    "output_description": "M개의 질의에 대한 정답을 모두 더한 뒤, 1,000,000,007로 나눈 나머지를 출력한다.",
    "examples": [
      {
        "input": "5 5 3\r\n1 2 1 3 3\r\n1 2\r\n2 3\r\n3 4\r\n4 5\r\n1 1\r\n1 3\r\n3 2\r\n4 3\r\n5 3",
        "output": "11"
      },
      {
        "input": "4 2 2\r\n1 2 2 2\r\n1 2\r\n1 3\r\n1 4\r\n1 1\r\n1 2",
        "output": "5"
      }
    ],
    "url": "https://www.acmicpc.net/problem/15899",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 그래프 문제 기본 구조\nfrom collections import deque\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\n# BFS/DFS 구현\nvisited = [False] * (N + 1)\n\ndef bfs(start):\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        node = queue.popleft()\n        for next_node in graph[node]:\n            if not visited[next_node]:\n                visited[next_node] = True\n                queue.append(next_node)\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor num in sorted(arr):\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\narr.sort()\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sort() 메서드로 정렬",
            "description": "arr.sort()로 리스트를 제자리에서 정렬합니다.",
            "code_pattern": "arr.sort()",
            "socratic_hint": "리스트를 제자리에서 정렬하는 메서드는?",
            "hint": ".sort() 메서드를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문을 사용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor i in range(n-1):\n    for j in range(n-1-i):\n        if arr[j] > arr[j+1]:\n            arr[j], arr[j+1] = arr[j+1], arr[j]\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 패스 횟수 제어",
            "description": "n-1번 반복하며 각 패스를 수행합니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "버블 정렬에서 몇 번의 패스가 필요한가요?",
            "hint": "n-1번의 패스가 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "내부 반복문: 인접 원소 비교",
            "description": "각 패스에서 인접한 두 원소를 비교합니다. 이미 정렬된 뒤쪽 부분은 제외합니다.",
            "code_pattern": "for j in range(n-1-i):",
            "socratic_hint": "각 패스에서 비교해야 할 원소의 범위는?",
            "hint": "n-1-i까지 비교합니다 (이미 정렬된 부분 제외)."
          },
          {
            "step_id": 4,
            "goal": "원소 교환",
            "description": "왼쪽 원소가 오른쪽 원소보다 크면 위치를 교환합니다.",
            "code_pattern": "if arr[j] > arr[j+1]:\n    arr[j], arr[j+1] = arr[j+1], arr[j]",
            "socratic_hint": "인접한 두 원소의 순서가 잘못되었을 때 어떻게 하나요?",
            "hint": "두 원소의 위치를 swap합니다."
          },
          {
            "step_id": 5,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      },
      {
        "solution_id": 5,
        "solution_name": "풀이 5",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor i in range(n-1):\n    min_idx = i\n    for j in range(i+1, n):\n        if arr[j] < arr[min_idx]:\n            min_idx = j\n    arr[i], arr[min_idx] = arr[min_idx], arr[i]\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 정렬할 위치 선택",
            "description": "n-1번 반복하며 각 위치에 올 최솟값을 찾습니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "선택 정렬에서 몇 번의 선택이 필요한가요?",
            "hint": "n-1번의 선택이 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "최솟값 인덱스 초기화",
            "description": "현재 위치를 최솟값 인덱스로 가정합니다.",
            "code_pattern": "min_idx = i",
            "socratic_hint": "최솟값을 찾기 위한 초기값은?",
            "hint": "현재 위치 i를 초기값으로 설정합니다."
          },
          {
            "step_id": 4,
            "goal": "내부 반복문: 최솟값 찾기",
            "description": "현재 위치 이후의 원소들 중 최솟값의 인덱스를 찾습니다.",
            "code_pattern": "for j in range(i+1, n):\n    if arr[j] < arr[min_idx]:\n        min_idx = j",
            "socratic_hint": "정렬되지 않은 부분에서 최솟값을 어떻게 찾나요?",
            "hint": "i+1부터 끝까지 순회하며 최솟값 인덱스를 업데이트합니다."
          },
          {
            "step_id": 5,
            "goal": "원소 교환",
            "description": "찾은 최솟값을 현재 위치로 이동시킵니다.",
            "code_pattern": "arr[i], arr[min_idx] = arr[min_idx], arr[i]",
            "socratic_hint": "최솟값을 현재 위치로 가져오려면?",
            "hint": "현재 위치의 값과 최솟값을 swap합니다."
          },
          {
            "step_id": 6,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "16139",
    "step_title": "누적 합",
    "title": "인간-컴퓨터 상호작용",
    "level": 10,
    "tags": [
      "누적 합"
    ],
    "description": "승재는 인간-컴퓨터 상호작용에서 생체공학 설계를 공부하다가 키보드 자판이 실용적인지 궁금해졌다. 이를 알아보기 위해 승재는 다음과 같은 생각을 했다.'문자열에서 특정 알파벳이 몇 번 나타나는지 알아봐서 자주 나타나는 알파벳이 중지나 검지 위치에 오는 알파벳인지 확인하면 실용적인지 확인할 수 있을 것이다.'승재를 도와 특정 문자열 $S$, 특정 알파벳 $\\alpha$와 문자열의 구간 $[l,r]$이 주어지면 $S$의 $l$번째 문자부터 $r$번째 문자 사이에 $\\alpha$가 몇 번 나타나는지 구하는 프로그램을 작성하여라. 승재는 문자열의 문자는 $0$번째부터 세며, $l$번째와 $r$번째 문자를 포함해서 생각한다. 주의할 점은 승재는 호기심이 많기에 (통계적으로 크게 무의미하지만) 같은 문자열을 두고 질문을 $q$번 할 것이다.",
    "input_description": "첫 줄에 문자열 $S$가 주어진다. 문자열의 길이는 $200,000$자 이하이며 알파벳 소문자로만 구성되었다. 두 번째 줄에는 질문의 수 $q$가 주어지며, 문제의 수는 $1\\leq q\\leq 200,000$을 만족한다. 세 번째 줄부터 $(q+2)$번째 줄에는 질문이 주어진다. 각 질문은 알파벳 소문자 $\\alpha_i$와 $0\\leq l_i\\leq r_i<|S|$를 만족하는 정수 $l_i,r_i$가 공백으로 구분되어 주어진다.",
    "output_description": "각 질문마다 줄을 구분해 순서대로 답변한다. $i$번째 줄에 $S$의 $l_i$번째 문자부터 $r_i$번째 문자 사이에 $\\alpha_i$가 나타나는 횟수를 출력한다.",
    "examples": [
      {
        "input": "seungjaehwang\r\n4\r\na 0 5\r\na 0 6\r\na 6 10\r\na 7 10",
        "output": "0\r\n1\r\n2\r\n1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/16139",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "s = input().strip()\nq = int(input())\n\n# 누적 합 배열\nn = len(s)\nprefix = [[0] * 26 for _ in range(n + 1)]\n\nfor i in range(n):\n    for j in range(26):\n        prefix[i+1][j] = prefix[i][j]\n    prefix[i+1][ord(s[i]) - ord('a')] += 1\n\nfor _ in range(q):\n    parts = input().split()\n    char = parts[0]\n    l = int(parts[1])\n    r = int(parts[2])\n    \n    char_idx = ord(char) - ord('a')\n    result = prefix[r+1][char_idx] - prefix[l][char_idx]\n    print(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "16163",
    "step_title": "문자열 알고리즘 2",
    "title": "#15164번_제보",
    "level": 16,
    "tags": [
      "문자열",
      "매내처"
    ],
    "description": "안녕 백준대숲 사람들, 억울한 일이 있어요.악랄한이회문은 회문아니야!!이런 문제를 냈어요. 근데 푼 사람이 너무 많은 거예요!내가 이걸 안 풀 순 없지...생각하면서 고통받으면서M어쩌구랑offline BIT‍를 짰다?근데솔루션을 보니까 내가 멍청한 거예요ㅠㅠ 백주뉴ㅠㅠ 그들이 절 기만했어요ㅠㅠㅠ그래서 다시는 낚이지 않겠다고 생각했어요.근데 얼마 전에 대회를 치면서가장 긴 증가하는 팰린드롬 부분수열문제를 봤어요.열심히 생각했는데M어쩌구 말고는 생각이 안 나서와 이번엔 진짜M어쩌구다생각하면서 열심히M어쩌구를 짰다?근데 이번에도 낚인 거예요ㅠㅠㅠㅠ 사람들 코드 길이가 다 너무 짧아ㅠㅠㅠㅠㅠㅠ 키파 너무 멍청해요ㅠㅠㅠ이제 키파는 기만자들에게 복수의 철퇴를 날릴 거예요. 그러니까 여러분이 부분 문자열 중 회문인 것의 개수를 구하는 프로그램을 작성해 주세요! 😈",
    "input_description": "길이가 1 이상 200만 이하인 문자열을 드릴게요. 알파벳 대문자로만 이루어져 있어요!",
    "output_description": "주어진 문자열의 부분 문자열 중 회문인 것의 개수를 출력해 주세요!",
    "examples": [
      {
        "input": "ABCBA",
        "output": "7"
      }
    ],
    "url": "https://www.acmicpc.net/problem/16163",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "16229",
    "step_title": "문자열 알고리즘 2",
    "title": "반복 패턴",
    "level": 17,
    "tags": [
      "문자열",
      "z"
    ],
    "description": "현욱은 반복되는 패턴에서 안정감을 느낀다. 그래서 모든 것을 반복되는 형태로 만들고 싶어한다. 현욱은 우선 가지고 있는 모든 책의 텍스트를 반복되는 형태로 만들려고 마음 먹었다.동일한 문자열을 두 번이상 반복해서 만들 수 있는 문자열을 반복 패턴을 갖고 있다고 말한다. 예를 들어, abdeabde 같은 경우 abde를 두 번 이상 반복해서 만들 수 있으니 반복 패턴을 갖고 있고, abcefabce 같은 경우 어떻게 해도 동일한 문자열을 반복해서 덧붙이는 방식으로는 만들 수 없으니 반복 패턴을 갖고 있지 않는 문자열이다.현욱은 책에 적힌 텍스트를 반복되는 패턴으로 만들려고 한다. 기존 문자열의 내용은 책에 인쇄되어 있기 때문에 변경할 수 없지만, 뒤에 종이를 덧붙여서 내용을 추가할 수는 있다. 하지만 너무 많은 글을 추가하면 팔이 아프기 때문에 최대K글자의 문자만 덧붙이려고 한다.이 때, 책의 텍스트를 반복되는 패턴으로 만들었을 때 그 패턴의 길이가 길 수록 현욱은 만족감을 느낀다. 단, 과도한 변화는 부자연스러우니 패턴의 길이는 최대N글자로 한다. 현욱을 도와 어떻게 하면 가장 긴 패턴을 만들 수 있는지 계산해보자.",
    "input_description": "문자열의 길이N(1 ≤N≤ 100,000), 덧붙일 수 있는 문자의 개수K(0 ≤K≤ 100,000)가 주어진다.두번째 줄에 길이N짜리 영어 소문자로만 이루어진 문자열S가 주어진다.",
    "output_description": "K글자 이하의 문자를 덧붙여서S를 반복되는 패턴으로 만들었을 때 만들어질 수 있는 길이N이하의 패턴의 최대 길이를 출력한다. 반복되는 패턴으로 만들 수 없으면 0을 출력한다.",
    "examples": [
      {
        "input": "8 0\nabdeabde",
        "output": "4"
      },
      {
        "input": "5 4\nabcde",
        "output": "0"
      },
      {
        "input": "5 5\nabcde",
        "output": "5"
      },
      {
        "input": "5 3\nababa",
        "output": "4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/16229",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "16357",
    "step_title": "세그먼트 트리 2",
    "title": "Circuits",
    "level": 20,
    "tags": [
      "자료 구조",
      "세그먼트 트리",
      "스위핑",
      "느리게 갱신되는 세그먼트 트리",
      "값 / 좌표 압축"
    ],
    "description": "There are a number of electronic circuits, such as CPU’s, ROM’s, RAM’s, to be printed in a single chip consisting of multiple layers. Due to some design restriction, there can be only two electrical wires that are horizontal segments. Your job is to find two horizontal wires that together connect as many circuits as possible so that the electric signals go through the circuits.This problem can be stated formally as follows. There arenaxis-aligned rectangles in the plane. Each of the rectangles represents a circuit to be printed in the chip. The rectangles may overlap each other. You are supposed to find two horizontal lines such that the total number of rectangles intersected by the two lines is maximized. We also say that a rectangle is intersected by a horizontal line if the line contains the top side or the bottom side of the rectangle. If a rectangle is intersected by both the lines, it is counted only once for the total number.For example, let’s consider 5 rectangles shown in Figure A.1. Figure A.1(c) shows two horizontal lines (red dashed lines) that intersect all 5 rectangles while the two horizontal lines (red dashed lines) in Figure A.1(b) intersect 4 rectangles.Figure A.1: (a) 5 axis-aligned rectangles. (b) Two horizontal lines that intersect 4 rectangles. (c) Two horizontal lines that intersect 5 rectangles.Given a set of axis-aligned rectangles, write a program to find two horizontal lines such that the total number of rectangles intersected by the two lines is maximized.",
    "input_description": "Your program is to read from standard input. The first line contains a positive integernrepresenting the number of axis-aligned rectangles in the plane, where 3 ≤n≤ 100,000. It is followed bynlines, each contains four integersux,uy,vxandvy(withux<vxanduy>vy) representing the (x, y)-coordinates, (ux,uy), of the top-left corner and the (x, y)-coordinates, (vx,vy), of the bottom-right corner of an axisaligned rectangle, where −10,000,000 ≤ux,uy,vx,vy≤ 10,000,000.",
    "output_description": "Your program is to write to standard output. Print exactly one line. The line should contain the maximum total number of rectangles that can be intersected by two horizontal lines.",
    "examples": [
      {
        "input": "5\r\n0 13 4 4\r\n2 14 11 9\r\n7 17 12 12\r\n3 5 16 0\r\n5 2 13 1",
        "output": "5"
      },
      {
        "input": "5\r\n0 4 4 0\r\n1 3 3 1\r\n5 8 9 4\r\n0 12 4 8\r\n1 11 3 9",
        "output": "4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/16357",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "16367",
    "step_title": "강한 연결 요소",
    "title": "TV Show Game",
    "level": 19,
    "tags": [
      "그래프 이론",
      "강한 연결 요소",
      "역추적",
      "2-sat"
    ],
    "description": "Mr. Dajuda, who is famous for a TV show program, occasionally suggests an interesting game for the audience and gives them some gifts as a prize. The game he suggested this week can be explained as follows.Thek(> 3) lamps on the stage are all turned off at the beginning of the game. For convenience, lamps are numbered from 1 tok. Each lamp has a color, either red or blue. However, the color of a lamp cannot be identified until it is turned on. Game participants are asked to select three lamps at random and to guess the colors of them. Then each participant submits a paper on which the predicted colors of selected lamps are recorded to Mr. Dajuda, the game host. When all the lamps are turned on, each participant checks how many predicted colors match the actual colors of the lamps. If two or more colors match, he/she will receive a nice gift as a prize.Mr. Dajuda prepared a special gift today. That is, after reviewing all the papers received from the game participants he tries to adjust the color of each lamp so that every participant can receive a prize if possible.Given information about the predicted colors as explained above, write a program that determines whether the colors of all the lamps can be adjusted so that all the participants can receive prizes.",
    "input_description": "Your program is to read from standard input. The input starts with a line containing two integers,kandn(3 <k≤ 5,000, 1 ≤n≤ 10,000), wherekis the number of lamps andnthe number of game participants. Each of the followingnlines contains three pairs of (l,c), wherelis the lamp number he/she selected andcis a character, eitherBfor blue orRfor red, which denotes the color he/she guessed for the lamp. There is a blank betweenlandcand each pair of (l,c) is separated by a blank as well as shown in following samples.",
    "output_description": "Your program is to write to standard output. If it is possible that all the colors can be adjusted so that every participant can receive a prize, printkcharacters in a line. Theithcharacter, eitherBfor blue orRfor red represents the color of theithlamp. If impossible, print -1. If there are more than one answer, you can print out any of them.",
    "examples": [
      {
        "input": "7 5\r\n3 R 5 R 6 B\r\n1 B 2 B 3 R\r\n4 R 5 B 6 B\r\n5 R 6 B 7 B\r\n1 R 2 R 4 R",
        "output": "BRRRBBB"
      },
      {
        "input": "5 6\r\n1 B 3 R 4 B\r\n2 B 3 R 4 R\r\n1 B 2 R 3 R\r\n3 R 4 B 5 B\r\n3 B 4 B 5 B\r\n1 R 2 R 4 R",
        "output": "-1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/16367",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\ndef dfs1(v):\n    visited[v] = True\n    for next_v in graph[v]:\n        if not visited[next_v]:\n            dfs1(next_v)\n    stack.append(v)\n\ndef dfs2(v, scc_num):\n    scc_id[v] = scc_num\n    for next_v in reverse_graph[v]:\n        if scc_id[next_v] == -1:\n            dfs2(next_v, scc_num)\n\nN, M = map(int, input().split())\n\ngraph = [[] for _ in range(2 * N + 1)]\nreverse_graph = [[] for _ in range(2 * N + 1)]\n\ndef get_node(x):\n    if x > 0:\n        return x\n    else:\n        return N + abs(x)\n\ndef get_not(x):\n    if x <= N:\n        return x + N\n    else:\n        return x - N\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[get_not(get_node(a))].append(get_node(b))\n    graph[get_not(get_node(b))].append(get_node(a))\n    reverse_graph[get_node(b)].append(get_not(get_node(a)))\n    reverse_graph[get_node(a)].append(get_not(get_node(b)))\n\nvisited = [False] * (2 * N + 1)\nstack = []\n\nfor i in range(1, 2 * N + 1):\n    if not visited[i]:\n        dfs1(i)\n\nscc_id = [-1] * (2 * N + 1)\nscc_num = 0\n\nwhile stack:\n    v = stack.pop()\n    if scc_id[v] == -1:\n        dfs2(v, scc_num)\n        scc_num += 1\n\n# 2-SAT 가능 여부 확인\npossible = True\nfor i in range(1, N + 1):\n    if scc_id[i] == scc_id[N + i]:\n        possible = False\n        break\n\nprint(1 if possible else 0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "16496",
    "step_title": "그리디 알고리즘 2",
    "title": "큰 수 만들기",
    "level": 16,
    "tags": [
      "그리디 알고리즘",
      "정렬"
    ],
    "description": "음이 아닌 정수가 N개 들어있는 리스트가 주어졌을 때, 리스트에 포함된 수를 나열하여 만들 수 있는 가장 큰 수를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 리스트에 포함된 수가 주어진다. 수는 공백으로 구분되어져 있고, 1,000,000,000보다 작거나 같은 음이 아닌 정수 이다. 0을 제외한 나머지 수는 0으로 시작하지 않으며, 0이 주어지는 경우 0 하나가 주어진다.",
    "output_description": "리스트에 포함된 수를 나열하여 만들 수 있는 가장 큰 수를 출력한다. 수는 0으로 시작하면 안되며, 0이 정답인 경우 0 하나를 출력해야 한다.",
    "examples": [
      {
        "input": "5\r\n3 30 34 5 9",
        "output": "9534330"
      },
      {
        "input": "5\r\n0 0 0 0 1",
        "output": "10000"
      }
    ],
    "url": "https://www.acmicpc.net/problem/16496",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from functools import cmp_to_key\n\nn = int(input())\nnums = input().split()\n\nnums.sort(key=cmp_to_key(lambda a, b: -1 if a+b > b+a else (1 if a+b < b+a else 0)))\nresult = ''.join(nums)\n\nprint(0 if result[0] == '0' else result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor num in sorted(arr):\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3",
        "solution_code": "from functools import cmp_to_key\n\nn = int(input())\nnums = input().split()\n\ndef compare(a, b):\n    if a + b > b + a:\n        return -1\n    elif a + b < b + a:\n        return 1\n    else:\n        return 0\n\nnums.sort(key=cmp_to_key(compare))\nresult = ''.join(nums)\n\nif result[0] == '0':\n    print(0)\nelse:\n    print(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 패스 횟수 제어",
            "description": "n-1번 반복하며 각 패스를 수행합니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "버블 정렬에서 몇 번의 패스가 필요한가요?",
            "hint": "n-1번의 패스가 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "내부 반복문: 인접 원소 비교",
            "description": "각 패스에서 인접한 두 원소를 비교합니다. 이미 정렬된 뒤쪽 부분은 제외합니다.",
            "code_pattern": "for j in range(n-1-i):",
            "socratic_hint": "각 패스에서 비교해야 할 원소의 범위는?",
            "hint": "n-1-i까지 비교합니다 (이미 정렬된 부분 제외)."
          },
          {
            "step_id": 4,
            "goal": "원소 교환",
            "description": "왼쪽 원소가 오른쪽 원소보다 크면 위치를 교환합니다.",
            "code_pattern": "if arr[j] > arr[j+1]:\n    arr[j], arr[j+1] = arr[j+1], arr[j]",
            "socratic_hint": "인접한 두 원소의 순서가 잘못되었을 때 어떻게 하나요?",
            "hint": "두 원소의 위치를 swap합니다."
          },
          {
            "step_id": 5,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "16883",
    "step_title": "스프라그 그런디 정리",
    "title": "대각 게임",
    "level": 21,
    "tags": [
      "구현",
      "다이나믹 프로그래밍",
      "게임 이론",
      "홀짝성",
      "스프라그–그런디 정리"
    ],
    "description": "구사과와 큐브러버는 대각 게임을 하려고 한다.대각 게임은 크기가 N×M인 격자에서 진행되며, 격자의 각 칸에는 L, R, X 중 하나의 글자가 적혀져 있다. 각 칸은 상태를 가지고 있는데, 활성과 비활성 중 하나이다. 가장 처음에 모든 칸의 상태는 활성이다.게임은 턴을 번갈아가면서 진행되고, 구사과가 먼저 턴을 갖는다. 각 턴은 활성 상태의 칸 하나를 골라야 하며, 고른 칸에 적힌 글자에 따라 다른 효과가 발생한다.L: 고른 칸과 왼쪽 아래 대각선 방향과 오른쪽 위 대각선 방향에 있는 칸이 비활성으로 변한다. 이 효과는 대각선 방향으로 연속해서 발생하며, 비활성 칸을 만나거나 격자를 벗어나면 연속이 끝난다. 즉, 고른 칸이 (r, c)이면, 비활성 칸을 만나기 전까지 (r+1, c-1), (r+2, c-2), ..., 그리고, (r-1, c+1,), (r-2, c+2), ... 칸이 모두 비활성으로 변한다.R: L과의 차이는 방향이며, 방향은 왼쪽 위 방향과 오른쪽 아래 방향이다.X: L과 R을 합친 효과이다.모든 칸이 비활성으로 변해 고를 칸이 없으면 게임에서 진다.두 사람이 최적의 방법으로 게임을 진행했을 때, 누가 이기는지 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 격자의 크기 N과 M (1 ≤ N, M ≤ 20)이 주어진다. 둘째 줄부터 N개의 줄에 격자에 적힌 문자가 주어진다.",
    "output_description": "구사과가 이기는 경우에는 \"koosaga\", 큐브러버가 이기는 경우에는 \"cubelover\"를 출력한다.",
    "examples": [
      {
        "input": "2 2\nRL\nLR",
        "output": "cubelover"
      },
      {
        "input": "2 2\nRR\nRR",
        "output": "koosaga"
      },
      {
        "input": "7 7\nLLLLXXL\nLXRRXXL\nXLXLRRL\nXRXRLXL\nXRXLXRL\nLXXXXRL\nRLLXLXR",
        "output": "koosaga"
      },
      {
        "input": "9 9\nLLXLXRRRX\nLLRXXRXLR\nXLRXXXLXL\nRXXRLLRRR\nLRLLRXXRX\nLLLLRLRLX\nXXXLLXXLX\nRLXLLRXLL\nRLRRRRLXX",
        "output": "cubelover"
      }
    ],
    "url": "https://www.acmicpc.net/problem/16883",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "16928",
    "step_title": "그래프와 순회",
    "title": "뱀과 사다리 게임",
    "level": 11,
    "tags": [
      "그래프 이론",
      "그래프 탐색",
      "너비 우선 탐색"
    ],
    "description": "뱀과 사다리 게임을 즐겨 하는 큐브러버는 어느 날 궁금한 점이 생겼다.주사위를 조작해 내가 원하는 수가 나오게 만들 수 있다면, 최소 몇 번만에 도착점에 도착할 수 있을까?게임은 정육면체 주사위를 사용하며, 주사위의 각 면에는 1부터 6까지 수가 하나씩 적혀있다. 게임은 크기가 10×10이고, 총 100개의 칸으로 나누어져 있는 보드판에서 진행된다. 보드판에는 1부터 100까지 수가 하나씩 순서대로 적혀져 있다.플레이어는 주사위를 굴려 나온 수만큼 이동해야 한다. 예를 들어, 플레이어가 i번 칸에 있고, 주사위를 굴려 나온 수가 4라면, i+4번 칸으로 이동해야 한다. 만약 주사위를 굴린 결과가 100번 칸을 넘어간다면 이동할 수 없다. 도착한 칸이 사다리면, 사다리를 타고 위로 올라간다. 뱀이 있는 칸에 도착하면, 뱀을 따라서 내려가게 된다. 즉, 사다리를 이용해 이동한 칸의 번호는 원래 있던 칸의 번호보다 크고, 뱀을 이용해 이동한 칸의 번호는 원래 있던 칸의 번호보다 작아진다.게임의 목표는 1번 칸에서 시작해서 100번 칸에 도착하는 것이다.게임판의 상태가 주어졌을 때, 100번 칸에 도착하기 위해 주사위를 굴려야 하는 횟수의 최솟값을 구해보자.",
    "input_description": "첫째 줄에 게임판에 있는 사다리의 수 N(1 ≤ N ≤ 15)과 뱀의 수 M(1 ≤ M ≤ 15)이 주어진다.둘째 줄부터 N개의 줄에는 사다리의 정보를 의미하는 x, y (x < y)가 주어진다. x번 칸에 도착하면, y번 칸으로 이동한다는 의미이다.다음 M개의 줄에는 뱀의 정보를 의미하는 u, v (u > v)가 주어진다. u번 칸에 도착하면, v번 칸으로 이동한다는 의미이다.1번 칸과 100번 칸은 뱀과 사다리의 시작 또는 끝이 아니다. 모든 칸은 최대 하나의 사다리 또는 뱀을 가지고 있으며, 동시에 두 가지를 모두 가지고 있는 경우는 없다. 항상 100번 칸에 도착할 수 있는 입력만 주어진다.",
    "output_description": "100번 칸에 도착하기 위해 주사위를 최소 몇 번 굴려야 하는지 출력한다.",
    "examples": [
      {
        "input": "3 7\n32 62\n42 68\n12 98\n95 13\n97 25\n93 37\n79 27\n75 19\n49 47\n67 17",
        "output": "3"
      },
      {
        "input": "4 9\n8 52\n6 80\n26 42\n2 72\n51 19\n39 11\n37 29\n81 3\n59 5\n79 23\n53 7\n43 33\n77 21",
        "output": "5"
      }
    ],
    "url": "https://www.acmicpc.net/problem/16928",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import deque\n\nN, M = map(int, input().split())\n\nboard = list(range(101))\n\nfor _ in range(N + M):\n    x, y = map(int, input().split())\n    board[x] = y\n\nvisited = [False] * 101\nqueue = deque([(1, 0)])\nvisited[1] = True\n\nwhile queue:\n    pos, count = queue.popleft()\n    \n    if pos == 100:\n        print(count)\n        break\n    \n    for dice in range(1, 7):\n        next_pos = pos + dice\n        if next_pos <= 100 and not visited[next_pos]:\n            visited[next_pos] = True\n            queue.append((board[next_pos], count + 1))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "16975",
    "step_title": "세그먼트 트리 1",
    "title": "수열과 쿼리 21",
    "level": 17,
    "tags": [
      "자료 구조",
      "세그먼트 트리",
      "느리게 갱신되는 세그먼트 트리",
      "차분 배열 트릭"
    ],
    "description": "길이가 N인 수열 A1, A2, ..., AN이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.1 i j k: Ai, Ai+1, ..., Aj에 k를 더한다.2 x: Ax를 출력한다.",
    "input_description": "첫째 줄에 수열의 크기 N (1 ≤ N ≤ 100,000)이 주어진다.둘째 줄에는 A1, A2, ..., AN이 주어진다. (1 ≤ Ai≤ 1,000,000)셋째 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.넷째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. 1번 쿼리의 경우 1 ≤ i ≤ j ≤ N, -1,000,000 ≤ k ≤ 1,000,000 이고, 2번 쿼리의 경우 1 ≤ x ≤ N이다. 2번 쿼리는 하나 이상 주어진다.",
    "output_description": "2번 쿼리가 주어질 때마다 출력한다.",
    "examples": [
      {
        "input": "5\r\n1 2 3 4 5\r\n4\r\n1 3 4 6\r\n2 3\r\n1 1 3 -2\r\n2 3",
        "output": "9\r\n7"
      }
    ],
    "url": "https://www.acmicpc.net/problem/16975",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "16993",
    "step_title": "세그먼트 트리 3",
    "title": "연속합과 쿼리",
    "level": 20,
    "tags": [
      "자료 구조",
      "세그먼트 트리",
      "최대 부분 배열 문제"
    ],
    "description": "길이가 N인 수열 A1, A2, ..., AN이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.i j: Ai, Ai+1, ..., Aj에서 가장 큰 연속합을 출력한다. (1 ≤ i ≤ j ≤ N)수열의 인덱스는 1부터 시작한다.연속합은 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합이며, 수는 한 개 이상 선택해야 한다.",
    "input_description": "첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 100,000)둘째 줄에는 A1, A2, ..., AN이 주어진다. (-1,000 ≤ Ai≤ 1,000)셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 100,000)넷째 줄부터 M개의 줄에는 쿼리가 주어진다.",
    "output_description": "쿼리의 정답을 한 줄에 하나씩 순서대로 출력한다.",
    "examples": [
      {
        "input": "10\n10 -4 3 1 5 6 -35 12 21 -1\n10\n1 1\n3 4\n1 6\n2 6\n6 6\n7 7\n8 9\n8 10\n1 10\n5 8",
        "output": "10\n4\n21\n15\n6\n-35\n33\n33\n33\n12"
      }
    ],
    "url": "https://www.acmicpc.net/problem/16993",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "17082",
    "step_title": "그리디 알고리즘 2",
    "title": "쿼리와 쿼리",
    "level": 17,
    "tags": [
      "자료 구조",
      "그리디 알고리즘",
      "집합과 맵",
      "스위핑",
      "트리를 사용한 집합과 맵"
    ],
    "description": "겨울이 가고 날이 풀리자, 택희는 겨울 옷을 세탁해 보관하고, 한참 동안 입지 않았던 후드를 하나 꺼냈다. 옷을 입던 택희는 후드의 주머니 안에 무언가 들어있음을 알아차렸다. 놀랍게도, 후드의 왼쪽 주머니와 오른쪽 주머니 안에는, 정확히M개씩의 정수가 들어 있었다.택희는 2018 연세대학교 교내 경진대회 문제에 사용했던 수열 하나를 꺼내 깨끗이 닦았다. 수열은N개의 정수로 이루어져 있으며, 인덱스는 1, 2, …,N으로 매겨진다. 택희는 이 수열과 주머니에서 발견한 정수들을 이용해 ‘쿼리 놀이’를 하기로 했다.쿼리 놀이는 아래와 같이 진행된다.왼쪽 주머니에서 하나의 정수를 꺼낸다. 이 값을L이라 한다.오른쪽 주머니에서 하나의 정수를 꺼낸다. 이 값을R이라 한다.L≤R이라면 수열의 [L,R] 구간 내에서 최댓값을 찾고, 그 값을 종이에 기록한다.L>R이라면 종이에 109을 기록한다. 그 후, 사용한L과R은 버린다.주머니가 빌 때까지 위의 작업을 반복한다.이 놀이가 끝나고 나면, 종이에는M개의 정수가 쓰여 있을 것이다. 택희는 이 놀이를 반복하다가, 종이에 쓰인 정수M개 중 최댓값을 최소화한다면 얼마가 될 지 궁금해졌다. 그리고 기왕 궁금해하는 김에, 수열의 두 원소의 위치를 바꾸는 쿼리 형태로 궁금해하기로 했다. 게다가 이런 궁금증이 무려Q번 생겨났다!택희의 쿼리 놀이에 대한 쿼리를 효율적으로 처리해 줄 프로그램을 작성해보도록 하자.",
    "input_description": "첫째 줄에 수열의 길이N, 왼쪽 주머니와 오른쪽 주머니에 들어 있는 정수의 개수M, 쿼리의 개수Q가 주어진다. (1 ≤N,M,Q≤ 200,000)둘째 줄에는 공백으로 구분된 수열의 원소ai가N개 주어진다. (-109≤ai≤ 109)셋째 줄에는 왼쪽 주머니에 들어 있는 정수li가M개 주어진다. (1 ≤li≤N)넷째 줄에는 오른쪽 주머니에 들어 있는 정수ri가M개 주어진다. (1 ≤ri≤N)다섯째 줄부터Q+4번째 줄까지, 쿼리에 대한 정보i j가 주어진다. 이는ai와aj를 서로 바꾸겠다는 의미이다. (1 ≤i,j≤N)모든 쿼리는 누적된다.",
    "output_description": "Q줄에 걸쳐, 수열 변경 직후에 대해, 놀이의 결과 정수M개 중 최댓값의 가능한 최솟값을 출력한다.",
    "examples": [
      {
        "input": "5 2 3\n-2 0 1 2 -1\n1 2\n4 2\n2 3\n4 5\n1 5",
        "output": "2\n1\n2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/17082",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "17103",
    "step_title": "약수, 배수와 소수 2",
    "title": "골드바흐 파티션",
    "level": 9,
    "tags": [
      "수학",
      "정수론",
      "소수 판정",
      "에라토스테네스의 체"
    ],
    "description": "골드바흐의 추측: 2보다 큰 짝수는 두 소수의 합으로 나타낼 수 있다.짝수 N을 두 소수의 합으로 나타내는 표현을 골드바흐 파티션이라고 한다. 짝수 N이 주어졌을 때, 골드바흐 파티션의 개수를 구해보자. 두 소수의 순서만 다른 것은 같은 파티션이다.",
    "input_description": "첫째 줄에 테스트 케이스의 개수 T (1 ≤ T ≤ 100)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 N은 짝수이고, 2 < N ≤ 1,000,000을 만족한다.",
    "output_description": "각각의 테스트 케이스마다 골드바흐 파티션의 수를 출력한다.",
    "examples": [
      {
        "input": "5\r\n6\r\n8\r\n10\r\n12\r\n100",
        "output": "1\r\n1\r\n2\r\n1\r\n6"
      }
    ],
    "url": "https://www.acmicpc.net/problem/17103",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def sieve(n):\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n + 1, i):\n                is_prime[j] = False\n    \n    return is_prime\n\nis_prime = sieve(1000000)\n\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    count = 0\n    \n    for i in range(2, N // 2 + 1):\n        if is_prime[i] and is_prime[N - i]:\n            count += 1\n    \n    print(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "17131",
    "step_title": "스위핑",
    "title": "여우가 정보섬에 올라온 이유",
    "level": 18,
    "tags": [
      "자료 구조",
      "세그먼트 트리",
      "스위핑"
    ],
    "description": "여우가 정보섬에 올라왔다!오늘도 하늘에는 아름다운 별들이 빛나고 있다. 정보섬은 언덕 꼭대기에 위치해 있기 때문에 별이 잘 보이기로 유명하다. 그래서인지, 여우 한 마리가 정보섬에 올라와 밤하늘을 바라보며 별자리를 만들고 있다. 여우는 세 개의 별을 연결하여 V형 별자리를 만드는데, 그 이유는 V가 자신의 얼굴과 닮았기 때문이라나 뭐라나. 여우는 자신의 시점을 기준으로 생각하기 때문에, V가 회전한 모양(<, >, ㄴ, ㄱ, ^ 등)은 V라고 생각하지 않는다.여우는 만들 수 있는 V형 별자리의 총 개수가 궁금해졌다. 그러나 일일이 세보기에는 별이 너무 많았기 때문에, 여우는 뛰어난 프로그래머인 당신에게 도움을 요청했다! 귀여운 여우를 위해 얼마나 많은 V형 별자리가 만들어질 수 있는지 계산해 주자.V형 별자리를 명확하게 정의하면 다음과 같다. 세 별 (s,t,u)가s.x < t.x < u.x이고s.y > t.y < u.y이면 V형 별자리이다. 예를 들어 아래의 '정보섬의 밤하늘 참고도'에서 (a,b,c)는 V형 별자리를 이루지만 (d,b,c)는 d.x < b.x가 아니므로 V형 별자리가 아니다. V형 별자리의 개수를 셀 때, 한 별이 여러 별자리에 속할 수 있다.답이 매우 커질 수 있으므로 (109+7)로 나눈 나머지를 출력한다.",
    "input_description": "첫 줄에 별의 개수 N이 주어진다. 그 다음 줄부터 N개의 줄에 걸쳐 별의 좌표 x y가 주어진다.",
    "output_description": "(만들 수 있는 V형 별자리의 개수) mod (109+7)을 출력한다.",
    "examples": [
      {
        "input": "4\r\n-1 1\r\n0 0\r\n1 1\r\n0 1",
        "output": "1"
      },
      {
        "input": "10\r\n-2 0\r\n-1 0\r\n0 0\r\n1 0\r\n2 0\r\n-2 1\r\n-1 1\r\n0 1\r\n1 1\r\n2 1",
        "output": "10"
      }
    ],
    "url": "https://www.acmicpc.net/problem/17131",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "17134",
    "step_title": "고속 푸리에 변환",
    "title": "르모앙의 추측",
    "level": 20,
    "tags": [
      "수학",
      "정수론",
      "소수 판정",
      "에라토스테네스의 체",
      "고속 푸리에 변환"
    ],
    "description": "골드바흐의 추측: 2보다 큰 짝수는 두 소수의 합으로 나타낼 수 있다.골드바흐의 약한 추측: 5보다 큰 홀수는 세 소수의 합으로 나타낼 수 있다.르모앙의 추측: 5보다 큰 홀수는 홀수 소수 하나와 짝수 세미소수 하나의 합으로 나타낼 수 있다. 세미소수는 두 소수를 곱한 수이다.홀수 N이 주어졌을 때, 홀수 소수 하나와 짝수 세미소수 하나의 합으로 나타내는 방법의 수를 구해보자.",
    "input_description": "첫째 줄에 테스트 케이스의 개수 T (1 ≤ T ≤ 100,000)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 N은 홀수이고, 5 < N ≤ 1,000,000을 만족한다.",
    "output_description": "각각의 테스트 케이스마다 홀수 소수 하나와 짝수 세미소수 하나의 합으로 나타내는 방법의 수를 출력한다.",
    "examples": [
      {
        "input": "6\r\n9\r\n11\r\n17\r\n19\r\n1929\r\n1999",
        "output": "2\r\n2\r\n4\r\n2\r\n65\r\n30"
      }
    ],
    "url": "https://www.acmicpc.net/problem/17134",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 수학 문제 기본 구조\ndef solve():\n    # 입력 처리\n    N = int(input())\n    \n    # 계산\n    result = N\n    \n    return result\n\nprint(solve())",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "17298",
    "step_title": "스택, 큐, 덱 2",
    "title": "오큰수",
    "level": 12,
    "tags": [
      "자료 구조",
      "스택"
    ],
    "description": "크기가 N인 수열 A = A1, A2, ..., AN이 있다. 수열의 각 원소 Ai에 대해서 오큰수 NGE(i)를 구하려고 한다. Ai의 오큰수는 오른쪽에 있으면서 Ai보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오큰수는 -1이다.예를 들어, A = [3, 5, 2, 7]인 경우 NGE(1) = 5, NGE(2) = 7, NGE(3) = 7, NGE(4) = -1이다. A = [9, 5, 4, 8]인 경우에는 NGE(1) = -1, NGE(2) = 8, NGE(3) = 8, NGE(4) = -1이다.",
    "input_description": "첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄에 수열 A의 원소 A1, A2, ..., AN(1 ≤ Ai≤ 1,000,000)이 주어진다.",
    "output_description": "총 N개의 수 NGE(1), NGE(2), ..., NGE(N)을 공백으로 구분해 출력한다.",
    "examples": [
      {
        "input": "4\n3 5 2 7",
        "output": "5 7 7 -1"
      },
      {
        "input": "4\n9 5 4 8",
        "output": "-1 8 8 -1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/17298",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nA = list(map(int, input().split()))\n\nresult = [-1] * N\nstack = []\n\nfor i in range(N):\n    while stack and A[stack[-1]] < A[i]:\n        result[stack.pop()] = A[i]\n    stack.append(i)\n\nprint(' '.join(map(str, result)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "17299",
    "step_title": "스택, 큐, 덱 2",
    "title": "오등큰수",
    "level": 13,
    "tags": [
      "자료 구조",
      "스택"
    ],
    "description": "크기가 N인 수열 A = A1, A2, ..., AN이 있다. 수열의 각 원소 Ai에 대해서 오등큰수 NGF(i)를 구하려고 한다.Ai가 수열 A에서 등장한 횟수를 F(Ai)라고 했을 때, Ai의 오등큰수는 오른쪽에 있으면서 수열 A에서 등장한 횟수가 F(Ai)보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오등큰수는 -1이다.예를 들어, A = [1, 1, 2, 3, 4, 2, 1]인 경우 F(1) = 3, F(2) = 2, F(3) = 1, F(4) = 1이다. A1의 오른쪽에 있으면서 등장한 횟수가 3보다 큰 수는 없기 때문에, NGF(1) = -1이다. A3의 경우에는 A7이 오른쪽에 있으면서 F(A3=2) < F(A7=1) 이기 때문에, NGF(3) = 1이다. NGF(4) = 2, NGF(5) = 2, NGF(6) = 1 이다.",
    "input_description": "첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째에 수열 A의 원소 A1, A2, ..., AN(1 ≤ Ai≤ 1,000,000)이 주어진다.",
    "output_description": "총 N개의 수 NGF(1), NGF(2), ..., NGF(N)을 공백으로 구분해 출력한다.",
    "examples": [
      {
        "input": "7\n1 1 2 3 4 2 1",
        "output": "-1 -1 1 2 2 1 -1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/17299",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import Counter\n\nN = int(input())\nA = list(map(int, input().split()))\n\nfreq = Counter(A)\nresult = [-1] * N\nstack = []\n\nfor i in range(N):\n    while stack and freq[A[stack[-1]]] < freq[A[i]]:\n        result[stack.pop()] = A[i]\n    stack.append(i)\n\nprint(' '.join(map(str, result)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "17353",
    "step_title": "세그먼트 트리 3",
    "title": "하늘에서 떨어지는 1, 2, ..., R-L+1개의 별",
    "level": 19,
    "tags": [
      "자료 구조",
      "세그먼트 트리",
      "느리게 갱신되는 세그먼트 트리",
      "차분 배열 트릭"
    ],
    "description": "욱제의 은밀한 취미 중 하나는 매일 밤하늘을 감상하는 것이다. 😓 욱제는 하늘의 별들이 다음과 같은 규칙들을 따르며 떨어지는 걸 관찰했다.별이 떨어지는 위치는 N개의 점이다. 점은 순서대로1, 2, ..., N의 번호를 갖는다.매일 밤 별들은1, 2, ..., N의 연속한 부분 구간 [L, R]에 떨어진다.[L, R]에 별이 떨어지면, 각 점에는 순서대로1, 2, ..., R-L+1개의 별이 떨어진다. 다시 말해, L에는 1개, L+1에는 2개, ..., R에는 R-L+1개의 별이 떨어진다.욱제는 하늘에서 떨어지는 별들을 기록하다가 잠이 들어버렸다!! 혹시나 했지만 역시나, 여러분은 욱제를 대신해 아래의 쿼리를 수행해야 한다. (ㅎㅎ;; ㅈㅅ.. ㅋㅋ!!)1 L R: [L, R]에 별이 떨어진다. (1 ≤ L ≤ R ≤ N)2 X: 점 X에 떨어진 별의 개수의 합을 출력한다. (1 ≤ X ≤ N)",
    "input_description": "첫째 줄에 별이 떨어지는 점의 개수 N이 주어진다. (1 ≤ N ≤ 105)둘째 줄에 욱제가 잠들기 전까지 세어 놓은, 이미 떨어진 별들의 개수 A1, ..., AN이 공백을 사이에 두고 주어진다. (0 ≤ A1, ..., AN≤ 106)셋째 줄에는 쿼리의 개수 Q가 주어진다. (1 ≤ Q ≤ 105)넷째 줄부터 Q개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.",
    "output_description": "2번 쿼리에 대한 답을 한 줄에 하나씩 출력한다.",
    "examples": [
      {
        "input": "5\n1 2 1 2 1\n4\n1 1 5\n2 5\n1 2 5\n2 5",
        "output": "6\n10"
      }
    ],
    "url": "https://www.acmicpc.net/problem/17353",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "17386",
    "step_title": "기하 2",
    "title": "선분 교차 1",
    "level": 13,
    "tags": [
      "기하학",
      "선분 교차 판정"
    ],
    "description": "2차원 좌표 평면 위의 두 선분 L1, L2가 주어졌을 때, 두 선분이 교차하는지 아닌지 구해보자.L1의 양 끝 점은 (x1, y1), (x2, y2), L2의 양 끝 점은 (x3, y3), (x4, y4)이다.",
    "input_description": "첫째 줄에 L1의 양 끝 점 x1, y1, x2, y2가, 둘째 줄에 L2의 양 끝 점 x3, y3, x4, y4가 주어진다. 세 점이 일직선 위에 있는 경우는 없다.",
    "output_description": "L1과 L2가 교차하면 1, 아니면 0을 출력한다.",
    "examples": [
      {
        "input": "1 1 5 5\n1 5 5 1",
        "output": "1"
      },
      {
        "input": "1 1 5 5\n6 10 10 6",
        "output": "0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/17386",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def ccw(x1, y1, x2, y2, x3, y3):\n    return (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1)\n\nx1, y1, x2, y2 = map(int, input().split())\nx3, y3, x4, y4 = map(int, input().split())\n\nccw1 = ccw(x1, y1, x2, y2, x3, y3)\nccw2 = ccw(x1, y1, x2, y2, x4, y4)\nccw3 = ccw(x3, y3, x4, y4, x1, y1)\nccw4 = ccw(x3, y3, x4, y4, x2, y2)\n\nif ccw1 * ccw2 < 0 and ccw3 * ccw4 < 0:\n    print(1)\nelse:\n    print(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "17387",
    "step_title": "기하 2",
    "title": "선분 교차 2",
    "level": 14,
    "tags": [
      "기하학",
      "많은 조건 분기",
      "선분 교차 판정"
    ],
    "description": "2차원 좌표 평면 위의 두 선분 L1, L2가 주어졌을 때, 두 선분이 교차하는지 아닌지 구해보자. 한 선분의 끝 점이 다른 선분이나 끝 점 위에 있는 것도 교차하는 것이다.L1의 양 끝 점은 (x1, y1), (x2, y2), L2의 양 끝 점은 (x3, y3), (x4, y4)이다.",
    "input_description": "첫째 줄에 L1의 양 끝 점 x1, y1, x2, y2가, 둘째 줄에 L2의 양 끝 점 x3, y3, x4, y4가 주어진다.",
    "output_description": "L1과 L2가 교차하면 1, 아니면 0을 출력한다.",
    "examples": [
      {
        "input": "1 1 5 5\n1 5 5 1",
        "output": "1"
      },
      {
        "input": "1 1 5 5\n6 10 10 6",
        "output": "0"
      },
      {
        "input": "1 1 5 5\n5 5 1 1",
        "output": "1"
      },
      {
        "input": "1 1 5 5\n3 3 5 5",
        "output": "1"
      },
      {
        "input": "1 1 5 5\n3 3 1 3",
        "output": "1"
      },
      {
        "input": "1 1 5 5\n5 5 9 9",
        "output": "1"
      },
      {
        "input": "1 1 5 5\n6 6 9 9",
        "output": "0"
      },
      {
        "input": "1 1 5 5\n5 5 1 5",
        "output": "1"
      },
      {
        "input": "1 1 5 5\n6 6 1 5",
        "output": "0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/17387",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def ccw(x1, y1, x2, y2, x3, y3):\n    return (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1)\n\nx1, y1, x2, y2 = map(int, input().split())\nx3, y3, x4, y4 = map(int, input().split())\n\nccw1 = ccw(x1, y1, x2, y2, x3, y3)\nccw2 = ccw(x1, y1, x2, y2, x4, y4)\nccw3 = ccw(x3, y3, x4, y4, x1, y1)\nccw4 = ccw(x3, y3, x4, y4, x2, y2)\n\nif ccw1 * ccw2 == 0 and ccw3 * ccw4 == 0:\n    if min(x1, x2) <= max(x3, x4) and min(x3, x4) <= max(x1, x2) and        min(y1, y2) <= max(y3, y4) and min(y3, y4) <= max(y1, y2):\n        print(1)\n    else:\n        print(0)\nelif ccw1 * ccw2 <= 0 and ccw3 * ccw4 <= 0:\n    print(1)\nelse:\n    print(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "17404",
    "step_title": "동적 계획법 3",
    "title": "RGB거리 2",
    "level": 12,
    "tags": [
      "다이나믹 프로그래밍"
    ],
    "description": "RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.1번 집의 색은 2번, N번 집의 색과 같지 않아야 한다.N번 집의 색은 N-1번, 1번 집의 색과 같지 않아야 한다.i(2 ≤ i ≤ N-1)번 집의 색은 i-1, i+1번 집의 색과 같지 않아야 한다.",
    "input_description": "첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다. 집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.",
    "output_description": "첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.",
    "examples": [
      {
        "input": "3\n26 40 83\n49 60 57\n13 89 99",
        "output": "110"
      },
      {
        "input": "3\n1 100 100\n100 1 100\n100 100 1",
        "output": "3"
      },
      {
        "input": "3\n1 100 100\n100 100 100\n1 100 100",
        "output": "201"
      },
      {
        "input": "6\n30 19 5\n64 77 64\n15 19 97\n4 71 57\n90 86 84\n93 32 91",
        "output": "208"
      },
      {
        "input": "8\n71 39 44\n32 83 55\n51 37 63\n89 29 100\n83 58 11\n65 13 15\n47 25 29\n60 66 19",
        "output": "253"
      }
    ],
    "url": "https://www.acmicpc.net/problem/17404",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\ncost = []\nfor _ in range(N):\n    cost.append(list(map(int, input().split())))\n\nINF = float('inf')\nresult = INF\n\nfor first in range(3):\n    dp = [[INF] * 3 for _ in range(N)]\n    dp[0][first] = cost[0][first]\n    \n    for i in range(1, N):\n        dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + cost[i][0]\n        dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + cost[i][1]\n        dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + cost[i][2]\n    \n    for last in range(3):\n        if first != last:\n            result = min(result, dp[N-1][last])\n\nprint(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "17409",
    "step_title": "세그먼트 트리 3",
    "title": "증가 수열의 개수",
    "level": 17,
    "tags": [
      "다이나믹 프로그래밍",
      "자료 구조",
      "세그먼트 트리"
    ],
    "description": "크기가 N인 수열 A와 정수 K가 주어졌을 때, A의 증가하는 부분 수열 중에서 길이가 K인 것의 개수를 구해보자.",
    "input_description": "첫째 줄에 N, K가 주어진다. 둘째 줄에 수열 A1, A2, ..., AN이 주어진다.",
    "output_description": "첫째 줄에 A의 증가하는 부분 수열 중에서 길이가 K인 것의 개수를 109+7로 나눈 나머지를 출력한다.",
    "examples": [
      {
        "input": "5 1\n1 2 3 5 4",
        "output": "5"
      },
      {
        "input": "5 2\n1 2 3 5 4",
        "output": "9"
      },
      {
        "input": "5 3\n1 2 3 5 4",
        "output": "7"
      },
      {
        "input": "5 4\n1 2 3 5 4",
        "output": "2"
      },
      {
        "input": "5 5\n1 2 3 5 4",
        "output": "0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/17409",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "17412",
    "step_title": "네트워크 플로우 1",
    "title": "도시 왕복하기 1",
    "level": 17,
    "tags": [
      "그래프 이론",
      "최대 유량"
    ],
    "description": "N개의 도시가 P개의 단방향 길로 연결되어 있다. 이석원은 1번 도시와 2번 도시 사이를 가며 워해머를 한다. 성실한 이석원은 1번에서 2번으로 가는 서로 다른 경로를 최대한 많이 찾으려고 하는데, 이때 한 경로에 포함된 길이 다른 경로에 포함되면 안된다. 입력에는 1번 도시와 2번 도시를 연결하는 길은 없다. 도시의 번호는 1번부터 N번까지이다.",
    "input_description": "첫째 줄에 두 정수 N(3 ≤ N ≤ 400), P(1 ≤ P ≤ 10,000)이 주어진다. 다음 P개의 줄에는 각 길이 연결하는 출발 도시와 도착 도시의 번호가 주어지며, 두 번호는 다르다.",
    "output_description": "1번에서 2번으로 가는 서로 다른 경로의 최대 개수를 출력한다.",
    "examples": [
      {
        "input": "5 5\n1 3\n3 2\n1 5\n5 4\n4 2",
        "output": "2"
      },
      {
        "input": "6 7\n1 3\n3 2\n1 4\n4 2\n1 5\n5 6\n6 2",
        "output": "3"
      },
      {
        "input": "7 8\n1 3\n1 4\n3 5\n4 5\n5 6\n5 7\n6 2\n7 2",
        "output": "2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/17412",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "17429",
    "step_title": "트리와 쿼리",
    "title": "국제 메시 기구",
    "level": 22,
    "tags": [
      "자료 구조",
      "트리",
      "세그먼트 트리",
      "느리게 갱신되는 세그먼트 트리",
      "오일러 경로 테크닉",
      "Heavy-light 분할"
    ],
    "description": "야구선수인메시는 국제 메시 기구(IMO, International messi organization)의 금고 관리자이다. 트리를 사랑하는 메시는 금고를 금고 1이 루트인 트리 모양으로 연결해서 관리한다고 한다.업무시간에A+B를 풀고 있던 메시는 메일 하나를 받았는데, 그 메일에는 '메시 흑역사.jpg.exe'라는 이름의 첨부파일이 하나 있었다. 안 그래도 어제 도난 사건으로 금고 N개가 다 털려 0원밖에 남지 않아 해고당할 위기에 처했는데 흑역사까지 드러날 위기에 처한 메시는 한 치의 고민도 없이 첨부파일을 열었다. 그러자 이상한 콘솔 창이 등장했다!금★고의 요☆정 지♨니! 금고 속의 돈을 늘려드립니다! 명령어를 입력하세요. 명령어의 목록은 다음과 같습니다.\"1 X V\" 금고 X의 서브트리에 있는 모든 금고에 V원을 더합니다. (1 ≤ X ≤ N, 1 ≤ V ≤ 109)\"2 X Y V\" 금고 X부터 금고 Y까지의 경로에 있는 모든 금고에 V원을 더합니다. 단, 경로는 경계를 포함합니다. (1 ≤ X, Y ≤ N, 1 ≤ V ≤ 109)\"3 X V\" 금고 X의 서브트리에 있는 모든 금고의 돈을 V배 합니다. (1 ≤ X ≤ N, 0 ≤ V ≤ 109)\"4 X Y V\" 금고 X부터 금고 Y까지의 경로에 있는 모든 금고의 돈을 V배 합니다. 단, 경로는 경계를 포함합니다. (1 ≤ X, Y ≤ N, 0 ≤ V ≤ 109)\"5 X\" 금고 X의 서브트리에 있는 모든 금고의 돈을 합한 값을 출력합니다. (1 ≤ X ≤ N)\"6 X Y\" 금고 X부터 금고 Y까지의 경로에 있는 모든 금고의 돈을 합한 값을 출력합니다. 단, 경로는 경계를 포함합니다. (1 ≤ X, Y ≤ N)메시는 도난 사건을 없던 일로 만들 기회라고 생각하여 명령어를 입력했지만, 이 파일은 당연하게도 바이러스라서 메시가 3개월간 짜던 A+B의 코드를 다 날려버렸다. 화가 난 메시는 위의 명령어를 실행하는 프로그램을 직접 만들기로 했다.",
    "input_description": "첫째 줄에 N, Q가 주어진다. (1 ≤ N ≤ 500,000, 1 ≤ Q ≤ 100,000)다음 N-1줄 중 i번째 줄에는 Si, Ei가 주어지며, 이는 금고 Si와 금고 Ei가 연결되어 있다는 뜻이다. (1 ≤ Si, Ei≤ N)금고가 연결된 모양은 올바른 트리 모양이다.다음 Q줄에는 명령어들이 한 줄에 하나씩 주어진다.",
    "output_description": "출력 명령어가 주어질 때마다 값을 출력한다. 단, 메시의 컴퓨터는 최신 트렌드인 4294967296비트 컴퓨터와는 다르게 32비트 컴퓨터이므로 232로 나눈 나머지를 대신 출력한다.",
    "examples": [
      {
        "input": "5 10\n2 4\n4 3\n5 4\n2 1\n3 1 82\n6 3 5\n2 2 5 45\n2 3 2 70\n6 3 5\n5 3\n4 2 1 47\n1 1 95\n6 3 2\n4 5 1 38",
        "output": "0\n230\n70\n5875"
      },
      {
        "input": "10 20\n3 7\n5 6\n10 9\n6 8\n10 2\n6 3\n1 3\n6 4\n10 4\n1 10 97\n1 10 50\n3 9 9\n5 5\n1 8 27\n5 10\n2 8 7 20\n2 4 4 41\n2 2 5 92\n3 4 96\n3 5 12\n1 7 32\n2 7 3 75\n4 5 6 60\n6 8 7\n6 1 2\n3 9 0\n1 3 20\n6 1 1\n1 6 82",
        "output": "0\n1617\n6989\n65471\n0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/17429",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 그래프 문제 기본 구조\nfrom collections import deque\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\n# BFS/DFS 구현\nvisited = [False] * (N + 1)\n\ndef bfs(start):\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        node = queue.popleft()\n        for next_node in graph[node]:\n            if not visited[next_node]:\n                visited[next_node] = True\n                queue.append(next_node)\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "17435",
    "step_title": "최소 공통 조상",
    "title": "합성함수와 쿼리",
    "level": 15,
    "tags": [
      "자료 구조",
      "희소 배열"
    ],
    "description": "함수 f : {1, 2, ..., m}→{1, 2, ..., m}이 있다. 이때 fn: {1, 2, ..., m}→{1, 2, ..., m}을 다음과 같이 정의하자.f1(x) = f(x)fn+1(x) = f(fn(x))예를 들어 f4(1) = f(f(f(f(1))))이다.n과 x가 주어질 때 fn(x)를 계산하는 쿼리를 수행하는 프로그램을 작성하시오.",
    "input_description": "첫 줄에 정수 m이 주어진다. (1 ≤ m ≤ 200,000)다음 줄에 f(1), f(2), ..., f(m)이 차례대로 주어진다.다음 줄에 쿼리의 개수 Q가 주어진다. (1 ≤ Q ≤ 200,000)다음 Q개의 줄에 각각 정수 n과 x가 주어진다. (1 ≤ n ≤ 500,000; 1 ≤ x ≤ m)",
    "output_description": "주어지는 n, x마다 fn(x)를 출력한다.",
    "examples": [
      {
        "input": "5\n3 3 5 4 3\n5\n1 1\n2 1\n11 3\n1000 4\n5 1",
        "output": "3\n5\n5\n4\n3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/17435",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\ninput = sys.stdin.readline\n\nm = int(input())\nf = [0] + list(map(int, input().split()))\n\n# sparse table\nMAX_LOG = 20\nsparse = [[0] * (m + 1) for _ in range(MAX_LOG)]\n\nfor i in range(1, m + 1):\n    sparse[0][i] = f[i]\n\nfor k in range(1, MAX_LOG):\n    for i in range(1, m + 1):\n        sparse[k][i] = sparse[k-1][sparse[k-1][i]]\n\nQ = int(input())\nfor _ in range(Q):\n    n, x = map(int, input().split())\n    \n    for k in range(MAX_LOG - 1, -1, -1):\n        if n >= (1 << k):\n            n -= (1 << k)\n            x = sparse[k][x]\n    \n    print(x)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "17469",
    "step_title": "유니온 파인드 2",
    "title": "트리의 색깔과 쿼리",
    "level": 18,
    "tags": [
      "자료 구조",
      "트리",
      "집합과 맵",
      "분리 집합",
      "트리를 사용한 집합과 맵",
      "오프라인 쿼리",
      "작은 집합에서 큰 집합으로 합치는 테크닉"
    ],
    "description": "N개의 정점으로 구성된 트리가 있다. 각 정점은 1번부터 N번까지 번호가 매겨져있고, 1 이상 10만 이하의 자연수로 표현되는 색깔을 하나 갖고 있다. 루트는 1번 정점이고, 트리이기 때문에 임의의 서로 다른 두 정점을 잇는 경로는 반드시 한 개 존재한다.정점 u와 v를 잇는 경로가 존재하면 u에서 v로 갈 수 있다고 하자.여러분은 아래 두 가지 쿼리를 처리해야 한다.1 a : 정점 a와 a의 부모 정점을 연결하는 간선을 제거한다. (해당 간선이 존재하는 경우에만 주어진다.)2 a : 정점 a에서 갈 수 있는 정점들만 보았을 때, 색깔의 종류의 개수를 출력한다.",
    "input_description": "첫 번째 줄에는 정점의 개수 N(1 ≤ N ≤ 100,000)과 2번 쿼리의 개수 Q(1 ≤ Q ≤ 1,000,000)가 주어진다.다음 N-1개 줄의 i번째 줄에는 정점 i+1의 부모 정점을 나타내는 정수 p(1 ≤ p ≤ N)가 주어진다.다음 N개 줄의 i번째 줄에는 정점 i의 색깔을 나타내는 정수 c(1 ≤ c ≤ 100,000)가 주어진다.다음 N+Q-1개의 줄에는 여러분이 처리해야 할 쿼리가 주어지는데, 1번 쿼리는 N-1개, 2번 쿼리는 Q개 주어진다.쿼리는 한 줄에 하나씩 쿼리의 종류를 나타내는 X(1 ≤ X ≤ 2)와 쿼리에서 처리할 정점의 번호 a(1 ≤ a ≤ N)가 주어진다.입력은 모두 자연수로 주어진다.",
    "output_description": "Q개의 2번 쿼리에 대한 답을 순서대로 한 줄에 하나씩 출력한다.",
    "examples": [
      {
        "input": "5 4\n5\n2\n2\n1\n1\n3\n2\n3\n3\n1 4\n2 1\n2 3\n1 2\n2 5\n1 5\n2 3\n1 3",
        "output": "3\n3\n2\n2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/17469",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 그래프 문제 기본 구조\nfrom collections import deque\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\n# BFS/DFS 구현\nvisited = [False] * (N + 1)\n\ndef bfs(start):\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        node = queue.popleft()\n        for next_node in graph[node]:\n            if not visited[next_node]:\n                visited[next_node] = True\n                queue.append(next_node)\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "17472",
    "step_title": "최소 신장 트리",
    "title": "다리 만들기 2",
    "level": 15,
    "tags": [
      "구현",
      "그래프 이론",
      "브루트포스 알고리즘",
      "그래프 탐색",
      "너비 우선 탐색",
      "깊이 우선 탐색",
      "최소 스패닝 트리"
    ],
    "description": "섬으로 이루어진 나라가 있고, 모든 섬을 다리로 연결하려고 한다. 이 나라의 지도는 N×M 크기의 이차원 격자로 나타낼 수 있고, 격자의 각 칸은 땅이거나 바다이다.섬은 연결된 땅이 상하좌우로 붙어있는 덩어리를 말하고, 아래 그림은 네 개의 섬으로 이루어진 나라이다. 색칠되어있는 칸은 땅이다.다리는 바다에만 건설할 수 있고, 다리의 길이는 다리가 격자에서 차지하는 칸의 수이다. 다리를 연결해서 모든 섬을 연결하려고 한다. 섬 A에서 다리를 통해 섬 B로 갈 수 있을 때, 섬 A와 B를 연결되었다고 한다. 다리의 양 끝은 섬과 인접한 바다 위에 있어야 하고, 한 다리의 방향이 중간에 바뀌면 안된다. 또, 다리의 길이는 2 이상이어야 한다.다리의 방향이 중간에 바뀌면 안되기 때문에, 다리의 방향은 가로 또는 세로가 될 수 밖에 없다. 방향이 가로인 다리는 다리의 양 끝이 가로 방향으로 섬과 인접해야 하고, 방향이 세로인 다리는 다리의 양 끝이 세로 방향으로 섬과 인접해야 한다.섬 A와 B를 연결하는 다리가 중간에 섬 C와 인접한 바다를 지나가는 경우에 섬 C는 A, B와 연결되어있는 것이 아니다.아래 그림은 섬을 모두 연결하는 올바른 2가지 방법이고, 다리는 회색으로 색칠되어 있다. 섬은 정수, 다리는 알파벳 대문자로 구분했다.다리의 총 길이: 13D는 2와 4를 연결하는 다리이고, 3과는 연결되어 있지 않다.다리의 총 길이: 9 (최소)다음은 올바르지 않은 3가지 방법이다C의 방향이 중간에 바뀌었다D의 길이가 1이다.가로 다리인 A가 1과 가로로 연결되어 있지 않다.다리가 교차하는 경우가 있을 수도 있다. 교차하는 다리의 길이를 계산할 때는 각 칸이 각 다리의 길이에 모두 포함되어야 한다. 아래는 다리가 교차하는 경우와 기타 다른 경우에 대한 2가지 예시이다.A의 길이는 4이고, B의 길이도 4이다.총 다리의 총 길이: 4 + 4 + 2 = 10다리 A: 2와 3을 연결 (길이 2)다리 B: 3과 4를 연결 (길이 3)다리 C: 2와 5를 연결 (길이 5)다리 D: 1과 2를 연결 (길이 2)총 길이: 12나라의 정보가 주어졌을 때, 모든 섬을 연결하는 다리 길이의 최솟값을 구해보자.",
    "input_description": "첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. 둘째 줄부터 N개의 줄에 지도의 정보가 주어진다. 각 줄은 M개의 수로 이루어져 있으며, 수는 0 또는 1이다. 0은 바다, 1은 땅을 의미한다.",
    "output_description": "모든 섬을 연결하는 다리 길이의 최솟값을 출력한다. 모든 섬을 연결하는 것이 불가능하면 -1을 출력한다.",
    "examples": [
      {
        "input": "7 8\n0 0 0 0 0 0 1 1\n1 1 0 0 0 0 1 1\n1 1 0 0 0 0 0 0\n1 1 0 0 0 1 1 0\n0 0 0 0 0 1 1 0\n0 0 0 0 0 0 0 0\n1 1 1 1 1 1 1 1",
        "output": "9"
      },
      {
        "input": "7 8\n0 0 0 1 1 0 0 0\n0 0 0 1 1 0 0 0\n1 1 0 0 0 0 1 1\n1 1 0 0 0 0 1 1\n1 1 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n1 1 1 1 1 1 1 1",
        "output": "10"
      },
      {
        "input": "7 8\n1 0 0 1 1 1 0 0\n0 0 1 0 0 0 1 1\n0 0 1 0 0 0 1 1\n0 0 1 1 1 0 0 0\n0 0 0 0 0 0 0 0\n0 1 1 1 0 0 0 0\n1 1 1 1 1 1 0 0",
        "output": "9"
      },
      {
        "input": "7 7\n1 1 1 0 1 1 1\n1 1 1 0 1 1 1\n1 1 1 0 1 1 1\n0 0 0 0 0 0 0\n1 1 1 0 1 1 1\n1 1 1 0 1 1 1\n1 1 1 0 1 1 1",
        "output": "-1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/17472",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\ndef find(x):\n    if parent[x] != x:\n        parent[x] = find(parent[x])\n    return parent[x]\n\ndef union(a, b):\n    a = find(a)\n    b = find(b)\n    if a != b:\n        parent[b] = a\n        return True\n    return False\n\nN, M = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(N)]\n\nisland_num = 2\nvisited = [[False] * M for _ in range(N)]\ndx = [-1, 1, 0, 0]\ndy = [0, 0, -1, 1]\n\nfor i in range(N):\n    for j in range(M):\n        if grid[i][j] == 1 and not visited[i][j]:\n            q = deque([(i, j)])\n            visited[i][j] = True\n            grid[i][j] = island_num\n            \n            while q:\n                x, y = q.popleft()\n                for k in range(4):\n                    nx, ny = x + dx[k], y + dy[k]\n                    if 0 <= nx < N and 0 <= ny < M and not visited[nx][ny] and grid[nx][ny] == 1:\n                        visited[nx][ny] = True\n                        grid[nx][ny] = island_num\n                        q.append((nx, ny))\n            \n            island_num += 1\n\nedges = []\nINF = float('inf')\ndist = [[INF] * island_num for _ in range(island_num)]\n\nfor i in range(N):\n    for j in range(M):\n        if grid[i][j] >= 2:\n            island = grid[i][j]\n            for k in range(4):\n                length = 0\n                nx, ny = i + dx[k], j + dy[k]\n                \n                while 0 <= nx < N and 0 <= ny < M and grid[nx][ny] == 0:\n                    length += 1\n                    nx += dx[k]\n                    ny += dy[k]\n                \n                if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] >= 2 and length >= 2:\n                    other = grid[nx][ny]\n                    dist[island][other] = min(dist[island][other], length)\n\nfor i in range(2, island_num):\n    for j in range(i + 1, island_num):\n        if dist[i][j] != INF:\n            edges.append((dist[i][j], i, j))\n\nedges.sort()\n\nparent = list(range(island_num))\ntotal = 0\ncount = 0\n\nfor cost, a, b in edges:\n    if union(a, b):\n        total += cost\n        count += 1\n\nprint(total if count == island_num - 3 else -1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "17635",
    "step_title": "평방 분할",
    "title": "다리",
    "level": 24,
    "tags": [
      "자료 구조",
      "분리 집합",
      "오프라인 쿼리",
      "제곱근 분할법"
    ],
    "description": "상트페테르부르크 시의 수로 길이의 총합은 약 282 km이고, 도시 면적 중 물이 차지하는 비중은 약 7%이다.Wikipedia상트페테르부르크는 n개의 섬을 m개의 다리로 이어 만든 도시이다. 섬은 1부터 n까지 정수로 표현할 수 있고, 다리는 1부터 m까지 정수로 표현한다. 각각의 다리는 서로 다른 두 섬을 연결한다. 어떤 다리는 표트르 대제 시절에 만들었고, 어떤 다리는 만든지 얼마 되지 않는다. 그래서 다리들마다 다양한 무게 제한이 있다. 즉, 자동차가 다리 i를 지나려면 무게가 di이하여야 한다. 때떄로 상트페테르부르크의 다리들을 보수할 때가 있다. 그렇지만 보수를 한다고 꼭 다리가 더 튼튼해지는 것은 아니어서, di값이 늘 수도 있고 줄어들 수도 있다. 이 도시의 시민과 관광객을 위해서, 다음 두 가지 질의를 처리할 수 있는 프로그램이 있다면 좋을 것이다.다리 bj의 무게 제한이 rj로 바뀌었다.무게가 wj인 자동차로 섬 sj에서 출발해서 도착할 수 있는 섬의 수를 구하시오.두번째 형태의 질의를 모두 답하시오.",
    "input_description": "첫 번째 줄에는 두 정수 n, m가 주어진다. — 이는 각각 상트페테르부르크의 섬과 다리의 수이다. (1 ≤ n ≤ 50 000, 0 ≤ m ≤ 100 000)다음 m 줄 중 i 번째 줄에는 세 정수 ui, vi, di가 주어지는데, 섬 ui과 섬 vi를 잇는 다리의 무게 제한은 최초에는 di라는 뜻이다. (1 ≤ ui, vi≤ n; ui≠ vi; 1 ≤ di≤ 109)그 다음 줄에는 하나의 정수 q가 주어진다. — 이는 질의의 수이다. (1 ≤ q ≤ 100 000). 다음 q 줄에 질의가 주어진다.각 질의는 정수 tj로 시작한다. (tj∈ {1, 2})만약 tj= 1이라면, 이 질의는 첫 번째 형태이고, 두 정수 bj와 rj가 뒤따라 주어지는데, 이는 다리 bj의 무게 제한이 rj로 바뀐다는 뜻이다. (1 ≤ bj≤ m, 1 ≤ rj≤ 109)만약 tj= 2이면, 이 질의는 두번째 형태이고, 두 정수 sj와 wj가 뒤따라 주어지는데, 이는 무게가 wj인 자동차가 섬 sj에서 출발하여 도착할 수 있는 섬의 수를 구하라는 뜻이다. (1 ≤ sj≤ n, 1 ≤ wj≤ 109)",
    "output_description": "두번째 형태의 질의 하나마다 한 줄에 하나씩 질의의 답을 출력한다.",
    "examples": [
      {
        "input": "3 4\n1 2 5\n2 3 2\n3 1 4\n2 3 8\n5\n2 1 5\n1 4 1\n2 2 5\n1 1 1\n2 3 2",
        "output": "3\n2\n3"
      },
      {
        "input": "7 8\n1 2 5\n1 6 5\n2 3 5\n2 7 5\n3 4 5\n4 5 5\n5 6 5\n6 7 5\n12\n2 1 6\n1 1 1\n2 1 2\n1 2 3\n2 2 2\n1 5 2\n1 3 1\n2 2 4\n2 4 2\n1 8 1\n2 1 1\n2 1 3",
        "output": "1\n7\n7\n5\n7\n7\n4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/17635",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "17752",
    "step_title": "인터랙티브와 투 스텝 2",
    "title": "Messenger",
    "level": 21,
    "tags": [
      "애드 혹",
      "많은 조건 분기",
      "비트마스킹"
    ],
    "description": "国際情報オリンピックの日本代表に選ばれた A さんと B さんは，情報処理技術を高めるため，情報オリ ンピック日本委員会の K 理事長と「メッセンジャー・ゲーム」を行うことになった．以下にこのゲームの ルールを説明する．A さんと B さんは，図のように部屋に隔離されている．A さん・B さん・K 理事長の各部屋には内線電 話が設置されているが，電話を発信することが可能なのは K 理事長のみである．その他の連絡手段は断た れており，A さんと B さんは指示がない限り部屋から出ることはできない．ゲームの開始時に，K 理事長は電話で A さんにある正の整数 X を伝える．ゲームの目的は，A さんと B さんが直接の連絡をとらずに，A さんが B さんに X の値を正しく伝えることである．K 理事長の部屋には 4×4 のマス目がある．i 行 j 列のマスを (i, j) と表す (1 5 i 5 4, 1 5 j 5 4)．マス (1, 1)が左上の隅，マス (1, 4) が右上の隅，マス (4, 1) が左下の隅，マス (4, 4) が右下の隅である．ゲームの開始時，1 つの駒がいずれかのマスに置かれる．以後，K 理事長は駒が置かれているマスを変えることはない．これから，K 理事長が A さんまたは B さんを電話で部屋に呼ぶということが繰り返される．A さんまたは B さんは，K 理事長の部屋に来るたびに，駒を上下左右のいずれかのマスに動かさなければならない．駒を動かしたら，A さんまたは B さんは自分の部屋に戻る．B さんは，K 理事長の部屋に来たときにもしX の値がわかったならば，駒を動かす代わりにそれを K 理事長に答えることができる．正しい X の値を答えられれば正解であり，そうでなければ不正解である．K 理事長が A さんまたは B さんを部屋に呼ぶタイミングは不規則であり，A さんと B さんは K 理事長がどういう順序で 2 人を部屋に呼んでいるかはわからない．ただし，K 理事長は 2 人を部屋に呼ぶ順序をゲームの開始時に決めており，また，K 理事長が A さんまたは B さんの一方を 100 回より多く連続して部屋に呼ぶことはないことが保証されている．K 理事長が A さんと B さんを合計 10 000 回部屋に呼んだ後に A さんまたは B さんが自分の部屋に戻った段階で B さんが X の値を答えていない場合は，不正解としてゲームは終了される．A さんと B さんの戦略を実装し，上で説明された「メッセンジャー・ゲーム」で正解できるプログラム を作成せよ．",
    "input_description": "採点プログラムのサンプルは標準入力から以下の入力を読み込む．1 行目には整数 T, X, I0, J0が空白を区切りとして書かれており，小課題の番号が T，A さんが B さん に伝えるべき整数が X，ゲームの開始時の駒の位置が (I0, J0) であることを表す．2 行目には 2 種類の文字A,Bからなる，長さがちょうど 10 000 の文字列が書かれており，k 文字目 (1 ≤ k ≤ 10 000) がAまたはBである場合，ルーチンInitAとInitBが呼び出された後に k 番目に呼 び出されるルーチンがそれぞれGameAまたは GameB であることを表す．",
    "output_description": "プログラムの実行が正常に終了した場合，採点プログラムのサンプルは標準出力へ以下の情報を 1 行で 出力する．正解の場合，“Accepted” と出力される (引用符は実際には出力されない．以下同様である)．不正解の場合，不正解の種類が「実装の詳細」の節に書かれた番号によって “Wrong Answer [1]” の ように出力される．さらに，不正解 [5] については，正しい X の値およびルーチンGameBが返した 正の整数 Y の値が “Wrong Answer [5] : X = 2, Y = 3” のように出力される．",
    "examples": [],
    "url": "https://www.acmicpc.net/problem/17752",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(\"\")",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "18108",
    "step_title": "입출력과 사칙연산",
    "title": "1998년생인 내가 태국에서는 2541년생?!",
    "level": 1,
    "tags": [
      "수학",
      "사칙연산"
    ],
    "description": "ICPC Bangkok Regional에 참가하기 위해 수완나품 국제공항에 막 도착한 팀 레드시프트 일행은 눈을 믿을 수 없었다. 공항의 대형 스크린에 올해가 2562년이라고 적혀 있던 것이었다.불교 국가인 태국은 불멸기원(佛滅紀元), 즉 석가모니가 열반한 해를 기준으로 연도를 세는 불기를 사용한다. 반면, 우리나라는 서기 연도를 사용하고 있다. 불기 연도가 주어질 때 이를 서기 연도로 바꿔 주는 프로그램을 작성하시오.",
    "input_description": "서기 연도를 알아보고 싶은 불기 연도y가 주어진다. (1000 ≤y≤ 3000)",
    "output_description": "불기 연도를 서기 연도로 변환한 결과를 출력한다.",
    "examples": [
      {
        "input": "2541",
        "output": "1998"
      }
    ],
    "url": "https://www.acmicpc.net/problem/18108",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "year = int(input())\nprint(year - 543)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "year = int(input())로 입력을 처리합니다.",
            "code_pattern": "year = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(year - 543)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "18123",
    "step_title": "트리와 쿼리",
    "title": "평행우주",
    "level": 22,
    "tags": [
      "트리",
      "해싱",
      "centroid",
      "트리 동형 사상",
      "트리에서의 전방향 다이나믹 프로그래밍",
      "트리의 지름"
    ],
    "description": "서강 프로그래밍 대회가 열리고 있는 지금도 수많은 별들이 다산관의 하늘을 수놓고 있다.태한이는 컴퓨터공학과지만, 취미로 별을 연구하고 있다. 이미 평행우주가 존재한다는 것을 증명하는 데 성공한 태한이는 별 연구에 너무 심취한 나머지 모든 평행우주의 모든 별들을 별자리로 만들었다.별자리는 별n개와 별을 잇는 선n− 1개로 정의되며, 한 별자리에 속한 모든 별들은 연결되어 있다. 태한이는 별자리를 정의할 때 한 평행우주에 같은 위상의 별자리가 있을 수 없도록 정의했다. 한 별자리의 별들의 연결 관계를 바꾸지 않고 위치만을 움직여서 다른 별자리를 만들 수 있다면 두 별자리의 위상이 같다고 말한다.한편 한나는 우리가 살고 있는 평행우주에 존재하는 모든 별자리를 찍기 위해, 태한이에게서 별자리들의 정보가 담긴 연구 노트를 받았다. 태한이의 연구 노트에는 모든 평행우주의 모든 별자리에 대한 정보가 적혀 있었지만, 안타깝게도 각각의 별자리가 어떤 평행우주에 있는지는 적혀 있지 않았다.태한이의 연구 노트를 토대로 한나가 찍을 사진의 최대 장 수를 계산해 주자. 한나는 별자리 하나당 한 장의 사진을 찍는다.",
    "input_description": "첫 번째 줄에는 모든 평행우주에 존재하는 별자리의 총 수n이 주어진다. (1 ≤n≤ 106) 별의 수의 총합은 106을 넘지 않는다.두 번째 줄부터는 각 별자리의 정보가 주어진다.각 별자리마다, 첫 번째 줄에는 별자리를 구성하는 별의 수s가 주어진다. (1 ≤s≤ 30)이후s− 1개의 줄에 별들 사이의 연결 관계를 의미하는 두 정수u,v가 주어진다. (0 ≤u,v<s,u≠v)편의를 위해 각 별자리 안에서 별들은 0, 1, 2, ⋯,s− 1번으로 번호가 붙어 있다고 생각하며,uv는u번 별과v번 별이 연결되어 있다는 의미이다. 별자리의 위상을 고려할 때는 별의 번호는 고려하지 않는다.",
    "output_description": "한나가 찍을 사진의 최대 장 수를 출력한다.",
    "examples": [
      {
        "input": "3\n4\n0 1\n1 2\n2 3\n4\n0 2\n2 3\n3 1\n4\n0 1\n1 2\n1 3",
        "output": "2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/18123",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 그래프 문제 기본 구조\nfrom collections import deque\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\n# BFS/DFS 구현\nvisited = [False] * (N + 1)\n\ndef bfs(start):\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        node = queue.popleft()\n        for next_node in graph[node]:\n            if not visited[next_node]:\n                visited[next_node] = True\n                queue.append(next_node)\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "18258",
    "step_title": "스택, 큐, 덱 1",
    "title": "큐 2",
    "level": 7,
    "tags": [
      "자료 구조",
      "큐"
    ],
    "description": "정수를 저장하는 큐를 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.명령은 총 여섯 가지이다.push X: 정수 X를 큐에 넣는 연산이다.pop: 큐에서 가장 앞에 있는 정수를 빼고, 그 수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.size: 큐에 들어있는 정수의 개수를 출력한다.empty: 큐가 비어있으면 1, 아니면 0을 출력한다.front: 큐의 가장 앞에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.back: 큐의 가장 뒤에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.",
    "input_description": "첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 2,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 문제에 나와있지 않은 명령이 주어지는 경우는 없다.",
    "output_description": "출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다.",
    "examples": [
      {
        "input": "15\npush 1\npush 2\nfront\nback\nsize\nempty\npop\npop\npop\nsize\nempty\npop\npush 3\nempty\nfront",
        "output": "1\n2\n2\n0\n1\n2\n-1\n0\n1\n-1\n0\n3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/18258",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nqueue = deque()\n\nfor _ in range(N):\n    cmd = input().split()\n    \n    if cmd[0] == 'push':\n        queue.append(int(cmd[1]))\n    elif cmd[0] == 'pop':\n        print(queue.popleft() if queue else -1)\n    elif cmd[0] == 'size':\n        print(len(queue))\n    elif cmd[0] == 'empty':\n        print(0 if queue else 1)\n    elif cmd[0] == 'front':\n        print(queue[0] if queue else -1)\n    elif cmd[0] == 'back':\n        print(queue[-1] if queue else -1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "18437",
    "step_title": "세그먼트 트리 2",
    "title": "회사 문화 5",
    "level": 18,
    "tags": [
      "자료 구조",
      "트리",
      "세그먼트 트리",
      "느리게 갱신되는 세그먼트 트리",
      "오일러 경로 테크닉"
    ],
    "description": "총 N명의 직원이 재직 중인 회사가 있고, 각 직원은 1번부터 N번까지 번호가 매겨져 있다. 이 회사는 수직적인 구조를 가지고 있고, 대표를 제외한 모든 직원은 한 명의 직속 상사를 갖고 있다. 직속 상사의 직속 상사도 상사이고, 직속 상사의 상사도 상사이다. 따라서, 대표를 제외한 모든 직원은 한 명 이상의 상사를 가지고 있고, 한 명의 직속 상사를 갖고 있다. 상사가 없는 사람은 대표이다.이 회사가 가지고 있는 문화는 아래와 같은 쿼리로 나타낼 수 있다. 가장 처음에 컴퓨터는 켜져있는 상태이다.1 i: i번 직원을 상사로 가지고 있는 모든 직원은 컴퓨터를 켠다.2 i: i번 직원을 상사로 가지고 있는 모든 직원은 컴퓨터를 끈다.3 i: i번 직원을 상사로 가지고 있는 직원 중에서 컴퓨터가 켜져있는 사람의 수를 출력한다.",
    "input_description": "첫째 줄에 직원의 수 N (1 ≤ N ≤ 100,000)이 주어진다.둘째 줄에는 각 직원의 상사 번호가 주어진다. i번째 정수는 i번 직원의 직속 상사 번호이다. 대표의 번호는 1번이고, 상사 번호로 0이 주어진다.셋째 줄에 쿼리의 수 M (1 ≤ M ≤ 100,000)이 주어진다.넷째 줄부터 M개의 줄에 쿼리가 주어진다. (1 ≤ i ≤ N)",
    "output_description": "3번 쿼리의 결과를 한 줄에 하나씩 출력한다.",
    "examples": [
      {
        "input": "3\n0 1 2\n8\n3 1\n2 1\n3 1\n1 1\n3 1\n2 2\n3 1\n3 2",
        "output": "2\n0\n2\n1\n0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/18437",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 그래프 문제 기본 구조\nfrom collections import deque\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\n# BFS/DFS 구현\nvisited = [False] * (N + 1)\n\ndef bfs(start):\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        node = queue.popleft()\n        for next_node in graph[node]:\n            if not visited[next_node]:\n                visited[next_node] = True\n                queue.append(next_node)\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "18438",
    "step_title": "동적 계획법 최적화 2",
    "title": "LCS 5",
    "level": 25,
    "tags": [
      "다이나믹 프로그래밍",
      "분할 정복",
      "역추적",
      "최장 공통 부분 수열 문제",
      "히르쉬버그"
    ],
    "description": "LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.",
    "input_description": "첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 7000글자로 이루어져 있다.",
    "output_description": "첫째 줄에 입력으로 주어진 두 문자열의 LCS의 길이를, 둘째 줄에 LCS를 출력한다.LCS가 여러 가지인 경우에는 아무거나 출력한다.",
    "examples": [
      {
        "input": "ACAYKP\nCAPCAK",
        "output": "4\nACAK"
      },
      {
        "input": "WEDONTNEEDNOEDUCATION\nWEDONTNEEDNOTHOUGHTCONTROL",
        "output": "16\nWEDONTNEEDNOUCTO"
      }
    ],
    "url": "https://www.acmicpc.net/problem/18438",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "18456",
    "step_title": "동적 계획법 최적화 2",
    "title": "Jealous Split",
    "level": 26,
    "tags": [
      "Aliens 트릭",
      "이분 탐색",
      "볼록 껍질을 이용한 최적화",
      "다이나믹 프로그래밍"
    ],
    "description": "You have an array of non-negative integers a1, a2, . . . , an.You need to split it into k non-empty subsegments: [1; b1], [b1+ 1; b2], . . . , [bk−1+ 1; n].Let us denote the sum on i-th segment as siand the maximum on i-th segment as mi. Your goal is to make |si− si+1| ≤ max(mi, mi+1) for each 1 ≤ i ≤ k − 1.",
    "input_description": "The first line of the input contains two integers n and k: the size of the array and the required number of segments (3 ≤ k ≤ n ≤ 100 000).The next line contains n integers a1, a2, . . . , an: the given array (0 ≤ ai≤ 50 000).",
    "output_description": "If splitting is possible, print “Yes” on the first line, and then print k − 1 space-separated integers b1, b2, . . . , bk−1on the second line. The integers must satisfy 1 ≤ b1< b2< . . . < bk−1< n. Additionally, the inequalities |si− si+1| ≤ max(mi, mi+1) must hold for each 1 ≤ i ≤ k − 1. If there are several possible solutions, print any one of them.If splitting is impossible, print “No” on a single line.",
    "examples": [
      {
        "input": "5 3\r\n17 18 17 30 35",
        "output": "Yes\r\n2 4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/18456",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "18586",
    "step_title": "네트워크 플로우 4",
    "title": "Salty Fish",
    "level": 24,
    "tags": [
      "다이나믹 프로그래밍",
      "그래프 이론",
      "자료 구조",
      "트리",
      "집합과 맵",
      "트리에서의 다이나믹 프로그래밍",
      "트리를 사용한 집합과 맵",
      "최대 유량",
      "작은 집합에서 큰 집합으로 합치는 테크닉",
      "최대 유량 최소 컷 정리"
    ],
    "description": "Little Q has an apple tree with n nodes, labeled by 1, 2, . . . , n. The root of the tree is node 1, and the length of each edge is one unit. There are aiapples on the i-th node. The price of each apple is one dollar, so if you sell t apples, you will gain t dollars.Skywalkert, a close friend of Little Q, lost most of his money betting on programming contests, so he wants to steal some apples from this apple tree and sell them to make money.The security system takes pictures of the nodes once per hour using m cameras. Let us denote d(x, y) as the number of edges on the shortest path from node x to node y, and denote set p(x, k) as {y | y is in subtree of x and d(x, y) ≤ k}. Note that x ∈ p(x, k). The image from the i-th camera shows the picture of all the nodes in p(xi, ki). If the security system detects a change in any of these images, it sounds an alarm, and the thief will be caught by Little Q.Skywalkert is also a gifted hacker. He can lock some cameras so that images from these cameras will never change. Specifically, if he wants to lock the i-th camera, he needs to pay cidollars to do such a hack. Skywalkert will pay for all hacks after he steals the apples and sells them.Please write a program to help Skywalkert earn the most money possible without being caught.",
    "input_description": "The first line of the input contains an integer T (1 ≤ T ≤ 10 000), denoting the number of test cases.Each test case starts by a line with two integers n and m (1 ≤ n, m ≤ 300 000), denoting the number of nodes and cameras.The second line of a test case contains n − 1 integers f2, f3, . . . , fn(1 ≤ fi< i), denoting the parents of nodes 2, 3, . . . , n.The third line of a test case contains n integers a1, a2, . . . , an(1 ≤ ai≤ 109), denoting the number of apples on nodes 1, 2, . . . , n.Each of the next m lines of a test case contains three integers xi, ki, and ci(1 ≤ xi≤ n, 0 ≤ ki≤ n, 1 ≤ ci≤ 109), denoting the parameters of each camera.It is guaranteed that the sum of all n is at most 106, and the sum of all m is at most 106.",
    "output_description": "For each test case, print a single line containing an integer denoting the maximum amount of dollars Skywalkert can earn.",
    "examples": [
      {
        "input": "1\r\n6 3\r\n1 1 2 2 3\r\n2 5 4 3 3 2\r\n2 1 3\r\n3 1 7\r\n1 2 4",
        "output": "6"
      }
    ],
    "url": "https://www.acmicpc.net/problem/18586",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "18653",
    "step_title": "네트워크 플로우 3",
    "title": "Honeycomb",
    "level": 24,
    "tags": [
      "그래프 이론",
      "자료 구조",
      "최대 유량",
      "최대 유량 최소 컷 정리"
    ],
    "description": "A honeycomb is a mass of hexagonal prismatic cells, where each cell has six adjacent cells, and every two adjacent cells share an edge. In addition, some edges are traversable but others are not.Hamilton is an industrious worker bee. Every day he works for connecting or disconnecting some pairs of adjacent cells in a honeycomb. In a few days, he will have a great chance to design a tiny block of cells by himself. This block is disconnected from its outside and it could be represented as cells in n rows and m columns, like the figure shown below.To cut off the connection of two cells, he may have to change some edges into untraversable. He is wondering the minimum number of edges he has to change so that two specified cells in the block would be disconnected. Could you please help him find out the minimum number of changed edges for every two special cells in this block? To avoid huge output data, you are asked to report the sum of these minimum numbers of edges.",
    "input_description": "The input contains several test cases. The first line contains an integer T indicating the number of test cases. The following describes all test cases. For each test case:The first line contains two integers n and m.The following (4n+ 3) lines describe the block, where each line contains at most (6m+ 3) characters. Odd lines contain grid vertices represented as plus signs (“+”) and horizontal edges, while even lines contain diagonal edges.Specifically, a cell is described as 6 vertices and 6 edges. All edge characters will be placed exactly between the corresponding vertices, such that edges are described as following:Its upper boundary or lower boundary is represented as three consecutive minus signs (“-”) if the edge is untraversable, or three consecutive spaces (“ ”) otherwise;Each one of its diagonal edges is represented as a single space if the edge is traversable, or otherwise as a single forward slash (“/”) or a single backslash (“\\”) character, depending on the direction of the edge.Besides, there is an asterisk (“*”) character at the center of each special cell. All other characters in the input will be spaces, and no input line will contain trailing spaces.",
    "output_description": "For each test case, output a line containing “Case #x: y” (without quotes), where x is the test case number starting from 1, and y is the answer to this test case.",
    "examples": [
      {
        "input": "2\r\n2 2\r\n  +---+\r\n /     \\\r\n+   *   +---+\r\n \\     /     \\\r\n  +---+   *   +\r\n /           /\r\n+   *   +   +\r\n \\           \\\r\n  +---+   *   +\r\n       \\     /\r\n        +---+\r\n2 3\r\n  +---+       +---+\r\n /     \\     /     \\\r\n+   *   +---+       +\r\n \\           \\     /\r\n  +---+   *   +---+\r\n /                 \\\r\n+   *   +---+   *   +\r\n \\                 /\r\n  +---+   *   +---+\r\n       \\     /\r\n        +---+",
        "output": "Case #1: 6\r\nCase #2: 16"
      }
    ],
    "url": "https://www.acmicpc.net/problem/18653",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "18857",
    "step_title": "네트워크 플로우 4",
    "title": "집 떠나와 열차 타고",
    "level": 21,
    "tags": [
      "그래프 이론",
      "집합과 맵",
      "단절점과 단절선",
      "이중 연결 요소",
      "선인장"
    ],
    "description": "자랑스러운 대한민국의 산업기능Agent욱제는 집 떠나와 열차 타고 훈련소로 떠난다.모두 알다시피 대한민국은 정점이 V개이고 간선이 E개인 선인장 그래프이고, 집은 1번 정점, 훈련소는 V번 정점이다.하지만 욱제는Agent를 감히 훈련소로 보내는 대한민국에 환멸을 느끼고, 간선 몇 개에 수류탄을 떨어뜨리기로 한다. 수류탄으로 간선을 터뜨리면 그 간선을 타고 이동할 수 없게 된다.욱제는 간선 몇 개를 터뜨린 다음 집에서 훈련소로 가는 경로가 없게 하고 싶다. 4월 2일이 오기 전에 빨리, 욱제가 터뜨려야 할 간선의 길이의 합의 최솟값을 구하자.",
    "input_description": "첫째 줄에 V, E가 주어진다.둘째 줄부터 E개의 줄에 대한민국을 이루는 그래프의 각 간선이 잇고 있는 두 정점의 번호 x, y와 간선의 길이 d가 공백을 사이에 두고 주어진다.",
    "output_description": "욱제가 터뜨려야 하는 간선의 길이의 합의 최솟값을 출력한다. 간선을 어떻게 터뜨려도 훈련소로 가는 경로가 존재하면,권욱제 재입대를 출력한다.",
    "examples": [
      {
        "input": "6 7\n1 2 3\n2 3 1\n3 4 4\n4 6 1\n6 3 5\n5 3 9\n5 1 2",
        "output": "3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/18857",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "18870",
    "step_title": "정렬",
    "title": "좌표 압축",
    "level": 9,
    "tags": [
      "정렬",
      "값 / 좌표 압축"
    ],
    "description": "수직선 위에 N개의 좌표 X1, X2, ..., XN이 있다. 이 좌표에 좌표 압축을 적용하려고 한다.Xi를 좌표 압축한 결과 X'i의 값은 Xi> Xj를 만족하는 서로 다른 좌표 Xj의 개수와 같아야 한다.X1, X2, ..., XN에 좌표 압축을 적용한 결과 X'1, X'2, ..., X'N를 출력해보자.",
    "input_description": "첫째 줄에 N이 주어진다.둘째 줄에는 공백 한 칸으로 구분된 X1, X2, ..., XN이 주어진다.",
    "output_description": "첫째 줄에 X'1, X'2, ..., X'N을 공백 한 칸으로 구분해서 출력한다.",
    "examples": [
      {
        "input": "5\n2 4 -10 4 -9",
        "output": "2 3 0 3 1"
      },
      {
        "input": "6\n1000 999 1000 999 1000 999",
        "output": "1 0 1 0 1 0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/18870",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\ncoords = list(map(int, input().split()))\n\nsorted_coords = sorted(set(coords))\ncoord_dict = {v: i for i, v in enumerate(sorted_coords)}\n\nresult = [str(coord_dict[c]) for c in coords]\nprint(' '.join(result))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = int(input())\ncoords = list(map(int, input().split()))\nsorted_coords = sorted(set(coords))\ncoord_map = {v: i for i, v in enumerate(sorted_coords)}\nresult = [coord_map[c] for c in coords]\nprint(' '.join(map(str, result)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "19532",
    "step_title": "브루트 포스",
    "title": "수학은 비대면강의입니다",
    "level": 4,
    "tags": [
      "수학",
      "브루트포스 알고리즘"
    ],
    "description": "수현이는 4차 산업혁명 시대에 살고 있는 중학생이다. 코로나 19로 인해, 수현이는 버추얼 학교로 버추얼 출석해 버추얼 강의를 듣고 있다. 수현이의 버추얼 선생님은 문자가 2개인 연립방정식을 해결하는 방법에 대해 강의하고, 다음과 같은 문제를 숙제로 냈다.다음 연립방정식에서 $x$와 $y$의 값을 계산하시오.\\[\\begin{cases}ax+by=c\\\\dx+ey=f\\end{cases}\\]4차 산업혁명 시대에 숙제나 하고 앉아있는 것보다 버추얼 친구들을 만나러 가는 게 더 가치있는 일이라고 생각했던 수현이는 이런 연립방정식을 풀 시간이 없었다. 다행히도, 버추얼 강의의 숙제 제출은 인터넷 창의 빈 칸에 수들을 입력하는 식이다. 각 칸에는 $-999$ 이상 $999$ 이하의 정수만 입력할 수 있다. 수현이가 버추얼 친구들을 만나러 버추얼 세계로 떠날 수 있게 도와주자.",
    "input_description": "정수 $a$, $b$, $c$, $d$, $e$, $f$가 공백으로 구분되어 차례대로 주어진다. ($-999 \\leq a,b,c,d,e,f \\leq 999$)문제에서 언급한 방정식을 만족하는 $\\left(x,y\\right)$가 유일하게 존재하고, 이 때 $x$와 $y$가 각각 $-999$ 이상 $999$ 이하의 정수인 경우만 입력으로 주어짐이 보장된다.",
    "output_description": "문제의 답인 $x$와 $y$를 공백으로 구분해 출력한다.",
    "examples": [
      {
        "input": "1 3 -1 4 1 7",
        "output": "2 -1"
      },
      {
        "input": "2 5 8 3 -4 -11",
        "output": "-1 2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/19532",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "a, b, c, d, e, f = map(int, input().split())\nfor x in range(-999, 1000):\n    for y in range(-999, 1000):\n        if a * x + b * y == c and d * x + e * y == f:\n            print(x, y)\n            break\n    else:\n        continue\n    break",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "a, b, c, d, e, f = map(int, input().split())\nfor x in range(-999, 1000):\n    for y in range(-999, 10",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "19554",
    "step_title": "인터랙티브와 투 스텝 1",
    "title": "Guess the number",
    "level": 8,
    "tags": [
      "이분 탐색"
    ],
    "description": "Write a program that guesses an integer X in the range 1, . . . , N.",
    "input_description": "",
    "output_description": "",
    "examples": [
      {
        "input": "5\n\n-1\n\n1\n\n0",
        "output": "? 1\n\n? 3\n\n? 2\n\n= 2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/19554",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "19569",
    "step_title": "인터랙티브와 투 스텝 2",
    "title": "돌멩이 게임",
    "level": 17,
    "tags": [
      "수학",
      "다이나믹 프로그래밍",
      "게임 이론",
      "역추적"
    ],
    "description": "당신은 muse와 함께 아래 규칙으로 게임을 해, 승리해야 한다.처음에 $N$개의 돌이 있으며, 게임은 당신부터 시작한다.맨 처음에 당신은 무조건 돌을 한 개 가져가야 한다.그 다음 차례부터는 돌을 1개 이상 ${x+1}$개 이하로 가져갈 수 있다. 이때, $x$는 전 차례에 상대방이 가져간 돌멩이의 개수이다.마지막 돌을 가져가는 사람이 이긴다.그런데, 사악한 muse는 돌의 개수 $N$을 자신이 이길 수밖에 없게 설정해 놓기도 한다! 따라서 당신은 돌의 개수를 보고, 이길 수 없다고 판단되면 첫 수를 두기 전에 게임을 끝내야 한다. muse는 이길 수 있는 경우에서 항상 최선의 수를 둔다. 이때, 게임에서 이길 수 있겠는가?",
    "input_description": "돌의 개수 $N$이 주어진다. ($2 \\le N \\le 10^5$)",
    "output_description": "먼저, 돌의 개수를 보고 당신이 이길 수 있는지 판단하여라. 이길 수 없다고 판단될 경우 NO를 출력하고 프로그램을 바로 종료해야 한다. 이길 수 있다고 판단될 경우 YES를 출력하고 게임을 진행한다.수를 둘 때는 가져갈 돌의 개수를 정수로 출력해야 한다. 이때 출력하고 난 뒤, 줄을 바꾸고 버퍼를 비워야 한다.당신이 수를 두고 나면 muse 역시 수를 둔다. muse가 가져간 돌의 개수를 입력받아 저장한 뒤, 다시 당신이 수를 두면 된다.게임이 끝나거나 당신이 잘못된 수를 둘 경우 (예: 가져간 돌의 개수가 음수이거나, 현재 있는 돌의 개수보다 많은 경우) 다음 수에서 프로그램은 즉시 종료되며, 문제를 틀리게 된다. 당신이 이겼을 경우, 프로그램은 즉시 종료되어야 한다. 그렇지 않으면, 시간 초과 등 예상치 못한 채점 결과를 받을 수 있다.이길 수 없는 게임을 이길 수 있다고 판단하고 게임을 시작할 경우, 즉시 오답 판정을 받는 것이 아닌, 게임이 모두 진행된 뒤에 오답 판정을 받는 것임에 유의하자. muse는 이길 수 있는 상황에서 항상 최선의 수를 둔다.",
    "examples": [
      {
        "input": "6\n\n\n2",
        "output": "YES\n1\n\n3"
      },
      {
        "input": "7",
        "output": "NO"
      }
    ],
    "url": "https://www.acmicpc.net/problem/19569",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "19654",
    "step_title": "네트워크 플로우 4",
    "title": "Sequence",
    "level": 23,
    "tags": [
      "그래프 이론",
      "자료 구조",
      "그리디 알고리즘",
      "우선순위 큐",
      "최대 유량",
      "최소 비용 최대 유량"
    ],
    "description": "Given two positive integer sequences \\({a_1, a_2, \\dots, a_n}\\) and \\({b_1, b_2, \\dots, b_n}\\) of length \\(n\\), you must find two sequences \\({c_1, c_2, \\dots, c_K}\\) and \\({d_1, d_2, \\dots, d_K}\\) of length \\(K\\) satisfying the following conditions:\\(1\\ le c_1 < c_2 < \\dots < c_K \\le n\\).\\(1 \\le d_1 < d_2 < \\dots < d_K \\le n\\).\\(|{c_1, c_2, \\dots, c_K} \\cap {d_1, d_2,\\dots,d_K}| \\ge L\\).Subject to these conditions, maximize \\(\\sum_{i=1}^{K}{a_{c_i}} + \\sum_{i=1}^{K}{b_{d_i}}\\).",
    "input_description": "The first line contains an integer \\(T\\), indicating the number of testcases.For each testcase:The first line contains three integers \\(n, K, L\\).The second line contains \\(n\\) integers, indicating \\({a_1, a_2, \\dots, a_n}\\).The third line contains \\(n\\) integers, indicating \\({b_1, b_2, \\dots, b_n}\\).",
    "output_description": "Output one integer on one line, the answer.",
    "examples": [
      {
        "input": "5\n1 1 1\n7\n7\n3 2 1\n4 1 2\n1 4 2\n5 2 1\n4 5 5 8 4\n2 1 7 2 7\n6 4 1\n1 5 8 3 2 4\n2 6 9 3 1 7\n7 5 4\n1 6 6 6 5 9 1\n9 5 3 9 1 4 2",
        "output": "14\n12\n27\n45\n62"
      }
    ],
    "url": "https://www.acmicpc.net/problem/19654",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "19693",
    "step_title": "동적 계획법 최적화 2",
    "title": "Safety",
    "level": 24,
    "tags": [
      "다이나믹 프로그래밍",
      "자료 구조",
      "우선순위 큐",
      "함수 개형을 이용한 최적화"
    ],
    "description": "Squeaky the Mouse has recently gained an appreciation for the visual arts, and is now attempting his own work of art to be put on display in the most prestigious visual arts festival in town.His artwork consists of many stacks of similar-sized illuminated cubes arranged to form a line. More precisely, there are N stacks, numbered from 1 to N from left to right, and stack i contains S[i] cubes. The following is one possibility of Squeaky’s artwork:Figure 5: Possible artwork configuration, with N = 20As the cubes are massive, assembling the cubes to form the artwork is a very exhausting task, and Squeaky was only able to complete its assembly a few days before the start of the festival.Just as he thought he was able to finally take a break, the safety committee came around to assess his artwork. The safety committee at this festival has been very particular and uncompromising ever since a disastrous mishap occurred during the festival last year.When Squeaky saw the committee huddling together and speaking to one another in hushed voices, his heart sank. He knew that they found an issue with his work. Eventually, some members of the committee approached him and explained their concern: Some of the stacks might topple over when visitors bump into the artwork. Specifically, the artwork is only safe if the heights of adjacent stacks differ by no more than H cubes; equivalently, |S[i] − S[i + 1]| ≤ H for all 1 ≤ i ≤ N − 1.They then gave him two choices – either alter the artwork to make it safe, or remove the artwork completely.Of course, having spent so much effort on this piece, Squeaky didn’t consider removing the artwork to be an option at all, so he opted to alter the artwork by adding and removing some cubes. As carrying cubes around is tiring, he wants to minimize the amount of work he needs to do.Formally, he wants to minimise the number of steps needed to make his artwork safe, where each step is one of the following:Add one cube to the top of stack kRemove one cube from the top of stack kHelp Squeaky determine the minimum number of steps he needs to make his artwork safe.",
    "input_description": "Your program must read from standard input.The first line of input contains two positive integers, N and H.The second line of input contains N non-negative integers. The ithinteger on this line is S[i].",
    "output_description": "Your program must output a single integer — the minimum number of operations required to make the artwork safe.",
    "examples": [
      {
        "input": "6 1\r\n2 10 0 2 4 3",
        "output": "10"
      },
      {
        "input": "6 3\r\n2 10 2 6 4 3",
        "output": "6"
      },
      {
        "input": "4 1\r\n1 4 1 4",
        "output": "4"
      },
      {
        "input": "10 1\r\n10 9 8 7 6 5 4 3 2 1",
        "output": "0"
      },
      {
        "input": "3 0\r\n1 1 3",
        "output": "2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/19693",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "20040",
    "step_title": "유니온 파인드 1",
    "title": "사이클 게임",
    "level": 12,
    "tags": [
      "자료 구조",
      "분리 집합"
    ],
    "description": "사이클 게임은 두 명의 플레이어가 차례대로 돌아가며 진행하는 게임으로, 선 플레이어가 홀수 번째 차례를, 후 플레이어가 짝수 번째 차례를 진행한다. 게임 시작 시 0 부터n− 1 까지 고유한 번호가 부여된 평면 상의 점n개가 주어지며, 이 중 어느 세 점도 일직선 위에 놓이지 않는다. 매 차례 마다 플레이어는 두 점을 선택해서 이를 연결하는 선분을 긋는데, 이전에 그린 선분을 다시 그을 수는 없지만 이미 그린 다른 선분과 교차하는 것은 가능하다. 게임을 진행하다가 처음으로 사이클을 완성하는 순간 게임이 종료된다. 사이클C는 플레이어가 그린 선분들의 부분집합으로, 다음 조건을 만족한다.C에 속한 임의의 선분의 한 끝점에서 출발하여 모든 선분을 한 번씩만 지나서 출발점으로 되돌아올 수 있다.문제는 선분을 여러 개 그리다 보면 사이클이 완성 되었는지의 여부를 판단하기 어려워 이미 사이클이 완성되었음에도 불구하고 게임을 계속 진행하게 될 수 있다는 것이다. 이 문제를 해결하기 위해서 게임의 진행 상황이 주어지면 몇 번째 차례에서 사이클이 완성되었는지, 혹은 아직 게임이 진행 중인지를 판단하는 프로그램을 작성하려 한다.입력으로 점의 개수n과m번째 차례까지의 게임 진행 상황이 주어지면 사이클이 완성 되었는지를 판단하고, 완성되었다면 몇 번째 차례에서 처음으로 사이클이 완성된 것인지를 출력하는 프로그램을 작성하시오.",
    "input_description": "입력은 표준입력을 사용한다. 입력의 첫 번째 줄에는 점의 개수를 나타내는 정수 3 ≤n≤ 500,000 과 진행된 차례의 수를 나타내는 정수 3 ≤m≤ 1,000,000 이 주어진다. 게임에서 사용하는n개의 점에는 0 부터n− 1 까지 고유한 번호가 부여되어 있으며, 이 중 어느 세 점도 일직선 위에 놓이지 않는다. 이어지는m개의 입력 줄에는 각각i번째 차례에 해당 플레이어가 선택한 두 점의 번호가 주어진다 (1 ≤i≤m).",
    "output_description": "출력은 표준출력을 사용한다. 입력으로 주어진 케이스에 대해,m번째 차례까지 게임을 진행한 상황에서 이미 게임이 종료되었다면 사이클이 처음으로 만들어진 차례의 번호를 양의 정수로 출력하고,m번의 차례를 모두 처리한 이후에도 종료되지 않았다면 0을 출력한다.",
    "examples": [
      {
        "input": "6 5\n0 1\n1 2\n2 3\n5 4\n0 4",
        "output": "0"
      },
      {
        "input": "6 5\n0 1\n1 2\n1 3\n0 3\n4 5",
        "output": "4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/20040",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def find(x):\n    if parent[x] != x:\n        parent[x] = find(parent[x])\n    return parent[x]\n\ndef union(x, y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return False\n    parent[y] = x\n    return True\n\nn, m = map(int, input().split())\nparent = list(range(n))\n\nresult = 0\nfor i in range(1, m + 1):\n    a, b = map(int, input().split())\n    if not union(a, b):\n        result = i\n        break\n\nprint(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "20090",
    "step_title": "동적 계획법 최적화 2",
    "title": "Aliens",
    "level": 24,
    "tags": [
      "다이나믹 프로그래밍",
      "이분 탐색",
      "볼록 껍질을 이용한 최적화",
      "Aliens 트릭"
    ],
    "description": "Our satellite has just discovered an alien civilization on a remote planet. We have already obtained a low-resolution photo of a square area of the planet. The photo shows many signs of intelligent life. Our experts have identifiednpoints of interest in the photo. The points are numbered from 0 ton- 1. We now want to take high-resolution photos that contain all of thosenpoints.Internally, the satellite has divided the area of the low-resolution photo into anmbymgrid of unit square cells. Both rows and columns of the grid are consecutively numbered from 0 tom- 1 (from the top and left, respectively). We use (s,t) to denote the cell in rowsand columnt. The point numberiis located in the cell (ri,ci). Each cell may contain an arbitrary number of these points.Our satellite is on a stable orbit that passes directly over themaindiagonal of the grid. The main diagonal is the line segment that connects the top left and the bottom right corner of the grid. The satellite can take a high-resolution photo of any area that satisfies the following constraints:the shape of the area is a square,two opposite corners of the square both lie on the main diagonal of the grid,each cell of the grid is either completely inside or completely outside the photographed area.The satellite is able to take at most high-resolution photos. Once the satellite is done taking photos, it will transmit the high-resolution photo of each photographed cell to our home base (regardless of whether that cell contains some points of interest). The data for each photographed cell will only be transmittedonce, even if the cell was photographed several times.Thus, we have to choose at mostksquare areas that will be photographed, assuring that:each cell containing at least one point of interest is photographed at least once, andthe number of cells that are photographed at least once is minimized.Your task is to find the smallest possible total number of photographed cells.",
    "input_description": "",
    "output_description": "",
    "examples": [],
    "url": "https://www.acmicpc.net/problem/20090",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(\"\")",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "20135",
    "step_title": "네트워크 플로우 3",
    "title": "연세 마스크 공장",
    "level": 21,
    "tags": [
      "그래프 이론",
      "최대 유량",
      "서큘레이션"
    ],
    "description": "연세대는 코로나 19를 대비하기 위해서 마스크 공장을 만들었다.마스크를 생산하는N개의 공간이 있고 각 공간들을M개의 단방향 통로, 그리고 마스크를 각 공간별로 보내거나 받는 지하 공간이 있다. 임의의 서로 다른 두 공간 사이에 두 개 이상의 통로가 있는 경우와 같은 공간을 잇는 통로가 있는 경우는 없다.각 공간별로 정수pi가 할당되어 있는데,pi가 양수면 만큼 지하 공간으로부터 마스크를 매 초마다pi개를 받고, 음수면 매 초마다 -pi개 만큼 지하 공간으로 보내야 한다. 또한, 각 통로별로 매 초마다 최소 보내야 하는 마스크의 개수si, 보낼 수 있는 마스크의 최대 개수ei가 주어진다.마스크를 생산하는 공간과 지하 공간은 매 초마다 마스크를 보낼 때 해당 공간의 마스크의 개수에 변동 사항이 없어야 한다.이렇게 했을 때, 각각의 통로별로 몇 개의 마스크를 보내야 하는지 구하여라.",
    "input_description": "다음과 같이 입력이 주어진다.NMp1. . .pNu1v1s1e1. . . . . .uMvMsMeM",
    "output_description": "첫 번째 줄에 답이 있는 경우에는1, 답이 없는 경우에는-1을 출력한다.답이 있는 경우,M개의 줄에 걸쳐 통로별로 매 초마다 보내야 하는 마스크의 개수를 번호 순서대로 출력하시오. 만약에 답이 여러 개인 경우 가능한 아무 경우나 출력하면 된다.",
    "examples": [
      {
        "input": "6 6\n-2 2 -2 2 -2 2\n1 2 2 4\n2 3 4 6\n3 4 3 5\n4 5 5 7\n5 6 1 3\n6 1 3 5",
        "output": "1\n3\n5\n3\n5\n3\n5"
      },
      {
        "input": "6 6\n-2 2 -2 2 -2 2\n1 2 2 4\n2 3 4 6\n3 4 3 5\n4 5 5 7\n5 6 1 2\n6 1 3 5",
        "output": "-1"
      },
      {
        "input": "1 0\n0",
        "output": "1"
      },
      {
        "input": "1 0\n1",
        "output": "-1"
      },
      {
        "input": "5 5\n0 0 0 0 0\n1 2 0 0\n2 3 0 0\n3 4 0 0\n4 5 0 0\n5 1 0 0",
        "output": "1\n0\n0\n0\n0\n0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/20135",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "20149",
    "step_title": "기하 2",
    "title": "선분 교차 3",
    "level": 17,
    "tags": [
      "기하학",
      "많은 조건 분기",
      "선분 교차 판정"
    ],
    "description": "2차원 좌표 평면 위의 두 선분 L1, L2가 주어졌을 때, 두 선분이 교차하는지 아닌지 구해보자. 한 선분의 끝 점이 다른 선분이나 끝 점 위에 있는 것도 교차하는 것이다.L1의 양 끝 점은 (x1, y1), (x2, y2), L2의 양 끝 점은 (x3, y3), (x4, y4)이다.",
    "input_description": "첫째 줄에 L1의 양 끝 점 x1, y1, x2, y2가, 둘째 줄에 L2의 양 끝 점 x3, y3, x4, y4가 주어진다.",
    "output_description": "L1과 L2가 교차하면 첫째 줄에 1, 아니면 0을 출력한다.두 선분이 한 점에서 교차하는 경우 둘째 줄에 교차하는 점의 x좌표와 y좌표를 공백으로 구분해 출력한다. 한 점에서 교차하지 않는 경우에는 둘째 줄을 출력하지 않는다.좌표의 절대/상대 오차는 10-9까지 허용한다.",
    "examples": [
      {
        "input": "1 1 5 5\n1 5 5 1",
        "output": "1\n3 3"
      },
      {
        "input": "1 1 5 5\n6 10 10 6",
        "output": "0"
      },
      {
        "input": "1 1 5 5\n5 5 1 1",
        "output": "1"
      },
      {
        "input": "1 1 5 5\n3 3 5 5",
        "output": "1"
      },
      {
        "input": "1 1 5 5\n3 3 1 3",
        "output": "1\n3 3"
      },
      {
        "input": "1 1 5 5\n5 5 9 9",
        "output": "1\n5 5"
      },
      {
        "input": "1 1 5 5\n6 6 9 9",
        "output": "0"
      },
      {
        "input": "1 1 5 5\n5 5 1 5",
        "output": "1\n5 5"
      },
      {
        "input": "1 1 5 5\n6 6 1 5",
        "output": "0"
      },
      {
        "input": "2 8 9 23\n1 10 9 8",
        "output": "1\n2.7313432835820897 9.5671641791044770"
      }
    ],
    "url": "https://www.acmicpc.net/problem/20149",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "20176",
    "step_title": "고속 푸리에 변환",
    "title": "Needle",
    "level": 20,
    "tags": [
      "수학",
      "고속 푸리에 변환"
    ],
    "description": "The “needle” is a legendary assassin who lives in the North Kingdom. As you know, the needle is very thin and long. More than anything, it is deadly sharp. The king of the North Kingdom is obsessed with the idea that the needle might kill him by stabbing countless times. The king issued an emergency order to arrest the needle. So, the needle decided to escape to the South Kingdom.As shown in the figure below, the border between two kingdoms consists of three horizontal barriers (line segments), each of which has one or more infinitesimally small holes inside. (The holes are marked as x in the figure.) Three barriers have the same length and are aligned vertically as in the figure. The upper barrier is one unit above the middle barrier, which is one unit above the lower barrier. Two kingdoms are surrounded by impenetrable outer wall. Each kingdom also has a very large territory so that the needle can move (translate or rotate) freely inside the kingdom. The needle is at least twice as long as the barriers. The needle is rigid, i.e., not bendable, and has zero-thickness, so it can pass the holes freely, but cannot drill any other part of the barriers than the holes.The only way from the Northern Kingdom to the Southern Kingdom is through three holes, one from each of the three barriers, at the same time. In other words, the needle can pass the border only through three holes, exactly one from each barrier, which are aligned on a line. The border in the figure has two possible escape passages from the north to the south.For this pity assassin, write a program to tell how many possible escape passages from the North Kingdom to the South Kingdom are available.",
    "input_description": "Your program is to read from standard input. The input consists of six lines. The first line contains a positive integernurepresenting the number of holes of the upper barrier. The second line containsnuintegers separated by a space that represent thex-coordinates of the holes. The third and fourth lines are for the middle barrier, each containingnm, the number of holes of the middle barrier, andnmx-coodinates of the holes. The fifth and sixth lines are for the lower barrier, each containingnl, the number of holes of the lower barrier, andnlx-coodinates of the holes. 1 ≤nu,nm,nl≤ 50,000 and allx-coordinates of the holes are integers between −30,000 and 30,000. Holes of each barrier have all distinctx-coordinates.",
    "output_description": "Your program is to write to standard output. Print exactly one line. The line should contain a nonnegative integer representing the number of all possible passages from the north to the south.",
    "examples": [
      {
        "input": "1\n1\n1\n2\n1\n1",
        "output": "0"
      },
      {
        "input": "3\n4 -3 2\n2\n4 1\n3\n-3 4 0",
        "output": "2"
      },
      {
        "input": "3\n-1 1 0\n3\n0 1 -1\n3\n0 -1 1",
        "output": "5"
      }
    ],
    "url": "https://www.acmicpc.net/problem/20176",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 수학 문제 기본 구조\ndef solve():\n    # 입력 처리\n    N = int(input())\n    \n    # 계산\n    result = N\n    \n    return result\n\nprint(solve())",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "20412",
    "step_title": "수학 2",
    "title": "추첨상 사수 대작전! (Hard)",
    "level": 14,
    "tags": [
      "수학",
      "정수론",
      "모듈로 곱셈 역원",
      "페르마의 소정리"
    ],
    "description": "입력 제한 외 난이도에 따른 문제의 차이는 없다.APC는 매년 교내 참가자들에게 추첨상을 지급하고 있다. 올해 추첨상은 공정한 추첨을 위해 준표가 직접 작성한 난수생성기를 통해 추첨을 하고자 한다.난수생성기란, 이론적으로 예측을 더 할 수 없도록 일련의 숫자나 심볼을 생성하는 장치이다.주헌 : 형이 짠 난수생성기가 공정하다는 걸 어떻게 알아 ?준표 : 걱정 마! c언어에서 ANSI 표준으로 사용하는 '선형합동법(Linear Congruential)' 을 구현할 거니까 ~주헌 : 선형합동법이 뭔데 ?준표 : 그게 뭐냐면 ..준표의 설명을 간단히 정리해보면,X1= (a × Seed + c) % mX2= (a × X1+ c) % m...Xn + 1= (a × Xn+ c) % m이런 식으로 준표가 몰래 정하는a,c,m와 참가자들이 정하는Seed값을 바탕으로 위 공식에 따라 난수를 생성한다는 것이었다.주헌 : 음...a,c,m을 아무렇게나 잡으면 안 되지 않을까 ?준표 : 응. Hull-Dobell 정리에 따르면 그게 맞아. 그런데 귀찮아서 그냥m을대충 내가 좋아하는 소수로 하려구.주헌 : (형이 좋아하는 소수..? 씨익..)사실 주헌이는 올해에는 추첨상을 반드시 받아내겠다는 야망이 있었다! 위 대화는 그를 위한 초석이었던 것이다! 주헌이는 준표를 너무 잘 알기 때문에 준표가 좋아하는 소수를 이미 알고 있었고, 준표가 자신이 직접 작성한 난수생성기에 문제가 없음을 참가자들에게 알려주기 위해 실제 추첨 전 난수생성기가 잘 작동한다는 것을 모두의 앞에서 시연하기로 되어있었다.주헌이는 계략을 짰다. 주헌이는 시연 중 참가자들이 정한Seed와 이를 이용해 만들어진X1,X2를 이용해 준표가 몰래 정한a,c를 찾아낼 것이다. 만약 주헌이가 추첨상을 받지 못한다면, 찾아낸a,c를 폭로해 모든 것이 조작되었다고 주장하며 추첨 자체를 무효로 만들 계략이다! 주헌이는a,c를 자동으로 찾아주는 프로그램을 만들고자 한다.",
    "input_description": "한 줄에 걸쳐 준표가 좋아하는 소수m, 참가자들이 정한 Seed, 시연으로 공개된X1,X2이 주어진다. 항상 가능한 상황만 입력으로 주어진다.",
    "output_description": "준표가 비밀리에 선정한 정수a,c를 출력한다. 가능한 답이 여러 개라면, 그중 아무거나 출력한다.",
    "examples": [
      {
        "input": "13 5 2 9",
        "output": "2 5"
      },
      {
        "input": "13 6 5 3",
        "output": "2 6"
      },
      {
        "input": "11 9 9 9",
        "output": "2 2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/20412",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 수학 문제 기본 구조\ndef solve():\n    # 입력 처리\n    N = int(input())\n    \n    # 계산\n    result = N\n    \n    return result\n\nprint(solve())",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "20670",
    "step_title": "기하 3",
    "title": "미스테리 싸인",
    "level": 18,
    "tags": [
      "기하학",
      "이분 탐색",
      "볼록 다각형 내부의 점 판정"
    ],
    "description": "취준생 태영이는 오랜 구직활동 끝에 취직에 성공했다. 여러가지 이유로 취업시장이 위축된 요즘, 가뭄의 단비 같은 일자리에 태영이는 기뻐했다. 하지만 모든 것은 계약되기 전에는 불확실한 법, 태영이는 하루빨리 근로계약서를 작성하고 싶은 마음에 밤잠을 설쳤다.사회적 거리두기로 인한 언택트 시대, 태영이는 비대면 전자계약 서비스모두싸인(MODUSIGN)을 이용해 근로계약서를 작성하게 되었다. 메일을 받은 후 태영이의 불안감은 사라졌고, 난생처음 작성해보는 계약서에 어떻게 하면 멋진 싸인을 할 수 있을지 행복한 고민을 시작했다.태영이는 너무 튀지 않으면서도 독특한 느낌적인 느낌의 싸인을 만들고 싶다. 평소 기하학적인 감각이 돋보이던 태영이는 자신만의 룰을 지키며 싸인을 만드려고 한다. 태영이가 정한 룰은 다음과 같다.태영이는 두 개의 볼록 다각형 A와 B를 정한다.다각형 B는 완전히 A의 내부에 존재한다.태영이의 싸인은 여러 개의 점을 차례로 이은 다각선이다.태영이의 싸인을 구성하는 점은 A의 내부에 있어야 한다. 그리고 B의 외부에 있어야 한다.도형의 외곽선 상에는 싸인의 점이 존재하지 않는다.문제에서 주어지는 모든 좌표는 정수다.<그림 1> 왼쪽부터 차례로 성공적인 싸인, B내부에 점이 존재해 실패한 싸인, A외부에 점이 존재해 실패한 싸인두 도형 A, B의 정보와 태영이가 싸인한 다각선의 정보가 입력으로 주어질 때, 해당 싸인은 주어진 규칙을 만족하는지 판단하는 프로그램을 작성해주자. 만약 태영이의 싸인이 규칙을 위반했다면, 몇 개의 점이 규칙을 위반했는지 계산하시오.",
    "input_description": "첫 번째 줄에는 세 개의 자연수N, M, K가 공백으로 구분되어 주어진다.N은 도형 A를 구성하는 점의 수이다. (3 ≤N​≤ 10,000)M은 도형 B를 구성하는 점의 수이다. (3 ≤M​≤ 10,000)K는 태영이의 싸인을 구성하는 점의 수이다. (2 ≤K​≤ 300,000)두 번째 줄에는 도형 A를 구성하는N개 점의 좌표가 공백으로 구분된 2N개의 정수로 주어진다. 각 점의 좌표는X Y형식으로 공백으로 구분되어 주어진다. 각 점은 반시계 방향 순서로 주어진다.세 번째 줄에는 도형 B를 구성하는M개 점의 좌표가 공백으로 구분된 2M개의 정수로 주어진다. 각 점의 좌표는X Y형식으로 공백으로 구분되어 주어진다. 각 점은 반시계 방향 순서로 주어진다.다각형 B의 모든 점은 다각형 A의 외곽선을 제외한 내부에 존재한다.네 번째 줄에는 싸인을 구성하는K개 점의 좌표가 공백으로 구분된 2K개의 정수로 주어진다. 각 점의 좌표는X Y형식으로 공백으로 구분되어 주어진다. 각 점을 차례로 이으면 태영이의 싸인이 완성된다.모든 좌표는 정수 값을 가진다. (-1,000,000,000 ≤X, Y​≤ 1,000,000,000)문제에서 주어지는 점이 중복되는 경우는 존재하지 않는다.싸인의 점은 도형 A, B의 외곽선상에 존재하지 않는다.",
    "output_description": "주어진 싸인이 태영이의 규칙을 만족한다면 \"YES\" 를 출력하시오.만약 태영이의 규칙을 만족하지 않는다면, 조건을 위반한 점의 개수를 정수로 출력하시오.",
    "examples": [
      {
        "input": "8 5 8\n2 5 1 6 -2 6 -4 5 -5 2 -1 0 2 1 3 3\n0 5 -4 4 -2 1 1 1 2 3\n-4 2 -3 5 -3 2 1 5 2 2 -2 5 -1 5 2 4",
        "output": "YES"
      },
      {
        "input": "8 5 9\n2 5 1 6 -2 6 -4 5 -5 2 -1 0 2 1 3 3\n0 5 -4 4 -2 1 1 1 2 3\n-4 2 -3 6 -3 2 2 2 1 3 -2 4 1 5 0 7 -2 5",
        "output": "4"
      },
      {
        "input": "3 3 3\n-1 -1 4 -1 -1 4\n0 0 1 0 0 1\n-2 -2 2 0 0 2",
        "output": "1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/20670",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "20920",
    "step_title": "심화 2",
    "title": "영단어 암기는 괴로워",
    "level": 8,
    "tags": [
      "자료 구조",
      "문자열",
      "정렬",
      "집합과 맵",
      "해시를 사용한 집합과 맵",
      "트리를 사용한 집합과 맵"
    ],
    "description": "화은이는 이번 영어 시험에서 틀린 문제를 바탕으로 영어 단어 암기를 하려고 한다. 그 과정에서 효율적으로 영어 단어를 외우기 위해 영어 단어장을 만들려 하고 있다. 화은이가 만들고자 하는 단어장의 단어 순서는 다음과 같은 우선순위를 차례로 적용하여 만들어진다.자주 나오는 단어일수록 앞에 배치한다.해당 단어의 길이가 길수록 앞에 배치한다.알파벳 사전 순으로 앞에 있는 단어일수록 앞에 배치한다$M$보다 짧은 길이의 단어의 경우 읽는 것만으로도 외울 수 있기 때문에 길이가 $M$이상인 단어들만 외운다고 한다. 화은이가 괴로운 영단어 암기를 효율적으로 할 수 있도록 단어장을 만들어 주자.",
    "input_description": "첫째 줄에는 영어 지문에 나오는 단어의 개수 $N$과 외울 단어의 길이 기준이 되는 $M$이 공백으로 구분되어 주어진다. ($1 \\leq N \\leq 100\\,000$, $1 \\leq M \\leq 10$)둘째 줄부터 $N+1$번째 줄까지 외울 단어를 입력받는다. 이때의 입력은 알파벳 소문자로만 주어지며 단어의 길이는 $10$을 넘지 않는다.단어장에 단어가 반드시 1개 이상 존재하는 입력만 주어진다.",
    "output_description": "화은이의 단어장에 들어 있는 단어를 단어장의 앞에 위치한 단어부터 한 줄에 한 단어씩 순서대로 출력한다.",
    "examples": [
      {
        "input": "7 4\napple\nant\nsand\napple\nappend\nsand\nsand",
        "output": "sand\napple\nappend"
      },
      {
        "input": "12 5\nappearance\nappend\nattendance\nswim\nswift\nswift\nswift\nmouse\nwallet\nmouse\nice\nage",
        "output": "swift\nmouse\nappearance\nattendance\nappend\nwallet"
      }
    ],
    "url": "https://www.acmicpc.net/problem/20920",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\nword_count = {}\n\nfor _ in range(N):\n    word = input().strip()\n    if len(word) >= M:\n        word_count[word] = word_count.get(word, 0) + 1\n\nwords = sorted(word_count.keys(), key=lambda x: (-word_count[x], -len(x), x))\nfor word in words:\n    print(word)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n, m = map(int, input().split())\nwords = {}\nfor _ in range(n):\n    word = input().strip()\n    if len(word) >= m:\n        words[word] = words.get(word, 0) + 1\n\nsorted_words = sorted(words.items(), key=lambda x: (-x[1], -len(x[0]), x[0]))\nfor word, _ in sorted_words:\n    print(word)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "20929",
    "step_title": "인터랙티브와 투 스텝 1",
    "title": "중간",
    "level": 15,
    "tags": [
      "이분 탐색"
    ],
    "description": "이 문제는 인터랙티브 문제다.국렬이는 $1$ 이상 $10^9$ 이하의 $N$개의 자연수로 이루어진 두 배열 $A$, $B$를 가지고 있다. 당신은 $A$, $B$를 합쳤을 때 중간값을 구해야 한다. 중간값은 $2N$개 수들을 오름차순으로 정렬했을 때 $N$번째 수를 중간값이라고 한다.국렬이는 인성이 나빠서 배열 $A$, $B$를 당신에게 제공하지 않을 것이다. 그래도 약간의 자비가 있기에 특정 배열의 $x$번째 수가 무엇인지 물어볼 기회를 줬다. 다만 40번까지 질문이 가능하며, 그 이상으로 질문할 경우 국렬이는틀렸습니다로 당신을 때릴 것이다. 답을 출력하는 것은 질문 횟수에 포함되지 않는다.40번 이하로 질문해서 중간값을 구해보자.",
    "input_description": "입력의 첫 줄에 배열의 길이 $N$이 주어진다. $N$은 $2^k$으로 표현할 수 있는 양의 정수만 주어진다. ($0 \\le k \\le 19$)",
    "output_description": "다음 중 하나를 표준 출력 스트림(stdout)으로 한 줄에 출력하여, 배열의 원소를 질문 할 수 있다.? A x: 배열 $A$의 $x$번째 수 ($1 \\le x \\le N$)? B x: 배열 $B$의 $x$번째 수 ($1 \\le x \\le N$)어떤 배열에서 $x$번째 수는, 그 배열을 오름차순으로 정렬했을 때 $x$번째인 수를 의미한다각 질문을 출력한 후에는 반드시 표준 출력 버퍼를 flush해 주어야 하고, 표준 입력 스트림(stdin)을 통해 질문에 대한 답을 입력받아야 한다. 질문에 대한 답을 입력받지 않으면런타임에러를 받게 된다. 최대 질문 횟수는 40번으로, 그 이상으로 질문을 요청한 경우틀렸습니다!를 받는다.만약 중간값을 알아낸 경우, 표준 출력 스트림으로 다음을 한 줄에 출력한다.! x: 배열 A, B를 합쳤을 때의 중앙값은 $x$이다.그 후 반드시 표준 출력 버퍼를 flush해야 하고, 프로그램을 종료한다. 이것은 질문 횟수에 포함되지 않는다.언어별로 표준 출력 버퍼를 flush하는 방법은 다음과 같다.C:fflush(stdout)C++:std::cout << std::flushJava:System.out.flush()Python:sys.stdout.flush()",
    "examples": [
      {
        "input": "2\n\n1\n\n2\n\n2\n\n3",
        "output": "? A 1\n\n? A 2\n\n? B 1\n\n? B 2\n\n! 2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/20929",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "20944",
    "step_title": "해 구성하기",
    "title": "팰린드롬 척화비",
    "level": 3,
    "tags": [
      "문자열",
      "애드 혹"
    ],
    "description": "흥선이는 팰린드롬을 싫어한다. 어느 날 지구를 정복한 흥선이는 팰린드롬 척화비를 세워, 전 지구의 팰린드롬을 없애버렸다. 그리고 수미상관 순수비를 만들어 수미상관을 널리 퍼뜨렸다.팰린드롬과 수미상관의 정의는 다음과 같다.팰린드롬 :(앞뒤가 똑같은 팰린드롬~)“u”, “xyx”, “krrk” 같이 뒤집어 읽어도 같은 문자열을 뜻한다.수미상관 :(앞뒤가 똑같은 수미상관~)“z”, “pqpq”, “astoast” 같이 앞쪽 절반이 뒤쪽 절반과 같은 문자열을 뜻한다. 정확히는, 길이가 $N$인 문자열이면 길이가 $\\left\\lfloor\\frac{N}{2}\\right\\rfloor$인 접두사와 접미사가 동일한 문자열을 뜻한다.민수는 팰린드롬의 유구한 역사를 살리고 싶었지만, 여기저기 박힌 팰린드롬 척화비 때문에 그 꿈을 이룰 수 없었다. 그래도 하늘이 무너져도 솟아날 구멍이 있으랴! 민수는 길이가 $N$인 수미상관이면서 팰린드롬인 문자열을 발견한 것이다! 이것은 흥선이의 팰린드롬 척화비에 위배되지 않았고, 민수는 팰린드롬의 유구한 역사를 후대에 남기기 위해 노트 한 켠에 이 사실을 적었다.미래에 후손들은 민수의 노트를 발견했지만, 시간이 너무 오래 지나버렸다. 민수의 노트는 얼룩과 먼지 때문에 많은 부분을 알아볼 수가 없었다. 오로지 민수가 길이가 $N$인 수미상관이면서 팰린드롬인 문자열을 발견했다는 사실만을 알 수 있었을 뿐이다.민수의 후손인 시철이는 민수의 노트가 사실이라 생각했고, 길이가 $N$인 수미상관이면서 팰린드롬인 문자열을 찾기 위해 공학관에서 밤새 연구를 하고 있다.민수가 찾은 것은 무엇이었을까?",
    "input_description": "다음과 같이 입력이 주어진다.$N$",
    "output_description": "길이가 $N$이고 알파벳 소문자로 이루어진, 수미상관이면서 팰린드롬인 문자열을 출력한다.항상 그러한 문자열은 존재하고, 만약 여러 가지가 있다면 그중 하나를 출력한다.",
    "examples": [
      {
        "input": "1",
        "output": "a"
      },
      {
        "input": "3",
        "output": "sts"
      }
    ],
    "url": "https://www.acmicpc.net/problem/20944",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "word = input()\nprint(1 if word == word[::-1] else 0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "word = input()로 입력을 처리합니다.",
            "code_pattern": "word = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "조건 판단",
            "description": "조건문을 사용하여 상황에 따라 다르게 처리합니다.",
            "code_pattern": "print(1 if word == word[::-1] else 0)",
            "socratic_hint": "조건에 따라 다르게 처리하려면?",
            "hint": "if-else 문을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(1 if word == word[::-1] else 0)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "21162",
    "step_title": "문자열 알고리즘 1",
    "title": "뒤집기 K",
    "level": 18,
    "tags": [
      "문자열",
      "해싱",
      "접미사 배열과 LCP 배열"
    ],
    "description": "길이가 $N$인 수열이 있다. 이 수열은 같은 수를 여러 개 포함할 수 있고 모든 수는 $N$ 이하의 자연수이다.이 수열을 길이가 0이 아닌 두 부분으로 나누어서 두 부분 각각 순서를 반대로 한 뒤 다시 이어 붙이려고 한다. 이렇게 해서 생성되는 모든 수열들을 나열하고 싶어하는 jhnah917은 당신에게 사전순으로 나열할 경우 어떤 수열이 $K$번째에 오게 될 것인지 물어보았다. 사전순이라 하는 것은 첫 번째 수가 작은 것이 먼저 오고, 첫 번째 수가 같다면 두 번째 수가 작은 것이 먼저 오고, 두 번째 수도 같다면 세 번째 수가…….jhnah917이 당신에게 물어본, 위 규칙으로 생성되는 수열을 사전 순으로 나열했을 때 $K$번째로 나오는 수열을 출력하는 프로그램을 작성하여라.",
    "input_description": "첫째 줄에 양의 정수 $N, K$가 주어진다. ($1 \\leq K < N \\leq 200\\,000$)둘째 줄에는 수열을 이루는 N개의 수가 빈 칸을 사이에 두고 차례대로 주어진다.",
    "output_description": "첫째 줄에 사전순으로 나열했을 때 $K$번째로 나오는 수열을 출력하여라.",
    "examples": [
      {
        "input": "10 1\n2 1 3 1 2 1 3 1 3 1",
        "output": "1 2 1 3 1 2 1 3 1 3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/21162",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "21725",
    "step_title": "유니온 파인드 2",
    "title": "더치페이",
    "level": 18,
    "tags": [
      "그래프 이론",
      "자료 구조",
      "그래프 탐색",
      "누적 합",
      "분리 집합",
      "작은 집합에서 큰 집합으로 합치는 테크닉"
    ],
    "description": "$n$명의 친구들이 인덱스국에 여행을 떠난다. 인덱스국은 굉장히 넓고, 친구들은 각자 가보고 싶은 위치가 다르다. 따라 맨 처음에는 모두 1인 그룹으로 각자 여행을 하다가, 일정이 지나면서 그룹끼리 합류하여 마지막에는 하나의 그룹으로 뭉쳐서 다같이 여행을 마무리하기로 했다.여행을 하는 데 지출은 필수적이다. 이 친구들은 각자 $2 \\times 10^{18}$원씩을 가지고 있어서, 여행 동안에 돈을 그다지 계획적으로 쓰지는 않았다. 그래서 여행이 모두 끝난 후, 각자가 원래 부담했어야 할 몫을 정산하는 것이 무척 성가시게 되었다.여행할 때 지출은 그룹 단위로 이루어지며, 여행할 때는 그룹원 중 한 명이 모두 계산한다. 여행이 모두 끝나고 정산할 때는 지출 당시의 모든 그룹원이 모두 공평하게 같은 금액만큼 부담한다. 금액은 원화로 계산하며, 각 지출은 당시 그룹원의 수로 나누어 떨어진다.정산은 한 명이 다른 한 명에게 돈을 전송하는 송금을 통해 이루어진다. 매 지출마다 각자의 부담금을 계산하여 여행할 때 돈을 냈던 사람에게 송금을 하는 것은 매우 귀찮기 때문에, 친구들은 지출들을 모두 한꺼번에 정산해 $n$번 이하의 송금으로 모든 정산을 할 수 있는지 궁금해졌다.그룹이 합류한 기록과 모든 지출의 기록이 시간 순서대로 주어진다. 여행이 모두 끝난 후, $n$번 이하의 송금으로 모든 지출을 정산할 수 없다면-1, 정산할 수 있다면 송금 횟수와 송금에 대한 정보를 출력하도록 하자.",
    "input_description": "입력의 첫 줄에 정수 $n, m$이 주어진다. $n$은 여행을 한 친구들의 수, $m$은 그룹의 합류 및 지출 기록의 총 개수이다. 각 친구들은 $1$번부터 $n$번까지의 번호로 표현한다.이후 $m$개의 줄에 걸쳐 각 기록을 나타내는 수들이 한 줄에 하나씩 주어진다.두 그룹이 합류한 기록은1 x y와 같이 주어진다. 이는x가 속한 그룹과y가 속한 그룹이 합류했다는 것을 의미한다.x와y가 이미 같은 그룹에 속해 있는 경우는 없다.지출이 발생한 기록은2 x c와 같이 주어진다. 이는x가 현재 그룹원들을 위해 총c원을 지출했다는 의미이다.c는x가 속한 그룹의 그룹원의 수로 나누어 떨어진다.기록들이 모두 처리된 시점에 모든 학생이 한 그룹에 속해 있음이 보장된다.",
    "output_description": "첫째 줄에 조건을 만족하는 송금 방법이 존재하지 않으면-1, 존재하면 송금의 총 횟수 $k$를 출력하라. (단, $0 \\le k \\le n$)그 다음 $k$개 줄 각각에는 송금에 대한 정보를 조건에 맞게 출력하라. 여러 방법이 존재하면 그 중 아무거나 출력해도 좋고, 송금 또한 아무 순서로나 출력해도 괜찮다.송금에 대한 정보는x y c와 같이 나타내도록 하자. 이는x가y에게c원을 보낸다는 의미이다.x와y의 순서에 유의하라.",
    "examples": [
      {
        "input": "3 5\n1 2 3\n2 1 7\n2 3 42\n1 2 1\n2 1 30",
        "output": "3\n2 3 21\n2 1 10\n3 1 10"
      }
    ],
    "url": "https://www.acmicpc.net/problem/21725",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "21905",
    "step_title": "네트워크 플로우 4",
    "title": "Archeologists",
    "level": 22,
    "tags": [
      "다이나믹 프로그래밍",
      "자료 구조",
      "그리디 알고리즘",
      "누적 합",
      "우선순위 큐",
      "함수 개형을 이용한 최적화"
    ],
    "description": "Your treasure hunter team has just discovered a giant archeological site, full of precious metals and valuable antiquities. The site is composed of $n$ digging spots on a line.The initial plans suggest that each of the $n$ digging spots has a net profit associated with it. The $i$-th spot’s associated profit is $p_i$. More specifically, this means that your team would gain $p_i$ dollars for each meter dug in the $i$-th spot. Note that $p_i$ may also be negative, which means that the running cost of the excavating machinery surpasses the actual gain from digging in the $i$-th spot.Naturally, you would want to dig as much as possible in the most profitable spots. However, in order not to cause landslides, you are not allowed to have slopes that are too steep. More precisely, for any two adjacent spots, the difference between the digging depth at these spots cannot differ by more than $1$ meter. In particular, spots $1$ and $n$ can be dug only at most $1$ meter deep.What is the largest net profit that you can obtain, under these conditions?For instance, a valid digging plan that turns out to be optimal in the case of the first example input is illustrated below. The net profit of such plan is $8$.",
    "input_description": "The first line of the input will contain a positive integer $n$ ($1 \\le n \\le 250\\,000$).The second line of the input will contain $n$ integers $p_i$ ($-10^6 \\le p_i \\le 10^6$), separated by spaces.",
    "output_description": "Output exactly one integer, the largest profit that you can obtain.",
    "examples": [
      {
        "input": "5\n1 3 -4 2 1",
        "output": "8"
      },
      {
        "input": "4\n1 1 -2 3",
        "output": "5"
      },
      {
        "input": "5\n-1 -3 0 -5 -4",
        "output": "0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/21905",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "21970",
    "step_title": "스프라그 그런디 정리",
    "title": "Football",
    "level": 18,
    "tags": [
      "수학",
      "게임 이론"
    ],
    "description": "Little Square’s school is organising the annual football match. The two team captains are Little Square and Little Triangle. They will select their teams from the N classes in the school. The team selection works in the following way:Little Square and Little Triangle alternate picking people in turns. Little Square goes first.In a turn, only students from a single class can be chosen.In a turn, at least one and at most K students can be chosen.In a turn, one must select at most as many students as were selected in the previous turn.The captain who selects the last student(s) gets the ”Fo(1)otball” prize.The captains do not care how many students they select overall, and all students are identical when it comes to football skill. They only care about the ”Fo(1)otball” prize. Assuming both have perfect strategy, who wins it ?",
    "input_description": "Each test file will contain multiple test cases, describing different scenarios. On the first line you will find T, the number of testcases. Their descriptions follow. On the first line of a testcase you will find N and K. On the second line of a testcase you will find N positive integers, which represent the sizes of the classes in Little Square’s school.",
    "output_description": "Output the answers for the T testcases, each on the same line, not separated by spaces. If Little Square wins the prize in a testcase, output1; output0otherwise.",
    "examples": [
      {
        "input": "3\n3 1\n3 1 1\n5 2\n2 1 1 1 1\n1 2\n3",
        "output": "111"
      }
    ],
    "url": "https://www.acmicpc.net/problem/21970",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 수학 문제 기본 구조\ndef solve():\n    # 입력 처리\n    N = int(input())\n    \n    # 계산\n    result = N\n    \n    return result\n\nprint(solve())",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "22029",
    "step_title": "인터랙티브와 투 스텝 2",
    "title": "철도",
    "level": 19,
    "tags": [
      "그래프 이론",
      "그래프 탐색",
      "트리",
      "해 구성하기",
      "너비 우선 탐색",
      "깊이 우선 탐색"
    ],
    "description": "사이가 나쁜 A, B 두 나라가 있다. A나라는 B나라를 침략하기 위해 B나라의 철도망을 알아내려 한다. B나라에 여러 차례 스파이를 보냈지만 항상 의미있는 정보를 캐기 전 잡혔기 때문에, A나라가 알고 있는 정보는 다음이 전부이다.B나라의 철도망은 모두 $N$개의 역으로 이루어져 있고, 각 역은 $1$부터 $N$까지 번호가 붙어 있다.서로 다른 어떤 두 역을 고르더라도 직접 철로로 이어져 있거나, 철로로 이어진 다른 역(들)을 통해서 이어져 있다.어떤 두 역을 고르더라도 이 둘을 연결하는 경로는 정확히 하나이다.자신과 자신을 철로로 직접 이은 경우는 없다.스파이를 보내는 것은 한계가 있음을 깨닫고, A나라는 B나라 철도회사 고위 간부를 매수하여 철도망을 그린 그림을 얻어내려고 한다. 이 그림을 직접 보내면 배신자가 누구인지 알려질 것이므로, 배신자는 다음과 같이 그림을 고쳐서 A나라에 보낼 것이다.철도망을 그린 그림 위에 $K$개의 가짜 철로를 그린다. 즉, 그림에서 철로로 직접 연결되지 않은 서로 다른 두 역 $a$와 $b$를 골라서, 이 둘을 가짜 철로로 직접 잇는다. 이를 $K$번 반복한다.하나의 역에특별한 표시를 한다.마지막으로, 역들의 번호를 모두 지운다.배신자는 최종적으로 얻은 그림을 A나라에 전송한다. 이 정보만으로는 B나라의 철도망을 그린 그림이라는 것을 알기 어렵기 때문에, 비밀 정보가 유출되었다는 사실을 아무도 모를 것이다.이 계획이 성공하기 위해서는 다음과 같은 문제가 해결되어야 한다.A나라가 받은 그림에는 역들의 번호가 지워져 있고, 또한 어느 철로가 진짜이고 가짜인지 표시되어 있지 않다. 알 수 있는 것은 어느 역에특별한 표시가 되어 있는지, 그리고 가짜 철로를 총 $K$군데 놓았다는 사실뿐이다.따라서, 보내는 쪽에서는 받는 쪽이 그림만 보고 어느 철로가 진짜이고 어느 철로가 가짜인지 알 수 있도록 적절한 위치에 가짜 철로를 놓고, 적절한 역에특별한 표시를 해야 한다.또한 받는 쪽에서는 보내는 쪽이 그림을 고친 방법을 이해하고, 받은 그림에서 원래 철도망을 그린 그림을구해야 한다.위에서 설명한 것처럼, 철도망을 그린 그림을 고치는 함수와, 이 그림으로부터 진짜 철도망을 구하는 함수 둘이 필요하다. A나라는 여러분에게 이 일을 맡기려고 한다.",
    "input_description": "",
    "output_description": "",
    "examples": [],
    "url": "https://www.acmicpc.net/problem/22029",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 그래프 문제 기본 구조\nfrom collections import deque\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\n# BFS/DFS 구현\nvisited = [False] * (N + 1)\n\ndef bfs(start):\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        node = queue.popleft()\n        for next_node in graph[node]:\n            if not visited[next_node]:\n                visited[next_node] = True\n                queue.append(next_node)\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(\"\")",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "22940",
    "step_title": "수학 3",
    "title": "선형 연립 방정식",
    "level": 16,
    "tags": [
      "수학",
      "선형대수학",
      "가우스 소거법"
    ],
    "description": "하나 이상의 미지수에 대해 최고차항의 차수가 1을 넘지 않는 방정식을 선형 방정식이라 한다. 족, 다음과 같은 식을 의미한다.A1x1+ A2x2+ ... + Anxn= B선형 연립 방정식이란 유한개의 선형 방정식의 모임이다. 예를 들면 다음과 같다.x1+ 2x2= 43x1+2x2= 6선형 연립 방정식이 주어졌을 때, 해를 구하는 프로그램을 작성하라.유일한 해가 존재하는 경우만 입력으로 주어지며, 해는 모두 100 이하의 자연수이다.",
    "input_description": "첫째 줄에 미지수의 수N(2 ≤N≤ 6)이 주어진다.둘째 줄부터N개의 줄에 걸쳐 각 방정식을 나타내는N+1개의 정수A1, A2, ..., AN, B(1 ≤Ai≤10)가 주어진다.",
    "output_description": "x1부터xN까지 순서대로 한 칸의 공백을 사이에 두고 출력한다.",
    "examples": [
      {
        "input": "2\n1 2 8\n3 2 12",
        "output": "2 3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/22940",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 수학 문제 기본 구조\ndef solve():\n    # 입력 처리\n    N = int(input())\n    \n    # 계산\n    result = N\n    \n    return result\n\nprint(solve())",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "22967",
    "step_title": "해 구성하기",
    "title": "구름다리",
    "level": 14,
    "tags": [
      "그래프 이론",
      "애드 혹",
      "해 구성하기"
    ],
    "description": "선린인터넷고등학교에는 여러 건물과 그 건물들을 연결하는 구름다리가 있다.구체적으로, $1$번부터 $N$번까지의 번호가 붙은 건물 $N$개와, 서로 다른 두 건물을 잇는 구름다리 $N-1$개가 있다.모든 건물들은 구름다리들을 통해 직, 간접적으로 연결되어 있다.2019년도 천하제일 토목건축대회 우승자인 정휘는 구름다리가 너무 적어서 건물 사이를 이동하기 힘들다고 느꼈다.그래서 정휘는 2018년도 준우승자인 노현이를 고용해 구름다리를 추가로 건설하기로 했다.노현이는 최대 $N-1$개의 구름다리를 추가로 건설해서, 선린인터넷고등학교의 지름을 최대한 작게 만들어야 한다.학교의 지름이란, 학교의두 건물 사이를 구름다리로만 이동할 때 거쳐야 하는 구름다리 개수의 최댓값을 뜻한다.지름을 최대한 작게 하려면, 구름다리를 어떻게 건설해야 할까?",
    "input_description": "첫째 줄에 건물의 개수 $N$이 주어진다.둘째 줄부터 $N-1$개의 줄에 걸쳐, 이미 존재하는 구름다리들이 연결하고 있는 서로 다른 두 건물의 번호가 한 줄에 하나씩 주어진다.",
    "output_description": "첫째 줄에는 학교의 지름을 최대한 작게 만들기 위해 노현이가 추가로 건설해야 하는 구름다리의 개수 $K$를 출력한다. ($0 \\le K \\le N-1$)둘째 줄에는 노현이가 아래에 출력할 방법으로 $K$개의 구름다리를 추가로 건설한 뒤 학교의 지름 $R$을 출력한다.셋째 줄부터 $K$개의 줄에 걸쳐, 건설할 구름다리들이 연결할 서로 다른 두 건물의 번호를 한 줄에 하나씩 출력한다.출력하는 구름다리들은 모두 서로 달라야 하며, 이미 존재하는 구름다리를 다시 건설할 수는 없다.출력한 방법대로 구름다리를 건설했을 때 학교의 지름이 $R$이 되고, 이 값 $R$이 $N-1$개 이하의 구름다리를 건설해서 만들 수 있는 지름의 최솟값과 같다면, 출력은 정답으로 채점된다.",
    "examples": [
      {
        "input": "3\n1 2\n2 3",
        "output": "1\n1\n1 3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/22967",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nedges = []\n\nfor _ in range(N - 1):\n    a, b = map(int, input().split())\n    edges.append((a, b))\n\nnew_edges = []\nnodes = set()\nfor a, b in edges:\n    nodes.add(a)\n    nodes.add(b)\n\nexisting = set(edges)\nexisting.update((b, a) for a, b in edges)\n\nfor i in nodes:\n    for j in nodes:\n        if i < j and (i, j) not in existing:\n            new_edges.append((i, j))\n            if len(new_edges) >= N:\n                break\n    if len(new_edges) >= N:\n        break\n\nprint(len(new_edges))\nfor a, b in new_edges:\n    print(a, b)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "23306",
    "step_title": "인터랙티브와 투 스텝 1",
    "title": "binary는 호남선",
    "level": 9,
    "tags": [
      "애드 혹"
    ],
    "description": "binary는 호남선~num row column char에~binary는 호남선은 총 $N$개의0과1로 표현할 수 있다.0은 저지대를 지나는 철로를 나타내고,1은 고지대를 지나는 철로를 나타낸다.binary는 호남선의 구간은 연속된 두 개의 철로를 뜻한다.01은 오르막 구간,10은 내리막 구간,00과11은 평탄한 구간이다.binary는 호남선의 각 구간이 어떤 구간인지 파악하고 상대적 많고 적음을 알아내는 것은, 철로의 유지보수를 위해 매우 중요한 일이다.",
    "input_description": "binary는 호남선의 철로 길이 $N$이 주어진다. ($8 \\leq N < 2\\ 048$)",
    "output_description": "다음을 표준 출력 스트림(stdout)으로 한 줄에 출력하여, 해당 위치의 철로가 무언인지 알아낼 수 있다.?$k$ : 왼쪽부터 $k$번째 철로를 출력한다. ($1 \\leq k \\leq N$)각 질문을 출력한 후에는 반드시 표준 출력 버퍼를flush해야 하고, 표준 입력 스트림(stdin)을 통해 질문에 대한 답을 입력받아야 한다. 그렇지 않으면,시간 초과또는런타임에러를 받는다.질문하는 $k$의 범위가 철로 구간을 벗어나는 경우,틀렸습니다를 받는다.질문은 최대 $\\lfloor log_2 N \\rfloor$번 할 수 있고, 이보다 더 많이 질문을 하면틀렸습니다를 받는다.최대 $\\lfloor log_2 N \\rfloor$번의 질문을 이용해, 정답을 아래의 표준 출력 스트림(stdout)을 이용해 한 번만 출력한다.!$a$ : binary는 호남선에서 오르막 구간의 수가 내리막 구간의 수보다 많다면1을, 같다면0을, 적다면-1을 출력한다.그 후 반드시 표준 출력 버퍼를flush해야 하고, 프로그램을 종료한다. 이것은 질문 횟수에 포함되지 않는다.",
    "examples": [
      {
        "input": "4\n\n0\n\n0\n\n1\n\n1",
        "output": "? 1\n\n? 3\n\n? 4\n\n? 2\n\n! 1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/23306",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "23381",
    "step_title": "인터랙티브와 투 스텝 2",
    "title": "Gyrating Glyphs",
    "level": 21,
    "tags": [
      "브루트포스 알고리즘",
      "애드 혹",
      "무작위화"
    ],
    "description": "You are rocking the latest breakthrough in Computer Science: animated fonts. Suddenly, all of your colleagues' code looks amazing, and you are finally motivated to review it. Unfortunately, due to the constant rotations, it is hard to distinguish between the $+$ (plus) and the $\\times$ (multiply) operators (all the other characters are still readable). The function you are reviewing takes as input $n+1$ integers $a_0, a_1, \\ldots, a_n$ and returns the value $$\\bigg(\\ldots\\Big(\\big((a_0 \\,\\operatorname{op}_1\\, a_1) \\,\\operatorname{op}_2\\, a_2\\big) \\,\\operatorname{op}_3\\, a_3\\Big) \\ldots \\,\\operatorname{op}_n\\, a_n\\bigg)\\quad \\bmod 10^9+7,$$ where the $n$ operators $\\operatorname{op}_1,\\, \\operatorname{op}_2,\\, \\ldots,\\, \\operatorname{op}_n$ are either $+$ or $\\times$. For example when given input $(a_0,a_1,a_2) = (1,1,2)$ with hidden operators $(\\operatorname{op}_1,\\operatorname{op}_2)=(+,\\times)$, then the function returns $((1+1)\\times2)=4 \\bmod 10^9+7$.You can still execute the function a few times on some input and read the returned value. Use this to recover the operators.",
    "input_description": "",
    "output_description": "",
    "examples": [
      {
        "input": "2\n\n4\n\n6",
        "output": "? 1 1 2\n\n? 1 1 3\n\n! +x"
      },
      {
        "input": "10\n\n5\n\n6224\n\n640750",
        "output": "? 1 1 1 1 1 1 1 1 1 1 1\n\n? 0 4 2 4 2 4 2 4 2 4 2\n\n? 1 2 3 4 5 6 7 8 9 10 11\n\n! ++xxx+x+xx"
      }
    ],
    "url": "https://www.acmicpc.net/problem/23381",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "23435",
    "step_title": "인터랙티브와 투 스텝 1",
    "title": "Cloud computing",
    "level": 15,
    "tags": [
      "자료 구조",
      "세그먼트 트리",
      "해 구성하기",
      "분할 정복"
    ],
    "description": "Cloud computations are gaining popularity as a powerful and versatile tool. However, they are seriously flawed: processing your data on a remote computer puts your information safety at risk.Vanya works in an Organization which implemented cloud computing for calculating order statistics of arrays. An order statistic of an array for a specific $k$ is the value of the element, which is $k$th in the array, if the array is sorted.However, the array which requires order statistics is extremely classified. The only thing known about it is that all its elements are different. With this in mind, Vanya came up with the following scheme: the array is stored on the Organization's server, and the cloud server performing the order statistics calculations can access the Organization's server to get the results of the comparison of two elements of the array. In this manner, the cloud server can define the position of the $k$th order statistic, and the classified array is never revealed to the cloud server. This produces another problem: the number of requests from the cloud server to the Organization's server should not be exceedingly large.In particular, Vanya decided to limit the calculations of the second order statistics to no more than $N + 20$ requests, where $N$ is the size of the array. Help Vanya implement an algorithm of finding the second smallest element of the classified array, such that it complies to this limitation.",
    "input_description": "",
    "output_description": "",
    "examples": [
      {
        "input": "4\n\n<\n\n<\n\n<\n\n>\n\n>",
        "output": "? 0 1\n\n? 0 2\n\n? 0 3\n\n? 3 2\n\n? 2 1\n\n! 1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/23435",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "23656",
    "step_title": "인터랙티브와 투 스텝 1",
    "title": "Jack and Jill",
    "level": 9,
    "tags": [
      "그리디 알고리즘",
      "이분 탐색"
    ],
    "description": "This is an interactive problem.Jack and Jill play \"guess the number\". Initially, Jill has to choose a secret number: an integer from $1$ to $10^{9}$. After that, Jack asks questions in the form \"is it the number $x$?\" with some integer $x$ from $1$ to $10^{9}$. For each question, Jill has to answer either \"yes\", or \"no, my number is greater\", or \"no, my number is less\". The game ends when Jack correctly guesses the secret number, or after $100$ questions if it does not happen by then.Despite Jack's best efforts, he was not able to guess the number in less than $30$ questions. He realized that Jill is cheating: instead of choosing a secret number in advance, she answers the questions in such a way that the game lasts long enough. Jack pondered: how does she do that?This is an interactive problem: you play as Jill, and the jury plays as Jack. Your task is to answer the questions in such a way that Jack asks at least $30$ questions before the game ends. Keep in mind that your answers should not contradict each other: otherwise, Jack will immediately call you out on it!",
    "input_description": "",
    "output_description": "",
    "examples": [
      {
        "input": "1\n2\n...and so on...\n29\n30",
        "output": ">\n>\n...and so on...\n>\n="
      },
      {
        "input": "1000\n999\n...and so on...\n902\n901",
        "output": "<\n<\n...and so on...\n<\n<"
      }
    ],
    "url": "https://www.acmicpc.net/problem/23656",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "24060",
    "step_title": "재귀",
    "title": "알고리즘 수업 - 병합 정렬 1",
    "level": 8,
    "tags": [
      "구현",
      "정렬",
      "재귀"
    ],
    "description": "오늘도 서준이는 병합 정렬 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.N개의 서로 다른 양의 정수가 저장된 배열 A가 있다. 병합 정렬로 배열 A를 오름차순 정렬할 경우 배열 A에K번째 저장되는 수를 구해서 우리 서준이를 도와주자.크기가N인 배열에 대한 병합 정렬 의사 코드는 다음과 같다.merge_sort(A[p..r]) { # A[p..r]을 오름차순 정렬한다.\r\n    if (p < r) then {\r\n        q <- ⌊(p + r) / 2⌋;       # q는 p, r의 중간 지점\r\n        merge_sort(A, p, q);      # 전반부 정렬\r\n        merge_sort(A, q + 1, r);  # 후반부 정렬\r\n        merge(A, p, q, r);        # 병합\r\n    }\r\n}\r\n\r\n# A[p..q]와 A[q+1..r]을 병합하여 A[p..r]을 오름차순 정렬된 상태로 만든다.\r\n# A[p..q]와 A[q+1..r]은 이미 오름차순으로 정렬되어 있다.\r\nmerge(A[], p, q, r) {\r\n    i <- p; j <- q + 1; t <- 1;\r\n    while (i ≤ q and j ≤ r) {\r\n        if (A[i] ≤ A[j])\r\n        then tmp[t++] <- A[i++]; # tmp[t] <- A[i]; t++; i++;\r\n        else tmp[t++] <- A[j++]; # tmp[t] <- A[j]; t++; j++;\r\n    }\r\n    while (i ≤ q)  # 왼쪽 배열 부분이 남은 경우\r\n        tmp[t++] <- A[i++];\r\n    while (j ≤ r)  # 오른쪽 배열 부분이 남은 경우\r\n        tmp[t++] <- A[j++];\r\n    i <- p; t <- 1;\r\n    while (i ≤ r)  # 결과를 A[p..r]에 저장\r\n        A[i++] <- tmp[t++]; \r\n}",
    "input_description": "첫째 줄에 배열 A의 크기N(5 ≤N≤ 500,000), 저장 횟수K(1 ≤K≤ 108)가 주어진다.다음 줄에 서로 다른 배열 A의 원소 A1, A2, ..., AN이 주어진다. (1 ≤ Ai≤ 109)",
    "output_description": "배열 A에K번째 저장 되는 수를 출력한다. 저장 횟수가K보다 작으면 -1을 출력한다.",
    "examples": [
      {
        "input": "5 7\n4 5 1 3 2",
        "output": "3"
      },
      {
        "input": "5 13\n4 5 1 3 2",
        "output": "-1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/24060",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def merge_sort(arr, p, r):\n    if p < r:\n        q = (p + r) // 2\n        merge_sort(arr, p, q)\n        merge_sort(arr, q + 1, r)\n        merge(arr, p, q, r)\n\ndef merge(arr, p, q, r):\n    global count, result\n    i, j = p, q + 1\n    temp = []\n    \n    while i <= q and j <= r:\n        if arr[i] <= arr[j]:\n            temp.append(arr[i])\n            i += 1\n        else:\n            temp.append(arr[j])\n            j += 1\n    \n    while i <= q:\n        temp.append(arr[i])\n        i += 1\n    \n    while j <= r:\n        temp.append(arr[j])\n        j += 1\n    \n    for k in range(len(temp)):\n        arr[p + k] = temp[k]\n        count += 1\n        if count == K:\n            result = temp[k]\n\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\ncount = 0\nresult = -1\n\nmerge_sort(A, 0, N - 1)\nprint(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n, k = map(int, input().split())\narr = list(map(int, input().split()))\n\nsave_count = 0\nresult = -1\n\ndef merge_sort(arr):\n    global save_count, result\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    merged = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            save_count += 1\n            if save_count == k:\n                result = left[i]\n            i += 1\n        else:\n            merged.append(right[j])\n            save_count += 1\n            if save_count == k:\n                result = right[j]\n            j += 1\n    \n    while i < len(left):\n        merged.append(left[i])\n        save_count += 1\n        if save_count == k:\n            result = left[i]\n        i += 1\n    \n    while j < len(right):\n        merged.append(right[j])\n        save_count += 1\n        if save_count == k:\n            result = right[j]\n        j += 1\n    \n    return merged\n\nmerge_sort(arr)\nprint(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "24262",
    "step_title": "시간 복잡도",
    "title": "알고리즘 수업 - 알고리즘의 수행 시간 1",
    "level": 1,
    "tags": [
      "구현",
      "시뮬레이션"
    ],
    "description": "오늘도 서준이는 알고리즘의 수행시간 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.입력의 크기n이 주어지면 MenOfPassion 알고리즘 수행 시간을 예제 출력과 같은 방식으로 출력해보자.MenOfPassion 알고리즘은 다음과 같다.MenOfPassion(A[], n) {\r\n    i = ⌊n / 2⌋;\r\n    return A[i]; # 코드1\r\n}",
    "input_description": "첫째 줄에 입력의 크기n(1 ≤n≤ 500,000)이 주어진다.",
    "output_description": "첫째 줄에 코드1 의 수행 횟수를 출력한다.둘째 줄에 코드1의 수행 횟수를 다항식으로 나타내었을 때, 최고차항의 차수를 출력한다. 단, 다항식으로 나타낼 수 없거나 최고차항의 차수가 3보다 크면 4를 출력한다.",
    "examples": [
      {
        "input": "1",
        "output": "1\n0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/24262",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "n = input()\nprint(1)\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "n = input()\nprint(1)\nprint(0)",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "24263",
    "step_title": "시간 복잡도",
    "title": "알고리즘 수업 - 알고리즘의 수행 시간 2",
    "level": 2,
    "tags": [
      "구현",
      "시뮬레이션"
    ],
    "description": "오늘도 서준이는 알고리즘의 수행시간 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.입력의 크기n이 주어지면 MenOfPassion 알고리즘 수행 시간을 예제 출력과 같은 방식으로 출력해보자.MenOfPassion 알고리즘은 다음과 같다.MenOfPassion(A[], n) {\r\n    sum <- 0;\r\n    for i <- 1 to n\r\n        sum <- sum + A[i]; # 코드1\r\n    return sum;\r\n}",
    "input_description": "첫째 줄에 입력의 크기n(1 ≤n≤ 500,000)이 주어진다.",
    "output_description": "첫째 줄에 코드1 의 수행 횟수를 출력한다.둘째 줄에 코드1의 수행 횟수를 다항식으로 나타내었을 때, 최고차항의 차수를 출력한다. 단, 다항식으로 나타낼 수 없거나 최고차항의 차수가 3보다 크면 4를 출력한다.",
    "examples": [
      {
        "input": "7",
        "output": "7\n1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/24263",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "n = input()\nprint(n)\nprint(1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "n = input()\nprint(n)\nprint(1)",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "24264",
    "step_title": "시간 복잡도",
    "title": "알고리즘 수업 - 알고리즘의 수행 시간 3",
    "level": 3,
    "tags": [
      "수학",
      "구현",
      "사칙연산",
      "시뮬레이션"
    ],
    "description": "오늘도 서준이는 알고리즘의 수행시간 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.입력의 크기n이 주어지면 MenOfPassion 알고리즘 수행 시간을 예제 출력과 같은 방식으로 출력해보자.MenOfPassion 알고리즘은 다음과 같다.MenOfPassion(A[], n) {\r\n    sum <- 0;\r\n    for i <- 1 to n\r\n        for j <- 1 to n\r\n            sum <- sum + A[i] × A[j]; # 코드1\r\n    return sum;\r\n}",
    "input_description": "첫째 줄에 입력의 크기n(1 ≤n≤ 500,000)이 주어진다.",
    "output_description": "첫째 줄에 코드1 의 수행 횟수를 출력한다.둘째 줄에 코드1의 수행 횟수를 다항식으로 나타내었을 때, 최고차항의 차수를 출력한다. 단, 다항식으로 나타낼 수 없거나 최고차항의 차수가 3보다 크면 4를 출력한다.",
    "examples": [
      {
        "input": "7",
        "output": "49\n2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/24264",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "n = int(input())\nprint(n * n)\nprint(2)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "n = int(input())\nprint(n * n)\nprint(2)",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "24265",
    "step_title": "시간 복잡도",
    "title": "알고리즘 수업 - 알고리즘의 수행 시간 4",
    "level": 3,
    "tags": [
      "수학",
      "구현",
      "사칙연산",
      "시뮬레이션"
    ],
    "description": "오늘도 서준이는 알고리즘의 수행시간 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.입력의 크기n이 주어지면 MenOfPassion 알고리즘 수행 시간을 예제 출력과 같은 방식으로 출력해보자.MenOfPassion 알고리즘은 다음과 같다.MenOfPassion(A[], n) {\r\n    sum <- 0;\r\n    for i <- 1 to n - 1\r\n        for j <- i + 1 to n\r\n            sum <- sum + A[i] × A[j]; # 코드1\r\n    return sum;\r\n}",
    "input_description": "첫째 줄에 입력의 크기n(1 ≤n≤ 500,000)이 주어진다.",
    "output_description": "첫째 줄에 코드1 의 수행 횟수를 출력한다.둘째 줄에 코드1의 수행 횟수를 다항식으로 나타내었을 때, 최고차항의 차수를 출력한다. 단, 다항식으로 나타낼 수 없거나 최고차항의 차수가 3보다 크면 4를 출력한다.",
    "examples": [
      {
        "input": "7",
        "output": "21\n2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/24265",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "n = int(input())\nprint(n * (n - 1) // 2)\nprint(2)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "n = int(input())\nprint(n * (n - 1) // 2)\nprint(2)",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "24266",
    "step_title": "시간 복잡도",
    "title": "알고리즘 수업 - 알고리즘의 수행 시간 5",
    "level": 3,
    "tags": [
      "수학",
      "구현",
      "시뮬레이션"
    ],
    "description": "오늘도 서준이는 알고리즘의 수행시간 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.입력의 크기n이 주어지면 MenOfPassion 알고리즘 수행 시간을 예제 출력과 같은 방식으로 출력해보자.MenOfPassion 알고리즘은 다음과 같다.MenOfPassion(A[], n) {\r\n    sum <- 0;\r\n    for i <- 1 to n\r\n        for j <- 1 to n\r\n            for k <- 1 to n\r\n                sum <- sum + A[i] × A[j] × A[k]; # 코드1\r\n    return sum;\r\n}",
    "input_description": "첫째 줄에 입력의 크기n(1 ≤n≤ 500,000)이 주어진다.",
    "output_description": "첫째 줄에 코드1 의 수행 횟수를 출력한다.둘째 줄에 코드1의 수행 횟수를 다항식으로 나타내었을 때, 최고차항의 차수를 출력한다. 단, 다항식으로 나타낼 수 없거나 최고차항의 차수가 3보다 크면 4를 출력한다.",
    "examples": [
      {
        "input": "7",
        "output": "343\n3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/24266",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "n = int(input())\nprint(n ** 3)\nprint(3)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "n = int(input())\nprint(n ** 3)\nprint(3)",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "24267",
    "step_title": "시간 복잡도",
    "title": "알고리즘 수업 - 알고리즘의 수행 시간 6",
    "level": 4,
    "tags": [
      "수학",
      "구현",
      "시뮬레이션"
    ],
    "description": "오늘도 서준이는 알고리즘의 수행시간 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.입력의 크기n이 주어지면 MenOfPassion 알고리즘 수행 시간을 예제 출력과 같은 방식으로 출력해보자.MenOfPassion 알고리즘은 다음과 같다.MenOfPassion(A[], n) {\r\n    sum <- 0;\r\n    for i <- 1 to n - 2\r\n        for j <- i + 1 to n - 1\r\n            for k <- j + 1 to n\r\n                sum <- sum + A[i] × A[j] × A[k]; # 코드1\r\n    return sum;\r\n}",
    "input_description": "첫째 줄에 입력의 크기n(1 ≤n≤ 500,000)이 주어진다.",
    "output_description": "첫째 줄에 코드1 의 수행 횟수를 출력한다.둘째 줄에 코드1의 수행 횟수를 다항식으로 나타내었을 때, 최고차항의 차수를 출력한다. 단, 다항식으로 나타낼 수 없거나 최고차항의 차수가 3보다 크면 4를 출력한다.",
    "examples": [
      {
        "input": "7",
        "output": "35\n3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/24267",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "n = int(input())\nprint(n * (n - 1) * (n - 2) // 6)\nprint(3)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "n = int(input())\nprint(n * (n - 1) * (n - 2) // 6)\nprint(3)",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "24313",
    "step_title": "시간 복잡도",
    "title": "알고리즘 수업 - 점근적 표기 1",
    "level": 6,
    "tags": [
      "수학"
    ],
    "description": "오늘도 서준이는 점근적 표기 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.알고리즘의 소요 시간을 나타내는 O-표기법(빅-오)을 다음과 같이 정의하자.O(g(n)) = {f(n) | 모든n≥n0에 대하여f(n) ≤c×g(n)인 양의 상수c와n0가 존재한다}이 정의는 실제 O-표기법(https://en.wikipedia.org/wiki/Big_O_notation)과 다를 수 있다.함수f(n) =a1n+a0, 양의 정수c,n0가 주어질 경우 O(n) 정의를 만족하는지 알아보자.",
    "input_description": "첫째 줄에 함수f(n)을 나타내는 정수a1,a0가 주어진다. (0 ≤ |ai| ≤ 100)다음 줄에 양의 정수c가 주어진다. (1 ≤c≤ 100)다음 줄에 양의 정수n0가 주어진다. (1 ≤n0≤ 100)",
    "output_description": "f(n),c,n0가 O(n) 정의를 만족하면 1, 아니면 0을 출력한다.",
    "examples": [
      {
        "input": "7 7\n8\n1",
        "output": "0"
      },
      {
        "input": "7 7\n8\n10",
        "output": "1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/24313",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "a1, a0 = map(int, input().split())\nc = int(input())\nn0 = int(input())\nif a1 * n0 + a0 <= c * n0 and a1 <= c:\n    print(1)\nelse:\n    print(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "a1, a0 = map(int, input().split())\nc = int(input())\nn0 = int(input())\nif a1 * n0 + a0 <= c * n0 and ",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "24416",
    "step_title": "동적 계획법 1",
    "title": "알고리즘 수업 - 피보나치 수 1",
    "level": 5,
    "tags": [
      "수학",
      "다이나믹 프로그래밍"
    ],
    "description": "오늘도 서준이는 동적 프로그래밍 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.오늘은n의 피보나치 수를 재귀호출과 동적 프로그래밍으로 구하는 알고리즘을 배웠다. 재귀호출에 비해 동적 프로그래밍이 얼마나 빠른지 확인해 보자. 아래 의사 코드를 이용하여n의 피보나치 수를 구할 경우 코드1 코드2 실행 횟수를 출력하자.피보나치 수 재귀호출 의사 코드는 다음과 같다.fib(n) {\r\n    if (n = 1 or n = 2)\r\n    then return 1;  # 코드1\r\n    else return (fib(n - 1) + fib(n - 2));\r\n}피보나치 수 동적 프로그래밍 의사 코드는 다음과 같다.fibonacci(n) {\r\n    f[1] <- f[2] <- 1;\r\n    for i <- 3 to n\r\n        f[i] <- f[i - 1] + f[i - 2];  # 코드2\r\n    return f[n];\r\n}",
    "input_description": "첫째 줄에n(5 ≤n≤ 40)이 주어진다.",
    "output_description": "코드1 코드2 실행 횟수를 한 줄에 출력한다.",
    "examples": [
      {
        "input": "5",
        "output": "5 3"
      },
      {
        "input": "30",
        "output": "832040 28"
      }
    ],
    "url": "https://www.acmicpc.net/problem/24416",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def fib(n):\n    if n == 1 or n == 2:\n        return 1\n    return fib(n-1) + fib(n-2)\n\ndef fibonacci(n):\n    f = [0] * (n + 1)\n    f[1] = f[2] = 1\n    count = 0\n    \n    for i in range(3, n + 1):\n        count += 1\n        f[i] = f[i-1] + f[i-2]\n    \n    return f[n], count\n\nn = int(input())\nfib_result = fib(n)\n_, dp_count = fibonacci(n)\nprint(fib_result, dp_count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "24444",
    "step_title": "그래프와 순회",
    "title": "알고리즘 수업 - 너비 우선 탐색 1",
    "level": 9,
    "tags": [
      "그래프 이론",
      "그래프 탐색",
      "정렬",
      "너비 우선 탐색"
    ],
    "description": "오늘도 서준이는 너비 우선 탐색(BFS) 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.N개의 정점과M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다. 정점 번호는 1번부터N번이고 모든 간선의 가중치는 1이다. 정점R에서 시작하여 너비 우선 탐색으로 노드를 방문할 경우 노드의 방문 순서를 출력하자.너비 우선 탐색 의사 코드는 다음과 같다. 인접 정점은오름차순으로 방문한다.bfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점\r\n    for each v ∈ V - {R}\r\n        visited[v] <- NO;\r\n    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.\r\n    enqueue(Q, R);  # 큐 맨 뒤에 시작 정점 R을 추가한다.\r\n    while (Q ≠ ∅) {\r\n        u <- dequeue(Q);  # 큐 맨 앞쪽의 요소를 삭제한다.\r\n        for each v ∈ E(u)  # E(u) : 정점 u의 인접 정점 집합.(정점 번호를오름차순으로 방문한다)\r\n            if (visited[v] = NO) then {\r\n                visited[v] <- YES;  # 정점 v를 방문 했다고 표시한다.\r\n                enqueue(Q, v);  # 큐 맨 뒤에 정점 v를 추가한다.\r\n            }\r\n    }\r\n}",
    "input_description": "첫째 줄에 정점의 수N(5 ≤N≤ 100,000), 간선의 수M(1 ≤M≤ 200,000), 시작 정점R(1 ≤R≤N)이 주어진다.다음M개 줄에 간선 정보uv가 주어지며 정점u와 정점v의 가중치 1인 양방향 간선을 나타낸다. (1 ≤u<v≤N,u≠v) 모든 간선의 (u,v) 쌍의 값은 서로 다르다.",
    "output_description": "첫째 줄부터N개의 줄에 정수를 한 개씩 출력한다.i번째 줄에는 정점i의 방문 순서를 출력한다. 시작 정점의 방문 순서는 1이다. 시작 정점에서 방문할 수 없는 경우 0을 출력한다.",
    "examples": [
      {
        "input": "5 5 1\n1 4\n1 2\n2 3\n2 4\n3 4",
        "output": "1\n2\n4\n3\n0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/24444",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\ndef bfs(start):\n    global order\n    queue = deque([start])\n    visited[start] = order\n    order += 1\n    \n    while queue:\n        node = queue.popleft()\n        \n        for next_node in graph[node]:\n            if visited[next_node] == 0:\n                visited[next_node] = order\n                order += 1\n                queue.append(next_node)\n\nN, M, R = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\nvisited = [0] * (N + 1)\norder = 1\n\nfor _ in range(M):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\nfor i in range(1, N + 1):\n    graph[i].sort()\n\nbfs(R)\n\nfor i in range(1, N + 1):\n    print(visited[i])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "from collections import deque\n\nn, m, r = map(int, input().split())\ngraph = [[] for _ in range(n + 1)]\n\nfor _ in range(m):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\nfor i in range(1, n + 1):\n    graph[i].sort()\n\nvisited = [0] * (n + 1)\norder = 1\n\nqueue = deque([r])\nvisited[r] = order\norder += 1\n\nwhile queue:\n    node = queue.popleft()\n    for next_node in graph[node]:\n        if visited[next_node] == 0:\n            visited[next_node] = order\n            order += 1\n            queue.append(next_node)\n\nfor i in range(1, n + 1):\n    print(visited[i])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "24445",
    "step_title": "그래프와 순회",
    "title": "알고리즘 수업 - 너비 우선 탐색 2",
    "level": 9,
    "tags": [
      "그래프 이론",
      "그래프 탐색",
      "정렬",
      "너비 우선 탐색"
    ],
    "description": "오늘도 서준이는 너비 우선 탐색(BFS) 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.N개의 정점과M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다. 정점 번호는 1번부터N번이고 모든 간선의 가중치는 1이다. 정점R에서 시작하여 너비 우선 탐색으로 노드를 방문할 경우 노드의 방문 순서를 출력하자.너비 우선 탐색 의사 코드는 다음과 같다. 인접 정점은내림차순으로 방문한다.bfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점\r\n    for each v ∈ V - {R}\r\n        visited[v] <- NO;\r\n    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.\r\n    enqueue(Q, R);  # 큐 맨 뒤에 시작 정점 R을 추가한다.\r\n    while (Q ≠ ∅) {\r\n        u <- dequeue(Q);  # 큐 맨 앞쪽의 요소를 삭제한다.\r\n        for each v ∈ E(u)  # E(u) : 정점 u의 인접 정점 집합.(정점 번호를내림차순으로 방문한다)\r\n            if (visited[v] = NO) then {\r\n                visited[v] <- YES;  # 정점 v를 방문 했다고 표시한다.\r\n                enqueue(Q, v);  # 큐 맨 뒤에 정점 v를 추가한다.\r\n            }\r\n    }\r\n}",
    "input_description": "첫째 줄에 정점의 수N(5 ≤N≤ 100,000), 간선의 수M(1 ≤M≤ 200,000), 시작 정점R(1 ≤R≤N)이 주어진다.다음M개 줄에 간선 정보uv가 주어지며 정점u와 정점v의 가중치 1인 양방향 간선을 나타낸다. (1 ≤u<v≤N,u≠v) 모든 간선의 (u,v) 쌍의 값은 서로 다르다.",
    "output_description": "첫째 줄부터N개의 줄에 정수를 한 개씩 출력한다.i번째 줄에는 정점i의 방문 순서를 출력한다. 시작 정점의 방문 순서는 1이다. 시작 정점에서 방문할 수 없는 경우 0을 출력한다.",
    "examples": [
      {
        "input": "5 5 1\n1 4\n1 2\n2 3\n2 4\n3 4",
        "output": "1\n3\n4\n2\n0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/24445",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\ndef bfs(start):\n    global order\n    queue = deque([start])\n    visited[start] = order\n    order += 1\n    \n    while queue:\n        node = queue.popleft()\n        \n        for next_node in graph[node]:\n            if visited[next_node] == 0:\n                visited[next_node] = order\n                order += 1\n                queue.append(next_node)\n\nN, M, R = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\nvisited = [0] * (N + 1)\norder = 1\n\nfor _ in range(M):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\nfor i in range(1, N + 1):\n    graph[i].sort(reverse=True)\n\nbfs(R)\n\nfor i in range(1, N + 1):\n    print(visited[i])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "from collections import deque\n\nn, m, r = map(int, input().split())\ngraph = [[] for _ in range(n + 1)]\n\nfor _ in range(m):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\nfor i in range(1, n + 1):\n    graph[i].sort(reverse=True)\n\nvisited = [0] * (n + 1)\norder = 1\n\nqueue = deque([r])\nvisited[r] = order\norder += 1\n\nwhile queue:\n    node = queue.popleft()\n    for next_node in graph[node]:\n        if visited[next_node] == 0:\n            visited[next_node] = order\n            order += 1\n            queue.append(next_node)\n\nfor i in range(1, n + 1):\n    print(visited[i])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "24479",
    "step_title": "그래프와 순회",
    "title": "알고리즘 수업 - 깊이 우선 탐색 1",
    "level": 9,
    "tags": [
      "그래프 이론",
      "그래프 탐색",
      "정렬",
      "깊이 우선 탐색"
    ],
    "description": "오늘도 서준이는 깊이 우선 탐색(DFS) 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.N개의 정점과M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다. 정점 번호는 1번부터N번이고 모든 간선의 가중치는 1이다. 정점R에서 시작하여 깊이 우선 탐색으로 노드를 방문할 경우 노드의 방문 순서를 출력하자.깊이 우선 탐색 의사 코드는 다음과 같다. 인접 정점은오름차순으로 방문한다.dfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점\r\n    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.\r\n    for each x ∈ E(R)  # E(R) : 정점 R의 인접 정점 집합.(정점 번호를오름차순으로 방문한다)\r\n        if (visited[x] = NO) then dfs(V, E, x);\r\n}",
    "input_description": "첫째 줄에 정점의 수N(5 ≤N≤ 100,000), 간선의 수M(1 ≤M≤ 200,000), 시작 정점R(1 ≤R≤N)이 주어진다.다음M개 줄에 간선 정보uv가 주어지며 정점u와 정점v의 가중치 1인 양방향 간선을 나타낸다. (1 ≤u<v≤N,u≠v) 모든 간선의 (u,v) 쌍의 값은 서로 다르다.",
    "output_description": "첫째 줄부터N개의 줄에 정수를 한 개씩 출력한다.i번째 줄에는 정점i의 방문 순서를 출력한다. 시작 정점의 방문 순서는 1이다. 시작 정점에서 방문할 수 없는 경우 0을 출력한다.",
    "examples": [
      {
        "input": "5 5 1\n1 4\n1 2\n2 3\n2 4\n3 4",
        "output": "1\n2\n3\n4\n0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/24479",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\ndef dfs(node):\n    global order\n    visited[node] = order\n    order += 1\n    \n    for next_node in graph[node]:\n        if visited[next_node] == 0:\n            dfs(next_node)\n\nN, M, R = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\nvisited = [0] * (N + 1)\norder = 1\n\nfor _ in range(M):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\nfor i in range(1, N + 1):\n    graph[i].sort()\n\ndfs(R)\n\nfor i in range(1, N + 1):\n    print(visited[i])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "import sys\nsys.setrecursionlimit(150000)\n\nn, m, r = map(int, input().split())\ngraph = [[] for _ in range(n + 1)]\n\nfor _ in range(m):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\nfor i in range(1, n + 1):\n    graph[i].sort()\n\nvisited = [0] * (n + 1)\norder = 1\n\ndef dfs(node):\n    global order\n    visited[node] = order\n    order += 1\n    \n    for next_node in graph[node]:\n        if visited[next_node] == 0:\n            dfs(next_node)\n\ndfs(r)\n\nfor i in range(1, n + 1):\n    print(visited[i])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3",
        "solution_code": "import sys\nsys.setrecursionlimit(150000)\n\nn, m, r = map(int, input().split())\ngraph = [[] for _ in range(n + 1)]\n\nfor _ in range(m):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\nfor i in range(1, n + 1):\n    graph[i].sort(reverse=False)\n\nvisited = [0] * (n + 1)\norder = 1\n\ndef dfs(node):\n    global order\n    visited[node] = order\n    order += 1\n    \n    for next_node in graph[node]:\n        if visited[next_node] == 0:\n            dfs(next_node)\n\ndfs(r)\n\nfor i in range(1, n + 1):\n    print(visited[i])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 패스 횟수 제어",
            "description": "n-1번 반복하며 각 패스를 수행합니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "버블 정렬에서 몇 번의 패스가 필요한가요?",
            "hint": "n-1번의 패스가 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "내부 반복문: 인접 원소 비교",
            "description": "각 패스에서 인접한 두 원소를 비교합니다. 이미 정렬된 뒤쪽 부분은 제외합니다.",
            "code_pattern": "for j in range(n-1-i):",
            "socratic_hint": "각 패스에서 비교해야 할 원소의 범위는?",
            "hint": "n-1-i까지 비교합니다 (이미 정렬된 부분 제외)."
          },
          {
            "step_id": 4,
            "goal": "원소 교환",
            "description": "왼쪽 원소가 오른쪽 원소보다 크면 위치를 교환합니다.",
            "code_pattern": "if arr[j] > arr[j+1]:\n    arr[j], arr[j+1] = arr[j+1], arr[j]",
            "socratic_hint": "인접한 두 원소의 순서가 잘못되었을 때 어떻게 하나요?",
            "hint": "두 원소의 위치를 swap합니다."
          },
          {
            "step_id": 5,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "24480",
    "step_title": "그래프와 순회",
    "title": "알고리즘 수업 - 깊이 우선 탐색 2",
    "level": 9,
    "tags": [
      "그래프 이론",
      "그래프 탐색",
      "정렬",
      "깊이 우선 탐색"
    ],
    "description": "오늘도 서준이는 깊이 우선 탐색(DFS) 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.N개의 정점과M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다. 정점 번호는 1번부터N번이고 모든 간선의 가중치는 1이다. 정점R에서 시작하여 깊이 우선 탐색으로 노드를 방문할 경우 노드의 방문 순서를 출력하자.깊이 우선 탐색 의사 코드는 다음과 같다. 인접 정점은내림차순으로 방문한다.dfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점\r\n    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.\r\n    for each x ∈ E(R)  # E(R) : 정점 R의 인접 정점 집합.(정점 번호를내림차순으로 방문한다)\r\n        if (visited[x] = NO) then dfs(V, E, x);\r\n}",
    "input_description": "첫째 줄에 정점의 수N(5 ≤N≤ 100,000), 간선의 수M(1 ≤M≤ 200,000), 시작 정점R(1 ≤R≤N)이 주어진다.다음M개 줄에 간선 정보uv가 주어지며 정점u와 정점v의 가중치 1인 양방향 간선을 나타낸다. (1 ≤u<v≤N,u≠v) 모든 간선의 (u,v) 쌍의 값은 서로 다르다.",
    "output_description": "첫째 줄부터N개의 줄에 정수를 한 개씩 출력한다.i번째 줄에는 정점i의 방문 순서를 출력한다. 시작 정점의 방문 순서는 1이다. 시작 정점에서 방문할 수 없는 경우 0을 출력한다.",
    "examples": [
      {
        "input": "5 5 1\n1 4\n1 2\n2 3\n2 4\n3 4",
        "output": "1\n4\n3\n2\n0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/24480",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\ndef dfs(node):\n    global order\n    visited[node] = order\n    order += 1\n    \n    for next_node in graph[node]:\n        if visited[next_node] == 0:\n            dfs(next_node)\n\nN, M, R = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\nvisited = [0] * (N + 1)\norder = 1\n\nfor _ in range(M):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\nfor i in range(1, N + 1):\n    graph[i].sort(reverse=True)\n\ndfs(R)\n\nfor i in range(1, N + 1):\n    print(visited[i])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "import sys\nsys.setrecursionlimit(150000)\n\nn, m, r = map(int, input().split())\ngraph = [[] for _ in range(n + 1)]\n\nfor _ in range(m):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\nfor i in range(1, n + 1):\n    graph[i].sort(reverse=True)\n\nvisited = [0] * (n + 1)\norder = 1\n\ndef dfs(node):\n    global order\n    visited[node] = order\n    order += 1\n    \n    for next_node in graph[node]:\n        if visited[next_node] == 0:\n            dfs(next_node)\n\ndfs(r)\n\nfor i in range(1, n + 1):\n    print(visited[i])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "24511",
    "step_title": "스택, 큐, 덱 1",
    "title": "queuestack",
    "level": 8,
    "tags": [
      "자료 구조",
      "스택",
      "덱",
      "큐"
    ],
    "description": "한가롭게 방학에 놀고 있던 도현이는 갑자기 재밌는 자료구조를 생각해냈다. 그 자료구조의 이름은 queuestack이다.queuestack의 구조는 다음과 같다. $1$번, $2$번, ... , $N$번의 자료구조(queue 혹은 stack)가 나열되어있으며, 각각의 자료구조에는 한 개의 원소가 들어있다.queuestack의 작동은 다음과 같다.$x_0$을 입력받는다.$x_0$을 $1$번 자료구조에 삽입한 뒤 $1$번 자료구조에서 원소를 pop한다. 그때 pop된 원소를 $x_1$이라 한다.$x_1$을 $2$번 자료구조에 삽입한 뒤 $2$번 자료구조에서 원소를 pop한다. 그때 pop된 원소를 $x_2$이라 한다....$x_{N-1}$을 $N$번 자료구조에 삽입한 뒤 $N$번 자료구조에서 원소를 pop한다. 그때 pop된 원소를 $x_N$이라 한다.$x_N$을 리턴한다.도현이는 길이 $M$의 수열 $C$를 가져와서 수열의 원소를 앞에서부터 차례대로 queuestack에 삽입할 것이다. 이전에 삽입한 결과는 남아 있다. (예제 $1$ 참고)queuestack에 넣을 원소들이 주어졌을 때, 해당 원소를 넣은 리턴값을 출력하는 프로그램을 작성해보자.",
    "input_description": "첫째 줄에 queuestack을 구성하는 자료구조의 개수 $N$이 주어진다. ($1 \\leq N \\leq 100\\,000$)둘째 줄에 길이 $N$의 수열 $A$가 주어진다. $i$번 자료구조가 큐라면 $A_i = 0$, 스택이라면 $A_i = 1$이다.셋째 줄에 길이 $N$의 수열 $B$가 주어진다. $B_i$는 $i$번 자료구조에 들어 있는 원소이다. ($1 \\leq B_i \\leq 1\\,000\\,000\\,000$)넷째 줄에 삽입할 수열의 길이 $M$이 주어진다. ($1 \\leq M \\leq 100\\,000$)다섯째 줄에 queuestack에 삽입할 원소를 담고 있는 길이 $M$의 수열 $C$가 주어진다. ($1 \\leq C_i \\leq 1\\,000\\,000\\,000$)입력으로 주어지는 모든 수는 정수이다.",
    "output_description": "수열 $C$의 원소를 차례대로 queuestack에 삽입했을 때의 리턴값을 공백으로 구분하여 출력한다.",
    "examples": [
      {
        "input": "4\n0 1 1 0\n1 2 3 4\n3\n2 4 7",
        "output": "4 1 2"
      },
      {
        "input": "5\n1 1 1 1 1\n1 2 3 4 5\n3\n1 3 5",
        "output": "1 3 5"
      }
    ],
    "url": "https://www.acmicpc.net/problem/24511",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\ntypes = list(map(int, input().split()))\nvalues = list(map(int, input().split()))\nM = int(input())\ninserts = list(map(int, input().split()))\n\ndq = deque()\nfor i in range(N):\n    if types[i] == 0:  # queue\n        dq.append(values[i])\n\nresult = []\nfor insert in inserts:\n    dq.appendleft(insert)\n    result.append(dq.pop())\n\nprint(' '.join(map(str, result)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "24723",
    "step_title": "조합론",
    "title": "녹색거탑",
    "level": 2,
    "tags": [
      "수학",
      "사칙연산"
    ],
    "description": "Naver D2를 아시나요? D2는 For Developers, By Developers의 약자로, 개발자들을 위해 개발자들이 직접 만들어 가고 있는 네이버 개발자 지원 프로그램입니다. 네이버가 축적한 기술과 지식을 공유하고, 외부 개발자들을 지원해 대한민국 개발자 역량 강화를 이끌고, 이를 통해 업계 전체와 네이버가 함께 성장하는 선순환 구조를 만들고자 합니다.사실 네이버의 개발자 지원은 오랜 기간 꾸준히 이어져 왔습니다. 개발자 컨퍼런스 DEVIEW를 비롯, 오픈 소스와 개발 도구 공개, 학회 및 커뮤니티 지원 등 여러 지원 프로그램이 있었습니다. 이런 다양한 프로그램을 하나로 통합한 것이 바로 Naver D2입니다.2022년 봄 어느 날.전 세계에코딩괴물이 나타났다.그리고 코딩괴물과 함께 갑작스레 등장한 '그것'...바로녹색거탑이다.녹색거탑의 정상에서는 매년NAVER가 개최하는 개발자 컨퍼런스DEVIEW가 열린다. 이 DEVIEW에 참여하면, 코딩에 깊은 깨달음을 얻어 코딩괴물이 될 수 있다고 전해진다. 그리고 코딩괴물은 녹색거탑의 정상에서 내려온다. 예전부터 전해 내려오는D2비전서에 의하면, 코딩괴물이 녹색거탑의 정상에서 내려오는 경우의 수를 파악한 사람은, 개발자 컨퍼런스DEVIEW에 참여할 수 있다 한다. 그리고 DEVIEW에 참여해 본인도 코딩괴물이 될 수 있다!녹색거탑은 위 그림과 같이 규칙적으로 쌓여있다.그림의 시야에 보이지 않는 블록은 없다.그림의 시야에 보이는 블록의 윗면만 이용해 녹색거탑을 내려올 수 있다.녹색거탑이 $N$층이면, 총 $N$개의 블록을 이용한 최단 경로로만 내려온다.녹색거탑을 내려올 때는 정상에서 시작해 노란색 바닥까지, 항상 인접한 아래층의 블록으로만 내려온다.녹색거탑을 정복하고DEVIEW에 참여하자.",
    "input_description": "녹색거탑의 높이를 나타내는 정수 $N$이 주어진다. ($1 \\leq N \\leq 5$)",
    "output_description": "녹색거탑의 정상에서 바닥으로 내려오는 경우의 수를 출력한다.",
    "examples": [
      {
        "input": "1",
        "output": "2"
      },
      {
        "input": "2",
        "output": "4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/24723",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "n = int(input())\nprint(n * 2)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "n = int(input())로 입력을 처리합니다.",
            "code_pattern": "n = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(n * 2)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "25051",
    "step_title": "기하 3",
    "title": "천체 관측",
    "level": 18,
    "tags": [
      "정렬",
      "기하학",
      "두 포인터",
      "각도 정렬"
    ],
    "description": "DGIST의 밤하늘에는 $N$개의 별이 떠 있습니다. DGIST의 위치가 무한히 넓은 2차원 좌표계 위의 원점 $(0, 0)$이라고 하면, 별들이 떠 있는 위치는 $(X_i, Y_i)$로 나타낼 수 있습니다. 모든 별들이 떠 있는 위치는 서로 다르고, 원점 위에 떠 있는 별은 없습니다.동현이는 밤하늘에 떠 있는 아름다운 별들의 사진을 찍어서 천체 사진 공모전에 참가하려고 합니다. 별의 사진을 찍으려면 망원경이 필요하기 때문에, 동현이는 우선 망원경부터 주문하기로 했습니다. 주문할 수 있는 망원경의 종류는 $M$ 가지가 있고, 각 망원경의 가격은 $P_i$ 입니다. 망원경의 가격이 비쌀수록 관측 성능이 올라갑니다. 가격이 $P_i$ 인 망원경으로는 관측 위치로부터 유클리드 거리의 제곱이 $P_i$ 보다 작거나 같은 곳에 위치한 별들을 관측할 수 있습니다.별들은 저마다 아름다움 수치 $S_i$ 를 가지고 있고, 어떤 사진의 아름다움은 그 사진에 찍힌 모든 별들의 아름다움 수치의 합으로 정의합니다. 그리고 가격이 $P_i$ 인 망원경으로 한 번에 사진에 담을 수 있는 별들의 영역은 원점을 꼭짓점으로 하고 중심각이 90도, 반지름의 길이가 $\\sqrt{P_i}$ 인 부채꼴 모양으로 나타낼 수 있습니다.동현이는 원하는 망원경을 하나 산 뒤, 최고로 아름다운 사진을 한 장 찍어서 공모전에 제출하려 합니다. 동현이는 공모전에서 입상도 하고 싶지만, 그렇다고 비싼 망원경을 구매하는 데 너무 많은 돈을 투자하고 싶지는 않습니다. 동현이를 위해 (사진의 아름다움) - (망원경의 가격)의 최댓값을 구해 줍시다.",
    "input_description": "첫 번째 줄에는 별들의 개수를 의미하는 정수 $N$과 살 수 있는 망원경의 종류의 수 $M$이 공백으로 구분되어 주어집니다. $( 1 \\le N \\le 10^5,\\  1 \\le M \\le 200 )$두 번째 줄부터 $N + 1$ 번째 줄에는 별의 좌표 $X_i, Y_i$ 와 별의 아름다움 $S_i$ 가 공백으로 구분되어 주어집니다. $( -10^9 \\le X_i, Y_i \\le 10^9,\\  0 \\le S_i \\le 10^{12},\\  (X_i, Y_i) \\neq (0, 0) )$$N + 2$ 번째 줄에는 망원경의 가격 $P_1, P_2, P_3, ..., P_M$을 나타내는 정수 M개가 공백으로 구분되어 주어집니다. $(1 \\le P_i \\le 10^{18})$",
    "output_description": "첫 번째 줄에 (사진의 가치) - (망원경의 가격)의 최댓값을 출력합니다.",
    "examples": [
      {
        "input": "8 2\n0 2 6\n2 2 8\n2 0 3\n2 -2 8\n0 -2 7\n-2 -2 1\n-2 0 5\n-2 2 5\n4 8",
        "output": "11"
      },
      {
        "input": "5 3\n6 2 89\n-3 0 86\n-4 0 98\n5 1 60\n10 -8 98\n100 2 58",
        "output": "126"
      },
      {
        "input": "3 3\n6 7 88\n5 -2 62\n-9 9 70\n52 47 18",
        "output": "15"
      },
      {
        "input": "1 2\n8 8 40\n40 60",
        "output": "-40"
      }
    ],
    "url": "https://www.acmicpc.net/problem/25051",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor num in sorted(arr):\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\narr.sort()\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sort() 메서드로 정렬",
            "description": "arr.sort()로 리스트를 제자리에서 정렬합니다.",
            "code_pattern": "arr.sort()",
            "socratic_hint": "리스트를 제자리에서 정렬하는 메서드는?",
            "hint": ".sort() 메서드를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문을 사용합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor i in range(n-1):\n    for j in range(n-1-i):\n        if arr[j] > arr[j+1]:\n            arr[j], arr[j+1] = arr[j+1], arr[j]\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 패스 횟수 제어",
            "description": "n-1번 반복하며 각 패스를 수행합니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "버블 정렬에서 몇 번의 패스가 필요한가요?",
            "hint": "n-1번의 패스가 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "내부 반복문: 인접 원소 비교",
            "description": "각 패스에서 인접한 두 원소를 비교합니다. 이미 정렬된 뒤쪽 부분은 제외합니다.",
            "code_pattern": "for j in range(n-1-i):",
            "socratic_hint": "각 패스에서 비교해야 할 원소의 범위는?",
            "hint": "n-1-i까지 비교합니다 (이미 정렬된 부분 제외)."
          },
          {
            "step_id": 4,
            "goal": "원소 교환",
            "description": "왼쪽 원소가 오른쪽 원소보다 크면 위치를 교환합니다.",
            "code_pattern": "if arr[j] > arr[j+1]:\n    arr[j], arr[j+1] = arr[j+1], arr[j]",
            "socratic_hint": "인접한 두 원소의 순서가 잘못되었을 때 어떻게 하나요?",
            "hint": "두 원소의 위치를 swap합니다."
          },
          {
            "step_id": 5,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      },
      {
        "solution_id": 5,
        "solution_name": "풀이 5",
        "solution_code": "n = int(input())\narr = [int(input()) for _ in range(n)]\nfor i in range(n-1):\n    min_idx = i\n    for j in range(i+1, n):\n        if arr[j] < arr[min_idx]:\n            min_idx = j\n    arr[i], arr[min_idx] = arr[min_idx], arr[i]\nfor num in arr:\n    print(num)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 정렬할 위치 선택",
            "description": "n-1번 반복하며 각 위치에 올 최솟값을 찾습니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "선택 정렬에서 몇 번의 선택이 필요한가요?",
            "hint": "n-1번의 선택이 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "최솟값 인덱스 초기화",
            "description": "현재 위치를 최솟값 인덱스로 가정합니다.",
            "code_pattern": "min_idx = i",
            "socratic_hint": "최솟값을 찾기 위한 초기값은?",
            "hint": "현재 위치 i를 초기값으로 설정합니다."
          },
          {
            "step_id": 4,
            "goal": "내부 반복문: 최솟값 찾기",
            "description": "현재 위치 이후의 원소들 중 최솟값의 인덱스를 찾습니다.",
            "code_pattern": "for j in range(i+1, n):\n    if arr[j] < arr[min_idx]:\n        min_idx = j",
            "socratic_hint": "정렬되지 않은 부분에서 최솟값을 어떻게 찾나요?",
            "hint": "i+1부터 끝까지 순회하며 최솟값 인덱스를 업데이트합니다."
          },
          {
            "step_id": 5,
            "goal": "원소 교환",
            "description": "찾은 최솟값을 현재 위치로 이동시킵니다.",
            "code_pattern": "arr[i], arr[min_idx] = arr[min_idx], arr[i]",
            "socratic_hint": "최솟값을 현재 위치로 가져오려면?",
            "hint": "현재 위치의 값과 최솟값을 swap합니다."
          },
          {
            "step_id": 6,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "25083",
    "step_title": "심화 1",
    "title": "새싹",
    "level": 1,
    "tags": [
      "구현"
    ],
    "description": "아래 예제와 같이 새싹을 출력하시오.",
    "input_description": "입력은 없다.",
    "output_description": "새싹을 출력한다.",
    "examples": [
      {
        "input": "",
        "output": ",r'\"7\nr`-_   ,'  ,/\n \\. \". L_r'\n   `~\\/\n      |\n      |"
      }
    ],
    "url": "https://www.acmicpc.net/problem/25083",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "print(\"         ,r'\\\"7\")\nprint(\"r`-_   ,'  ,/\")\nprint(\" \\\\. \\\". L_r'\")\nprint(\"   `~\\\\/\")\nprint(\"      |\")\nprint(\"      |\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(\",r'\\\"7\")",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: 기본 출력",
        "solution_code": "print(\"         ,r'\\\"7\")\nprint(\"r`-_   ,'  ,/\")\nprint(\" \\\\. \\\". L_r'\")\nprint(\"   `~\\\\/\")\nprint(\"      |\")\nprint(\"      |\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "각 줄 출력",
            "description": "각 줄을 순서대로 print합니다.",
            "code_pattern": "print(\"...\")",
            "socratic_hint": "여러 줄을 출력하려면?",
            "hint": "각 줄마다 print()를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "25184",
    "step_title": "해 구성하기",
    "title": "동가수열 구하기",
    "level": 7,
    "tags": [
      "해 구성하기"
    ],
    "description": "길이가 $N$인 동가수열은 다음 두 조건을 만족하는 수열이다.동가수열은 $1$ 이상 $N$ 이하인 정수로 이루어져 있고, 모든 원소는 서로 다르다.동가수열의 서로 이웃한 원소의 차는 $\\lfloor \\frac{N}{2} \\rfloor$이상이다.길이가 $N$인 동가수열을 아무거나 하나 구해보자. 주어지는 모든 입력에 대해 동가수열은 항상 존재한다.",
    "input_description": "첫째 줄에 구하고자 하는 동가수열의 길이 $N$($1 \\le N \\le 5\\,000$)이 주어진다.",
    "output_description": "첫째 줄에 길이가 $N$인 동가수열을 아무거나 하나 출력한다. 동가수열은 공백으로 구분해서 출력해야 한다.",
    "examples": [
      {
        "input": "3",
        "output": "1 2 3"
      },
      {
        "input": "4",
        "output": "2 4 1 3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/25184",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\n\nresult = []\nmid = (N + 1) // 2\n\nfor i in range(1, mid + 1):\n    result.append(i)\nfor i in range(mid + 1, N + 1):\n    result.append(i)\n\nans = [0] * N\nfor i in range(0, N, 2):\n    ans[i] = result[i // 2]\nfor i in range(1, N, 2):\n    ans[i] = result[mid + i // 2]\n\nprint(' '.join(map(str, ans)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "25192",
    "step_title": "심화 2",
    "title": "인사성 밝은 곰곰이",
    "level": 7,
    "tags": [
      "자료 구조",
      "집합과 맵",
      "해시를 사용한 집합과 맵",
      "트리를 사용한 집합과 맵"
    ],
    "description": "알고리즘 입문방 오픈 채팅방에서는 새로운 분들이 입장을 할 때마다 곰곰티콘을 사용해 인사를 한다. 이를 본 문자열 킬러 임스는 채팅방의 기록을 수집해 그 중 곰곰티콘이 사용된 횟수를 구해 보기로 했다.ENTER는 새로운 사람이 채팅방에 입장했음을 나타낸다. 그 외는 채팅을 입력한 유저의 닉네임을 나타낸다. 닉네임은 숫자 또는 영문 대소문자로 구성되어 있다.새로운 사람이 입장한 이후 처음 채팅을 입력하는 사람은 반드시 곰곰티콘으로 인사를 한다. 그 외의 기록은 곰곰티콘을 쓰지 않은 평범한 채팅 기록이다.채팅 기록 중 곰곰티콘이 사용된 횟수를 구해보자!",
    "input_description": "첫 번째 줄에는 채팅방의 기록 수를 나타내는 정수 $N$ 이 주어진다. ($1 \\le N \\le 100\\,000$)두 번째 줄부터 $N$ 개의 줄에 걸쳐 새로운 사람의 입장을 나타내는ENTER, 혹은 채팅을 입력한 유저의 닉네임이 문자열로 주어진다. ($1 \\le \\texttt{문자열 길이} \\le 20$)첫 번째 주어지는 문자열은 무조건ENTER이다.",
    "output_description": "채팅 기록 중 곰곰티콘이 사용된 횟수를 출력하시오.",
    "examples": [
      {
        "input": "9\nENTER\npjshwa\nchansol\nchogahui05\nlms0806\npichulia\nr4pidstart\nswoon\ntony9402",
        "output": "8"
      },
      {
        "input": "7\nENTER\npjshwa\nchansol\nchogahui05\nENTER\npjshwa\nchansol",
        "output": "5"
      },
      {
        "input": "3\nENTER\nlms0806\nlms0806",
        "output": "1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/25192",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nusers = set()\ncount = 0\n\nfor _ in range(N):\n    message = input()\n    if message == \"ENTER\":\n        users = set()\n    else:\n        if message not in users:\n            count += 1\n            users.add(message)\n\nprint(count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "25206",
    "step_title": "심화 1",
    "title": "너의 평점은",
    "level": 6,
    "tags": [
      "수학",
      "구현",
      "문자열"
    ],
    "description": "인하대학교 컴퓨터공학과를 졸업하기 위해서는, 전공평점이 3.3 이상이거나 졸업고사를 통과해야 한다. 그런데 아뿔싸, 치훈이는 깜빡하고 졸업고사를 응시하지 않았다는 사실을 깨달았다!치훈이의 전공평점을 계산해주는 프로그램을 작성해보자.전공평점은 전공과목별 (학점 × 과목평점)의 합을 학점의 총합으로 나눈 값이다.인하대학교 컴퓨터공학과의 등급에 따른 과목평점은 다음 표와 같다.A+4.5A04.0B+3.5B03.0C+2.5C02.0D+1.5D01.0F0.0P/F 과목의 경우 등급이P또는F로 표시되는데, 등급이P인 과목은 계산에서 제외해야 한다.과연 치훈이는 무사히 졸업할 수 있을까?",
    "input_description": "20줄에 걸쳐 치훈이가 수강한 전공과목의 과목명, 학점, 등급이 공백으로 구분되어 주어진다.",
    "output_description": "치훈이의 전공평점을 출력한다.정답과의 절대오차 또는 상대오차가 \\(10^{-4}\\) 이하이면 정답으로 인정한다.",
    "examples": [
      {
        "input": "ObjectOrientedProgramming1 3.0 A+\nIntroductiontoComputerEngineering 3.0 A+\nObjectOrientedProgramming2 3.0 A0\nCreativeComputerEngineeringDesign 3.0 A+\nAssemblyLanguage 3.0 A+\nInternetProgramming 3.0 B0\nApplicationProgramminginJava 3.0 A0\nSystemProgramming 3.0 B0\nOperatingSystem 3.0 B0\nWirelessCommunicationsandNetworking 3.0 C+\nLogicCircuits 3.0 B0\nDataStructure 4.0 A+\nMicroprocessorApplication 3.0 B+\nEmbeddedSoftware 3.0 C0\nComputerSecurity 3.0 D+\nDatabase 3.0 C+\nAlgorithm 3.0 B0\nCapstoneDesigninCSE 3.0 B+\nCompilerDesign 3.0 D0\nProblemSolving 4.0 P",
        "output": "3.284483"
      },
      {
        "input": "BruteForce 3.0 F\nGreedy 1.0 F\nDivideandConquer 2.0 F\nDynamicProgramming 3.0 F\nDepthFirstSearch 4.0 F\nBreadthFirstSearch 3.0 F\nShortestPath 4.0 F\nDisjointSet 2.0 F\nMinimumSpanningTree 2.0 F\nTopologicalSorting 1.0 F\nLeastCommonAncestor 2.0 F\nSegmentTree 4.0 F\nEulerTourTechnique 3.0 F\nStronglyConnectedComponent 2.0 F\nBipartiteMatching 2.0 F\nMaximumFlowProblem 3.0 F\nSuffixArray 1.0 F\nHeavyLightDecomposition 4.0 F\nCentroidDecomposition 3.0 F\nSplayTree 1.0 F",
        "output": "0.000000"
      }
    ],
    "url": "https://www.acmicpc.net/problem/25206",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "total_grade_points = 0\ntotal_credits = 0\ngrade_map = {\n    'A+': 4.5, 'A0': 4.0,\n    'B+': 3.5, 'B0': 3.0,\n    'C+': 2.5, 'C0': 2.0,\n    'D+': 1.5, 'D0': 1.0,\n    'F': 0.0\n}\n\nfor _ in range(20):\n    line = input().split()\n    subject = line[0]\n    credit = float(line[1])\n    grade = line[2]\n    \n    if grade == 'P':\n        continue\n    \n    total_credits += credit\n    total_grade_points += credit * grade_map[grade]\n\ngpa = total_grade_points / total_credits\nprint(f\"{gpa:.6f}\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "total_grade_points = 0\ntotal_credits = 0\ngrade_map = {'A+': 4.5, 'A0': 4.0, 'B+': 3.5, 'B0': 3.0, 'C",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "25288",
    "step_title": "해 구성하기",
    "title": "영어 시험",
    "level": 7,
    "tags": [
      "문자열",
      "애드 혹",
      "해 구성하기"
    ],
    "description": "정휘는 영어 시험에서 배점이 큰 서술형 문제의 답안을 apple 대신 aple이라고 써서 틀렸다. 한 글자 차이로 큰 점수를 잃은 정휘는 이런 채점 방식이 합리적이지 않다고 생각해서 선생님께 새로운 채점 기준을 제안하기로 했다.정휘는 응시자가 작성한 답안과 실제 정답의 \"최장 공통 부분 수열\"의 길이에 비례하게 점수를 주는 방식을 제안했다. 만약 정답이 apple인 문제에 aple을 적어서 내면 배점의 80%를 얻을 수 있고, apple을 적어서 내면 문제의 점수를 온전하게 받을 수 있다. 하지만 선생님은 정답을 구성하는 알파벳과 정답의 길이만 알면, 동일한 단어로 모든 문제를 풀 수 있는 문자열이 존재함을 지적하며 이 방식을 거절했다. 예를 들어 정답의 길이가 2이고 정답에 a와 b만 들어갈 수 있다면, abba를 이용해 모든 문제를 풀 수 있다.선생님이 거절하신 이유를 납득하지 못한 정휘는, 정답을 구성하는 알파벳들과 정답의 길이가 주어졌을 때 모든 답안에 대해 만점을 받을 수 있는 가장 짧은 문자열을 직접 만들어보기로 했다.최장 공통 부분 수열이 무엇인지 잘 모르는 친구들은 친절한 준서가 준비한 아래 정의를 읽어보도록 하자. 알파벳을 수라고 생각하면 문자열도 수열이다.부분 수열이란 주어진 수열에서 1개 이상의 원소를 골라 원래 순서대로 나열하여 얻은 수열을 말한다.두 수열 $A, B$의공통 부분 수열이란 $A$의 부분 수열이면서 동시에 $B$의 부분 수열인 수열을 말한다.두 수열 $A, B$의최장 공통 부분 수열이란 $A, B$의 공통 부분 수열 중 가장 긴 수열을 말한다.예를 들어, appl와 aple의 최장 공통 부분 수열은 apl이다.",
    "input_description": "첫째 줄에 정답의 길이 $N$이 주어진다. ($1 \\leq N \\leq 10\\,000$)둘째 줄에 정답을 구성하는 알파벳이 공백 없이 소문자로 주어진다. 각 알파벳은 최대 한 번 주어진다.",
    "output_description": "모든 답안에 대해 만점을 받을 수 있는 가장 짧은 문자열을 출력한다.가능한 가장 짧은 문자열이 여러 가지인 경우 아무거나 출력한다.",
    "examples": [
      {
        "input": "2\nba",
        "output": "abba"
      }
    ],
    "url": "https://www.acmicpc.net/problem/25288",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\n\nfor _ in range(N):\n    S, T = input().split()\n    \n    if len(S) >= len(T):\n        print(S)\n    else:\n        result = []\n        s_idx = 0\n        \n        for ch in T:\n            if s_idx < len(S) and ch == S[s_idx]:\n                result.append(ch)\n                s_idx += 1\n            elif len(result) + (len(T) - len(result)) > len(S):\n                result.append(ch)\n        \n        print(''.join(result))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "25304",
    "step_title": "반복문",
    "title": "영수증",
    "level": 2,
    "tags": [
      "수학",
      "구현",
      "사칙연산"
    ],
    "description": "준원이는 저번 주에 살면서 처음으로 코스트코를 가 봤다. 정말 멋졌다. 그런데, 몇 개 담지도 않았는데 수상하게 높은 금액이 나오는 것이다! 준원이는 영수증을 보면서 정확하게 계산된 것이 맞는지 확인해보려 한다.영수증에 적힌,구매한 각 물건의 가격과 개수구매한 물건들의 총 금액을 보고, 구매한 물건의 가격과 개수로 계산한 총 금액이 영수증에 적힌 총 금액과 일치하는지 검사해보자.",
    "input_description": "첫째 줄에는 영수증에 적힌 총 금액 $X$가 주어진다.둘째 줄에는 영수증에 적힌 구매한 물건의 종류의 수 $N$이 주어진다.이후 $N$개의 줄에는 각 물건의 가격 $a$와 개수 $b$가 공백을 사이에 두고 주어진다.",
    "output_description": "구매한 물건의 가격과 개수로 계산한 총 금액이 영수증에 적힌 총 금액과 일치하면Yes를 출력한다. 일치하지 않는다면No를 출력한다.",
    "examples": [
      {
        "input": "260000\n4\n20000 5\n30000 2\n10000 6\n5000 8",
        "output": "Yes"
      },
      {
        "input": "250000\n4\n20000 5\n30000 2\n10000 6\n5000 8",
        "output": "No"
      }
    ],
    "url": "https://www.acmicpc.net/problem/25304",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "X = int(input())\nN = int(input())\ntotal = 0\nfor _ in range(N):\n    a, b = map(int, input().split())\n    total += a * b\nprint(\"Yes\" if total == X else \"No\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "X = int(input())로 입력을 처리합니다.",
            "code_pattern": "X = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "조건 판단",
            "description": "조건문을 사용하여 상황에 따라 다르게 처리합니다.",
            "code_pattern": "print(\"Yes\" if total == X else \"No\")",
            "socratic_hint": "조건에 따라 다르게 처리하려면?",
            "hint": "if-else 문을 사용합니다."
          },
          {
            "step_id": 5,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(\"Yes\" if total == X else \"No\")",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2: while문 활용",
        "solution_code": "N = int(input())\nresult = 0\ni = 1\nwhile i <= N:\n    result += i\n    i += 1\nprint(result)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 N을 입력받습니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "정수를 입력받으려면?",
            "hint": "int(input())을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "while 반복문 작성",
            "description": "while문으로 조건을 만족하는 동안 반복합니다.",
            "code_pattern": "while i <= N:",
            "socratic_hint": "조건을 만족하는 동안 반복하려면?",
            "hint": "while 조건: 형태로 작성합니다."
          },
          {
            "step_id": 3,
            "goal": "결과 출력",
            "description": "각 단계의 결과를 출력합니다.",
            "code_pattern": "print(result)",
            "socratic_hint": "계산 결과를 출력하려면?",
            "hint": "print()를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3: 리스트 컴프리헨션",
        "solution_code": "N = int(input())\nprint(sum(range(1, N + 1)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 N을 입력받습니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "정수를 입력받으려면?",
            "hint": "int(input())을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "리스트 컴프리헨션으로 계산",
            "description": "리스트 컴프리헨션으로 모든 결과를 한 번에 생성합니다.",
            "code_pattern": "[표현식 for i in range(...)]",
            "socratic_hint": "여러 결과를 리스트로 한 번에 만들려면?",
            "hint": "리스트 컴프리헨션을 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "결과 출력",
            "description": "생성된 결과를 출력합니다.",
            "code_pattern": "print()",
            "socratic_hint": "결과를 출력하려면?",
            "hint": "print()를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "25305",
    "step_title": "정렬",
    "title": "커트라인",
    "level": 4,
    "tags": [
      "구현",
      "정렬"
    ],
    "description": "2022 연세대학교 미래캠퍼스 슬기로운 코딩생활에 $N$명의 학생들이 응시했다.이들 중 점수가 가장 높은 $k$명은 상을 받을 것이다. 이 때, 상을 받는 커트라인이 몇 점인지 구하라.커트라인이란 상을 받는 사람들 중 점수가 가장 가장 낮은 사람의 점수를 말한다.",
    "input_description": "첫째 줄에는 응시자의 수 $N$과 상을 받는 사람의 수 $k$가 공백을 사이에 두고 주어진다.둘째 줄에는 각 학생의 점수 $x$가 공백을 사이에 두고 주어진다.",
    "output_description": "상을 받는 커트라인을 출력하라.",
    "examples": [
      {
        "input": "5 2\n100 76 85 93 98",
        "output": "98"
      }
    ],
    "url": "https://www.acmicpc.net/problem/25305",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N, k = map(int, input().split())\nscores = list(map(int, input().split()))\nscores.sort(reverse=True)\nprint(scores[k-1])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 2,
        "solution_name": "풀이 2",
        "solution_code": "n, k = map(int, input().split())\nscores = list(map(int, input().split()))\nscores.sort(reverse=True)\nprint(scores[k-1])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 숫자들을 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\n...",
            "socratic_hint": "입력을 받으려면?",
            "hint": "int(input())과 리스트 컴프리헨션 또는 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "sorted() 함수로 정렬 및 출력",
            "description": "sorted(arr)로 정렬된 새 리스트를 생성하고 출력합니다.",
            "code_pattern": "for num in sorted(arr):\n    print(num)",
            "socratic_hint": "리스트를 정렬하는 내장 함수는?",
            "hint": "sorted() 함수를 사용합니다."
          }
        ]
      },
      {
        "solution_id": 3,
        "solution_name": "풀이 3",
        "solution_code": "n, k = map(int, input().split())\nscores = list(map(int, input().split()))\nfor i in range(n-1):\n    for j in range(n-1-i):\n        if scores[j] < scores[j+1]:\n            scores[j], scores[j+1] = scores[j+1], scores[j]\nprint(scores[k-1])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 패스 횟수 제어",
            "description": "n-1번 반복하며 각 패스를 수행합니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "버블 정렬에서 몇 번의 패스가 필요한가요?",
            "hint": "n-1번의 패스가 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "내부 반복문: 인접 원소 비교",
            "description": "각 패스에서 인접한 두 원소를 비교합니다. 이미 정렬된 뒤쪽 부분은 제외합니다.",
            "code_pattern": "for j in range(n-1-i):",
            "socratic_hint": "각 패스에서 비교해야 할 원소의 범위는?",
            "hint": "n-1-i까지 비교합니다 (이미 정렬된 부분 제외)."
          },
          {
            "step_id": 4,
            "goal": "원소 교환",
            "description": "왼쪽 원소가 오른쪽 원소보다 크면 위치를 교환합니다.",
            "code_pattern": "if arr[j] > arr[j+1]:\n    arr[j], arr[j+1] = arr[j+1], arr[j]",
            "socratic_hint": "인접한 두 원소의 순서가 잘못되었을 때 어떻게 하나요?",
            "hint": "두 원소의 위치를 swap합니다."
          },
          {
            "step_id": 5,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      },
      {
        "solution_id": 4,
        "solution_name": "풀이 4",
        "solution_code": "n, k = map(int, input().split())\nscores = list(map(int, input().split()))\nfor i in range(k):\n    max_idx = i\n    for j in range(i+1, n):\n        if scores[j] > scores[max_idx]:\n            max_idx = j\n    scores[i], scores[max_idx] = scores[max_idx], scores[i]\nprint(scores[k-1])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "정수 n과 n개의 숫자를 리스트로 입력받습니다.",
            "code_pattern": "n = int(input())\narr = [int(input()) for _ in range(n)]",
            "socratic_hint": "여러 개의 숫자를 리스트로 입력받으려면?",
            "hint": "리스트 컴프리헨션이나 map을 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "외부 반복문: 정렬할 위치 선택",
            "description": "n-1번 반복하며 각 위치에 올 최솟값을 찾습니다.",
            "code_pattern": "for i in range(n-1):",
            "socratic_hint": "선택 정렬에서 몇 번의 선택이 필요한가요?",
            "hint": "n-1번의 선택이 필요합니다."
          },
          {
            "step_id": 3,
            "goal": "최솟값 인덱스 초기화",
            "description": "현재 위치를 최솟값 인덱스로 가정합니다.",
            "code_pattern": "min_idx = i",
            "socratic_hint": "최솟값을 찾기 위한 초기값은?",
            "hint": "현재 위치 i를 초기값으로 설정합니다."
          },
          {
            "step_id": 4,
            "goal": "내부 반복문: 최솟값 찾기",
            "description": "현재 위치 이후의 원소들 중 최솟값의 인덱스를 찾습니다.",
            "code_pattern": "for j in range(i+1, n):\n    if arr[j] < arr[min_idx]:\n        min_idx = j",
            "socratic_hint": "정렬되지 않은 부분에서 최솟값을 어떻게 찾나요?",
            "hint": "i+1부터 끝까지 순회하며 최솟값 인덱스를 업데이트합니다."
          },
          {
            "step_id": 5,
            "goal": "원소 교환",
            "description": "찾은 최솟값을 현재 위치로 이동시킵니다.",
            "code_pattern": "arr[i], arr[min_idx] = arr[min_idx], arr[i]",
            "socratic_hint": "최솟값을 현재 위치로 가져오려면?",
            "hint": "현재 위치의 값과 최솟값을 swap합니다."
          },
          {
            "step_id": 6,
            "goal": "정렬된 결과 출력",
            "description": "정렬된 리스트의 각 원소를 출력합니다.",
            "code_pattern": "for num in arr:\n    print(num)",
            "socratic_hint": "리스트의 모든 원소를 출력하려면?",
            "hint": "for 반복문으로 각 원소를 출력합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "25308",
    "step_title": "기하 2",
    "title": "방사형 그래프",
    "level": 12,
    "tags": [
      "브루트포스 알고리즘",
      "기하학"
    ],
    "description": "게임 캐릭터의 능력치를 한 눈에 보기 좋게 나타내는 방법으로 방사형 그래프가 있다. 캐릭터는 8개의 능력치를 갖고 있고 각 능력치를 $a_1, a_2, \\cdots, a_8$이라고 하면, 그래프는 팔각형 형태이고 $k$번째 꼭짓점은 원점을 기준으로 $45\\times k$도 방향으로 $a_k$만큼 떨어져 있다.방사형 그래프를 사용하면 능력치가 얼마나 고르게 분포되어 있는지 쉽게 알 수 있다. 만약 모든 능력치가 동일하다면 정다각형 형태가 되고, 한 능력치가 다른 능력치에 비해 현저히 낮으면 오목 다각형이 된다. 많은 사람들은 방사형 그래프를 볼록 다각형, 즉 모든 내각이 $180°$ 이하인 다각형으로 만들어 자신의 약점을 없애기 위해 노력한다.시루는 자신의 그래프를 볼록 다각형으로 바꾸고 싶지만, 능력치를 올리는 것은 매우 귀찮기 때문에 한 가지 꼼수를 생각해냈다. 바로 능력치를 나열하는 순서를 바꾸는 것이다. 예를 들어, $\\lbrace 6,7,7,8,9,10,11,13 \\rbrace$ 순서대로 나열하면 오목 다각형이 되지만, 순서를 바꿔 $\\lbrace 7,6,7,8,9,10,11,13 \\rbrace$ 순서대로 나열하면 볼록 다각형이 된다.능력치를 나열하는 순서에 따라 오목 다각형이 될 수도, 볼록 다각형이 될 수도 있기 때문에, 시루는 능력치를 잘 배열해서 볼록 다각형이 되는 경우의 수가 궁금해졌다. 볼록 다각형을 만드는 경우의 수를 구해보자.",
    "input_description": "첫째 줄에 8개의 능력치를 나타내는 정수 $a_1, a_2, \\cdots , a_8$가 공백으로 구분되어 주어진다. ($1 \\leq a_i \\leq 10^4$)",
    "output_description": "8개의 능력치를 잘 배열해서 방사형 그래프를 볼록 다각형으로 만드는 경우의 수를 출력한다.",
    "examples": [
      {
        "input": "1 1 1 1 1 1 1 1",
        "output": "40320"
      },
      {
        "input": "6 7 7 8 9 10 11 13",
        "output": "7712"
      }
    ],
    "url": "https://www.acmicpc.net/problem/25308",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "25314",
    "step_title": "반복문",
    "title": "코딩은 체육과목 입니다",
    "level": 1,
    "tags": [
      "구현"
    ],
    "description": "오늘은 혜아의 면접 날이다. 면접 준비를 열심히 해서 앞선 질문들을 잘 대답한 혜아는 이제 마지막으로 칠판에 직접 코딩하는 문제를 받았다. 혜아가 받은 문제는 두 수를 더하는 문제였다. C++ 책을 열심히 읽었던 혜아는 간단히 두 수를 더하는 코드를 칠판에 적었다. 코드를 본 면접관은 다음 질문을 했다. “만약, 입출력이 $N$바이트 크기의 정수라면 프로그램을 어떻게 구현해야 할까요?”혜아는 책에 있는 정수 자료형과 관련된 내용을 기억해 냈다. 책에는long int는 $4$바이트 정수까지 저장할 수 있는 정수 자료형이고long long int는 $8$바이트 정수까지 저장할 수 있는 정수 자료형이라고 적혀 있었다. 혜아는 이런 생각이 들었다. “int앞에long을 하나씩 더 붙일 때마다 $4$바이트씩 저장할 수 있는 공간이 늘어나는 걸까? 분명long long long int는 $12$바이트,long long long long int는 $16$바이트까지 저장할 수 있는 정수 자료형일 거야!” 그렇게 혜아는 당황하는 면접관의 얼굴을 뒤로한 채 칠판에 정수 자료형을 써 내려가기 시작했다.혜아가 $N$바이트 정수까지 저장할 수 있다고 생각해서 칠판에 쓴 정수 자료형의 이름은 무엇일까?",
    "input_description": "첫 번째 줄에는 문제의 정수 $N$이 주어진다. $(4\\le N\\le 1\\, 000$; $N$은 $4$의 배수$)$",
    "output_description": "혜아가 $N$바이트 정수까지 저장할 수 있다고 생각하는 정수 자료형의 이름을 출력하여라.",
    "examples": [
      {
        "input": "4",
        "output": "long int"
      },
      {
        "input": "20",
        "output": "long long long long long int"
      }
    ],
    "url": "https://www.acmicpc.net/problem/25314",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\nprint(\"long \" * (N // 4) + \"int\")",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(\"long \" * (N // 4) + \"int\")",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "25501",
    "step_title": "재귀",
    "title": "재귀의 귀재",
    "level": 4,
    "tags": [
      "구현",
      "문자열",
      "재귀"
    ],
    "description": "정휘는 후배들이 재귀 함수를 잘 다루는 재귀의 귀재인지 알아보기 위해 재귀 함수와 관련된 문제를 출제하기로 했다.팰린드롬이란, 앞에서부터 읽었을 때와 뒤에서부터 읽었을 때가 같은 문자열을 말한다. 팰린드롬의 예시로 AAA, ABBA, ABABA 등이 있고, 팰린드롬이 아닌 문자열의 예시로 ABCA, PALINDROME 등이 있다.어떤 문자열이 팰린드롬인지 판별하는 문제는 재귀 함수를 이용해 쉽게 해결할 수 있다. 아래 코드의 isPalindrome 함수는 주어진 문자열이 팰린드롬이면 1, 팰린드롬이 아니면 0을 반환하는 함수다.#include <stdio.h>\r\n#include <string.h>int recursion(const char *s, int l, int r){\r\n    if(l >= r) return 1;\r\n    else if(s[l] != s[r]) return 0;\r\n    else return recursion(s, l+1, r-1);\r\n}int isPalindrome(const char *s){\r\n    return recursion(s, 0, strlen(s)-1);\r\n}int main(){\r\n    printf(\"ABBA: %d\\n\", isPalindrome(\"ABBA\")); // 1\r\n    printf(\"ABC: %d\\n\", isPalindrome(\"ABC\"));   // 0\r\n}정휘는 위에 작성된 isPalindrome 함수를 이용하여 어떤 문자열이 팰린드롬인지 여부를 판단하려고 한다.구체적으로는, 문자열 $S$를 isPalindrome 함수의 인자로 전달하여 팰린드롬 여부를 반환값으로 알아낼 것이다. 더불어 판별하는 과정에서 recursion 함수를 몇 번 호출하는지 셀 것이다.정휘를 따라 여러분도 함수의 반환값과 recursion 함수의 호출 횟수를 구해보자.",
    "input_description": "첫째 줄에 테스트케이스의 개수 $T$가 주어진다. ($1 \\leq T \\leq 1\\,000$)둘째 줄부터 $T$개의 줄에 알파벳 대문자로 구성된 문자열 $S$가 주어진다. ($1 \\leq \\vert S\\vert \\leq 1\\,000$)",
    "output_description": "각 테스트케이스마다, isPalindrome 함수의 반환값과 recursion 함수의 호출 횟수를 한 줄에 공백으로 구분하여 출력한다.",
    "examples": [
      {
        "input": "5\nAAA\nABBA\nABABA\nABCA\nPALINDROME",
        "output": "1 2\n1 3\n1 3\n0 2\n0 1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/25501",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "count = 0\n\ndef recursion(s, l, r):\n    global count\n    count += 1\n    if l >= r:\n        return 1\n    elif s[l] != s[r]:\n        return 0\n    else:\n        return recursion(s, l+1, r-1)\n\ndef isPalindrome(s):\n    return recursion(s, 0, len(s)-1)\n\nT = int(input())\nfor _ in range(T):\n    count = 0\n    string = input()\n    result = isPalindrome(string)\n    print(result, count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "25504",
    "step_title": "평방 분할",
    "title": "최적 경로와 쿼리",
    "level": 21,
    "tags": [
      "다이나믹 프로그래밍",
      "그래프 이론",
      "제곱근 분할법"
    ],
    "description": "여러분은 $N$개의 버스 정류장과 $M$개의 셔틀버스가 있는 마을의 길찾기 서비스를 개발하려고 한다.$i$번째 셔틀버스는 $u_i$번 정류장과 $v_i$번 정류장 사이를 오고 가는 버스다. 편도로 이동할 때마다 $t_i$ 만큼의 시간이 걸리며, $u_i$와 $v_i$번 정류장을 제외한 다른 정류장에서 멈추지 않는다.버스를 갈아타는 것은 매우 귀찮은 일이기 때문에, 출발 지점과 도착 지점이 주어지면 최대 3개의 버스만 이용해 이동하는 가장 짧은 경로를 구하도록 개발해야 한다. 3개 이하의 버스만 이용해서 이동할 수 없는 경우도 존재할 수 있는데, 이때는 사용자에게 자가용이나 택시 이용을 권하는 메시지를 출력하려고 한다.구체적으로 여러분은 다음과 같은 요청을 처리해야 한다.$s$ $e$: $s$번 정류장에서 $e$번 정류장으로 최대 3개의 버스만 이용해 이동할 때 필요한 소요 시간의 최솟값을 출력한다. 만약 이동할 수 없다면 -1을 출력한다.버스를 기다리거나 환승할 때 걸리는 시간은 생각하지 않는다. 즉, 버스의 이동 시간만 고려한다.",
    "input_description": "첫째 줄에 버스 정류의 개수 $N$, 셔틀버스의 개수 $M$, 처리해야 하는 요청의 개수 $Q$가 공백으로 구분되어 주어진다. ($2 \\leq N \\leq 50\\,000$, $1 \\leq M \\leq 50\\,000$, $1 \\leq Q \\leq 50\\,000$)둘째 줄부터 $M$개의 줄에 걸쳐, $i$번째 줄에 $i$번째 셔틀버스의 정보 $u_i, v_i, t_i$가 공백으로 구분되어 주어진다. ($1 \\leq u_i, v_i \\leq N$, $1 \\leq t_i \\leq 50\\,000$, $u_i \\neq v_i$) 오고 가는 정류장이 같은 버스가 여러 대 주어지지 않는다.다음 $Q$개의 줄에 걸쳐, 여러분이 처리해야 하는 요청의 정보 $s, e$가 공백으로 구분되어 한 줄에 하나씩 주어진다. ($1 \\leq s,e \\leq N$, $s \\neq e$)",
    "output_description": "요청의 결과를 한 줄에 하나씩 차례대로 출력한다.",
    "examples": [
      {
        "input": "8 9 6\n1 2 1\n2 3 2\n3 4 3\n4 1 4\n4 5 5\n5 6 6\n6 7 7\n7 8 8\n8 5 9\n1 2\n1 3\n1 7\n1 8\n4 2\n4 7",
        "output": "1\n3\n-1\n18\n5\n18"
      }
    ],
    "url": "https://www.acmicpc.net/problem/25504",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "25672",
    "step_title": "인터랙티브와 투 스텝 1",
    "title": "Even and Odd Combinations",
    "level": 12,
    "tags": [
      "애드 혹",
      "해 구성하기"
    ],
    "description": "Let a$k$-combination out of $n$be a $k$-element subset of the $n$-element set $\\{1, 2, \\ldots, n\\}$. To denote a combination, list its elements in ascending order. For example, $2$-combinations out of $3$ look as follows: $\\{1, 2\\}$, $\\{1, 3\\}$, $\\{2, 3\\}$.Let a combination beevenif the number of its elements is an even number, andoddotherwise. For a fixed $n > 0$, consider two sets: $A_n$, the set of all even combinations out of $n$, and $B_n$, the set of all odd combinations out of $n$. It can be shown that $A_n$ and $B_n$ contain the same number of combinations.For each $n = 1, 2, \\ldots, 50$, your task is as follows. Construct any bijection (a one-to-one correspondence) between the sets $A_n$ and $B_n$. After that, given an element of one of these sets, print the corresponding element of the other set.",
    "input_description": "",
    "output_description": "",
    "examples": [
      {
        "input": "6\n3 0\n\n2 1\n1\n3 3\n1 2 3\n3 1\n1\n3 1\n2\n3 1\n3",
        "output": "3 3\n1 2 3\n2 2\n1 2\n3 0\n\n3 2\n2 3\n3 2\n1 3\n3 2\n1 2"
      },
      {
        "input": "6\n3 3\n1 2 3\n2 2\n1 2\n3 0\n\n3 2\n2 3\n3 2\n1 3\n3 2\n1 2",
        "output": "3 0\n\n2 1\n1\n3 3\n1 2 3\n3 1\n1\n3 1\n2\n3 1\n3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/25672",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "25682",
    "step_title": "누적 합",
    "title": "체스판 다시 칠하기 2",
    "level": 12,
    "tags": [
      "누적 합"
    ],
    "description": "지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M×N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 K×K 크기의 체스판으로 만들려고 한다.체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다.보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 K×K 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다. 당연히 K×K 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 정수 N, M, K가 주어진다. 둘째 줄부터 N개의 줄에는 보드의 각 행의 상태가 주어진다. B는 검은색이며, W는 흰색이다.",
    "output_description": "첫째 줄에 지민이가 잘라낸 K×K 보드를 체스판으로 만들기 위해 다시 칠해야 하는 정사각형 개수의 최솟값을 출력한다.",
    "examples": [
      {
        "input": "4 4 3\nBBBB\nBBBB\nBBBW\nBBWB",
        "output": "2"
      },
      {
        "input": "8 8 8\nWBWBWBWB\nBWBWBWBW\nWBWBWBWB\nBWBBBWBW\nWBWBWBWB\nBWBWBWBW\nWBWBWBWB\nBWBWBWBW",
        "output": "1"
      },
      {
        "input": "10 13 10\nBBBBBBBBWBWBW\nBBBBBBBBBWBWB\nBBBBBBBBWBWBW\nBBBBBBBBBWBWB\nBBBBBBBBWBWBW\nBBBBBBBBBWBWB\nBBBBBBBBWBWBW\nBBBBBBBBBWBWB\nWWWWWWWWWWBWB\nWWWWWWWWWWBWB",
        "output": "30"
      },
      {
        "input": "9 23 9\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBWWWWWWWW",
        "output": "40"
      }
    ],
    "url": "https://www.acmicpc.net/problem/25682",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N, M, K = map(int, input().split())\nboard = []\nfor _ in range(N):\n    board.append(input())\n\n# W로 시작하는 체스판과의 차이 누적합\nprefix_W = [[0] * (M + 1) for _ in range(N + 1)]\n\nfor i in range(N):\n    for j in range(M):\n        expected = 'W' if (i + j) % 2 == 0 else 'B'\n        diff = 0 if board[i][j] == expected else 1\n        prefix_W[i+1][j+1] = prefix_W[i][j+1] + prefix_W[i+1][j] - prefix_W[i][j] + diff\n\nmin_count = float('inf')\nfor i in range(K, N + 1):\n    for j in range(K, M + 1):\n        count_W = prefix_W[i][j] - prefix_W[i-K][j] - prefix_W[i][j-K] + prefix_W[i-K][j-K]\n        count_B = K * K - count_W\n        min_count = min(min_count, count_W, count_B)\n\nprint(min_count)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "25952",
    "step_title": "평방 분할",
    "title": "Rectangles",
    "level": 21,
    "tags": [
      "기하학",
      "제곱근 분할법"
    ],
    "description": "An axis-parallel rectangle is a rectangle with sides parallel to the $x$-axis or the $y$-axis. Also its four vertices are different from each other.For a set $S$ of points in the plane, an axis-parallel rectangle is called to becontainedin $S$ if it has, as its vertices, four points belonging to $S$.For example, in the left of Figure J.1, a set $S$ of ten points is given in the plane. Then as the right of Figure J.1, there are three axis-parallel rectangles contained in $S$.Figure J.1 There are three axis-parallel rectangles contained in the given set of points.Given a set $S$ of $n$ distinct points in the plane, write a program to output the number of all the axis-parallel rectangles contained in $S$.",
    "input_description": "Your program is to read from standard input. The input starts with a line containing an integer $n$ ($1 ≤ n ≤ 70\\,000$), where $n$ is the number of points given in the plane. In the following $n$ lines, each line contains two integers that represent, respectively, the $x$-coordinate and the $y$-coordinate of a point. These coordinate values are between $0$ and $10^5$ and all the given points are distinct.",
    "output_description": "Your program is to write to standard output. Print exactly one line. The line should contain the number of axis-parallel rectangles contained in the given point set.",
    "examples": [
      {
        "input": "4\n0 0\n0 1\n1 0\n1 1",
        "output": "1"
      },
      {
        "input": "4\n0 0\n0 1\n1 0\n1 2",
        "output": "0"
      },
      {
        "input": "10\n1 1\n3 1\n6 1\n3 3\n6 3\n8 3\n1 4\n6 4\n3 6\n8 6",
        "output": "3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/25952",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "25953",
    "step_title": "동적 계획법 3",
    "title": "템포럴 그래프",
    "level": 13,
    "tags": [
      "다이나믹 프로그래밍",
      "그래프 이론"
    ],
    "description": "템포럴 그래프는 시간의 흐름에 따라 변화하는 관계를 표현하는 자료 구조이다. 템포럴 그래프를 구성하는 정점 집합 $V$는 시간의 흐름에 따라 변하지 않으며, 정점의 개수가 $n ≥ 1$이라 할 때 $V$는 $\\{0, 1, \\dots , n - 1\\}$으로 나타낸다. 시간 표기 $T$는 양의 정수 $1, 2, \\dots , t$의 값을 가지며 시간 표기가 차례로 증가하는 것으로 시간의 흐름을 표현한다. 각 시간 표기 $T$에서 양의 정수인 가중치를 가지는 간선들의 집합 $E_T$가 정의되고, $E_T$에 포함되는 간선의 수는 일정하게 유지된다. 아래 그림은 정점 집합 $V = \\{0, 1, 2, 3, 4\\}$와 시간 표기 $T = 1, 2, 3, 4$에서 정의된 템포럴 그래프의 예시이다.템포럴 그래프의 한 정점에서 다른 정점으로 향하는 경로는 증가하는 시간 표기에 따라 차례로 나타나는 간선들의 집합으로 구성된다. 경로를 구성할 때에는 각 시간 표기에서 최대 한 개의 간선을 선택할 수 있으며, 경로를 구성하는 간선들이 정의되는 시간 표기가 연속할 필요는 없다. 예를 들어, 위 그림의 템포럴 그래프에서 세 간선 $(0, 1)$, $(1, 2)$, $(2, 4)$를 각각 시간 표기 $T = 1, 2, 4$에서 선택한다면 이는 정점 $0$에서 정점 $4$로 향하는 경로가 된다. 하지만 세 간선 $(0, 2)$, $(2, 3)$, $(3, 4)$를 각각 시간 표기 $T = 1, 3, 2$에서 선택한다면 이는 정점 $0$에서 정점 $4$로 향하는 경로가 될 수 없다(왜냐하면, 선택된 시간 표기가 증가하지 않기 때문이다). 경로의 길이는 경로에 포함되는 간선의 가중치의 총 합으로 정의한다. 따라서, 두 간선 $(0, 2)$, $(2, 4)$를 각각 시간 표기 $T = 1, 4$에서 선택한다면 이는 정점 $0$에서 정점 $4$로 향하는 최단 길이 경로가 되고 경로의 길이는 $1 + 2 = 3$이 된다.입력으로 템포럴 그래프와 경로의 시작과 끝이 되는 두 정점 $s$와 $e$가 주어질 때, $s$에서 $e$로 향하는 최단 길이 경로의 길이를 구하는 프로그램을 작성하시오.",
    "input_description": "입력은 표준입력을 사용한다. 첫 번째 줄에 정점 집합의 크기를 나타내는 양의 정수 $n$ ($2 ≤ n ≤ 10\\,000$), 시간 표기의 범위를 나타내는 양의 정수 $t$ ($1 ≤ t ≤ 1\\,000$), 매 시간 표기마다 정의되는 간선들의 개수를 나타내는 양의 정수 $m$ ($1 ≤ m ≤ 1\\,000$)이 차례로 주어진다. 다음 줄에 경로의 시작이 되는 정점을 나타내는 정수 $s$와 경로의 끝이 되는 정점을 나타내는 정수 $e$ ($0 ≤ s ≠ e ≤ n - 1$)가 차례로 주어진다. 이어지는 $m$개의 줄은 시간 표기 $T = 1$에서 정의되는 간선들의 정보를 나타낸다. 특정한 두 정점을 연결하는 간선이 두 개 이상 나타나는 경우는 없다. 각 줄에는 간선이 연결하는 두 정점의 번호와 간선의 가중치를 나타내는 양의 정수 $w$ ($1 ≤ w ≤ 10\\,000$)가 차례로 주어진다. 이어지는 $m × (t − 1)$줄은 시간 표기 $T = 2, \\dots , t$에서 정의되는 간선들의 정보를 동일한 방식으로 나타낸다.",
    "output_description": "출력은 표준출력을 사용한다. 정점 $s$에서 정점 $e$로 향하는 최단 길이 경로의 길이를 한 줄에 출력하고, 경로가 정의되지 않는 경우에는 $-1$을 출력한다.",
    "examples": [
      {
        "input": "5 4 3\n0 4\n0 1 1\n0 2 1\n2 4 3\n0 3 3\n1 2 3\n3 4 2\n0 4 5\n1 4 4\n2 3 4\n0 1 2\n1 2 3\n2 4 2",
        "output": "3"
      },
      {
        "input": "5 4 2\n0 4\n0 1 1\n0 2 1\n1 2 3\n3 4 2\n1 2 3\n2 3 4\n0 1 2\n1 2 3",
        "output": "-1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/25953",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "26001",
    "step_title": "인터랙티브와 투 스텝 2",
    "title": "Jagged Skyline",
    "level": 18,
    "tags": [
      "이분 탐색",
      "무작위화"
    ],
    "description": "The future is here! The Boxes And Parcels Centre has decided to start delivering parcels using drones. Being a BrAinPort Company, naturally the first deliveries will be to Eindhoven.To keep the flight logic simple, the first prototype will only deliver to the roofs of the tallest buildings. After take-off, the drone will take a $w\\times h$ ($1 \\leq w\\leq 10\\,000$, $1\\leq h\\leq 10^{18}$) photo of the skyline, as shown in Figure J.1. You have been tasked with the problem of determining the location and height of the tallest building in this photo, so that the drone knows where to go.You have access to a classifier that can determine for each pixel whether it is \"sky\" or \"building\". You can use this multiple times for different pixels. To avoid unnecessary delays, you may run the classifier at most $12\\,000$ times.It is guaranteed that the buildings will not contain any hovering parts: whenever a pixel that is not on the bottom row of the photo is classified as building, the pixels below it will also be classified as building.Figure J.1: The skyline of the sample interaction.",
    "input_description": "",
    "output_description": "",
    "examples": [
      {
        "input": "10 6\r\n\r\nsky\r\n\r\nbuilding\r\n\r\nsky\r\n\r\nbuilding",
        "output": "? 1 1\r\n\r\n? 3 5\r\n\r\n? 7 3\r\n\r\n? 9 2\r\n\r\n! 3 5"
      }
    ],
    "url": "https://www.acmicpc.net/problem/26001",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "26069",
    "step_title": "심화 2",
    "title": "붙임성 좋은 총총이",
    "level": 7,
    "tags": [
      "자료 구조",
      "집합과 맵",
      "해시를 사용한 집합과 맵",
      "트리를 사용한 집합과 맵"
    ],
    "description": "총총이는 친구 곰곰이의 소개로제2회 곰곰컵에 출연할 기회를 얻었다!총총이는 자신의 묘기인무지개댄스를 선보여, 여러분의 환심을 사려 한다. 이 댄스는 중독성이 강하기 때문에, 한번 보게 된 사람은 모두 따라 하게 돼버린다.사람들이 만난 기록이 시간 순서대로 $N$개 주어진다. (총총이는 토끼이지만 이 문제에서는 편의상 사람이라고 가정한다.)무지개 댄스를 추지 않고 있던 사람이 무지개 댄스를 추고 있던 사람을 만나게 된다면, 만난 시점 이후로 무지개 댄스를 추게 된다.기록이 시작되기 이전 무지개 댄스를 추고 있는 사람은 총총이 뿐이라고 할 때, 마지막 기록 이후 무지개 댄스를 추는 사람이 몇 명인지 구해보자!",
    "input_description": "첫번째 줄에는 사람들이 만난 기록의 수 $N\\ (1 \\le N \\le 1\\ 000)$이 주어진다.두번째 줄부터 $N$개의 줄에 걸쳐 사람들이 만난 기록이 주어진다. $i + 1$번째 줄에는 $i$번째로 만난 사람들의 이름 $A_i$와 $B_i$가 공백을 사이에 두고 주어진다. $A_i$와 $B_i$는 숫자와 영문 대소문자로 이루어진 최대 길이 $20$의 문자열이며, 서로 같지 않다.총총이의 이름은ChongChong으로 주어지며,기록에서 1회 이상 주어진다.동명이인은 없으며, 사람의 이름은 대소문자를 구분한다. (ChongChong과chongchong은 다른 이름이다.)",
    "output_description": "마지막 기록 이후 무지개 댄스를 추는 사람의 수를 출력하라.",
    "examples": [
      {
        "input": "12\nbnb2011 chansol\nchansol chogahui05\nchogahui05 jthis\njthis ChongChong\njthis jyheo98\njyheo98 lms0806\nlms0806 pichulia\npichulia pjshwa\npjshwa r4pidstart\nr4pidstart swoon\nswoon tony9402\ntony9402 bnb2011",
        "output": "10"
      }
    ],
    "url": "https://www.acmicpc.net/problem/26069",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\ndancers = set(['ChongChong'])\n\nfor _ in range(N):\n    A, B = input().split()\n    if A in dancers or B in dancers:\n        dancers.add(A)\n        dancers.add(B)\n\nprint(len(dancers))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "27312",
    "step_title": "인터랙티브와 투 스텝 1",
    "title": "운영진에게 설정 짜기는 어려워",
    "level": 10,
    "tags": [
      "수학",
      "애드 혹"
    ],
    "description": "Sait2000은 지문을 안 쓰는 pani를 기다리다가 너무 심심한 나머지 문제를 납치해서 직접 지문을 써버렸다!대회 배경에 넣을 캐릭터 설정을 정하는 일은 생각보다 어려운 일이다. 아니메컵 운영진은 수많은 캐릭터 아이디어를 내봤지만, 어떤 아이디어를 내도 참고 대상인 캐릭터와 설정이 겹치는 일만 반복되었다. pani는 이 문제를 해결하기 위하여 캐릭터의 설정을 세부적으로 분류하기로 하였다!pani의 분류에 의하면, 캐릭터의 설정은 $N$ 개의 속성 각각에 대한 속성의 값의 순서쌍으로 표현할 수 있다. $i$ 번째 속성의 값은 $1$ 이상 $a_i$ 이하인 정수로 표현된다. 그리고 만약 어떠한 두 캐릭터의 $N$ 개의 속성의 값이 모두 겹친다면, pani는 두 캐릭터의 설정이 겹친다고 정의하였다.캐릭터 제작을 할 때 참고하기 위하여 아니메컵 운영진들은 총 $M$ 명의 캐릭터를 선정해놓았다. pani는 참고 대상인 $M$ 명의 캐릭터 그 누구와도 설정이 겹치지 않는 새로운 캐릭터를 만들어내고자 한다. 하지만 모든 캐릭터들의 모든 속성을 일일히 구하는 건 너무 힘든 작업이기 때문에, pani는 다음 작업을 총 $Q$ 번 이하로 하기로 하였다.$k$ 번째 캐릭터의 $i$ 번째 속성의 값이 얼마인지 알아낸다.pani를 도와 설정이 겹치지 않는 캐릭터를 만들어내는 프로그램을 작성해 보자!",
    "input_description": "첫 번째 줄에 $M$, $N$, $Q$가 공백으로 구분되어 주어진다. ($1\\leq M\\leq Q\\leq N\\leq 1\\,000$)두 번째 줄에 $a_1,a_2,\\cdots ,a_N$가 공백으로 구분되어 주어진다. ($2\\leq a_i\\leq 1\\,000$)",
    "output_description": "",
    "examples": [
      {
        "input": "2 4 4\n3 4 5 6\n\n1\n\n4\n\n3\n\n3",
        "output": "? 1 1\n\n? 1 2\n\n? 2 3\n\n? 2 4\n\n! 3 1 5 6"
      }
    ],
    "url": "https://www.acmicpc.net/problem/27312",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 수학 문제 기본 구조\ndef solve():\n    # 입력 처리\n    N = int(input())\n    \n    # 계산\n    result = N\n    \n    return result\n\nprint(solve())",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "27323",
    "step_title": "기하 1: 직사각형과 삼각형",
    "title": "직사각형",
    "level": 1,
    "tags": [
      "수학",
      "기하학",
      "사칙연산"
    ],
    "description": "정수A, B가 주어진다. 세로 길이가Acm, 가로 길이가Bcm 인 아래와 같은 직사각형의 넓이를 cm2단위로 구하시오.",
    "input_description": "표준 입력에 다음과 같은 형태로 입력이 주어진다.AB",
    "output_description": "세로 길이가Acm, 가로 길이가Bcm인 직사각형의 넓이를 cm2단위로 구하고, 단위 (cm2)를 생략하여 출력한다.",
    "examples": [
      {
        "input": "2\r\n3",
        "output": "6"
      },
      {
        "input": "100\r\n1",
        "output": "100"
      },
      {
        "input": "4\r\n4",
        "output": "16"
      }
    ],
    "url": "https://www.acmicpc.net/problem/27323",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "A = int(input())\nB = int(input())\nprint(A * B)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "A = int(input())\nB = int(input())\nprint(A * B)",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "27433",
    "step_title": "재귀",
    "title": "팩토리얼 2",
    "level": 1,
    "tags": [
      "수학",
      "사칙연산"
    ],
    "description": "0보다 크거나 같은 정수 N이 주어진다. 이때, N!을 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 정수 N(0 ≤ N ≤ 20)이 주어진다.",
    "output_description": "첫째 줄에 N!을 출력한다.",
    "examples": [
      {
        "input": "10",
        "output": "3628800"
      },
      {
        "input": "0",
        "output": "1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/27433",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "def factorial(n):\n    if n <= 1:\n        return 1\n    return n * factorial(n-1)\n\nN = int(input())\nprint(factorial(N))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "27852",
    "step_title": "스프라그 그런디 정리",
    "title": "Kruskal",
    "level": 19,
    "tags": [
      "수학",
      "정수론",
      "게임 이론",
      "소수 판정",
      "스프라그–그런디 정리"
    ],
    "description": "A three-headed monkey was on his (theirs?) peaceful way from his dorm to the university. He decided to use the subway. But as soon as he descended into the station, he was stopped by a strange geek with a flashlight, saying strange words...\"I am a servant of the Secret Group Order, wielder of the flame of Primes. Your limited knowledge of partial derivatives will not avail you, flame of Riemann! You shall not pass! You can't beat Kruskal in his game!\"The three-headed monkey shook his head. The left one. But there was no way out. If he wanted to get to the university in time, he had to play.(Many others in his situation would use the distract-and-run tactics to get past the evil Kruskal into the subway. However, this was not possible in this case – nobody will turn around upon hearing\"Hey! Look behind you! A three-headed monkey!\"when he already sees the monkey in front of him...)So, what was the game about? It is a two-player game. At the beginning there areN(not necessarily equal) heaps of matches. On each turn, a player may only remove matches from one heap only, and he has to remove between 1 andKmatches, inclusive. A player wins if after his move the size of some heap is a prime number. The three-headed monkey moves first.You will be given several starting positions. For each of them, determine whether the three-headed monkey can win this game. You may assume that Kruskal (the monkey's opponent) plays optimally.",
    "input_description": "The first line of the input file contains an integerTspecifying the number of test cases. Each test case is preceded by a blank line.Each test case looks as follows: on the first line there are the two integersNandK, separated by a single space.Nlines follow, one for each heap of matches. Thei-th of these lines contains a single integeraigiving the number of matches on thei-th heap.In each test case each heap has at least three matches.",
    "output_description": "For each test case output one line. If the monkey can win the game, output the string \"YES\", otherwise output the string \"NO\".",
    "examples": [
      {
        "input": "2\n3 3\n48\n15\n4\n2 3\n51\n51",
        "output": "YES\nNO"
      }
    ],
    "url": "https://www.acmicpc.net/problem/27852",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 수학 문제 기본 구조\ndef solve():\n    # 입력 처리\n    N = int(input())\n    \n    # 계산\n    result = N\n    \n    return result\n\nprint(solve())",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "27866",
    "step_title": "문자열",
    "title": "문자와 문자열",
    "level": 1,
    "tags": [
      "구현",
      "문자열"
    ],
    "description": "단어 $S$와 정수 $i$가 주어졌을 때, $S$의 $i$번째 글자를 출력하는 프로그램을 작성하시오.",
    "input_description": "첫째 줄에 영어 소문자와 대문자로만 이루어진 단어 $S$가 주어진다. 단어의 길이는 최대 $1\\,000$이다.둘째 줄에 정수 $i$가 주어진다. ($1 \\le i \\le \\left|S\\right|$)",
    "output_description": "$S$의 $i$번째 글자를 출력한다.",
    "examples": [
      {
        "input": "Sprout\n3",
        "output": "r"
      },
      {
        "input": "shiftpsh\n6",
        "output": "p"
      },
      {
        "input": "Baekjoon\n4",
        "output": "k"
      }
    ],
    "url": "https://www.acmicpc.net/problem/27866",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "S = input()\ni = int(input())\nprint(S[i-1])",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "문제 해결",
            "description": "주어진 문제를 해결합니다.",
            "code_pattern": "S = input()\ni = int(input())\nprint(S[i-1])",
            "socratic_hint": "이 문제를 어떻게 해결할 수 있을까요?",
            "hint": "문제의 요구사항을 단계별로 구현합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "28065",
    "step_title": "해 구성하기",
    "title": "SW 수열 구하기",
    "level": 7,
    "tags": [
      "해 구성하기"
    ],
    "description": "길이가 \\(N\\)인 SW 수열은 다음 두 조건에 맞는 수열이다.SW 수열은 \\(1\\) 이상 \\(N\\) 이하의 정수로 이루어져 있고, 모든 원소는 서로 다르다.수열 \\(A\\)가 SW 수열이라고 하자. \\(2 \\leq i \\leq N - 1\\)인 정수 \\(i\\)에 대해, \\(\\left|A_i - A_{i-1}\\right| > \\left|A_{i+1} - A_i\\right|\\)이다.길이가 \\(N\\)인 SW 수열을 아무거나 하나 구해보자. 주어지는 모든 입력에 대해 SW 수열은 항상 존재한다.",
    "input_description": "첫째 줄에 구하고자 하는 SW 수열의 길이 \\(N\\)이 주어진다. \\((3 \\leq N \\leq 5\\ 000)\\)",
    "output_description": "첫째 줄에 길이가 \\(N\\)인 SW 수열을 아무거나 하나 출력한다. SW 수열은 공백으로 구분해서 출력해야 한다.",
    "examples": [
      {
        "input": "3",
        "output": "1 3 2"
      },
      {
        "input": "4",
        "output": "4 1 3 2"
      }
    ],
    "url": "https://www.acmicpc.net/problem/28065",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\n\nif N <= 3:\n    print(' '.join(map(str, range(1, N + 1))))\nelse:\n    result = [N, 1] + list(range(2, N))\n    print(' '.join(map(str, result)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "28121",
    "step_title": "유니온 파인드 2",
    "title": "산책과 쿼리",
    "level": 17,
    "tags": [
      "그래프 이론",
      "자료 구조",
      "애드 혹",
      "분리 집합",
      "홀짝성",
      "이분 그래프"
    ],
    "description": "성서는 숭실대학교 근처 자취 후보 장소를 $N$개 선정해 $1$부터 $N$까지 번호를 붙였다. 각 장소에는 자취방이 정확히 하나씩 있다. 자취방을 구할 때 고려할 사항은 여러 가지가 있지만, 성서는 그중에서도 산책의 자유도를 가장 중요하게 생각한다.산책로$(a,b)$는 서로 다른 두 장소 $a$와 $b$를 잇는 길로, $a$에서 $b$로 걷는 데 $1$의 시간이 걸리고, $b$에서 $a$로 걷는 데에도 $1$의 시간이 걸린다. 일단 걷기 시작하면 중간에 방향을 꺾거나 멈추지 않고 정확히 $1$의 시간 동안 걸어서 반대편에 도착해야 한다.산책은 어떤 장소 $u$에서 출발해 산책로를 따라 걸어 다니다가 마지막에 다시 $u$로 되돌아오는 행동이다. 산책 도중에 어떤 장소나 산책로를 여러 번 방문해도 되지만, 산책 도중에 잠시라도 걸음을 멈추면 안 된다.성서는 장소들 사이를 둘러보며 분위기가 좋은 산책로들을 자신만의 산책로 리스트에 추가할 계획이다.만족스러운 산책이란, 산책로 리스트에 적힌 산책로만을 사용하는 산책이다.성서는 충분히 긴 시간 동안 산책을 하다가 원하는 시간에 맞춰 되돌아오고 싶다. 어떤 자취방 $u$가산책의 자유도가 높다는 것은, $10^6$ 이상의 어떤 정수 $t$를 고르더라도, 장소 $u$에서 출발하면서 정확히 $t$의 시간이 걸리는 만족스러운 산책이 존재함을 의미한다.처음에는 산책로 리스트가 비어 있지만, 성서는 분위기가 좋은 산책로를 발견할 때마다 그 산책로를 리스트에 추가할 것이다. 리스트가 변경될 때마다 산책의 자유도가 높은 자취방이 몇 개나 있는지 알아보자.구체적으로, 다음과 같은 쿼리를 $Q$번 처리해야 한다.a b: 산책로 $(a,b)$를 산책로 리스트에 추가한다. 이후 산책의 자유도가 높은 자취방의 개수를 출력한다.예를 들어 자취방이 $6$개이고 산책로 리스트가 $\\{(1,2) ,(2,3) ,(1,3) ,(4,5)\\}$라면 위 그림처럼 표현할 수 있다.자취방 $6$에서는 $10^6$의 시간이 걸리는 만족스러운 산책을 할 수 없으므로 산책의 자유도가 높지 않다.자취방 $4$와 $5$에서는 $10^6$이나 $10^6+2$ 등의 시간이 걸리는 만족스러운 산책은 할 수 있지만, $10^6+1$이나 $10^6+3$ 등의 시간이 걸리는 만족스러운 산책은 할 수 없으므로 산책의 자유도가 높지 않다.반면에 자취방 $1,2,3$은 $10^6$이나 $10^6+1,10^6+2,10^6+3,\\cdots$의 시간이 걸리는 만족스러운 산책이 모두 가능하므로 산책의 자유도가 높다.따라서 위 그림에서 산책의 자유도가 높은 자취방의 개수는 $3$이다.",
    "input_description": "첫째 줄에 장소의 개수 $N$과 쿼리의 개수 $Q$가 공백으로 구분되어 주어진다.둘째 줄부터 $Q$개의 줄에 걸쳐, $i$번째 줄에 $i$번째 쿼리에서 추가되는 산책로가 연결하는 두 장소 $a_i,b_i$가 공백으로 구분되어 주어진다.",
    "output_description": "쿼리가 주어질 때마다 한 줄에 하나씩 정답을 출력한다.",
    "examples": [
      {
        "input": "6 5\n1 2\n2 3\n1 3\n4 5\n2 5",
        "output": "0\n0\n3\n3\n5"
      },
      {
        "input": "4 4\n1 2\n2 3\n3 4\n1 4",
        "output": "0\n0\n0\n0"
      }
    ],
    "url": "https://www.acmicpc.net/problem/28121",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "28122",
    "step_title": "문자열 알고리즘 1",
    "title": "아이템",
    "level": 19,
    "tags": [
      "그래프 이론",
      "자료 구조",
      "그래프 탐색",
      "트리",
      "깊이 우선 탐색",
      "트라이"
    ],
    "description": "좌우로 무한히 긴 수직선 위에 $N$개의 아이템이 떨어져 있다. $i$번째 아이템의 위치는 $X_i$이며, 여러 개의 아이템이 한 곳에 있을 수 있다. 현재 위치 $0$에 있는 주원이는 최대한 많은 개수의 아이템을 줍고 싶다.처음에 주원이는 한 번 이동할 때마다 $1$씩 왼쪽 또는 오른쪽으로 이동할 수 있다. 단, 아이템을 하나 주울 때마다 이동 거리가 2배씩 늘어난다. 즉, 현재까지 획득한 아이템이 $k$개라면 수직선 위에서 한 번 이동할 때마다 $2^k$씩 왼쪽 또는 오른쪽으로 이동할 수 있다. 단, 이동 중에는 중간에 멈출 수 없다.아이템은 해당 아이템이 존재하는 위치에 멈춰야 주울 수 있으며, 아이템이 있는 위치에 멈췄더라도 아이템을 줍지 않을 수 있다. 아이템을 주우면 해당 아이템은 그 자리에서 사라진다.주울 수 있는 아이템의 최대 개수를 구해보자.",
    "input_description": "첫째 줄에 아이템의 개수 $N$이 주어진다.둘째 줄에 아이템의 위치 $X_1,X_2,\\cdots ,X_N$이 공백으로 구분되어 주어진다.",
    "output_description": "주울 수 있는 아이템의 최대 개수를 출력한다.",
    "examples": [
      {
        "input": "5\n0 1 3 8 9",
        "output": "3"
      },
      {
        "input": "5\n5 39 19 27 11",
        "output": "5"
      },
      {
        "input": "3\n0 0 1000000000000000000",
        "output": "3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/28122",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 그래프 문제 기본 구조\nfrom collections import deque\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\n# BFS/DFS 구현\nvisited = [False] * (N + 1)\n\ndef bfs(start):\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        node = queue.popleft()\n        for next_node in graph[node]:\n            if not visited[next_node]:\n                visited[next_node] = True\n                queue.append(next_node)\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "28277",
    "step_title": "유니온 파인드 2",
    "title": "뭉쳐야 산다",
    "level": 15,
    "tags": [
      "자료 구조",
      "집합과 맵",
      "트리를 사용한 집합과 맵",
      "작은 집합에서 큰 집합으로 합치는 테크닉"
    ],
    "description": "N개의 집합S1,S2, …,SN이 주어질 때 다음 명령들을Q개 처리해 보자.1 a b: 집합Sa를Sa∪Sb로 바꾸고,Sb는 공집합으로 바꾼다. (1 ≤a,b≤ N;a≠b)2 a: 집합Sa의 크기를 출력한다. (1 ≤a≤N)",
    "input_description": "첫 번째 줄에N과Q가 주어진다. (1 ≤N,Q≤ 500,000)다음N개 줄의i번째 줄에는 집합Si의 정보가 주어진다.각 줄에는Si의 크기ni가 먼저 주어지고, 이어서Si의 원소sij가 주어진다. (1 ≤ ∑ni≤ 500,000; 1 ≤sij≤ 109; 모든k≠j에 대해sij≠sik)다음Q개 줄에는 위에서 설명한 명령이 한 줄에 하나씩 주어진다.입력되는 모든 수는 정수이고, 명령2 a는 하나 이상 주어진다.",
    "output_description": "명령2 a가 주어질 때마다 각 줄에 명령의 결과를 출력한다.",
    "examples": [
      {
        "input": "3 11\n2 5 1\n3 2 4 7\n4 8 5 2 6\n2 1\n2 2\n2 3\n1 1 3\n2 1\n2 3\n1 2 3\n2 2\n1 2 1\n2 1\n2 2",
        "output": "2\n3\n4\n5\n0\n3\n0\n7"
      }
    ],
    "url": "https://www.acmicpc.net/problem/28277",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 기본 입출력 구조\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nresult = []\n\nfor _ in range(N):\n    data = input().strip()\n    # 처리 로직 구현 필요\n    result.append(data)\n\nfor r in result:\n    print(r)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "28278",
    "step_title": "스택, 큐, 덱 1",
    "title": "스택 2",
    "level": 7,
    "tags": [
      "자료 구조",
      "스택"
    ],
    "description": "정수를 저장하는 스택을 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.명령은 총 다섯 가지이다.1 X: 정수X를 스택에 넣는다. (1 ≤X≤ 100,000)2: 스택에 정수가 있다면 맨 위의 정수를 빼고 출력한다. 없다면-1을 대신 출력한다.3: 스택에 들어있는 정수의 개수를 출력한다.4: 스택이 비어있으면1, 아니면0을 출력한다.5: 스택에 정수가 있다면 맨 위의 정수를 출력한다. 없다면-1을 대신 출력한다.",
    "input_description": "첫째 줄에 명령의 수N이 주어진다. (1 ≤N≤ 1,000,000)둘째 줄부터N개 줄에 명령이 하나씩 주어진다.출력을 요구하는 명령은 하나 이상 주어진다.",
    "output_description": "출력을 요구하는 명령이 주어질 때마다 명령의 결과를 한 줄에 하나씩 출력한다.",
    "examples": [
      {
        "input": "9\n4\n1 3\n1 5\n3\n2\n5\n2\n2\n5",
        "output": "1\n2\n5\n3\n3\n-1\n-1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/28278",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "import sys\ninput = sys.stdin.readline\n\nN = int(input())\nstack = []\n\nfor _ in range(N):\n    cmd = list(map(int, input().split()))\n    \n    if cmd[0] == 1:\n        stack.append(cmd[1])\n    elif cmd[0] == 2:\n        print(stack.pop() if stack else -1)\n    elif cmd[0] == 3:\n        print(len(stack))\n    elif cmd[0] == 4:\n        print(0 if stack else 1)\n    elif cmd[0] == 5:\n        print(stack[-1] if stack else -1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "28279",
    "step_title": "스택, 큐, 덱 1",
    "title": "덱 2",
    "level": 7,
    "tags": [
      "자료 구조",
      "덱"
    ],
    "description": "정수를 저장하는 덱을 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.명령은 총 여덟 가지이다.1 X: 정수X를 덱의 앞에 넣는다. (1 ≤X≤ 100,000)2 X: 정수X를 덱의 뒤에 넣는다. (1 ≤X≤ 100,000)3: 덱에 정수가 있다면 맨 앞의 정수를 빼고 출력한다. 없다면-1을 대신 출력한다.4: 덱에 정수가 있다면 맨 뒤의 정수를 빼고 출력한다. 없다면-1을 대신 출력한다.5: 덱에 들어있는 정수의 개수를 출력한다.6: 덱이 비어있으면1, 아니면0을 출력한다.7: 덱에 정수가 있다면 맨 앞의 정수를 출력한다. 없다면-1을 대신 출력한다.8: 덱에 정수가 있다면 맨 뒤의 정수를 출력한다. 없다면-1을 대신 출력한다.",
    "input_description": "첫째 줄에 명령의 수N이 주어진다. (1 ≤N≤ 1,000,000)둘째 줄부터N개 줄에 명령이 하나씩 주어진다.출력을 요구하는 명령은 하나 이상 주어진다.",
    "output_description": "출력을 요구하는 명령이 주어질 때마다 명령의 결과를 한 줄에 하나씩 출력한다.",
    "examples": [
      {
        "input": "11\n6\n1 3\n1 8\n7\n8\n3\n2 5\n1 2\n5\n4\n4",
        "output": "1\n8\n3\n8\n3\n5\n3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/28279",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\ndq = deque()\n\nfor _ in range(N):\n    cmd = list(map(int, input().split()))\n    \n    if cmd[0] == 1:\n        dq.appendleft(cmd[1])\n    elif cmd[0] == 2:\n        dq.append(cmd[1])\n    elif cmd[0] == 3:\n        print(dq.popleft() if dq else -1)\n    elif cmd[0] == 4:\n        print(dq.pop() if dq else -1)\n    elif cmd[0] == 5:\n        print(len(dq))\n    elif cmd[0] == 6:\n        print(0 if dq else 1)\n    elif cmd[0] == 7:\n        print(dq[0] if dq else -1)\n    elif cmd[0] == 8:\n        print(dq[-1] if dq else -1)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "28340",
    "step_title": "그리디 알고리즘 2",
    "title": "K-ary Huffman Encoding",
    "level": 17,
    "tags": [
      "자료 구조",
      "그리디 알고리즘",
      "트리",
      "우선순위 큐"
    ],
    "description": "Huffman 나라의 문자는 $N$개의 문자로 이루어져 있다.0과1로 이루어진 이진 인코딩이 발달한 대한민국과는 달리, Huffman 나라에서는 $0$부터 $K - 1$까지의 숫자로 이루어진 $K$진법 인코딩이 발달했다.우리는 Huffman 나라의 언어를 $K$진법으로 인코딩하려 한다. 이 때 다음 조건을 만족해야 한다.$N$개의 각 문자에 $K$진법 문자열을 하나씩 배정해야 한다.배정된 $K$진법 문자열들이 서로의 접두사 (prefix)일 수 없다.예를 들어 아래의 표는!,@,#,+$4$개의 문자를 $3$진법으로 올바르게 인코딩한 예이다.문자인코딩!012@120#201+210$4$개의 문자 각각에 서로의 접두사가 아닌 3진법 문자열을 할당했음을 확인해 볼 수 있다. 반면,문자인코딩!013@120#201+210은!에013을 배정해서 첫 번째 조건을 만족하지 않고,문자인코딩!012@120#201+20은+이#의 접두사이기 때문에 두 번째 조건을 만족하지 않는다.Huffman 나라 언어 문자열이 하나 주어졌을 때, 이 문자열을 $K$진법으로 인코딩한 결과를 가장 짧게 만들면 길이가 어떻게 될까? 예를 들어 “!!!@@@@#####++++++” 과 같이!가 $3$번,@가 $4$번,#가 $5$번,+가 $6$번 문자열에 나타났다면, 첫 번째 표에서 제시한 인코딩을 적용한 경우 총 길이는 $54$가 된다 ($3 \\times 3+4\\times 3+5\\times 3+6\\times 3 = 54$).",
    "input_description": "입력은 $T$개의 테스트 케이스로 구성된다. 입력의 첫 줄에는 $T$가 주어진다.각 테스트 케이스 첫 줄에는 두 정수 $N$ ($2 ≤ N ≤ 10\\,000$), $K$ ($2 ≤ K ≤ 10\\,000$)가 공백으로 구분되어 주어진다. $N$은 Huffman 나라의 문자의 수이고 $K$는 인코딩할 진법을 나타낸다. 다음 줄에는 각 문자가 문자열에 몇 번이나 나타나는지를 의미하는 $N$개의 정수 $C_i$ ($0 ≤ C_i ≤ 100\\,000$)가 공백으로 구분되어 주어진다.",
    "output_description": "각 테스트 케이스마다 한 줄에 하나씩 주어진 문자열의 가능한 최소 $K$진법 인코딩의 길이를 출력한다.",
    "examples": [
      {
        "input": "2\r\n4 2\r\n0 1 2 3\r\n4 2\r\n0 1 2 2",
        "output": "10\r\n9"
      }
    ],
    "url": "https://www.acmicpc.net/problem/28340",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 그래프 문제 기본 구조\nfrom collections import deque\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\n# BFS/DFS 구현\nvisited = [False] * (N + 1)\n\ndef bfs(start):\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        node = queue.popleft()\n        for next_node in graph[node]:\n            if not visited[next_node]:\n                visited[next_node] = True\n                queue.append(next_node)\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "29771",
    "step_title": "트리와 쿼리",
    "title": "트리 컴포넌트 찾기",
    "level": 20,
    "tags": [
      "자료 구조",
      "트리",
      "최소 공통 조상",
      "희소 배열",
      "트리 압축"
    ],
    "description": "\\(N\\)개의 정점과 \\(N-1\\)개의 양방향 간선으로 구성된 트리가 주어진다. 정점 번호는 \\(0\\)부터 \\(N-1\\)까지이고 \\(0\\)번 정점이 루트이다. 주어진 트리에 대한 다음과 같은 쿼리를 $Q$번 수행하자.\\(k\\ v_1\\ v_2\\ v_3\\ ...\\ v_k\\) : \\(k\\)개의 정점 \\(v_1,\\ v_2,\\ v_3,\\ ...,\\ v_k\\)를 모두 포함하는 연결 컴포넌트 중 정점의 수가 가장 작은 연결 컴포넌트를 \\(C\\)라고 하자. 연결 컴포넌트 \\(C\\)의 정점의 수와 정점 번호의 총합을 공백으로 구분하여 출력한다.",
    "input_description": "첫 번째 줄에 정점의 수 \\(N\\)이 입력된다. \\((2\\le N \\le 100\\,000)\\)다음 \\(N-1\\)개 줄에 부모 정점 번호 \\(p\\)와 자식 정점 번호 \\(c\\)가 공백으로 구분되어 입력된다. 입력으로 주어지는 그래프는 트리이다. \\((0\\le p\\le N-1, 0 \\le c \\le N-1, p ≠ c)\\)다음 줄에 쿼리의 수 \\(Q\\)가 입력된다. \\((1\\le Q \\le 100\\,000)\\)다음 \\(Q\\)개의 줄에 \\(k, v_1, v_2, v_3, ..., v_k\\)가 공백으로 구분되어 입력된다. \\(k\\)의 총합은 \\(10^6\\) 이하이다. \\((1 \\le k \\le N\\), \\(0 \\le v_i \\le N-1(1 \\le i \\le k)\\), \\(v_i ≠ v_j(1 \\le i < j \\le k))\\)입력으로 주어지는 모든 수는 정수이다.",
    "output_description": "쿼리가 주어질 때마다 쿼리의 답을 한 줄에 하나씩 출력한다.",
    "examples": [
      {
        "input": "7\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\n5\n1 1\n2 0 1\n2 1 2\n3 2 3 4\n7 0 1 2 3 4 5 6",
        "output": "1 1\n2 1\n3 3\n5 10\n7 21"
      }
    ],
    "url": "https://www.acmicpc.net/problem/29771",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 그래프 문제 기본 구조\nfrom collections import deque\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N + 1)]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\n# BFS/DFS 구현\nvisited = [False] * (N + 1)\n\ndef bfs(start):\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        node = queue.popleft()\n        for next_node in graph[node]:\n            if not visited[next_node]:\n                visited[next_node] = True\n                queue.append(next_node)\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "30618",
    "step_title": "해 구성하기",
    "title": "donstructive",
    "level": 7,
    "tags": [
      "해 구성하기"
    ],
    "description": "순열은 $1$부터 $N$까지 $N$개의 정수가 각각 한 번씩 나오는 수열이다. 예를 들어, $[1]$, $[3, 5, 2, 1, 4]$, $[1, 3, 2]$는 순열이지만, $[2, 3, 2]$, $[4, 3, 1]$, $[0]$은 순열이 아니다.순열의 점수는 다음과 같은 방법으로 구한다.순열의 모든 연속 부분 수열 각각에 대해 원소의 합을 구한다.순열의 점수는 (1)에서 구한 모든 값의 합이다.길이가 $N$인 모든 순열 중에서 점수가 가장 높은 순열을 구해보자. 점수가 가장 높은 순열이 여러 가지라면 그 중 아무거나 하나를 출력한다.",
    "input_description": "첫째 줄에 구하고자 하는 순열의 길이 $N$이 주어진다. $(1 \\le N \\le 200\\,000)$",
    "output_description": "첫째 줄에 점수가 가장 높은 순열에 해당하는 $N$개의 정수를 공백으로 구분해서 출력한다.",
    "examples": [
      {
        "input": "4",
        "output": "2 3 4 1"
      }
    ],
    "url": "https://www.acmicpc.net/problem/30618",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\n\nif N == 1:\n    print(1)\nelse:\n    result = []\n    left, right = 1, N\n    for i in range(N):\n        if i % 2 == 0:\n            result.append(right)\n            right -= 1\n        else:\n            result.append(left)\n            left += 1\n    \n    print(' '.join(map(str, result)))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "30917",
    "step_title": "인터랙티브와 투 스텝 1",
    "title": "A+B - 10 (제1편)",
    "level": 3,
    "tags": [
      "수학",
      "구현",
      "브루트포스 알고리즘",
      "사칙연산"
    ],
    "description": "1 이상 9 이하의 정수 A, B에 대해 A+B의 값을 출력해야 한다. 단, 이 문제는인터랙티브 (상호작용)문제이다. 이 문제에서는 A와 B의 값이 바로 주어지지 않고, 채점기와의 상호작용을 통해 그 값을 알아내야 한다.",
    "input_description": "",
    "output_description": "여러분은 채점기에게최대 18번질문할 수 있다. 질문의 형태는 다음 중 하나이다.? A x- A의 값이 x인지 물어본다.? B x- B의 값이 x인지 물어본다.예를 들어 A의 값이 4인지 물어보려면? A 4를 출력하면 된다. 이때 x는 1 이상 9 이하의 정수여야 한다.질문을 출력한 뒤 실제로 질문을 채점기에게 보내려면표준 출력을 flush해야 한다. 자세한 내용은 아래의노트란을 참조하자.질문을 보낸 뒤에는 채점기로부터 정수 하나를 입력받는다. 그 수는 질문의 답이 \"예\"인 경우 1, \"아니요\"인 경우 0이다.A와 B의 값을 알아냈으면 A+B를 계산하여 다음과 같은 형태로 출력한다.! x- A+B의 값은 x이다.예를 들어 A+B가 10인 경우! 10을 출력하면 된다. 이는 질문 횟수에 포함되지 않는다.아래의 \"노트\" 란에 여러 언어에 대한 예시 코드가 작성되어 있다. 단, 완성되지 않은 코드이므로 빈 공간은 직접 채워 넣어야 한다.",
    "examples": [
      {
        "input": "​\n0\n\n0\n\n1\n\n0\n\n1",
        "output": "? A 1\n\n? A 2\n\n? A 3\n\n? B 1\n\n? B 2\n\n! 5"
      }
    ],
    "url": "https://www.acmicpc.net/problem/30917",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 수학 문제 기본 구조\ndef solve():\n    # 입력 처리\n    N = int(input())\n    \n    # 계산\n    result = N\n    \n    return result\n\nprint(solve())",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "30924",
    "step_title": "인터랙티브와 투 스텝 1",
    "title": "A+B - 10 (제2편)",
    "level": 6,
    "tags": [
      "수학",
      "사칙연산",
      "무작위화"
    ],
    "description": "1 이상 10,000 이하의 정수 A, B에 대해 A+B의 값을 출력해야 한다. 단, 이 문제는인터랙티브 (상호작용)문제이다. 이 문제에서는 A와 B의 값이 바로 주어지지 않고, 채점기와의 상호작용을 통해 그 값을 알아내야 한다.상호작용 문제에 대해 잘 모른다면,제1편을 먼저 풀어보자.",
    "input_description": "",
    "output_description": "제1편과 같은 방식으로 상호작용하면 된다. 단, 이 문제에서는최대 19,997번질문할 수 있다.이 문제의 채점기는적응하지 않는다. 자세한 설명은 아래노트란을 참조하자.",
    "examples": [
      {
        "input": "​\n0\n\n0\n\n1\n\n0\n\n1",
        "output": "? A 123\n\n? A 2517\n\n? A 3150\n\n? B 1342\n\n? B 205\n\n! 3355"
      }
    ],
    "url": "https://www.acmicpc.net/problem/30924",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 수학 문제 기본 구조\ndef solve():\n    # 입력 처리\n    N = int(input())\n    \n    # 계산\n    result = N\n    \n    return result\n\nprint(solve())",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "31430",
    "step_title": "인터랙티브와 투 스텝 1",
    "title": "A+B - 투 스텝",
    "level": 7,
    "tags": [
      "수학",
      "구현",
      "문자열"
    ],
    "description": "이 문제는 투 스텝 문제이다. 한 번 채점할 때 참가자의 프로그램을 2번 실행하는 형식의 문제이다. 각 실행은 일반적인 문제와 같이 진행되지만, 두 실행은 서로 독립적이다.갑과 을은 주어진 음이 아닌 두 정수 $A,B$의 합을 구하려고 한다. 두 정수의 합을 구하는 과정은 다음과 같다.갑에게 음이 아닌 두 정수 $A$와 $B$가 주어진다.갑은 소문자 알파벳으로 구성된 길이가 $13$인 문자열을 만든다.을에게는 갑이 만든 문자열이 주어진다.단, 을에게는 $A,B$의 값이 주어지지 않는다.을은 주어진 문자열을 통해 $A+B$를 구해야 한다.갑과 을이 이러한 과정을 통해 $A+B$를 구할 수 있는 프로그램을 작성하자.",
    "input_description": "첫 번째 줄에는 입력의 종류를 나타내는 정수 $T$가 주어진다. $(T \\in \\{ 1, 2 \\})$$T=1$인 경우 갑의 입력이 주어진다. 즉, 두 번째 줄에 음이 아닌 정수 $A$와 $B$가 공백으로 구분되어 주어진다. $(0 \\le A, B \\le 10^{18})$$T=2$인 경우 을의 입력이 주어진다. 즉, 두 번째 줄에 갑이 만든 소문자 알파벳으로 구성된 길이가 $13$인 문자열이 주어진다.",
    "output_description": "$T=1$인 경우, 첫 번째 줄에 소문자 알파벳으로 구성된 길이가 $13$인 문자열을 출력한다.$T=2$인 경우, 첫 번째 줄에 $A+B$의 값을 출력한다.",
    "examples": [
      {
        "input": "1\n1 2",
        "output": "aaaaaaaathree"
      },
      {
        "input": "2\naaaaaaaathree",
        "output": "3"
      }
    ],
    "url": "https://www.acmicpc.net/problem/31430",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 수학 문제 기본 구조\ndef solve():\n    # 입력 처리\n    N = int(input())\n    \n    # 계산\n    result = N\n    \n    return result\n\nprint(solve())",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "31836",
    "step_title": "해 구성하기",
    "title": "피보나치 기념품",
    "level": 10,
    "tags": [
      "수학",
      "애드 혹",
      "해 구성하기"
    ],
    "description": "피보나치 수열은 다음과 같이 정의되는 수열이다.$F_1=1$$F_2=1$$F_n=F_{n-1}+F_{n-2}$ (단, $n\\ge 3$)정휘는 이집트 룩소르의 한 시장에서 피보나치 수가 적혀 있는 $N$개의 기념품을 구매했다. $x(1\\le x\\le N)$번 기념품에는 $F_x$가 적혀 있다.정휘는 피보나치 수열을 좋아하는 세림이와 성주에게 기념품을 선물하려고 한다. 하지만 한 명에게 너무 많은 기념품을 주면 기념품을 적게 받은 사람이 슬퍼할 수 있기 때문에, 두 명이 받게 될기념품에 적힌 피보나치 수의 합이 같아지도록 선물을 분배하려고 한다. 구매한 기념품의 개수 $N$에 따라 $N$개의 기념품을 전부 나눠주지 못할 수 있는데, 이때는 최대한많은 개수의 기념품을 나눠주려고 한다.나눠주는 기념품의 개수를 최대화하면서, 두 명이 받는 기념품에 적힌 수의 합이 같도록 기념품을 나눠주는 방법을 구해보자. 두 사람에게 1개 이상의 기념품을 나눠주는 방법은 항상 존재한다.",
    "input_description": "첫째 줄에 정휘가 구매한 기념품의 개수 $N$이 주어진다.",
    "output_description": "첫째 줄에 세림이가 받을 기념품의 개수 $X$를 출력한다.둘째 줄에 세림이가 받을 기념품들의 번호 $A_1,A_2,\\cdots ,A_X$를 공백으로 구분해서 출력한다.셋째 줄에 성주가 받을 기념품의 개수 $Y$를 출력한다.넷째 줄에 성주가 받을 기념품들의 번호 $B_1,B_2,\\cdots ,B_Y$를 공백으로 구분해서 출력한다.가능한 분배 방법이 여러 가지면 그중 아무거나 하나만 출력하라.",
    "examples": [
      {
        "input": "2",
        "output": "1\n1\n1\n2"
      },
      {
        "input": "4",
        "output": "2\n1 3\n1\n4"
      }
    ],
    "url": "https://www.acmicpc.net/problem/31836",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "N = int(input())\n\nif N == 1:\n    print(1, 0)\n    print(1)\n    print()\nelif N == 2:\n    print(1, 1)\n    print(1)\n    print(2)\nelse:\n    if N % 2 == 1:\n        k = (N - 1) // 2\n    else:\n        k = N // 2 - 1\n    \n    print(k, N - k)\n    print(' '.join(map(str, range(1, k + 1))))\n    print(' '.join(map(str, range(k + 1, N + 1))))",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "32395",
    "step_title": "평방 분할",
    "title": "4-cycle (Hard)",
    "level": 22,
    "tags": [
      "수학",
      "그래프 이론",
      "조합론",
      "제곱근 분할법"
    ],
    "description": "$N$개의 정점과 $M$개의 무방향 간선으로 이루어진 단순 그래프 $G$가 주어진다. 단순 그래프란, 두 정점 사이에는 최대 $1$개의 간선이 존재하고, 모든 간선이 서로 다른 두 정점을 연결하는 그래프이다. $G$의 정점들은 $N$ 이하의 양의 정수들로 번호가 매겨져 있다.그래프 $G$의 길이가 $L$인 단순 사이클은 다음 조건을 만족하는 정점의 수열 $\\left( v_0,v_1,\\cdots ,v_L \\right)$로 정의된다.모든 $0\\leq i<L$인 $i$에 대해 $v_i$와 $v_{i+1}$을 연결하는 간선이 $G$에 존재한다.모든 $0\\leq i<j<L$인 $i,j$에 대해 $v_i\\neq v_j$를 만족하고, $v_L=v_0$이다.이때, 두 단순 사이클이 다음의 연산을 이용해 서로 변환 가능하면, 이를 동일한 사이클로 간주한다.수열을 뒤집는다. 즉, $\\left( v_0,v_1,\\cdots ,v_L \\right)$을 $\\left( v_L,\\cdots ,v_1,v_0 \\right)$로 변경한다.수열의 두 번째 원소를 맨 뒤에 추가하고 첫 번째 원소를 삭제한다. 즉, $\\left( v_0,v_1,\\cdots ,v_L \\right)$을 $\\left( v_1,\\cdots ,v_L,v_1 \\right)$로 변경한다.예를 들어, 단순 사이클 $\\left( 1,2,3,4,1 \\right)$과 $\\left( 2,1,4,3,2 \\right)$는 동일한 단순 사이클이다. 주어진 그래프 $G$에서 길이가 $4$인 서로 다른 단순 사이클의 개수를 구해보자.",
    "input_description": "첫 번째 줄에 그래프 $G$의 정점의 개수 $N(2\\leq N\\leq 10^5)$과 간선의 개수 $M(1\\leq M\\leq 10^5)$이 공백으로 구분되어 주어진다.두 번째 줄부터 $M$줄에 걸쳐 그래프 $G$의 간선을 이루는 서로 다른 두 정점 $u,v(1\\leq u,v\\leq N)$가 공백으로 구분되어 주어진다.간선이 중복으로 들어오지 않음이 보장된다.",
    "output_description": "그래프 $G$에서 길이가 $4$인 서로 다른 단순 사이클의 개수를 $10^9+7$로 나눈 나머지를 출력한다.단, $10^9+7$은 소수이다.",
    "examples": [
      {
        "input": "6 7\n1 2\n2 3\n3 4\n4 1\n4 5\n5 6\n6 4",
        "output": "1"
      },
      {
        "input": "4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4",
        "output": "3"
      },
      {
        "input": "6 15\n1 2\n1 3\n1 4\n1 5\n1 6\n2 3\n2 4\n2 5\n2 6\n3 4\n3 5\n3 6\n4 5\n4 6\n5 6",
        "output": "45"
      }
    ],
    "url": "https://www.acmicpc.net/problem/32395",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# 수학 문제 기본 구조\ndef solve():\n    # 입력 처리\n    N = int(input())\n    \n    # 계산\n    result = N\n    \n    return result\n\nprint(solve())",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  },
  {
    "problem_id": "33918",
    "step_title": "스택, 큐, 덱 2",
    "title": "맛있는 스콘 만들기",
    "level": 18,
    "tags": [
      "다이나믹 프로그래밍",
      "자료 구조",
      "덱",
      "덱을 이용한 구간 최댓값 트릭",
      "덱을 이용한 다이나믹 프로그래밍"
    ],
    "description": "도현이는 SCON 참가자들에게 나눠줄 간식으로 스콘을 만들기로 했다.매 시각마다 스콘이 가장 맛있게 구워지는 최적의 온도가 존재한다는 사실을 알고 있는 도현이는 시각 $0$부터 시작하여 시각 $N-1$까지 오븐의 온도를 총 $N$번 조절하여 스콘을 굽기로 했다.스콘을 만드는 데 사용할 오븐은 $1$부터 $M$까지의 정수 온도로 조절이 가능하다. 각 시각마다 한 번만 오븐의 온도를 조절할 수 있는데, 시각 $0$에서는 자유롭게 오븐의 온도를 조절할 수 있지만, 다른 시각에서는 기존 온도에서 $C$의 정수 배만큼만 온도를 높이거나 낮출 수 있다. 또, 한 번에 $D$를 초과해서 온도를 높이거나 낮출 수 없다. 예를 들어, 시각 $t$에서 오븐의 온도를 $182$로 조절했고, $C=5,D=10$일 경우, 시각 $t+1$에서 조절 가능한 온도는 $172,177,182,187,192$뿐이다.시각 $t$에서의 최적의 온도를 $b_t$, 시각 $t$에서 조절한 오븐의 온도를 $k_t$라고 하면 시각 $t+1$에서 스콘의 맛은 $M-|b_t-k_t|$만큼 증가한다.시각 $0$부터 시각 $N-1$까지의 최적의 온도가 주어졌을 때, 시각 $N$에 완성되는 스콘의 맛의 최댓값을 구해보자. 처음 스콘을 오븐에 넣었을 때의 시각은 $0$이며, 스콘의 맛은 $0$이다. 모든 시각은 정수 시각만 고려한다.",
    "input_description": "첫째 줄에 네 정수 $N,M,C,D$가 공백으로 구분되어 주어진다.둘째 줄에 각 시각의 최적의 온도를 의미하는 $N$개의 정수 $b_0,b_1,...,b_{N-1}$이 주어진다.",
    "output_description": "시각 $N$에 완성되는 스콘의 맛의 최댓값을 출력한다.",
    "examples": [
      {
        "input": "3 8 2 4\n3 7 1",
        "output": "22"
      },
      {
        "input": "3 8 2 4\n8 3 2",
        "output": "23"
      }
    ],
    "url": "https://www.acmicpc.net/problem/33918",
    "solutions": [
      {
        "solution_id": 1,
        "solution_name": "풀이 1",
        "solution_code": "# DP 문제 기본 구조\nN = int(input())\n# 입력 처리\ndata = []\nfor _ in range(N):\n    line = input().strip()\n    data.append(line)\n\n# DP 배열 초기화\ndp = {}\n\n# DP 계산\n# TODO: 점화식 구현\n\n# 결과 출력\nprint(0)",
        "logic_steps": [
          {
            "step_id": 1,
            "goal": "정수 입력 받기",
            "description": "N = int(input())로 입력을 처리합니다.",
            "code_pattern": "N = int(input())",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 2,
            "goal": "입력 받기",
            "description": "data = input()로 입력을 처리합니다.",
            "code_pattern": "data = input()",
            "socratic_hint": "입력을 받으려면 어떤 함수를 사용하나요?",
            "hint": "input() 함수를 사용합니다."
          },
          {
            "step_id": 3,
            "goal": "반복 처리",
            "description": "반복문을 사용하여 작업을 수행합니다.",
            "code_pattern": "for _ in range(N):",
            "socratic_hint": "같은 작업을 여러 번 수행하려면?",
            "hint": "for 또는 while 반복문을 사용합니다."
          },
          {
            "step_id": 4,
            "goal": "결과 출력",
            "description": "계산된 결과를 출력합니다.",
            "code_pattern": "print(data)",
            "socratic_hint": "결과를 화면에 보여주려면?",
            "hint": "print() 함수를 사용합니다."
          }
        ]
      }
    ]
  }
]