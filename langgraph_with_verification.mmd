%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#4a90d9', 'primaryTextColor': '#000', 'primaryBorderColor': '#2d5986', 'lineColor': '#5c5c5c', 'secondaryColor': '#f0f0f0', 'tertiaryColor': '#fff'}, 'flowchart': {'nodeSpacing': 30, 'rankSpacing': 50}}}%%

flowchart TD
    %% ==================== ì¢Œì¸¡ ìƒë‹¨ ë²”ë¡€ ====================
    subgraph LEGEND1["ğŸ¯ Solution Matching í•µì‹¬ ì² í•™"]
        L1["âŒ ì‚¬ìš©ì ì½”ë“œë¥¼ 'í‹€ë ¸ë‹¤'ê³  í•˜ì§€<br/>ì•ŠìŒ"]
        L2["âœ… ì‚¬ìš©ìì˜ í˜„ì¬ ë°©ì‹ ì¡´ì¤‘"]
        L3["âœ… 'ë‹¤ìŒ ë‹¨ê³„' ì•ˆë‚´ ë°©ì‹"]
        L4["âœ… solution_code ê¸°ë°˜<br/>code_example"]
    end

    subgraph LEGEND2["ğŸ“‹ ë¶„ê¸° ì¡°ê±´"]
        B_A["A: ì½”ë“œ ì—†ìŒ/ë¬¸ë²• ì˜¤ë¥˜"]
        B_B["B: completion + í…ŒìŠ¤íŠ¸ ë¯¸í†µê³¼"]
        B_C["C: completion + ì²« í†µê³¼"]
        B_D["D: optimization + í…ŒìŠ¤íŠ¸ ë¯¸í†µê³¼"]
        B_E1["E1: ë³„ íšë“"]
        B_E2["E2: í’ˆì§ˆ ê°œì„  í•„ìš”"]
        B_F["F: ìµœì  ë‹¬ì„±"]
    end

    subgraph LEGEND3["ğŸ” Solution Matching ì•Œê³ ë¦¬ì¦˜"]
        SM1["ğŸ“Š ì½”ë“œ ìœ ì‚¬ë„ (60%)<br/>difflib.SequenceMatcher"]
        SM2["ğŸ“Š íŒ¨í„´ ìœ ì‚¬ë„ (40%)<br/>ì…ë ¥ë°©ì‹/ìë£Œêµ¬ì¡°/ì•Œê³ ë¦¬ì¦˜"]
        SM3["â†’ ê°€ì¥ ìœ ì‚¬í•œ ì†”ë£¨ì…˜ ì„ íƒ"]
    end

    subgraph LEGEND4["ğŸ”¬ LLM ìê¸°ê²€ì¦ ê¸°ì¤€"]
        V1["ğŸ“Š ë ˆë²¨ë³„ ìƒì„¸ë„ ì í•©ì„±"]
        V2["ğŸ“Š ì½”ë“œ ë…¸ì¶œ ìˆ˜ì¤€ ê²€ì¦"]
        V3["ğŸ“Š ê·œì¹™ ì¤€ìˆ˜ ì—¬ë¶€"]
        V4["â†’ ë¶€ì í•© ì‹œ ì¬ìƒì„±"]
    end

    %% ==================== ë©”ì¸ í”Œë¡œìš° ====================
    subgraph INPUT_STAGE["ğŸ”µ ì…ë ¥ ë‹¨ê³„"]
        START(["â–¶ START"])
        INPUT["ğŸ  input_node<br/>ì…ë ¥ ê²€ì¦ & ë¬¸ì œ ë¡œë“œ<br/>(title, description, solutions)"]
        START --> INPUT
    end

    subgraph MATCH_STAGE[" "]
        SOLUTION["ğŸ” solution_match_node<br/>ì‚¬ìš©ì ì½”ë“œì™€<br/>ê°€ì¥ ìœ ì‚¬í•œ ì†”ë£¨ì…˜ ë§¤ì¹­"]
        INPUT --> SOLUTION
    end

    subgraph PURPOSE_STAGE[" "]
        PURPOSE["ğŸ¯ purpose_node<br/>ë³„ì  ì¡°íšŒ & ëª©ì  ê²°ì •<br/>(completion/optimization/optimal)"]
        SOLUTION --> PURPOSE
    end

    subgraph PARALLEL_STAGE["ğŸŸ¢ ë³‘ë ¬ë¶„ì„ ë‹¨ê³„"]
        PARALLEL["âš¡ parallel_analysis_node<br/>(ThreadPoolExecutor)"]
        PURPOSE --> PARALLEL

        subgraph STATIC_BOX["ì •ì  ë¶„ì„"]
            STATIC["ğŸ“Š static_analysis<br/>ì •ì  ë©”íŠ¸ë¦­ 6ê°œ<br/>- syntax_errors<br/>- test_pass_rate<br/>- execution_time<br/>- memory_usage<br/>- code_quality_score<br/>- pep8_violations"]
        end

        subgraph LLM_BOX["LLM í‰ê°€"]
            LLM_EVAL["ğŸ¤– llm_eval<br/>LLM ë©”íŠ¸ë¦­ 6ê°œ<br/>- algorithm_efficiency<br/>- code_readability<br/>- edge_case_handling<br/>- code_conciseness<br/>- test_coverage_estimate<br/>- security_awareness"]
        end

        PARALLEL --> STATIC
        PARALLEL --> LLM_EVAL
        STATIC --> MERGE["ğŸ“¦ ê²°ê³¼ ë³‘í•©"]
        LLM_EVAL --> MERGE
    end

    subgraph BRANCH_STAGE["ğŸŸ  ë¶„ê¸° ê²°ì • ë‹¨ê³„"]
        BRANCH["ğŸ”€ branch_node<br/>ë¶„ê¸° ê²°ì • (A~F)"]
        MERGE --> BRANCH

        SKIP_CHECK{"â“ should_skip_coh<br/>A, C, E1 ë¶„ê¸°?"}
        BRANCH --> SKIP_CHECK
    end

    subgraph COH_STAGE["ğŸŸ¢ COH ê³„ì‚° ë‹¨ê³„"]
        COH_CHECK["ğŸ“Š coh_check_node<br/>COH ê¹Šì´ ê³„ì‚°<br/>(code_hash ë¹„êµ)"]
        COH_LEVEL["ğŸ“ˆ coh_level_node<br/>íŒíŠ¸ ë ˆë²¨ ê³„ì‚° (1-9)<br/>base_level - coh_depth"]
        COMPONENT["ğŸ§© component_filter_node<br/>êµ¬ì„±ìš”ì†Œ í•„í„°ë§"]

        SKIP_CHECK -->|"continue<br/>B, D, E2, F"| COH_CHECK
        COH_CHECK --> COH_LEVEL
        COH_LEVEL --> COMPONENT
    end

    subgraph LLM_STAGE["ğŸŸ¢ LLM íŒíŠ¸ ìƒì„±"]
        PROMPT["ğŸ“ prompt_node<br/>í”„ë¡¬í”„íŠ¸ êµ¬ì„±<br/>(COH ë ˆë²¨ + ë§¤ì¹­ëœ ì†”ë£¨ì…˜ ë°˜ì˜)"]
        RULE1["âœ… 'í‹€ë ¸ë‹¤' â†’ 'ë‹¤ìŒ ë‹¨ê³„' ì•ˆë‚´"]
        RULE2["âœ… í•™ìƒ ì½”ë“œ ìŠ¤íƒ€ì¼ ì¡´ì¤‘"]
        LLM_HINT["ğŸ¤– llm_hint_node<br/>GPT-4.1 íŒíŠ¸ ìƒì„±<br/>(solution_code ì°¸ê³ )"]

        COMPONENT --> PROMPT
        PROMPT --> RULE1
        RULE1 --> RULE2
        RULE2 --> LLM_HINT
    end

    subgraph VERIFY_STAGE["ğŸ”´ LLM ìê¸°ê²€ì¦ ë‹¨ê³„ (NEW!)"]
        VERIFY{"ğŸ”¬ verify_hint_node<br/>LLM ê¸°ë°˜ ê²€ì¦<br/>(ìƒì„¸ë„/ì í•©ì„± íŒë‹¨)"}
        FEEDBACK["ğŸ“‹ feedback_node<br/>í”¼ë“œë°± ìƒì„±<br/>(êµ¬ì²´ì  ìˆ˜ì • ì§€ì¹¨)"]

        LLM_HINT --> VERIFY
        VERIFY -->|"âŒ ë¶€ì í•©<br/>(ë„ˆë¬´ ìƒì„¸/ì¶”ìƒ)"| FEEDBACK
        FEEDBACK -->|"ì¬ìƒì„± ë£¨í”„<br/>(max 2íšŒ)"| PROMPT
    end

    subgraph FORMAT_STAGE[" "]
        FORMAT["âœ¨ format_node<br/>íŒíŠ¸ í¬ë§·íŒ…"]
        VERIFY -->|"âœ… ì í•©<br/>(ìƒì„¸ë„ ì ì ˆ)"| FORMAT
    end

    subgraph SKIP_STAGE["ğŸŸ¡ COH & LLM ìŠ¤í‚µ ê²½ë¡œ"]
        SKIP_LLM["ğŸ’¬ skip_llm_node<br/>ì •ì  íŒíŠ¸ ë°˜í™˜<br/>(COH & LLM ìŠ¤í‚µ)"]
        SKIP_CHECK -->|"skip<br/>A, C, E1"| SKIP_LLM
    end

    subgraph SAVE_STAGE["ğŸŸ¢ ì €ì¥ ë‹¨ê³„"]
        SAVE["ğŸ’¾ save_node<br/>DB ì €ì¥<br/>(code_hash, hint_branch,<br/>coh_depth, retry_count)"]
        END_NODE(["â–  END"])

        FORMAT --> SAVE
        SKIP_LLM --> SAVE
        SAVE --> END_NODE
    end

    %% ==================== ìŠ¤íƒ€ì¼ë§ ====================
    classDef startEnd fill:#4a90d9,stroke:#2d5986,color:white,stroke-width:2px
    classDef inputNode fill:#fff3cd,stroke:#ffc107,color:#000,stroke-width:2px
    classDef analysisNode fill:#d4edda,stroke:#28a745,color:#000,stroke-width:2px
    classDef branchNode fill:#ffe0b2,stroke:#ff9800,color:#000,stroke-width:2px
    classDef cohNode fill:#e8f5e9,stroke:#4caf50,color:#000,stroke-width:2px
    classDef llmNode fill:#fce4ec,stroke:#e91e63,color:#000,stroke-width:2px
    classDef verifyNode fill:#ffcdd2,stroke:#f44336,color:#000,stroke-width:3px
    classDef skipNode fill:#fff9c4,stroke:#ffeb3b,color:#000,stroke-width:2px
    classDef saveNode fill:#e3f2fd,stroke:#2196f3,color:#000,stroke-width:2px
    classDef decisionNode fill:#fff3e0,stroke:#ff9800,color:#000,stroke-width:2px
    classDef legendBox fill:#fffde7,stroke:#fbc02d,color:#000,stroke-width:1px
    classDef ruleNode fill:#e8f5e9,stroke:#4caf50,color:#000,stroke-width:1px

    class START,END_NODE startEnd
    class INPUT,SOLUTION,PURPOSE inputNode
    class PARALLEL,STATIC,LLM_EVAL,MERGE analysisNode
    class BRANCH branchNode
    class SKIP_CHECK,VERIFY decisionNode
    class COH_CHECK,COH_LEVEL,COMPONENT cohNode
    class PROMPT,LLM_HINT llmNode
    class FEEDBACK verifyNode
    class FORMAT saveNode
    class SKIP_LLM skipNode
    class SAVE saveNode
    class L1,L2,L3,L4,B_A,B_B,B_C,B_D,B_E1,B_E2,B_F,SM1,SM2,SM3,V1,V2,V3,V4 legendBox
    class RULE1,RULE2 ruleNode
