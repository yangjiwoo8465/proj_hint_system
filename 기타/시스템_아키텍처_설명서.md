# P[AI] 시스템 아키텍처 완전 설명서

이 문서는 P[AI] 코딩 테스트 플랫폼이 어떻게 만들어졌는지, 어떤 기술들이 사용되었는지, 그 기술들이 서로 어떻게 연결되어 작동하는지를 초등학생도 이해할 수 있도록 설명합니다.

---

## 목차

1. [웹사이트는 어떻게 작동하나요?](#1-웹사이트는-어떻게-작동하나요)
2. [P[AI]의 전체 구조](#2-pai의-전체-구조)
3. [프론트엔드 기술 상세 설명](#3-프론트엔드-기술-상세-설명)
4. [백엔드 기술 상세 설명](#4-백엔드-기술-상세-설명)
5. [데이터베이스 상세 설명](#5-데이터베이스-상세-설명)
6. [Docker 상세 설명](#6-docker-상세-설명)
7. [기술들의 상호작용](#7-기술들의-상호작용)
8. [실제 작동 예시](#8-실제-작동-예시)

---

## 1. 웹사이트는 어떻게 작동하나요?

### 기본 개념

웹사이트를 사용할 때, 우리 눈에는 하나의 화면만 보이지만 실제로는 여러 프로그램이 함께 일하고 있습니다.

**예를 들어 네이버에 접속할 때:**

1. 내가 주소창에 "naver.com"을 입력합니다
2. 내 컴퓨터(브라우저)가 네이버 서버에 "화면 보여줘"라고 요청합니다
3. 네이버 서버가 화면을 만들어서 보내줍니다
4. 내 브라우저가 받은 정보를 화면에 그립니다

이것을 **클라이언트-서버 구조**라고 합니다.

- **클라이언트**: 요청하는 쪽 (내 컴퓨터, 브라우저)
- **서버**: 요청을 받아서 처리하는 쪽 (네이버 컴퓨터)

### 웹사이트의 3가지 구성 요소

모든 웹사이트는 크게 3가지로 나뉩니다:

| 구성 요소 | 역할 | P[AI]에서 |
|----------|------|----------|
| **프론트엔드** | 사용자가 보는 화면 | React |
| **백엔드** | 데이터 처리, 계산 | Django |
| **데이터베이스** | 데이터 저장 | MySQL |

---

## 2. P[AI]의 전체 구조

### 시스템 구성도

```
사용자가 브라우저에서 P[AI] 접속
              │
              ▼
┌─────────────────────────────┐
│      Nginx (문지기)         │
│  - 누가 어디로 가야 하는지  │
│    알려주는 역할            │
└──────────┬──────────────────┘
           │
     ┌─────┴─────┐
     │           │
     ▼           ▼
┌─────────┐ ┌─────────────┐
│React    │ │Django       │
│(화면)   │ │(처리)       │
└─────────┘ └──────┬──────┘
                   │
          ┌────────┼────────┐
          │        │        │
          ▼        ▼        ▼
     ┌───────┐ ┌───────┐ ┌───────┐
     │MySQL  │ │Chroma │ │AI     │
     │(저장) │ │DB     │ │모델   │
     └───────┘ └───────┘ └───────┘
```

### 각 기술의 한 줄 설명

- **React**: 예쁜 화면을 만드는 도구
- **Django**: 요청을 받아서 처리하는 서버
- **MySQL**: 데이터를 저장하는 창고
- **ChromaDB**: 문서를 빨리 찾아주는 검색 엔진
- **Nginx**: 요청을 올바른 곳으로 안내하는 문지기
- **Docker**: 모든 프로그램을 한꺼번에 실행시키는 도구
- **AI 모델**: 힌트를 만들어주는 인공지능

---

## 3. 프론트엔드 기술 상세 설명

프론트엔드는 사용자가 보는 화면을 담당합니다.

### 3.1 React (리액트)

#### React가 뭔가요?

React는 **화면을 만드는 도구**입니다. Facebook(지금의 Meta)에서 만들었습니다.

#### 왜 React를 사용하나요?

**일반 HTML로 만들면:**
```html
<div id="counter">0</div>
<button onclick="increase()">+1</button>

<script>
  let count = 0;
  function increase() {
    count = count + 1;
    document.getElementById('counter').innerText = count;
  }
</script>
```

**React로 만들면:**
```jsx
function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <div>{count}</div>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  );
}
```

**React의 장점:**
1. **컴포넌트**: 화면을 작은 조각으로 나눠서 만듭니다. 레고 블록처럼 조립할 수 있습니다.
2. **자동 업데이트**: 데이터가 바뀌면 화면이 자동으로 바뀝니다.
3. **재사용**: 한 번 만든 버튼을 여러 곳에서 사용할 수 있습니다.

#### P[AI]에서 React가 하는 일

- 메인 페이지의 P[AI] 로고 표시
- 문제 목록을 카드 형태로 보여주기
- 코드 편집기 화면 구성
- 마이페이지 통계 그래프 그리기

---

### 3.2 Vite (비트)

#### Vite가 뭔가요?

Vite는 **React를 빠르게 실행시켜주는 도구**입니다.

#### 왜 필요한가요?

React 코드는 브라우저가 바로 이해하지 못합니다.
- React 코드 → 변환 → 브라우저가 이해하는 코드

이 변환 작업을 해주는 게 Vite입니다.

**Vite의 장점:**
- 코드를 수정하면 0.1초 만에 화면에 반영됩니다
- 서버 시작이 빠릅니다 (1초 이내)

#### P[AI]에서 Vite가 하는 일

- `npm run dev` 명령어로 개발 서버 시작
- 코드 수정하면 바로 화면에 반영
- 최종 배포용 파일 생성 (`npm run build`)

---

### 3.3 Redux Toolkit (리덕스 툴킷)

#### Redux가 뭔가요?

Redux는 **여러 화면이 같은 데이터를 공유**할 수 있게 해주는 도구입니다.

#### 왜 필요한가요?

**문제 상황:**
- 로그인 화면에서 로그인 성공
- 메인 화면에서도 "로그인됨"을 알아야 함
- 마이페이지에서도 내 정보를 알아야 함

**Redux 없이:**
```
로그인 화면 → 메인 화면에 전달 → 마이페이지에 전달 → ...
(복잡하고 실수하기 쉬움)
```

**Redux 사용:**
```
          ┌─────────────┐
          │ Redux Store │
          │ (중앙 저장소)│
          └──────┬──────┘
     ┌───────────┼───────────┐
     │           │           │
     ▼           ▼           ▼
  로그인      메인화면    마이페이지
  (저장)      (읽기)      (읽기)
```

모든 화면이 중앙 저장소에서 데이터를 읽고 씁니다.

#### P[AI]에서 Redux가 저장하는 것들

```javascript
{
  auth: {
    isAuthenticated: true,      // 로그인 했는지
    user: {
      id: 1,
      username: 'kim123',
      rating: 150
    },
    tokens: {
      access: 'eyJ...',         // 로그인 토큰
      refresh: 'eyJ...'
    }
  },
  codingTest: {
    currentProblem: {...},      // 지금 풀고 있는 문제
    userCode: 'print("hello")', // 작성 중인 코드
  }
}
```

---

### 3.4 React Router (리액트 라우터)

#### React Router가 뭔가요?

React Router는 **주소에 따라 다른 화면을 보여주는 도구**입니다.

#### 왜 필요한가요?

웹사이트에는 여러 페이지가 있습니다:
- `/` → 메인 화면
- `/login` → 로그인 화면
- `/problems` → 문제 목록

React Router가 주소를 보고 알맞은 화면을 보여줍니다.

#### P[AI]의 주소 구조

```javascript
// App.jsx
<Routes>
  <Route path="/" element={<MainPage />} />
  <Route path="/login" element={<Login />} />
  <Route path="/signup" element={<Signup />} />
  <Route path="/app/problems" element={<Problems />} />
  <Route path="/app/coding-test/:id" element={<CodingTest />} />
  <Route path="/app/chatbot" element={<Chatbot />} />
  <Route path="/app/mypage" element={<MyPage />} />
  <Route path="/app/roadmap" element={<Roadmap />} />
  <Route path="/app/admin" element={<AdminPanel />} />
</Routes>
```

---

### 3.5 Axios (악시오스)

#### Axios가 뭔가요?

Axios는 **프론트엔드가 백엔드와 대화하는 도구**입니다.

#### 어떻게 대화하나요?

프론트엔드는 백엔드에게 데이터를 요청하거나 보낼 수 있습니다.

**요청 종류:**
- **GET**: "데이터 줘" (문제 목록 가져오기)
- **POST**: "이거 처리해줘" (로그인, 코드 실행)
- **PUT**: "이거 수정해줘" (프로필 수정)
- **DELETE**: "이거 삭제해줘" (계정 삭제)

#### 사용 예시

```javascript
// 문제 목록 가져오기
const response = await axios.get('/api/v1/coding-test/problems/');
const problems = response.data;

// 로그인
const response = await axios.post('/api/v1/auth/login/', {
  username: 'kim123',
  password: 'mypassword'
});
const token = response.data.tokens.access;

// 코드 실행
const response = await axios.post('/api/v1/coding-test/execute/', {
  problem_id: 1001,
  code: 'print("Hello")'
});
const result = response.data.output;
```

#### P[AI]의 Axios 설정

```javascript
// frontend/src/services/api.js

// 기본 주소 설정
const api = axios.create({
  baseURL: 'http://192.168.0.4:8000/api/v1',
  timeout: 30000  // 30초 기다림
});

// 요청할 때마다 자동으로 토큰 추가
api.interceptors.request.use((config) => {
  const token = localStorage.getItem('accessToken');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});
```

---

### 3.6 Monaco Editor (모나코 에디터)

#### Monaco Editor가 뭔가요?

Monaco Editor는 **VS Code와 똑같은 코드 편집기**입니다.

Microsoft가 VS Code를 만들 때 사용한 편집기를 웹에서도 쓸 수 있게 공개했습니다.

#### 왜 사용하나요?

일반 텍스트 입력창(`<textarea>`)과 비교:

| 기능 | 일반 입력창 | Monaco Editor |
|------|------------|---------------|
| 문법 강조 | X | O (색깔로 구분) |
| 자동 완성 | X | O |
| 줄 번호 | X | O |
| 오류 표시 | X | O |
| 코드 접기 | X | O |

#### P[AI]에서 사용하는 곳

코딩 테스트 페이지의 오른쪽 코드 작성 영역

```jsx
// CodingTest/index.jsx
import Editor from '@monaco-editor/react';

<Editor
  height="500px"
  language="python"
  value={code}
  onChange={(value) => setCode(value)}
  theme="vs-dark"
/>
```

---

### 3.7 Recharts (리차트)

#### Recharts가 뭔가요?

Recharts는 **React에서 차트를 그리는 도구**입니다.

#### P[AI]에서 사용하는 곳

마이페이지의 방사형 그래프 (나의 코딩 지표)

```jsx
// MyPage/index.jsx
import { RadarChart, Radar, PolarGrid } from 'recharts';

<RadarChart data={[
  { subject: '코드 유사도', value: 75 },
  { subject: '문법 정확도', value: 90 },
  { subject: '논리 정확도', value: 60 },
  { subject: '개념 이해도', value: 80 }
]}>
  <PolarGrid />
  <Radar dataKey="value" fill="#667eea" />
</RadarChart>
```

---

### 3.8 CSS (스타일)

#### CSS가 뭔가요?

CSS는 **화면의 디자인을 정하는 언어**입니다.

- 색깔
- 크기
- 위치
- 간격
- 글꼴

#### 사용 예시

```css
/* MainPage.css */

.hero-title {
  font-size: 8rem;        /* 글자 크기 */
  font-weight: bold;      /* 글자 굵기 */
  color: white;           /* 글자 색 */
  letter-spacing: 0.5rem; /* 글자 간격 */
}

.start-btn {
  padding: 1.5rem 4rem;   /* 안쪽 여백 */
  background-color: white; /* 배경색 */
  border-radius: 50px;    /* 둥근 모서리 */
}

.start-btn:hover {        /* 마우스 올렸을 때 */
  transform: scale(1.1);  /* 10% 크게 */
}
```

---

## 4. 백엔드 기술 상세 설명

백엔드는 실제 작업을 처리하는 서버입니다.

### 4.1 Django (장고)

#### Django가 뭔가요?

Django는 **Python으로 웹 서버를 만드는 도구**입니다.

#### 웹 서버란?

웹 서버는 요청을 받아서 처리하고 응답을 보내는 프로그램입니다.

```
브라우저: "1001번 문제 정보 줘"
     │
     ▼
Django 서버: 데이터베이스에서 1001번 문제 찾기
     │
     ▼
브라우저: 문제 정보 받아서 화면에 표시
```

#### Django의 구조

Django는 **MTV 패턴**을 사용합니다:

- **M (Model)**: 데이터 구조 정의
- **T (Template)**: 화면 (우리는 React 사용)
- **V (View)**: 요청 처리 로직

#### P[AI]의 Django 앱 구조

```
backend/apps/
├── authentication/   # 로그인, 회원가입
├── coding_test/      # 문제, 제출, 힌트
├── chatbot/          # RAG 챗봇
├── mypage/           # 마이페이지
└── admin_panel/      # 관리자
```

---

### 4.2 Django REST Framework (DRF)

#### REST API가 뭔가요?

REST API는 **데이터를 주고받는 규칙**입니다.

- URL로 무엇을 원하는지 표현
- HTTP 메서드로 어떤 작업인지 표현
- JSON으로 데이터를 주고받음

**예시:**
```
GET /api/v1/problems/        → 문제 목록 조회
GET /api/v1/problems/1001/   → 1001번 문제 조회
POST /api/v1/problems/       → 새 문제 생성
PUT /api/v1/problems/1001/   → 1001번 문제 수정
DELETE /api/v1/problems/1001/ → 1001번 문제 삭제
```

#### JSON이 뭔가요?

JSON은 데이터를 표현하는 형식입니다.

```json
{
  "problem_id": 1001,
  "title": "두 수의 합",
  "level": 1,
  "tags": ["수학", "기초"]
}
```

#### DRF가 하는 일

Django에서 REST API를 쉽게 만들 수 있게 도와줍니다.

```python
# views.py
from rest_framework.decorators import api_view
from rest_framework.response import Response

@api_view(['GET'])
def get_problems(request):
    problems = Problem.objects.all()
    return Response({
        'success': True,
        'data': problems
    })
```

---

### 4.3 JWT (JSON Web Token)

#### JWT가 뭔가요?

JWT는 **로그인 상태를 유지하는 토큰**입니다.

#### 왜 필요한가요?

웹사이트는 기본적으로 "기억력이 없습니다". 페이지를 이동할 때마다 누가 접속했는지 잊어버립니다.

**JWT 없이:**
```
1. 로그인 성공
2. 문제 페이지 이동
3. 서버: "너 누구야?" (다시 로그인해야 함)
```

**JWT 사용:**
```
1. 로그인 성공 → 토큰 받음
2. 문제 페이지 이동 → 토큰 함께 전송
3. 서버: 토큰 확인 → "아, kim123이구나"
```

#### JWT의 구조

JWT는 3부분으로 나뉩니다:

```
eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoxfQ.abc123
   [헤더]          .    [내용]      . [서명]
```

- **헤더**: 토큰 종류
- **내용**: 사용자 정보 (user_id: 1)
- **서명**: 위조 방지

#### P[AI]의 JWT 설정

```python
# settings.py
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(hours=1),   # 1시간
    'REFRESH_TOKEN_LIFETIME': timedelta(days=7),   # 7일
}
```

**토큰 종류:**
- **Access Token**: API 요청할 때 사용 (1시간)
- **Refresh Token**: Access Token 재발급용 (7일)

---

### 4.4 Gunicorn (구니콘)

#### Gunicorn이 뭔가요?

Gunicorn은 **Django를 실제 서비스용으로 실행시키는 도구**입니다.

#### 왜 필요한가요?

Django 개발 서버(`python manage.py runserver`)는:
- 한 번에 하나의 요청만 처리
- 보안이 약함
- 느림

Gunicorn은:
- 여러 요청을 동시에 처리
- 안정적
- 빠름

```bash
# 개발용
python manage.py runserver

# 실제 서비스용
gunicorn config.wsgi:application --workers 4
```

`--workers 4`는 4개의 Django를 동시에 실행한다는 의미입니다.

---

### 4.5 Python 코드 실행 엔진

#### 어떻게 사용자 코드를 실행하나요?

P[AI]에서 사용자가 코드를 작성하고 "실행" 버튼을 누르면, 서버에서 그 코드를 실행합니다.

**파일**: `backend/apps/coding_test/code_executor.py`

```python
import subprocess
import tempfile

def execute_python(code, input_data):
    # 1. 임시 파일 생성
    with tempfile.NamedTemporaryFile(suffix='.py', delete=False) as f:
        f.write(code.encode())
        temp_file = f.name

    # 2. subprocess로 실행
    result = subprocess.run(
        ['python', temp_file],
        input=input_data,
        capture_output=True,
        timeout=10,
        text=True
    )

    # 3. 결과 반환
    return {
        'stdout': result.stdout,
        'stderr': result.stderr,
        'success': result.returncode == 0
    }
```

#### 보안 장치

사용자가 악의적인 코드를 실행할 수 있으므로 보안이 중요합니다:

1. **타임아웃**: 10초 초과하면 강제 종료
2. **출력 제한**: 5000자까지만 표시
3. **격리 실행**: subprocess로 분리해서 실행

---

## 5. 데이터베이스 상세 설명

### 5.1 MySQL

#### 데이터베이스가 뭔가요?

데이터베이스는 **데이터를 저장하는 창고**입니다.

엑셀 파일을 생각하면 됩니다:
- 여러 개의 시트 = 여러 개의 테이블
- 각 행 = 하나의 데이터
- 각 열 = 데이터의 속성

#### MySQL을 선택한 이유

- 무료
- 안정적
- 많이 사용됨 (자료가 많음)
- Django와 잘 연동됨

#### P[AI]의 주요 테이블

**1. User (사용자)**
```
┌────┬──────────┬─────────────┬────────┬────────┐
│ id │ username │ email       │ rating │ solved │
├────┼──────────┼─────────────┼────────┼────────┤
│ 1  │ kim123   │ kim@mail.com│ 150    │ 10     │
│ 2  │ lee456   │ lee@mail.com│ 200    │ 15     │
└────┴──────────┴─────────────┴────────┴────────┘
```

**2. Problem (문제)**
```
┌────────────┬───────────────┬───────┬─────────────┐
│ problem_id │ title         │ level │ tags        │
├────────────┼───────────────┼───────┼─────────────┤
│ 1001       │ 두 수의 합    │ 1     │ 수학,기초   │
│ 1002       │ 문자열 뒤집기 │ 1     │ 문자열      │
└────────────┴───────────────┴───────┴─────────────┘
```

**3. Submission (제출)**
```
┌────┬─────────┬────────────┬─────────┬────────┐
│ id │ user_id │ problem_id │ result  │ rating │
├────┼─────────┼────────────┼─────────┼────────┤
│ 1  │ 1       │ 1001       │ success │ 10     │
│ 2  │ 1       │ 1002       │ failure │ 0      │
└────┴─────────┴────────────┴─────────┴────────┘
```

#### 테이블 간의 관계

```
User (1) ───< Submission (다)
  │              │
  │              │
  │              ▼
  │         Problem (1)
  │              │
  └──────< HintMetrics (다)
```

- 한 명의 사용자는 여러 개의 제출을 할 수 있음
- 한 문제에 여러 개의 제출이 있을 수 있음
- 한 명의 사용자는 여러 개의 힌트 지표를 가질 수 있음

---

### 5.2 ChromaDB

#### ChromaDB가 뭔가요?

ChromaDB는 **문서를 빠르게 찾아주는 특수 데이터베이스**입니다.

일반 데이터베이스와 다른 점:
- 일반 DB: 정확한 값으로 검색 ("제목이 '파이썬'인 것")
- ChromaDB: 의미가 비슷한 것을 검색 ("파이썬 리스트 정렬" → 관련 문서들)

#### 어떻게 작동하나요?

**1단계: 문서를 숫자로 변환 (임베딩)**
```
"파이썬에서 리스트 정렬하기"
    ↓
[0.2, -0.5, 0.8, 0.1, ...] (768개의 숫자)
```

**2단계: 숫자들을 저장**

**3단계: 검색할 때**
```
"리스트를 순서대로 정리하는 방법"
    ↓
[0.3, -0.4, 0.7, 0.2, ...] (768개의 숫자)
    ↓
비슷한 숫자를 가진 문서 찾기
    ↓
"파이썬에서 리스트 정렬하기" 문서 반환
```

#### P[AI]에서 사용하는 곳

RAG 챗봇에서 Python, Git 문서 검색

---

## 6. Docker 상세 설명

### 6.1 Docker가 뭔가요?

Docker는 **프로그램을 실행하는 가상 환경**입니다.

#### 왜 필요한가요?

**문제 상황:**
```
개발자 A: "내 컴퓨터에서는 잘 되는데?"
개발자 B: "내 컴퓨터에서는 에러나요"
```

이유:
- Python 버전이 다름
- 설치된 라이브러리가 다름
- 운영체제가 다름

**Docker 사용:**
```
개발자 A: Docker 컨테이너에서 실행
개발자 B: 같은 Docker 컨테이너에서 실행
→ 결과가 똑같음
```

#### Docker의 개념

- **이미지**: 프로그램 실행에 필요한 모든 것을 담은 패키지
- **컨테이너**: 이미지를 실행한 것 (실제로 돌아가는 프로그램)

집으로 비유하면:
- 이미지 = 집의 설계도
- 컨테이너 = 설계도로 지은 실제 집

---

### 6.2 Docker Compose

#### Docker Compose가 뭔가요?

Docker Compose는 **여러 컨테이너를 한 번에 관리하는 도구**입니다.

P[AI]는 4개의 컨테이너가 필요합니다:
- MySQL (데이터베이스)
- Django (백엔드)
- React (프론트엔드)
- Nginx (웹 서버)

이걸 하나씩 실행하면:
```bash
docker run mysql ...
docker run django ...
docker run react ...
docker run nginx ...
```

Docker Compose를 사용하면:
```bash
docker compose up
```

한 줄로 모든 컨테이너가 실행됩니다.

#### docker-compose.yml 파일

```yaml
services:
  # 데이터베이스
  db:
    image: mysql:8.0
    ports:
      - "3307:3306"
    environment:
      MYSQL_DATABASE: hint_system
      MYSQL_USER: hint_user
      MYSQL_PASSWORD: HintSystem2024!

  # 백엔드
  backend:
    build: ./backend
    ports:
      - "8000:8000"
    depends_on:
      - db

  # 프론트엔드
  frontend:
    build: ./frontend
    ports:
      - "3000:3000"

  # 웹 서버
  nginx:
    build: ./nginx
    ports:
      - "80:80"
```

---

### 6.3 Nginx (엔진엑스)

#### Nginx가 뭔가요?

Nginx는 **요청을 올바른 서버로 전달하는 문지기**입니다.

#### 왜 필요한가요?

사용자는 하나의 주소(`p-ai.com`)로 접속하지만, 실제로는:
- 화면 요청 → React 서버
- API 요청 → Django 서버

Nginx가 요청을 보고 적절한 곳으로 전달합니다.

```
사용자 요청: p-ai.com/
    → Nginx: "화면 요청이네" → React

사용자 요청: p-ai.com/api/problems/
    → Nginx: "API 요청이네" → Django
```

#### Nginx 설정

```nginx
# nginx/nginx.conf

# 일반 요청 → React
location / {
    proxy_pass http://frontend:3000;
}

# API 요청 → Django
location /api/ {
    proxy_pass http://backend:8000;
}
```

---

## 7. 기술들의 상호작용

### 7.1 사용자가 문제를 푸는 과정

```
┌─────────────────────────────────────────────────────────┐
│ 1. 사용자가 브라우저에서 문제 페이지 접속                │
│    http://p-ai.com/app/coding-test/1001                 │
└────────────────────────┬────────────────────────────────┘
                         ▼
┌─────────────────────────────────────────────────────────┐
│ 2. Nginx가 요청 받음                                     │
│    - 주소 확인: /app/coding-test/1001                    │
│    - 결정: 화면 요청 → React로 전달                      │
└────────────────────────┬────────────────────────────────┘
                         ▼
┌─────────────────────────────────────────────────────────┐
│ 3. React가 화면 구성                                     │
│    - CodingTest 컴포넌트 렌더링                          │
│    - 문제 정보 필요 → Axios로 API 요청                   │
│    - GET /api/v1/coding-test/problems/1001/              │
└────────────────────────┬────────────────────────────────┘
                         ▼
┌─────────────────────────────────────────────────────────┐
│ 4. Nginx가 API 요청 받음                                 │
│    - 주소 확인: /api/...                                 │
│    - 결정: API 요청 → Django로 전달                      │
└────────────────────────┬────────────────────────────────┘
                         ▼
┌─────────────────────────────────────────────────────────┐
│ 5. Django가 요청 처리                                    │
│    - JWT 토큰 확인 (로그인 여부)                         │
│    - MySQL에서 1001번 문제 정보 조회                     │
│    - JSON 형태로 응답                                    │
└────────────────────────┬────────────────────────────────┘
                         ▼
┌─────────────────────────────────────────────────────────┐
│ 6. React가 데이터 받아서 화면에 표시                     │
│    - 문제 제목, 설명, 예제 표시                          │
│    - Monaco Editor로 코드 편집기 표시                    │
└─────────────────────────────────────────────────────────┘
```

### 7.2 사용자가 코드를 실행하는 과정

```
┌─────────────────────────────────────────────────────────┐
│ 1. 사용자가 코드 작성 후 "실행" 버튼 클릭                │
│    print("Hello, World!")                               │
└────────────────────────┬────────────────────────────────┘
                         ▼
┌─────────────────────────────────────────────────────────┐
│ 2. React가 Axios로 API 요청                              │
│    POST /api/v1/coding-test/execute/                    │
│    { problem_id: 1001, code: 'print("Hello")' }         │
└────────────────────────┬────────────────────────────────┘
                         ▼
┌─────────────────────────────────────────────────────────┐
│ 3. Django가 요청 처리                                    │
│    - code_executor.py 호출                               │
│    - 임시 파일에 코드 저장                               │
│    - subprocess로 Python 실행                            │
│    - 결과 수집                                           │
└────────────────────────┬────────────────────────────────┘
                         ▼
┌─────────────────────────────────────────────────────────┐
│ 4. Django가 결과 응답                                    │
│    {                                                     │
│      "success": true,                                    │
│      "output": "Hello, World!\n"                         │
│    }                                                     │
└────────────────────────┬────────────────────────────────┘
                         ▼
┌─────────────────────────────────────────────────────────┐
│ 5. React가 결과를 화면에 표시                            │
│    실행 결과 영역에 "Hello, World!" 표시                 │
└─────────────────────────────────────────────────────────┘
```

### 7.3 사용자가 힌트를 요청하는 과정

```
┌─────────────────────────────────────────────────────────┐
│ 1. 사용자가 "힌트" 버튼 클릭                             │
└────────────────────────┬────────────────────────────────┘
                         ▼
┌─────────────────────────────────────────────────────────┐
│ 2. React가 Axios로 API 요청                              │
│    POST /api/v1/coding-test/hints/                      │
│    { problem_id: 1001, code: '...', hint_level: 1 }     │
└────────────────────────┬────────────────────────────────┘
                         ▼
┌─────────────────────────────────────────────────────────┐
│ 3. Django가 요청 처리 (hint_api.py)                      │
│    - 이전 힌트 요청 확인 (HintMetrics 조회)              │
│    - 코드 분석 (code_analyzer.py)                        │
│      - 코드 유사도 계산                                   │
│      - 문법 오류 확인                                     │
│      - 논리 오류 확인                                     │
│      - 개념 이해도 평가                                   │
│    - 2회차 이상이면 약점 분석                             │
└────────────────────────┬────────────────────────────────┘
                         ▼
┌─────────────────────────────────────────────────────────┐
│ 4. AI 모델 호출                                          │
│    - 프롬프트 생성 (문제 + 코드 + 약점)                  │
│    - Hugging Face API 호출                               │
│    - AI가 힌트 생성                                      │
└────────────────────────┬────────────────────────────────┘
                         ▼
┌─────────────────────────────────────────────────────────┐
│ 5. Django가 지표 저장                                    │
│    - HintMetrics 테이블에 저장                           │
│      (다음 힌트 요청 때 약점 분석에 사용)                │
└────────────────────────┬────────────────────────────────┘
                         ▼
┌─────────────────────────────────────────────────────────┐
│ 6. React가 힌트를 화면에 표시                            │
│    힌트 영역에 AI가 생성한 힌트 표시                     │
└─────────────────────────────────────────────────────────┘
```

### 7.4 로그인 과정

```
┌─────────────────────────────────────────────────────────┐
│ 1. 사용자가 아이디, 비밀번호 입력 후 "로그인" 버튼       │
└────────────────────────┬────────────────────────────────┘
                         ▼
┌─────────────────────────────────────────────────────────┐
│ 2. React가 Axios로 API 요청                              │
│    POST /api/v1/auth/login/                             │
│    { username: 'kim123', password: '1234' }             │
└────────────────────────┬────────────────────────────────┘
                         ▼
┌─────────────────────────────────────────────────────────┐
│ 3. Django가 요청 처리                                    │
│    - MySQL에서 사용자 찾기                               │
│    - 비밀번호 확인                                       │
│    - JWT 토큰 생성 (Access + Refresh)                    │
└────────────────────────┬────────────────────────────────┘
                         ▼
┌─────────────────────────────────────────────────────────┐
│ 4. React가 토큰 저장                                     │
│    - Redux store에 저장 (화면에서 사용)                  │
│    - localStorage에 저장 (브라우저 껐다 켜도 유지)       │
└────────────────────────┬────────────────────────────────┘
                         ▼
┌─────────────────────────────────────────────────────────┐
│ 5. 이후 모든 API 요청에 토큰 포함                        │
│    Authorization: Bearer eyJ...                         │
└─────────────────────────────────────────────────────────┘
```

---

## 8. 실제 작동 예시

### 8.1 전체 시스템 시작하기

```bash
# 1. 프로젝트 폴더로 이동
cd 5th-project_mvp

# 2. Docker Compose로 모든 컨테이너 시작
docker compose up -d

# 3. 확인
docker compose ps
```

결과:
```
NAME                  STATUS
hint_system_db        running (healthy)
hint_system_backend   running
hint_system_frontend  running
hint_system_nginx     running
```

### 8.2 브라우저에서 접속

1. 브라우저에서 `http://localhost` 접속
2. Nginx가 받아서 React로 전달
3. 메인 페이지 표시

### 8.3 로그 확인

```bash
# 백엔드 로그
docker compose logs -f backend

# 프론트엔드 로그
docker compose logs -f frontend

# 전체 로그
docker compose logs -f
```

### 8.4 데이터베이스 접속

```bash
# MySQL 컨테이너에 접속
docker compose exec db mysql -u hint_user -p hint_system

# 비밀번호 입력: HintSystem2024!
```

```sql
-- 사용자 목록 보기
SELECT * FROM users;

-- 문제 개수 확인
SELECT COUNT(*) FROM problems;

-- 제출 기록 보기
SELECT * FROM submissions ORDER BY created_at DESC LIMIT 10;
```

---

## 마무리

### 기술 스택 요약

| 분류 | 기술 | 역할 |
|------|------|------|
| **프론트엔드** | React | 화면 구성 |
| | Vite | 빠른 개발 환경 |
| | Redux | 상태 관리 |
| | React Router | 페이지 이동 |
| | Axios | API 통신 |
| | Monaco Editor | 코드 편집기 |
| | Recharts | 차트/그래프 |
| | CSS | 디자인 |
| **백엔드** | Django | 웹 서버 |
| | DRF | REST API |
| | JWT | 로그인 유지 |
| | Gunicorn | 프로덕션 서버 |
| | PyTorch | AI 모델 실행 |
| **데이터베이스** | MySQL | 데이터 저장 |
| | ChromaDB | 문서 검색 |
| **인프라** | Docker | 가상 환경 |
| | Docker Compose | 컨테이너 관리 |
| | Nginx | 요청 분배 |

### 데이터 흐름

```
사용자 → 브라우저 → Nginx → React/Django → MySQL/ChromaDB
```

### 이 문서를 읽고 나면

1. 웹사이트가 어떻게 작동하는지 이해할 수 있습니다
2. 각 기술이 무엇이고 왜 사용하는지 알 수 있습니다
3. 기술들이 어떻게 연결되어 작동하는지 알 수 있습니다
4. 코드를 수정하거나 새 기능을 추가할 때 어디를 봐야 하는지 알 수 있습니다

질문이 있으면 언제든지 물어보세요!
