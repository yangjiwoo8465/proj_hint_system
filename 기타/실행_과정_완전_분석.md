# 프로젝트 실행 과정 완전 분석 - 초상세 기술 문서

> 이 문서는 현재 프로젝트의 코드를 기반으로 Docker부터 프론트엔드, 백엔드, 데이터베이스까지
> **모든 실행 과정을 극도로 상세하게** 분석한 기술 문서입니다.

---

## 목차

### Part 1: 통합 흐름 (서로를 넘나드는 과정)
1. [전체 시스템 부팅 과정](#1-전체-시스템-부팅-과정)
2. [사용자 로그인 요청의 완전한 여정](#2-사용자-로그인-요청의-완전한-여정)
3. [코드 실행 요청의 완전한 여정](#3-코드-실행-요청의-완전한-여정)

### Part 2: 개별 상세 (각 컴포넌트 내부 동작)
4. [Docker 컨테이너 생명주기 상세 분석](#4-docker-컨테이너-생명주기-상세-분석)
5. [프론트엔드 내부 동작 상세 분석](#5-프론트엔드-내부-동작-상세-분석)
6. [백엔드 내부 동작 상세 분석](#6-백엔드-내부-동작-상세-분석)
7. [데이터베이스 연결 및 쿼리 처리 과정](#7-데이터베이스-연결-및-쿼리-처리-과정)

---

# Part 1: 통합 흐름

## 1. 전체 시스템 부팅 과정

### 1.1 docker-compose up --build 명령어 실행 시 일어나는 일

#### 단계 1: Docker Compose 초기화 (0-2초)

```
사용자 입력: docker-compose up --build
    ↓
Docker Compose 프로세스 시작
    ↓
docker-compose.yml 파일 파싱
```

**상세 내용:**

1. **파일 읽기**
   - 현재 디렉토리에서 `docker-compose.yml` 검색
   - YAML 문법 검증
   - 환경 변수 파일 `.env` 로드

2. **환경 변수 치환**
   ```yaml
   # docker-compose.yml에서
   MYSQL_DATABASE: ${DB_NAME}

   # .env에서 읽어옴
   DB_NAME=hint_system

   # 최종 결과
   MYSQL_DATABASE: hint_system
   ```

3. **서비스 의존성 그래프 생성**
   ```
   nginx → backend → db
       ↘ frontend ↗
   ```

4. **볼륨 및 네트워크 체크**
   - `mysql_data` 볼륨 존재 여부 확인
   - `hint_network` 네트워크 존재 여부 확인
   - 없으면 생성 준비

---

#### 단계 2: 네트워크 생성 (2-3초)

```
Docker 네트워크 드라이버 초기화
    ↓
Bridge 네트워크 생성
    ↓
hint_network (172.18.0.0/16 대역)
```

**상세 내용:**

1. **Bridge 네트워크 생성**
   ```bash
   # Docker가 실행하는 내부 명령
   docker network create \
     --driver bridge \
     --subnet 172.18.0.0/16 \
     --gateway 172.18.0.1 \
     5th-project_mvp_hint_network
   ```

2. **가상 인터페이스 생성**
   - Linux: `br-<network_id>` 인터페이스 생성
   - Windows: Hyper-V 가상 스위치 생성
   - 각 컨테이너는 이 네트워크의 가상 NIC 할당받음

3. **DNS 서버 설정**
   - Docker 내부 DNS: `127.0.0.11:53`
   - 컨테이너 이름 → IP 매핑 준비
   ```
   db       → 172.18.0.2
   backend  → 172.18.0.3
   frontend → 172.18.0.4
   nginx    → 172.18.0.5
   ```

---

#### 단계 3: 볼륨 생성 (3-4초)

```
볼륨 드라이버 초기화
    ↓
3개의 Named Volume 생성
```

**상세 내용:**

1. **mysql_data 볼륨**
   ```bash
   # Windows 경로 예시
   C:\ProgramData\Docker\volumes\5th-project_mvp_mysql_data\_data\
   ```
   - 용도: MySQL 데이터 파일 영구 저장
   - 크기: 처음엔 거의 0MB, 데이터 쌓이면 증가

2. **static_volume 볼륨**
   ```bash
   C:\ProgramData\Docker\volumes\5th-project_mvp_static_volume\_data\
   ```
   - 용도: Django 정적 파일 (CSS, JS)
   - Django의 `collectstatic` 명령어로 수집

3. **media_volume 볼륨**
   ```bash
   C:\ProgramData\Docker\volumes\5th-project_mvp_media_volume\_data\
   ```
   - 용도: 사용자 업로드 파일

---

#### 단계 4: 이미지 빌드 - db 서비스 (4-10초)

```
MySQL 이미지 다운로드 (처음 실행 시)
    ↓
mysql:8.0 이미지 pull
```

**상세 내용:**

1. **이미지 레이어 다운로드**
   ```
   Layer 1: 기본 OS (Ubuntu 22.04 minimal)  - 30MB
   Layer 2: MySQL 바이너리                   - 150MB
   Layer 3: 설정 파일                        - 5MB
   Layer 4: 초기화 스크립트                  - 2MB
   ---
   전체: 약 187MB
   ```

2. **이미지 레이어 저장**
   - Docker 이미지 저장소에 레이어별로 저장
   - SHA256 해시로 식별
   - 이미 있으면 skip (Using cache)

---

#### 단계 5: 이미지 빌드 - backend 서비스 (10-60초)

```
backend/Dockerfile 읽기
    ↓
단계별 빌드 실행
```

**Dockerfile 빌드 과정 상세 분석:**

```dockerfile
FROM python:3.10-slim
```
**실행 내용:**
- Docker Hub에서 `python:3.10-slim` 이미지 pull
- 베이스 이미지 크기: 약 125MB
- Debian 11 기반 + Python 3.10.x

```dockerfile
WORKDIR /app
```
**실행 내용:**
- 컨테이너 내부에 `/app` 디렉토리 생성
- 이후 모든 명령은 `/app`에서 실행
- 실제 Linux 명령어: `mkdir -p /app && cd /app`

```dockerfile
RUN apt-get update && apt-get install -y \
    gcc \
    default-libmysqlclient-dev \
    pkg-config \
    && rm -rf /var/lib/apt/lists/*
```
**실행 내용 (초상세):**

1. `apt-get update`
   - Debian 패키지 저장소 목록 업데이트
   - `/var/lib/apt/lists/` 갱신
   - 약 3-5초 소요

2. `apt-get install gcc`
   - GNU C 컴파일러 설치
   - Python C 확장 모듈 컴파일용
   - 크기: 약 30MB

3. `apt-get install default-libmysqlclient-dev`
   - MySQL 클라이언트 개발 라이브러리
   - `mysqlclient` Python 패키지 컴파일용
   - 헤더 파일 포함
   - 크기: 약 10MB

4. `apt-get install pkg-config`
   - 라이브러리 컴파일 설정 도구
   - 크기: 약 2MB

5. `rm -rf /var/lib/apt/lists/*`
   - 패키지 목록 캐시 삭제
   - 이미지 크기 절약 (약 50MB 절약)

```dockerfile
COPY requirements.txt .
```
**실행 내용:**
- 호스트의 `backend/requirements.txt` → 컨테이너 `/app/requirements.txt`
- 파일 크기: 약 1KB
- MD5 체크섬으로 변경 감지

```dockerfile
RUN pip install --no-cache-dir -r requirements.txt
```
**실행 내용 (초상세):**

Python 패키지 43개 설치 과정:

1. **Django 5.0.1 설치**
   ```
   pip download Django==5.0.1
       ↓
   Wheel 파일 다운로드 (Django-5.0.1-py3-none-any.whl)
       ↓
   /usr/local/lib/python3.10/site-packages/django/ 에 압축 해제
       ↓
   의존성 체크 (asgiref, sqlparse, tzdata)
   ```

2. **djangorestframework 설치**
   ```
   pip download djangorestframework
       ↓
   Django 버전 호환성 체크
       ↓
   설치
   ```

3. **mysqlclient 설치** (중요!)
   ```
   pip download mysqlclient
       ↓
   소스 코드 다운로드 (.tar.gz)
       ↓
   C 컴파일러(gcc)로 컴파일
       ↓
   pkg-config로 MySQL 라이브러리 찾기
       ↓
   libmysqlclient.so 링크
       ↓
   .so 파일 생성
       ↓
   site-packages에 설치
   ```
   - 이 과정이 가장 오래 걸림 (10-20초)
   - gcc와 libmysqlclient-dev가 필요한 이유

4. **나머지 40개 패키지 설치**
   - PyTorch (ML 모델용) - 매우 큼 (500MB+)
   - Transformers (AI 모델용)
   - ChromaDB (벡터 DB)
   - 기타 유틸리티들

**전체 설치 시간:**
- 처음: 40-50초
- 캐시 있으면: 5-10초

```dockerfile
COPY . .
```
**실행 내용:**
- `backend/` 폴더의 모든 파일을 `/app/`로 복사
- `.dockerignore` 파일이 있으면 제외 항목 적용
- 복사되는 주요 디렉토리:
  ```
  /app/config/
  /app/apps/
  /app/common/
  /app/vectordb/
  /app/manage.py
  ```

```dockerfile
RUN mkdir -p logs
```
**실행 내용:**
- `/app/logs` 디렉토리 생성
- Gunicorn, Django 로그 저장용

```dockerfile
CMD ["gunicorn", "config.wsgi:application", "--bind", "0.0.0.0:8000", "--workers", "4"]
```
**설명:**
- 컨테이너 시작 시 실행될 기본 명령어 정의
- 실제 실행은 컨테이너 시작 시 (지금은 이미지 빌드만)

**최종 이미지 크기:**
- 베이스: 125MB
- 시스템 패키지: 42MB
- Python 패키지: 800MB (PyTorch 때문에 큼)
- 애플리케이션 코드: 50MB
- **총합: 약 1.0GB**

---

#### 단계 6: 이미지 빌드 - frontend 서비스 (60-90초)

```dockerfile
FROM node:18-alpine
```
**실행 내용:**
- Alpine Linux (5MB) + Node.js 18 (40MB)
- 전체 베이스 이미지: 약 45MB

```dockerfile
WORKDIR /app
```

```dockerfile
COPY package*.json ./
```
**실행 내용:**
- `package.json` (1KB)
- `package-lock.json` (100KB)
- npm 의존성 버전 잠금 정보

```dockerfile
RUN npm install
```
**실행 내용 (초상세):**

1. **npm 레지스트리 연결**
   ```
   https://registry.npmjs.org/ 연결
       ↓
   package.json 파싱
       ↓
   의존성 트리 계산
   ```

2. **React 설치**
   ```
   npm → react@18.2.0 다운로드
       ↓
   node_modules/react/ 생성
       ↓
   의존성: loose-envify, js-tokens
   ```

3. **Vite 설치**
   ```
   npm → vite@5.0.11
       ↓
   네이티브 모듈 (esbuild) 다운로드
       ↓
   플랫폼별 바이너리 (linux-x64)
   ```

4. **Monaco Editor 설치** (중요!)
   ```
   npm → monaco-editor@4.6.0
       ↓
   크기: 약 50MB (에디터 코어 + 언어 지원)
       ↓
   Python, JavaScript 등 문법 하이라이팅 파일들
   ```

5. **나머지 패키지**
   - Redux Toolkit
   - Axios
   - React Router
   - 기타 유틸리티

**node_modules 전체 크기: 약 300MB**

```dockerfile
COPY . .
```
**실행 내용:**
- `frontend/src/` 전체 복사
- `public/` 복사
- `vite.config.js`, `index.html` 등

```dockerfile
EXPOSE 3000
CMD ["npm", "run", "dev", "--", "--host"]
```

**최종 이미지 크기:**
- 베이스: 45MB
- node_modules: 300MB
- 소스 코드: 5MB
- **총합: 약 350MB**

---

#### 단계 7: 이미지 빌드 - nginx 서비스 (90-95초)

```dockerfile
FROM nginx:alpine
```
**실행 내용:**
- Alpine Linux + Nginx
- 크기: 약 23MB

```dockerfile
COPY nginx.conf /etc/nginx/conf.d/default.conf
```
**실행 내용:**
- `nginx/nginx.conf` → `/etc/nginx/conf.d/default.conf`
- Nginx 기본 설정 덮어쓰기

**최종 이미지 크기: 약 23MB**

---

#### 단계 8: 컨테이너 생성 및 시작 - db (95-100초)

```
이미지 준비 완료
    ↓
mysql:8.0 이미지로 컨테이너 생성
    ↓
hint_system_db 컨테이너 시작
```

**상세 과정:**

1. **컨테이너 파일 시스템 생성**
   ```
   이미지 레이어들 (읽기 전용)
       ↓
   새 쓰기 가능 레이어 생성 (Copy-on-Write)
       ↓
   Union File System 마운트
   ```

2. **네트워크 연결**
   ```
   veth 페어 생성 (가상 이더넷 케이블)
       ↓
   한쪽: 컨테이너 내부 (eth0)
   다른쪽: 호스트 브리지 (veth123abc)
       ↓
   IP 할당: 172.18.0.2
       ↓
   DNS 등록: db → 172.18.0.2
   ```

3. **볼륨 마운트**
   ```
   mysql_data 볼륨 → /var/lib/mysql (컨테이너 내부)
       ↓
   바인드 마운트 설정
   ```

4. **환경 변수 주입**
   ```bash
   MYSQL_ROOT_PASSWORD=HintSystem2024!
   MYSQL_DATABASE=hint_system
   MYSQL_USER=hint_user
   MYSQL_PASSWORD=HintSystem2024!
   ```

5. **MySQL 초기화 스크립트 실행**
   ```bash
   # 컨테이너 내부에서 실행
   /usr/local/bin/docker-entrypoint.sh mysqld
   ```

   **entrypoint.sh가 하는 일:**

   a. **데이터 디렉토리 확인**
      ```bash
      if [ ! -d "/var/lib/mysql/mysql" ]; then
        # 처음 실행 - 초기화 필요
        초기화 실행
      else
        # 이미 초기화됨 - skip
      fi
      ```

   b. **MySQL 시스템 테이블 초기화**
      ```bash
      mysqld --initialize-insecure --user=mysql --datadir=/var/lib/mysql
      ```
      - `mysql` 시스템 데이터베이스 생성
      - 권한 테이블 생성
      - 시간대 테이블 로드

   c. **임시 MySQL 서버 시작**
      ```bash
      mysqld --skip-networking --socket=/tmp/mysql_init.sock &
      ```
      - 네트워크 없이 로컬에서만 접속 가능
      - 초기 설정용

   d. **root 비밀번호 설정**
      ```sql
      mysql -uroot --socket=/tmp/mysql_init.sock <<EOF
      ALTER USER 'root'@'localhost' IDENTIFIED BY 'HintSystem2024!';
      CREATE USER 'root'@'%' IDENTIFIED BY 'HintSystem2024!';
      GRANT ALL ON *.* TO 'root'@'%' WITH GRANT OPTION;
      FLUSH PRIVILEGES;
      EOF
      ```

   e. **데이터베이스 생성**
      ```sql
      CREATE DATABASE IF NOT EXISTS hint_system
      CHARACTER SET utf8mb4
      COLLATE utf8mb4_unicode_ci;
      ```

   f. **일반 사용자 생성**
      ```sql
      CREATE USER 'hint_user'@'%' IDENTIFIED BY 'HintSystem2024!';
      GRANT ALL PRIVILEGES ON hint_system.* TO 'hint_user'@'%';
      FLUSH PRIVILEGES;
      ```

   g. **임시 서버 종료**
      ```bash
      mysqladmin -uroot -pHintSystem2024! shutdown
      ```

   h. **실제 MySQL 서버 시작**
      ```bash
      exec mysqld --user=mysql
      ```
      - `exec`: 현재 프로세스를 mysqld로 교체
      - PID 1으로 실행 (Docker 신호 처리용)

6. **포트 바인딩**
   ```
   호스트 3307번 → 컨테이너 3306번
   ```

7. **헬스체크 시작**
   ```bash
   # 20초마다 실행
   mysqladmin ping -h localhost
   ```

   **헬스체크 과정:**
   ```
   시도 1 (2초 후): unhealthy (아직 시작 중)
   시도 2 (4초 후): unhealthy
   시도 3 (6초 후): unhealthy
   시도 4 (8초 후): healthy! ✓
   ```

**MySQL 준비 완료까지 총 시간: 약 8-10초**

---

#### 단계 9: 컨테이너 시작 - backend (100-115초)

```
db 헬스체크 통과 대기 (depends_on)
    ↓
backend 컨테이너 생성 및 시작
```

**상세 과정:**

1. **컨테이너 생성**
   - 이미지: hint_system_backend (1.0GB)
   - IP: 172.18.0.3
   - DNS: backend → 172.18.0.3

2. **볼륨 마운트**
   ```
   호스트: ./backend/ → 컨테이너: /app/
   호스트: ./hint-system/ → 컨테이너: /app/hint-system/
   static_volume → /app/staticfiles/
   media_volume → /app/media/
   ```

3. **환경 변수 로드**
   ```bash
   # .env 파일 전체 로드
   DJANGO_SECRET_KEY=nredl*mr9%@...
   DEBUG=True
   DB_NAME=hint_system
   DB_USER=hint_user
   DB_PASSWORD=HintSystem2024!
   DB_HOST=db  ← 중요!
   DB_PORT=3306
   ```

4. **Gunicorn 시작**
   ```bash
   gunicorn config.wsgi:application \
     --bind 0.0.0.0:8000 \
     --workers 4 \
     --reload
   ```

   **Gunicorn 시작 과정 (초상세):**

   a. **마스터 프로세스 시작**
      ```
      PID 1: Gunicorn Master
          ↓
      설정 파싱
          ↓
      WSGI 애플리케이션 로드 준비
      ```

   b. **config.wsgi 모듈 import**
      ```python
      # config/wsgi.py
      import os
      from django.core.wsgi import get_wsgi_application

      os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
      application = get_wsgi_application()
      ```

   c. **Django 초기화**
      ```python
      # config/settings.py 실행

      1. load_dotenv()  # .env 로드
      2. INSTALLED_APPS 파싱
      3. MIDDLEWARE 설정
      4. DATABASE 설정
      ```

   d. **데이터베이스 연결 테스트**
      ```python
      # Django가 자동으로 실행
      connection = MySQLdb.connect(
          host='db',      # Docker DNS 해석
          port=3306,
          user='hint_user',
          passwd='HintSystem2024!',
          db='hint_system'
      )
      ```

      **DNS 해석 과정:**
      ```
      'db' 조회
          ↓
      Docker 내부 DNS (127.0.0.11)
          ↓
      hint_network의 'db' 컨테이너 검색
          ↓
      172.18.0.2 반환
          ↓
      TCP 연결 시도 172.18.0.2:3306
          ↓
      MySQL 핸드셰이크
          ↓
      인증 성공
      ```

   e. **워커 프로세스 4개 생성**
      ```
      Master (PID 1)
        ├─ Worker 1 (PID 7)
        ├─ Worker 2 (PID 8)
        ├─ Worker 3 (PID 9)
        └─ Worker 4 (PID 10)
      ```

      각 워커:
      - WSGI 애플리케이션 로드
      - 독립적인 Python 인터프리터
      - 독립적인 DB 커넥션 풀

   f. **소켓 바인딩**
      ```
      0.0.0.0:8000 포트 리스닝 시작
          ↓
      TCP 소켓 생성
          ↓
      backlog=2048 설정
      ```

5. **--reload 옵션 동작**
   ```python
   # 파일 감시 스레드 시작
   watch_dirs = ['/app']
   while True:
       for file in watch_dirs:
           if file.mtime != last_mtime:
               # 변경 감지!
               워커들 재시작
       time.sleep(1)
   ```

**Backend 준비 완료: 약 5-7초**

---

#### 단계 10: 컨테이너 시작 - frontend (115-125초)

**상세 과정:**

1. **컨테이너 생성**
   - IP: 172.18.0.4
   - DNS: frontend → 172.18.0.4

2. **볼륨 마운트**
   ```
   호스트: ./frontend/ → /app/
   단, /app/node_modules는 컨테이너 것 사용
   ```

3. **Vite 개발 서버 시작**
   ```bash
   npm run dev -- --host
   ```

   **npm run dev의 실제 명령어:**
   ```bash
   vite --host
   ```

   **Vite 시작 과정 (초상세):**

   a. **Vite 프로세스 시작**
      ```javascript
      // node_modules/vite/bin/vite.js
      import { createServer } from 'vite'

      const server = await createServer({
        configFile: 'vite.config.js'
      })
      ```

   b. **설정 파일 로드**
      ```javascript
      // vite.config.js
      export default defineConfig({
        plugins: [react()],
        resolve: {
          alias: { '@': './src', ... }
        },
        server: {
          host: '0.0.0.0',
          port: 3000,
          proxy: {
            '/api': {
              target: 'http://backend:8000'  ← 중요!
            }
          }
        }
      })
      ```

   c. **React 플러그인 초기화**
      ```javascript
      // @vitejs/plugin-react
      - Babel 변환 설정
      - Fast Refresh 설정
      - JSX 변환 준비
      ```

   d. **의존성 사전 번들링 (Pre-bundling)**
      ```
      node_modules 스캔
          ↓
      자주 사용되는 패키지 찾기 (react, react-dom 등)
          ↓
      esbuild로 사전 번들링
          ↓
      node_modules/.vite/deps/ 에 캐시
      ```
      - React: react.js → react.js (optimized)
      - React-DOM: react-dom.js → react-dom.js (optimized)
      - 첫 실행: 5-10초, 이후: 캐시 사용

   e. **HTTP 서버 시작**
      ```
      0.0.0.0:3000 리스닝
          ↓
      WebSocket 서버 시작 (HMR용)
          ↓
      ws://frontend:3000
      ```

   f. **파일 감시 시작**
      ```javascript
      // Chokidar (파일 감시 라이브러리)
      watcher.on('change', (path) => {
        // src/ 폴더 내 변경 감지
        if (path.endsWith('.jsx')) {
          // HMR 트리거
          ws.send({ type: 'update', path })
        }
      })
      ```

4. **준비 완료 메시지**
   ```
   VITE v5.0.11  ready in 500 ms

   ➜  Local:   http://localhost:3000/
   ➜  Network: http://172.18.0.4:3000/
   ```

**Frontend 준비 완료: 약 2-3초**

---

#### 단계 11: 컨테이너 시작 - nginx (125-127초)

**상세 과정:**

1. **컨테이너 생성**
   - IP: 172.18.0.5
   - DNS: nginx → 172.18.0.5

2. **설정 파일 로드**
   ```bash
   # nginx.conf 파싱
   nginx -t  # 문법 체크
   ```

3. **Upstream 서버 정의 해석**
   ```nginx
   upstream backend {
       server backend:8000;
   }
   ```

   **DNS 해석:**
   ```
   'backend' 조회
       ↓
   Docker DNS
       ↓
   172.18.0.3 반환
       ↓
   실제: 172.18.0.3:8000
   ```

4. **Nginx 마스터 프로세스 시작**
   ```
   PID 1: nginx master
       ↓
   Worker 프로세스 생성 (CPU 코어 수만큼)
       ├─ Worker 1
       └─ Worker 2
   ```

5. **80번 포트 리스닝**
   ```
   0.0.0.0:80 바인딩
       ↓
   준비 완료
   ```

**Nginx 준비 완료: 약 1-2초**

---

### 1.2 전체 시스템 준비 완료 상태

```
시간: 약 125-127초 (2분)

컨테이너 상태:
┌─────────────────────────────────────────────┐
│  hint_system_db        172.18.0.2:3306     │  ✓ healthy
│  hint_system_backend   172.18.0.3:8000     │  ✓ running
│  hint_system_frontend  172.18.0.4:3000     │  ✓ running
│  hint_system_nginx     172.18.0.5:80       │  ✓ running
└─────────────────────────────────────────────┘

포트 매핑:
호스트:3307 → db:3306
호스트:8000 → backend:8000
호스트:3000 → frontend:3000
호스트:80   → nginx:80
```

---

## 2. 사용자 로그인 요청의 완전한 여정

### 시나리오: 사용자가 이메일 `student@test.com`, 비밀번호 `1234`로 로그인

---

### 2.1 브라우저에서 시작 (0ms)

```
사용자: 브라우저 주소창에 http://localhost:3000 입력
```

**브라우저 내부 동작:**

1. **DNS 해석**
   ```
   'localhost' 조회
       ↓
   hosts 파일 확인 (C:\Windows\System32\drivers\etc\hosts)
       ↓
   127.0.0.1 반환
   ```

2. **TCP 연결**
   ```
   SYN → 127.0.0.1:3000
   SYN-ACK ← 127.0.0.1:3000
   ACK →
   ```

3. **HTTP 요청**
   ```http
   GET / HTTP/1.1
   Host: localhost:3000
   Connection: keep-alive
   User-Agent: Mozilla/5.0 ...
   Accept: text/html,application/xhtml+xml,...
   ```

---

### 2.2 요청이 Docker 네트워크로 (1ms)

**Windows Docker Desktop 내부:**

```
브라우저 (127.0.0.1:random)
    ↓
Windows TCP/IP Stack
    ↓
Docker Desktop (Hyper-V VM)
    ↓
포트 포워딩 규칙: 3000 → 172.18.0.4:3000
    ↓
frontend 컨테이너 (172.18.0.4:3000)
```

---

### 2.3 Vite 개발 서버가 요청 처리 (2-5ms)

**Vite 내부:**

```javascript
// Vite HTTP 서버
server.on('request', async (req, res) => {
  // 1. URL 파싱
  const url = new URL(req.url, 'http://localhost')
  // url.pathname = '/'

  // 2. 정적 파일 체크
  if (url.pathname === '/') {
    // index.html 반환
    const html = await fs.readFile('./index.html', 'utf-8')

    // 3. HTML 변환 (HMR 주입)
    const transformed = html.replace(
      '</head>',
      '<script type="module" src="/@vite/client"></script></head>'
    )

    res.writeHead(200, { 'Content-Type': 'text/html' })
    res.end(transformed)
  }
})
```

**브라우저가 받는 HTML:**

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hint System</title>
    <script type="module" src="/@vite/client"></script>  ← HMR 클라이언트
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/index.jsx"></script>  ← 메인 스크립트
  </body>
</html>
```

---

### 2.4 브라우저가 추가 리소스 요청 (5-100ms)

```
브라우저 HTML 파싱
    ↓
리소스 발견
    ↓
병렬로 요청
```

**요청 1: `/@vite/client`**
```http
GET /@vite/client HTTP/1.1
Host: localhost:3000
```

Vite 응답:
```javascript
// HMR 클라이언트 코드
const socket = new WebSocket('ws://localhost:3000')
socket.onmessage = (event) => {
  const { type, path } = JSON.parse(event.data)
  if (type === 'update') {
    // 모듈 핫 리로드
    import(path + '?t=' + Date.now())
  }
}
```

**요청 2: `/src/index.jsx`**
```http
GET /src/index.jsx HTTP/1.1
```

**Vite의 On-Demand 변환:**
```javascript
// Vite 내부
async function transformModule(path) {
  // 1. 파일 읽기
  const code = await fs.readFile('./src/index.jsx', 'utf-8')

  // 2. Babel 변환 (JSX → JS)
  const transformed = await babel.transform(code, {
    plugins: ['@babel/plugin-transform-react-jsx']
  })

  // 3. Import 경로 해석
  // import React from 'react'
  // → import React from '/node_modules/.vite/deps/react.js'

  return transformed.code
}
```

**변환된 코드 예시:**
```javascript
// 원본: src/index.jsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'

// Vite가 변환한 코드
import React from '/node_modules/.vite/deps/react.js?v=abc123'
import ReactDOM from '/node_modules/.vite/deps/react-dom.js?v=abc123'
import App from '/src/App.jsx?v=abc123'

ReactDOM.createRoot(document.getElementById('root')).render(
  React.createElement(App, null)
)
```

---

### 2.5 React 앱 초기화 (100-200ms)

**브라우저 JavaScript 엔진:**

```javascript
// 1. React 라이브러리 로드
import React from '/node_modules/.vite/deps/react.js'
    ↓
React 코어 초기화
    ↓
Fiber 아키텍처 준비

// 2. React Router 초기화
import { BrowserRouter } from 'react-router-dom'
    ↓
History API 연결
    ↓
현재 URL 파싱 (/)

// 3. Redux Store 초기화
import { configureStore } from '@reduxjs/toolkit'
import authSlice from './store/authSlice'

const store = configureStore({
  reducer: {
    auth: authSlice,
    codingTest: codingTestSlice,
    chatbot: chatbotSlice
  }
})
    ↓
초기 상태 생성
{
  auth: {
    user: null,
    isAuthenticated: false,
    loading: false
  },
  ...
}

// 4. App 컴포넌트 렌더링
ReactDOM.createRoot(document.getElementById('root')).render(
  <Provider store={store}>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </Provider>
)
```

**React 렌더링 과정:**

```
가상 DOM 생성
    ↓
<App>
  <Routes>
    <Route path="/" element={<MainPage />} />  ← 매칭!
    <Route path="/login" element={<Login />} />
    ...
  </Routes>
</App>
    ↓
MainPage 컴포넌트 렌더링
    ↓
실제 DOM 업데이트
    ↓
화면에 표시
```

---

### 2.6 사용자가 로그인 버튼 클릭 (200ms~)

```
사용자: "로그인" 버튼 클릭
    ↓
브라우저: onClick 이벤트 발생
    ↓
React: 이벤트 핸들러 실행
```

**MainPage 컴포넌트:**
```javascript
// src/pages/MainPage/MainPage.jsx
function MainPage() {
  const navigate = useNavigate()

  const handleLoginClick = () => {
    navigate('/login')  // ← 실행됨
  }

  return (
    <button onClick={handleLoginClick}>로그인</button>
  )
}
```

**React Router 동작:**
```javascript
// navigate('/login') 호출 시
    ↓
History API 사용
window.history.pushState({}, '', '/login')
    ↓
URL 변경 (브라우저 주소창: http://localhost:3000/login)
    ↓
Router 컴포넌트 상태 업데이트
    ↓
새로운 매칭 경로 계산
    ↓
<Route path="/login" element={<Login />} /> 매칭!
    ↓
Login 컴포넌트 렌더링
```

---

### 2.7 로그인 페이지 렌더링 및 입력

**Login 컴포넌트 마운트:**
```javascript
// src/pages/Login/Login.jsx
function Login() {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const dispatch = useDispatch()

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      />
      <button type="submit">로그인</button>
    </form>
  )
}
```

**사용자 입력:**
```
입력: s
    ↓
onChange 이벤트
    ↓
setEmail('s')
    ↓
React 상태 업데이트
    ↓
컴포넌트 리렌더링 (input value="s")

... (이하 반복)

최종: email="student@test.com", password="1234"
```

---

### 2.8 로그인 폼 제출 (사용자가 "로그인" 버튼 클릭)

**이벤트 핸들러 실행:**
```javascript
const handleSubmit = async (e) => {
  e.preventDefault()  // 기본 폼 제출 방지

  // 1. Redux Thunk 액션 디스패치
  dispatch(loginUser({ email, password }))
}
```

**Redux Thunk 액션 (authSlice.js):**
```javascript
// src/store/authSlice.js
export const loginUser = createAsyncThunk(
  'auth/login',
  async ({ email, password }) => {
    // API 호출
    const response = await api.post('/auth/login/', {
      email,
      password
    })
    return response.data
  }
)
```

---

### 2.9 Axios 요청 생성 및 전송

**api.post() 내부 (src/services/api.js):**

```javascript
// 1. Axios 인스턴스 설정 확인
const api = axios.create({
  baseURL: 'http://192.168.0.4:8000/api/v1',  ← 환경변수에서 로드
  timeout: 30000
})

// 2. Request 인터셉터 실행
api.interceptors.request.use((config) => {
  // localStorage에서 토큰 가져오기
  const token = localStorage.getItem('accessToken')
  // 첫 로그인이므로 token = null

  if (token) {
    config.headers.Authorization = `Bearer ${token}`
  }

  return config  // 토큰 없이 진행
})

// 3. HTTP 요청 생성
const request = {
  method: 'POST',
  url: 'http://192.168.0.4:8000/api/v1/auth/login/',
  headers: {
    'Content-Type': 'application/json'
  },
  data: {
    email: 'student@test.com',
    password: '1234'
  }
}
```

**실제 HTTP 요청:**
```http
POST /api/v1/auth/login/ HTTP/1.1
Host: 192.168.0.4:8000
Content-Type: application/json
Content-Length: 56

{"email":"student@test.com","password":"1234"}
```

---

### 2.10 요청이 네트워크를 타고 이동

**경로:**
```
브라우저 (localhost:3000)
    ↓
목적지: 192.168.0.4:8000
    ↓
Docker Desktop 네트워크 스택
    ↓
backend 컨테이너 (172.18.0.3:8000)
```

**TCP 패킷 전송:**
```
[Ethernet Frame]
  ├─ [IP Header]
  │   ├─ Source: 172.18.0.4 (frontend)
  │   └─ Destination: 172.18.0.3 (backend)
  └─ [TCP Segment]
      ├─ Source Port: 54321
      ├─ Dest Port: 8000
      └─ [HTTP Data]
          POST /api/v1/auth/login/ ...
```

---

### 2.11 Backend: Nginx가 요청 받음 (실제로는 직접 backend로)

> 주의: 현재 설정에서는 프론트엔드가 **직접 backend:8000**으로 요청하므로
> Nginx를 거치지 않습니다. (Nginx는 브라우저 → 프론트엔드 HTML만 처리)

하지만 만약 Nginx를 통한다면:
```nginx
# nginx.conf
location /api/ {
    proxy_pass http://backend:8000;  # backend로 프록시
}
```

---

### 2.12 Backend: Gunicorn이 요청 받음

**Gunicorn Worker 프로세스:**

```
TCP 연결 수락
    ↓
Worker 1 (PID 7)이 처리
    ↓
HTTP 요청 파싱
```

**WSGI 인터페이스:**
```python
# Gunicorn → Django
environ = {
    'REQUEST_METHOD': 'POST',
    'PATH_INFO': '/api/v1/auth/login/',
    'CONTENT_TYPE': 'application/json',
    'wsgi.input': <요청 본문>,
    'HTTP_HOST': '192.168.0.4:8000',
    ...
}

# WSGI 애플리케이션 호출
response = application(environ, start_response)
```

---

### 2.13 Backend: Django 미들웨어 체인

**settings.py의 MIDDLEWARE 순서대로 처리:**

```python
# 1. SecurityMiddleware
class SecurityMiddleware:
    def __call__(self, request):
        # HTTPS 체크, 보안 헤더 추가
        return self.get_response(request)

# 2. SessionMiddleware
class SessionMiddleware:
    def __call__(self, request):
        # 세션 ID 쿠키 확인
        # request.session 객체 생성
        return self.get_response(request)

# 3. CorsMiddleware
class CorsMiddleware:
    def __call__(self, request):
        # CORS 헤더 체크
        # OPTIONS 요청 처리
        return self.get_response(request)

# 4. CommonMiddleware
class CommonMiddleware:
    def __call__(self, request):
        # URL 정규화
        # Content-Length 체크
        return self.get_response(request)

# 5. CsrfViewMiddleware
class CsrfViewMiddleware:
    def __call__(self, request):
        # POST 요청인가?
        # 하지만 DRF는 자체 CSRF 처리 → Skip
        return self.get_response(request)

# 6. AuthenticationMiddleware
class AuthenticationMiddleware:
    def __call__(self, request):
        # request.user 설정
        # 아직 인증 전이므로 AnonymousUser
        request.user = AnonymousUser()
        return self.get_response(request)
```

---

### 2.14 Backend: URL 라우팅

**config/urls.py:**
```python
urlpatterns = [
    path('api/v1/auth/', include('apps.authentication.urls')),
    ...
]
```

URL 매칭:
```
요청: /api/v1/auth/login/
    ↓
'api/v1/auth/' 매칭
    ↓
apps.authentication.urls로 위임
```

**apps/authentication/urls.py:**
```python
urlpatterns = [
    path('login/', LoginView.as_view(), name='login'),
    ...
]
```

매칭:
```
남은 경로: login/
    ↓
'login/' 매칭
    ↓
LoginView 실행
```

---

### 2.15 Backend: LoginView 실행

**apps/authentication/views.py:**

```python
class LoginView(APIView):
    permission_classes = [AllowAny]  # 인증 불필요

    def post(self, request):
        # 1. 요청 데이터 파싱
        data = request.data
        # data = {'email': 'student@test.com', 'password': '1234'}

        # 2. Serializer로 유효성 검증
        serializer = LoginSerializer(data=data)
        if not serializer.is_valid():
            return Response({
                'success': False,
                'error': serializer.errors
            }, status=400)

        # 3. 데이터 추출
        email = serializer.validated_data['email']
        password = serializer.validated_data['password']

        # 4. 사용자 조회
        try:
            user = User.objects.get(email=email)
        except User.DoesNotExist:
            return Response({
                'success': False,
                'error': '존재하지 않는 사용자입니다'
            }, status=404)

        # 5. 비밀번호 검증
        if not user.check_password(password):
            return Response({
                'success': False,
                'error': '비밀번호가 틀렸습니다'
            }, status=401)

        # 6. JWT 토큰 생성
        refresh = RefreshToken.for_user(user)

        # 7. 응답
        return Response({
            'success': True,
            'data': {
                'access': str(refresh.access_token),
                'refresh': str(refresh),
                'user': UserSerializer(user).data
            }
        })
```

**각 단계 초상세 분석:**

---

**4단계: User.objects.get(email=email) - DB 쿼리**

```python
# Django ORM이 생성하는 SQL
SELECT * FROM authentication_user
WHERE email = 'student@test.com'
LIMIT 1;
```

**데이터베이스 연결 과정:**
```python
# Django DB 백엔드
connection = connections['default']
    ↓
# mysqlclient 라이브러리
conn = MySQLdb.connect(
    host='db',  # DNS: db → 172.18.0.2
    port=3306,
    user='hint_user',
    passwd='HintSystem2024!',
    db='hint_system',
    charset='utf8mb4'
)
```

**MySQL 서버 (db 컨테이너):**
```
1. TCP 연결 수락 (172.18.0.3:random → 172.18.0.2:3306)
2. MySQL 핸드셰이크
3. 인증 (hint_user / HintSystem2024!)
4. 쿼리 수신
5. 쿼리 파싱
   SELECT * FROM authentication_user WHERE email = ?
6. 쿼리 최적화
   - 인덱스 확인 (email에 UNIQUE 인덱스 있음)
   - B-Tree 인덱스 검색
7. 스토리지 엔진 (InnoDB)
   - 데이터 페이지 로드
   - /var/lib/mysql/hint_system/authentication_user.ibd
8. 레코드 반환
   {
     id: 1,
     email: 'student@test.com',
     password: 'pbkdf2_sha256$600000$...',  ← 해시된 비밀번호
     name: '홍길동',
     role: 'user',
     ...
   }
```

**Django ORM 객체 생성:**
```python
user = User(
    id=1,
    email='student@test.com',
    password='pbkdf2_sha256$600000$...',
    ...
)
```

---

**5단계: user.check_password('1234')**

```python
# Django의 비밀번호 검증
def check_password(raw_password):
    # DB에 저장된 해시
    stored = 'pbkdf2_sha256$600000$salt123$hash456'

    # 알고리즘 분석
    algorithm = 'pbkdf2_sha256'
    iterations = 600000
    salt = 'salt123'
    stored_hash = 'hash456'

    # 입력 비밀번호로 동일한 해시 생성
    new_hash = pbkdf2_sha256(
        password='1234',
        salt='salt123',
        iterations=600000
    )

    # 비교
    return new_hash == stored_hash
```

**PBKDF2 해시 계산 (CPU 집약적, 약 50-100ms):**
```
Round 1: hash = SHA256(salt + password)
Round 2: hash = SHA256(hash)
Round 3: hash = SHA256(hash)
...
Round 600000: hash = SHA256(hash)  ← 최종 해시
```

비밀번호 일치! ✓

---

**6단계: JWT 토큰 생성**

```python
from rest_framework_simplejwt.tokens import RefreshToken

refresh = RefreshToken.for_user(user)
```

**RefreshToken.for_user() 내부:**

```python
def for_user(cls, user):
    # 1. Refresh 토큰 생성
    token = cls()
    token['user_id'] = user.id
    token['email'] = user.email
    token['role'] = user.role

    # 2. 만료 시간 설정
    token['exp'] = datetime.now() + timedelta(days=7)
    token['iat'] = datetime.now()

    # 3. JWT 서명
    # Header
    header = {
        'typ': 'JWT',
        'alg': 'HS256'
    }

    # Payload
    payload = {
        'user_id': 1,
        'email': 'student@test.com',
        'role': 'user',
        'exp': 1735689600,  # Unix timestamp
        'iat': 1735084800
    }

    # Signature
    message = base64(header) + '.' + base64(payload)
    signature = HMAC_SHA256(
        message,
        secret_key='nredl*mr9%@d0a8czrz5...'
    )

    # 최종 토큰
    refresh_token = message + '.' + base64(signature)
    # eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoxLCJlbWFpbCI6InN0dWRlbnRAdGVzdC5jb20iLCJyb2xlIjoidXNlciIsImV4cCI6MTczNTY4OTYwMCwiaWF0IjoxNzM1MDg0ODAwfQ.abc123def456...

    return token
```

**Access 토큰 생성:**
```python
access_token = refresh.access_token

# 동일한 과정, 단 만료 시간 1시간
{
    'user_id': 1,
    'email': 'student@test.com',
    'role': 'user',
    'exp': datetime.now() + timedelta(hours=1),
    'iat': datetime.now()
}
```

---

**7단계: 응답 생성**

```python
response_data = {
    'success': True,
    'data': {
        'access': 'eyJ0eXAiOiJKV1QiLC...',  # Access 토큰
        'refresh': 'eyJ0eXAiOiJKV1QiLC...',  # Refresh 토큰
        'user': {
            'id': 1,
            'email': 'student@test.com',
            'name': '홍길동',
            'role': 'user',
            'rating': 0,
            'skill_score': 0.0
        }
    }
}

return Response(response_data, status=200)
```

---

### 2.16 Backend: Django Response → HTTP 응답

**Django DRF Response 처리:**

```python
# 1. Serialization
json_data = json.dumps(response_data)
# '{"success":true,"data":{...}}'

# 2. HTTP 응답 생성
http_response = HttpResponse(
    content=json_data,
    content_type='application/json',
    status=200
)

# 3. 헤더 추가
http_response['Content-Length'] = len(json_data)
http_response['Access-Control-Allow-Origin'] = '*'  # CORS
```

**역방향 미들웨어 체인:**
```
응답 생성
    ↓
AuthenticationMiddleware (응답 처리)
    ↓
CsrfViewMiddleware
    ↓
CommonMiddleware
    ↓
CorsMiddleware (CORS 헤더 추가)
    ↓
SessionMiddleware
    ↓
SecurityMiddleware
```

---

### 2.17 Backend: Gunicorn → 클라이언트

**Gunicorn:**
```python
# WSGI 응답 수신
status = '200 OK'
headers = [
    ('Content-Type', 'application/json'),
    ('Content-Length', '234'),
    ('Access-Control-Allow-Origin', '*')
]
body = b'{"success":true,...}'

# HTTP 응답 전송
worker.send_http_response(status, headers, body)
```

**실제 HTTP 응답:**
```http
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 234
Access-Control-Allow-Origin: *
Connection: keep-alive

{"success":true,"data":{"access":"eyJ0eXAi...","refresh":"eyJ0eXAi...","user":{...}}}
```

---

### 2.18 Frontend: Axios 응답 수신

**Response 인터셉터:**
```javascript
// src/services/api.js
api.interceptors.response.use(
  (response) => {
    // 성공 응답
    return response  // 그대로 반환
  },
  async (error) => {
    // 에러 처리 (401 등)
    // 지금은 200이므로 실행 안됨
  }
)
```

**Promise 해석:**
```javascript
// Redux Thunk에서
const response = await api.post('/auth/login/', { ... })
// response.data = { success: true, data: { access: '...', ... } }

return response.data  // Redux state로 반환
```

---

### 2.19 Frontend: Redux State 업데이트

**authSlice.js:**
```javascript
// Redux Toolkit이 자동 생성한 reducer
const loginUserReducer = {
  pending: (state) => {
    state.loading = true
  },
  fulfilled: (state, action) => {
    // action.payload = { success: true, data: { ... } }
    state.loading = false
    state.isAuthenticated = true
    state.user = action.payload.data.user
    state.token = action.payload.data.access
  },
  rejected: (state, action) => {
    state.loading = false
    state.error = action.error.message
  }
}

// fulfilled 실행!
state.auth = {
  user: {
    id: 1,
    email: 'student@test.com',
    name: '홍길동',
    ...
  },
  isAuthenticated: true,
  loading: false,
  token: 'eyJ0eXAi...'
}
```

**localStorage 저장:**
```javascript
// Login.jsx에서
useEffect(() => {
  if (isAuthenticated) {
    localStorage.setItem('accessToken', token)
    localStorage.setItem('refreshToken', refreshToken)

    // 페이지 이동
    navigate('/dashboard')
  }
}, [isAuthenticated])
```

---

### 2.20 Frontend: 대시보드 페이지로 이동

**React Router:**
```javascript
navigate('/dashboard')
    ↓
History API
window.history.pushState({}, '', '/dashboard')
    ↓
URL 변경
    ↓
Router 리렌더링
    ↓
<Route path="/dashboard" element={<Dashboard />} /> 매칭
    ↓
Dashboard 컴포넌트 렌더링
```

**Dashboard 컴포넌트:**
```javascript
function Dashboard() {
  const { user } = useSelector(state => state.auth)

  return (
    <div>
      <h1>환영합니다, {user.name}님!</h1>
      <p>점수: {user.rating}</p>
    </div>
  )
}
```

---

### 로그인 요청 전체 시간 분해

```
브라우저 입력 → Vite 서버         :  5ms
Vite → React 렌더링                : 100ms
사용자 입력                         : (가변)
폼 제출 → Axios 요청 생성          :  2ms
네트워크 전송 (frontend→backend)   :  1ms
Gunicorn 수신 → Django 미들웨어    :  3ms
Django URL 라우팅                  :  1ms
LoginView 실행                     :  2ms
DB 쿼리 (사용자 조회)              : 10ms
비밀번호 해시 검증                 : 80ms  ← 가장 오래 걸림
JWT 토큰 생성                      :  5ms
응답 생성 및 전송                  :  3ms
네트워크 전송 (backend→frontend)   :  1ms
Axios 응답 처리                    :  2ms
Redux 상태 업데이트                :  1ms
React 리렌더링 (Dashboard)         : 50ms
───────────────────────────────────────
총 시간                            : 약 266ms
```

---

## 3. 코드 실행 요청의 완전한 여정

### 시나리오: 사용자가 "두 수의 합" 문제 풀이 중 코드 실행

---

### 3.1 사용자가 Monaco Editor에 코드 작성

**CodingTest 페이지:**
```javascript
// src/pages/CodingTest/CodingTest.jsx
import Editor from '@monaco-editor/react'

function CodingTest() {
  const [code, setCode] = useState('')

  return (
    <Editor
      height="500px"
      language="python"
      theme="vs-dark"
      value={code}
      onChange={(newCode) => setCode(newCode)}
    />
  )
}
```

**Monaco Editor 내부 동작 (초상세):**

```javascript
// Monaco Editor 초기화
const editor = monaco.editor.create(domElement, {
  language: 'python',
  theme: 'vs-dark'
})

// Python 문법 하이라이팅
// node_modules/monaco-editor/esm/vs/basic-languages/python/python.js
const pythonLanguage = {
  keywords: ['def', 'class', 'if', 'else', 'for', 'while', ...],
  operators: ['+', '-', '*', '/', '=', '==', ...],

  tokenizer: {
    root: [
      [/[a-zA-Z_]\w*/, {
        cases: {
          '@keywords': 'keyword',
          '@default': 'identifier'
        }
      }],
      [/\d+/, 'number'],
      ...
    ]
  }
}
```

**사용자 타이핑:**
```python
# 사용자가 입력한 코드
a, b = map(int, input().split())
print(a + b)
```

**각 키 입력마다:**
```javascript
editor.onDidChangeModelContent((event) => {
  // 1. 변경 감지
  const newCode = editor.getValue()

  // 2. React 상태 업데이트
  setCode(newCode)

  // 3. 문법 하이라이팅 재계산
  monaco.editor.tokenize(newCode, 'python')

  // 4. 에디터 다시 렌더링
})
```

---

### 3.2 "코드 실행" 버튼 클릭

```javascript
function CodingTest() {
  const [code, setCode] = useState('...')
  const [problem, setProblem] = useState({ id: 1, ... })
  const [result, setResult] = useState(null)

  const handleRunCode = async () => {
    // 1. 로딩 상태
    setLoading(true)

    // 2. API 요청
    try {
      const response = await api.post('/coding-test/execute/', {
        problem_id: problem.id,
        code: code
      })

      // 3. 결과 표시
      setResult(response.data.data)
    } catch (error) {
      setError(error.message)
    } finally {
      setLoading(false)
    }
  }

  return (
    <>
      <Editor ... />
      <button onClick={handleRunCode}>코드 실행</button>
      {result && <ResultDisplay result={result} />}
    </>
  )
}
```

---

### 3.3 Axios 요청 생성

**Request 인터셉터:**
```javascript
// src/services/api.js
api.interceptors.request.use((config) => {
  // localStorage에서 토큰 가져오기
  const token = localStorage.getItem('accessToken')
  // token = 'eyJ0eXAi...' (로그인 후 저장됨)

  // Authorization 헤더 추가
  config.headers.Authorization = `Bearer ${token}`

  return config
})
```

**최종 HTTP 요청:**
```http
POST /api/v1/coding-test/execute/ HTTP/1.1
Host: 192.168.0.4:8000
Authorization: Bearer eyJ0eXAiOiJKV1QiLC...
Content-Type: application/json
Content-Length: 123

{
  "problem_id": 1,
  "code": "a, b = map(int, input().split())\nprint(a + b)"
}
```

---

### 3.4 Backend: Django JWT 인증

**JWT 인증 미들웨어:**
```python
# rest_framework_simplejwt
from rest_framework_simplejwt.authentication import JWTAuthentication

class JWTAuthentication:
    def authenticate(self, request):
        # 1. Authorization 헤더 파싱
        auth_header = request.META.get('HTTP_AUTHORIZATION')
        # 'Bearer eyJ0eXAi...'

        if not auth_header:
            return None

        # 2. 'Bearer ' 제거
        token = auth_header.split(' ')[1]
        # 'eyJ0eXAi...'

        # 3. 토큰 디코딩
        try:
            # Header, Payload, Signature 분리
            header_b64, payload_b64, signature_b64 = token.split('.')

            # Base64 디코딩
            header = json.loads(base64_decode(header_b64))
            payload = json.loads(base64_decode(payload_b64))

            # 4. 서명 검증
            message = header_b64 + '.' + payload_b64
            expected_signature = HMAC_SHA256(
                message,
                settings.SECRET_KEY
            )

            if signature_b64 != base64_encode(expected_signature):
                raise Exception('Invalid signature')

            # 5. 만료 시간 체크
            exp = payload['exp']  # Unix timestamp
            if datetime.fromtimestamp(exp) < datetime.now():
                raise Exception('Token expired')

            # 6. 사용자 조회
            user_id = payload['user_id']
            user = User.objects.get(id=user_id)

            # 7. request.user 설정
            return (user, token)

        except Exception as e:
            raise AuthenticationFailed('Invalid token')
```

**결과:**
```python
request.user = User(id=1, email='student@test.com', ...)
request.auth = 'eyJ0eXAi...'
```

---

### 3.5 Backend: CodeExecutionView 실행

**apps/coding_test/views.py:**

```python
class CodeExecutionView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        # 1. 요청 데이터
        problem_id = request.data.get('problem_id')  # 1
        code = request.data.get('code')  # 'a, b = ...'

        # 2. 문제 조회
        try:
            problem = Problem.objects.get(problem_id=problem_id)
        except Problem.DoesNotExist:
            return Response({
                'success': False,
                'error': '문제를 찾을 수 없습니다'
            }, status=404)

        # 3. 테스트 케이스 로드
        test_cases = problem.test_cases  # JSONField
        # [
        #   {"input": "1 2", "output": "3"},
        #   {"input": "5 7", "output": "12"},
        #   ...
        # ]

        # 4. 코드 실행
        from apps.coding_test.code_executor import execute_code

        results = []
        for i, test_case in enumerate(test_cases):
            result = execute_code(
                code=code,
                test_input=test_case['input'],
                timeout=5
            )

            results.append({
                'test_case': i + 1,
                'input': test_case['input'],
                'expected': test_case['output'],
                'actual': result['output'],
                'passed': result['output'].strip() == test_case['output'].strip(),
                'error': result.get('error'),
                'execution_time': result.get('time')
            })

        # 5. 응답
        all_passed = all(r['passed'] for r in results)

        return Response({
            'success': True,
            'data': {
                'results': results,
                'all_passed': all_passed
            }
        })
```

---

### 3.6 Backend: code_executor.py - 코드 실행 (핵심!)

**apps/coding_test/code_executor.py:**

```python
import subprocess
import tempfile
import os
import time

def execute_code(code, test_input, timeout=5):
    # 1. 임시 파일 생성
    with tempfile.NamedTemporaryFile(
        mode='w',
        suffix='.py',
        delete=False,
        encoding='utf-8'
    ) as f:
        f.write(code)
        temp_file = f.name
    # temp_file = '/tmp/tmpXYZ123.py'

    try:
        # 2. subprocess로 Python 실행
        start_time = time.time()

        process = subprocess.Popen(
            ['python', temp_file],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding='utf-8'
        )

        # 3. 입력 전달 및 실행
        try:
            stdout, stderr = process.communicate(
                input=test_input,
                timeout=timeout
            )

            end_time = time.time()
            execution_time = end_time - start_time

            # 4. 결과 반환
            return {
                'output': stdout,
                'error': stderr if stderr else None,
                'time': execution_time,
                'returncode': process.returncode
            }

        except subprocess.TimeoutExpired:
            # 5초 초과 - 프로세스 강제 종료
            process.kill()
            return {
                'output': '',
                'error': 'Execution timeout (5 seconds)',
                'time': 5.0,
                'returncode': -1
            }

    finally:
        # 5. 임시 파일 삭제
        if os.path.exists(temp_file):
            os.remove(temp_file)
```

**subprocess.Popen() 초상세 분석:**

```
1. 새 프로세스 생성
   ├─ fork() 시스템 콜 (Linux)
   │  또는 CreateProcess (Windows in Docker)
   ├─ PID 할당 (예: 1234)
   └─ 독립된 메모리 공간

2. Python 인터프리터 로드
   ├─ /usr/bin/python3.10 실행
   ├─ Python VM 초기화
   └─ sys, builtins 모듈 로드

3. 사용자 코드 실행
   ├─ /tmp/tmpXYZ123.py 읽기
   ├─ 바이트코드 컴파일
   │  a, b = map(int, input().split())
   │  print(a + b)
   └─ 실행

4. input() 함수 호출
   ├─ stdin에서 읽기 요청
   ├─ subprocess가 전달한 "1 2\n" 읽음
   └─ 반환: "1 2"

5. 계산
   ├─ "1 2".split() → ["1", "2"]
   ├─ map(int, ...) → [1, 2]
   ├─ a, b = 1, 2
   └─ a + b = 3

6. print(3)
   ├─ stdout에 쓰기
   └─ "3\n"

7. 프로그램 종료
   ├─ exit(0)
   └─ returncode = 0

8. subprocess.communicate()
   ├─ stdout 읽기: "3\n"
   ├─ stderr 읽기: "" (없음)
   └─ 반환
```

**실행 시간: 약 50-100ms**

---

### 3.7 Backend: 결과 집계 및 응답

```python
# 테스트 케이스 1
result_1 = {
    'test_case': 1,
    'input': '1 2',
    'expected': '3',
    'actual': '3',
    'passed': True,
    'error': None,
    'execution_time': 0.052
}

# 테스트 케이스 2
result_2 = {
    'test_case': 2,
    'input': '5 7',
    'expected': '12',
    'actual': '12',
    'passed': True,
    'error': None,
    'execution_time': 0.048
}

# 최종 응답
response = {
    'success': True,
    'data': {
        'results': [result_1, result_2],
        'all_passed': True
    }
}
```

---

### 3.8 Frontend: 결과 표시

**React 컴포넌트 업데이트:**
```javascript
const response = await api.post('/coding-test/execute/', ...)

setResult(response.data.data)
// result = {
//   results: [...],
//   all_passed: true
// }
```

**ResultDisplay 컴포넌트 렌더링:**
```javascript
function ResultDisplay({ result }) {
  return (
    <div>
      <h3>실행 결과</h3>
      {result.results.map((tc, i) => (
        <div key={i} className={tc.passed ? 'success' : 'fail'}>
          <p>테스트 케이스 {tc.test_case}</p>
          <p>입력: {tc.input}</p>
          <p>기대 출력: {tc.expected}</p>
          <p>실제 출력: {tc.actual}</p>
          <p>결과: {tc.passed ? '✓ 통과' : '✗ 실패'}</p>
          <p>실행 시간: {tc.execution_time}초</p>
        </div>
      ))}

      {result.all_passed && (
        <button onClick={handleSubmit}>제출하기</button>
      )}
    </div>
  )
}
```

---

### 코드 실행 요청 전체 시간 분해

```
Monaco Editor 코드 작성           : (가변)
"실행" 버튼 클릭 → Axios 요청     :   2ms
네트워크 전송                     :   1ms
Django JWT 인증                   :   5ms
문제 조회 (DB)                    :  10ms
코드 실행 준비                    :   2ms
├─ 테스트 케이스 1 실행           :  52ms
└─ 테스트 케이스 2 실행           :  48ms
결과 집계                         :   1ms
응답 생성 및 전송                 :   3ms
네트워크 전송                     :   1ms
React 결과 렌더링                 :  20ms
────────────────────────────────────────
총 시간                           : 약 145ms
```

---

# Part 2: 개별 상세

## 4. Docker 컨테이너 생명주기 상세 분석

### 4.1 컨테이너 생성 과정

**docker-compose up 내부:**

```
1. 이미지 준비
   ├─ 로컬에 이미지 있는지 확인
   ├─ 없으면 빌드 또는 pull
   └─ 이미지 ID 확인 (SHA256)

2. 컨테이너 설정 생성
   ├─ 이름: hint_system_backend
   ├─ 네트워크: hint_network
   ├─ 볼륨: ./backend:/app
   ├─ 환경 변수: .env 로드
   └─ 명령어: gunicorn ...

3. 파일 시스템 준비
   ├─ 이미지 레이어 마운트 (읽기 전용)
   │  Layer 1: python:3.10-slim
   │  Layer 2: apt-get install ...
   │  Layer 3: pip install ...
   │  Layer 4: COPY . .
   │
   └─ 쓰기 가능 레이어 생성
      (Copy-on-Write)

4. 네트워크 설정
   ├─ veth 페어 생성
   ├─ IP 할당: 172.18.0.3
   ├─ DNS 등록: backend → 172.18.0.3
   └─ 라우팅 테이블 업데이트

5. 볼륨 마운트
   ├─ 바인드 마운트: ./backend → /app
   ├─ Named volume: static_volume → /app/staticfiles
   └─ 파일 시스템 동기화

6. 프로세스 시작
   ├─ 새 PID namespace 생성
   ├─ 명령어 실행: gunicorn ...
   ├─ PID 1로 시작
   └─ stdout/stderr 로그 수집 시작
```

---

### 4.2 컨테이너 간 네트워크 통신

**backend → db 연결 과정:**

```python
# Django settings.py
DATABASES = {
    'default': {
        'HOST': 'db',  # ← 컨테이너 이름
        ...
    }
}
```

**DNS 해석 과정 (초상세):**

```
1. backend 컨테이너 내부
   ├─ Python 코드: connect(host='db')
   └─ gethostbyname('db') 시스템 콜

2. 컨테이너 /etc/resolv.conf 확인
   nameserver 127.0.0.11  ← Docker 내부 DNS

3. Docker Embedded DNS 서버 (127.0.0.11)
   ├─ 'db' 조회 요청 수신
   ├─ hint_network 컨테이너 목록 검색
   ├─ 'db' 컨테이너 찾음
   └─ IP 172.18.0.2 반환

4. TCP 연결 시도
   ├─ Source: 172.18.0.3:random
   ├─ Dest: 172.18.0.2:3306
   └─ SYN 패킷 전송

5. Linux Bridge (br-xxx)
   ├─ ARP 테이블 확인
   ├─ 172.18.0.2의 MAC 주소 조회
   └─ 패킷 전달

6. db 컨테이너 수신
   ├─ eth0 인터페이스
   ├─ MySQL 프로세스 (PID 1)
   └─ SYN-ACK 응답

7. 연결 성립
   └─ TCP 3-way handshake 완료
```

---

### 4.3 볼륨 동작 원리

**Bind Mount (./backend:/app):**

```
호스트 경로:
C:\Users\...\5th-project_mvp\backend\

컨테이너 경로:
/app/

실제 동작:
├─ 파일 시스템 마운트 포인트 생성
├─ 호스트 디렉토리를 컨테이너에 마운트
└─ 실시간 동기화
   - 호스트에서 파일 변경 → 컨테이너에 즉시 반영
   - 컨테이너에서 파일 변경 → 호스트에 즉시 반영
```

**Named Volume (mysql_data):**

```
Docker 관리 경로:
C:\ProgramData\Docker\volumes\5th-project_mvp_mysql_data\_data\

컨테이너 경로:
/var/lib/mysql/

특징:
├─ Docker가 관리하는 독립 저장소
├─ 컨테이너 삭제해도 유지
├─ 성능 최적화 (네이티브 파일 시스템)
└─ 백업 가능
```

---

## 5. 프론트엔드 내부 동작 상세 분석

### 5.1 Vite 개발 서버 아키텍처

**Vite 서버 구조:**

```
Vite Server (Node.js)
├─ HTTP Server (port 3000)
│  ├─ 정적 파일 서빙
│  ├─ On-demand 변환
│  └─ Proxy 처리
│
├─ WebSocket Server (HMR)
│  ├─ 파일 변경 감지
│  └─ 클라이언트에 알림
│
├─ Plugin System
│  ├─ @vitejs/plugin-react
│  └─ 기타 플러그인
│
└─ File Watcher (Chokidar)
   └─ src/ 폴더 감시
```

---

### 5.2 React 컴포넌트 렌더링 과정

**초기 렌더링:**

```javascript
// index.jsx
ReactDOM.createRoot(document.getElementById('root')).render(
  <Provider store={store}>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </Provider>
)
```

**React 내부 Fiber 아키텍처:**

```
Fiber Tree 생성
    ↓
Root Fiber
├─ Provider Fiber
│  └─ context value: Redux store
│
├─ BrowserRouter Fiber
│  └─ Router context
│
└─ App Fiber
   └─ Routes Fiber
      ├─ Route (/) → MainPage Fiber
      ├─ Route (/login) → Login Fiber
      └─ ...

Commit Phase
    ↓
실제 DOM 업데이트
    ↓
<div id="root">
  <div class="app">...</div>
</div>
```

---

### 5.3 Redux State 관리

**Store 구조:**

```javascript
// Redux Toolkit
const store = configureStore({
  reducer: {
    auth: authReducer,
    codingTest: codingTestReducer,
    chatbot: chatbotReducer
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(logger)
})
```

**State Tree:**

```
state (전역 상태)
├─ auth
│  ├─ user: { id, email, name, ... }
│  ├─ isAuthenticated: true
│  └─ token: 'eyJ...'
│
├─ codingTest
│  ├─ currentProblem: { id: 1, title: '...', ... }
│  ├─ code: 'a, b = ...'
│  ├─ result: { ... }
│  └─ submissions: []
│
└─ chatbot
   ├─ messages: []
   └─ loading: false
```

**Action Dispatch 과정:**

```javascript
// 1. 컴포넌트에서 dispatch
dispatch(loginUser({ email, password }))

// 2. Redux Thunk 미들웨어
// - 비동기 함수 실행
// - API 호출
// - pending 액션 자동 dispatch

dispatch({ type: 'auth/login/pending' })

// 3. Reducer 실행 (Immer.js 사용)
produce(state, draft => {
  draft.auth.loading = true
})

// 4. API 성공 후
dispatch({
  type: 'auth/login/fulfilled',
  payload: { user, token }
})

// 5. Reducer 실행
produce(state, draft => {
  draft.auth.loading = false
  draft.auth.isAuthenticated = true
  draft.auth.user = action.payload.user
})

// 6. 구독된 컴포넌트 리렌더링
// useSelector 훅이 변경 감지
// → 컴포넌트 리렌더링
```

---

## 6. 백엔드 내부 동작 상세 분석

### 6.1 Gunicorn Worker 관리

**Master 프로세스:**

```python
# Gunicorn Master
class Arbiter:
    def run(self):
        # 1. 워커 프로세스 생성
        for i in range(self.cfg.workers):  # 4개
            self.spawn_worker()

        # 2. 워커 감시 루프
        while True:
            # 워커 상태 체크
            for worker in self.workers:
                if not worker.is_alive():
                    # 워커 죽었으면 재시작
                    self.spawn_worker()

            # 설정 파일 변경 감지 (--reload)
            if self.cfg.reload:
                if self.config_changed():
                    # 모든 워커 재시작
                    self.restart_workers()

            time.sleep(1)
```

**Worker 프로세스:**

```python
class Worker:
    def run(self):
        # 1. WSGI 애플리케이션 로드
        self.wsgi = self.load_wsgi()

        # 2. 소켓 리스닝
        self.sockets = self.create_sockets()

        # 3. 요청 처리 루프
        while True:
            # Accept 대기
            client, addr = self.sockets[0].accept()

            # HTTP 요청 파싱
            request = self.parse_http_request(client)

            # WSGI 호출
            environ = self.make_environ(request)
            response = self.wsgi(environ, self.start_response)

            # HTTP 응답 전송
            self.send_response(client, response)
```

---

### 6.2 Django ORM 쿼리 과정

**ORM 쿼리 예시:**

```python
user = User.objects.get(email='student@test.com')
```

**내부 동작 (초상세):**

```python
# 1. QuerySet 생성
queryset = User.objects.all()
# SQL: SELECT * FROM authentication_user

# 2. filter 체인
queryset = queryset.filter(email='student@test.com')
# 아직 SQL 실행 안됨 (Lazy Evaluation)

# 3. get() 호출
# 이제 SQL 실행!
result = queryset.get()

# 4. SQL 컴파일
compiler = SQLCompiler(queryset)
sql, params = compiler.as_sql()
# sql = 'SELECT * FROM authentication_user WHERE email = %s LIMIT 1'
# params = ('student@test.com',)

# 5. 데이터베이스 백엔드 선택
backend = connections['default']  # MySQL

# 6. 연결 풀에서 연결 가져오기
connection = backend.get_connection()

# 7. 쿼리 실행
cursor = connection.cursor()
cursor.execute(sql, params)

# 8. 결과 페치
row = cursor.fetchone()
# row = (1, 'student@test.com', 'pbkdf2_sha256$...', ...)

# 9. Model 인스턴스 생성
user = User(*row)

# 10. 연결 반환
backend.return_connection(connection)
```

---

### 6.3 Django 미들웨어 체인

**요청 처리 (Request):**

```python
def get_response(request):
    # 1. SecurityMiddleware
    request = SecurityMiddleware.process_request(request)

    # 2. SessionMiddleware
    request = SessionMiddleware.process_request(request)
    # request.session 객체 생성

    # 3. CorsMiddleware
    request = CorsMiddleware.process_request(request)

    # 4. CommonMiddleware
    request = CommonMiddleware.process_request(request)

    # 5. CsrfViewMiddleware
    request = CsrfViewMiddleware.process_request(request)

    # 6. AuthenticationMiddleware
    request = AuthenticationMiddleware.process_request(request)
    # request.user = User(...) 또는 AnonymousUser()

    # 7. View 실행
    response = view_function(request)

    # 역순으로 응답 처리
    response = AuthenticationMiddleware.process_response(response)
    response = CsrfViewMiddleware.process_response(response)
    response = CommonMiddleware.process_response(response)
    response = CorsMiddleware.process_response(response)
    response = SessionMiddleware.process_response(response)
    response = SecurityMiddleware.process_response(response)

    return response
```

---

## 7. 데이터베이스 연결 및 쿼리 처리 과정

### 7.1 MySQL 연결 풀

**Django DB 연결 관리:**

```python
# django.db.backends.mysql
class DatabaseWrapper:
    def __init__(self):
        self.connection = None
        self.queries_log = []

    def ensure_connection(self):
        if self.connection is None:
            # 새 연결 생성
            self.connection = MySQLdb.connect(
                host='db',
                port=3306,
                user='hint_user',
                passwd='HintSystem2024!',
                db='hint_system',
                charset='utf8mb4',
                use_unicode=True,
                connect_timeout=10,
                read_timeout=30,
                write_timeout=30
            )

            # 연결 설정
            self.connection.set_character_set('utf8mb4')
            cursor = self.connection.cursor()
            cursor.execute("SET NAMES 'utf8mb4'")
            cursor.execute("SET time_zone = '+00:00'")
            cursor.close()
```

---

### 7.2 MySQL 쿼리 실행 과정

**SQL 실행 내부:**

```sql
SELECT * FROM authentication_user WHERE email = 'student@test.com';
```

**MySQL 서버 내부:**

```
1. 쿼리 수신
   ├─ TCP 소켓에서 패킷 읽기
   └─ MySQL 프로토콜 파싱

2. 쿼리 캐시 확인 (MySQL 8.0에서는 제거됨)
   └─ Skip

3. 파서 (Parser)
   ├─ SQL 문법 체크
   ├─ AST (Abstract Syntax Tree) 생성
   │  SELECT
   │  ├─ FROM: authentication_user
   │  └─ WHERE: email = 'student@test.com'
   └─ 문법 오류 없음

4. 전처리기 (Preprocessor)
   ├─ 테이블 존재 확인
   ├─ 컬럼 존재 확인
   └─ 권한 확인

5. 옵티마이저 (Optimizer)
   ├─ 실행 계획 생성
   │
   │  Option 1: Full Table Scan
   │  - 전체 행 스캔
   │  - 예상 비용: 1000
   │
   │  Option 2: Index Scan (email)
   │  - email 인덱스 사용
   │  - 예상 비용: 10  ← 선택!
   │
   └─ 최적 계획 선택: Index Scan

6. 실행 엔진 (Executor)
   ├─ 스토리지 엔진 (InnoDB) 호출
   └─ 인덱스 검색 요청

7. InnoDB 스토리지 엔진
   ├─ B-Tree 인덱스 검색
   │
   │  Root Node
   │   ├─ 'a' ~ 'm'
   │   └─ 'n' ~ 'z'  ← 's'는 여기
   │       ├─ 'n' ~ 'r'
   │       └─ 's' ~ 'z'  ← 검색
   │           └─ 'student@test.com' 발견!
   │              PK: 1
   │
   ├─ Primary Key로 데이터 페이지 접근
   │  - 테이블스페이스: hint_system/authentication_user.ibd
   │  - 페이지 16KB
   │  - 버퍼 풀에서 찾기
   │  - 있으면 반환, 없으면 디스크 I/O
   │
   └─ 행 데이터 반환
      (1, 'student@test.com', 'pbkdf2_sha256$...', ...)

8. 결과 반환
   ├─ Result Set 생성
   ├─ MySQL 프로토콜 인코딩
   └─ TCP 소켓으로 전송
```

---

## 마무리

이 문서는 프로젝트의 **모든 실행 과정**을 초상세하게 분석했습니다.

### 핵심 요약

**Part 1: 통합 흐름**
- Docker 부팅부터 모든 컨테이너 준비까지: 약 2분
- 로그인 요청 처리: 약 266ms
- 코드 실행 요청 처리: 약 145ms

**Part 2: 개별 상세**
- Docker: 컨테이너 생명주기, 네트워크, 볼륨
- 프론트엔드: Vite, React, Redux
- 백엔드: Gunicorn, Django, ORM
- 데이터베이스: MySQL 연결, 쿼리 실행

이제 이 프로젝트가 어떻게 작동하는지 **완벽하게** 이해하셨을 것입니다!
