# 프로젝트 완전정복 가이드 - AI 코딩 학습 플랫폼

> 이 문서는 초등학생도 이해할 수 있도록 쉽게 설명한 프로젝트 가이드입니다.
> 처음부터 차근차근 따라하면 누구나 이 프로젝트를 이해하고 실행할 수 있습니다!

---

## 목차

1. [이 프로젝트는 무엇인가요?](#1-이-프로젝트는-무엇인가요)
2. [프로젝트 구조 한눈에 보기](#2-프로젝트-구조-한눈에-보기)
3. [Docker 완전 정복하기](#3-docker-완전-정복하기)
4. [프론트엔드 완전 이해하기](#4-프론트엔드-완전-이해하기)
5. [백엔드 완전 이해하기](#5-백엔드-완전-이해하기)
6. [프론트엔드와 백엔드는 어떻게 대화할까요?](#6-프론트엔드와-백엔드는-어떻게-대화할까요)
7. [데이터베이스 이해하기](#7-데이터베이스-이해하기)
8. [프로젝트 처음부터 설치하기](#8-프로젝트-처음부터-설치하기)
9. [각 기능별 상세 설명](#9-각-기능별-상세-설명)
10. [자주 묻는 질문 (FAQ)](#10-자주-묻는-질문-faq)

---

## 1. 이 프로젝트는 무엇인가요?

### 쉽게 설명하면...

이 프로젝트는 **"AI가 도와주는 코딩 학습 웹사이트"**입니다!

마치 학원에서 선생님이 문제를 내고, 학생이 풀고, 모르면 힌트를 주는 것처럼:

1. **문제 풀기** - 코딩 문제를 풀 수 있어요
2. **힌트 받기** - AI가 힌트를 줘요 (쉬운 힌트, 중간 힌트, 자세한 힌트)
3. **점수 받기** - 문제를 풀면 점수를 얻어요
4. **배지 모으기** - 열심히 하면 배지를 받아요

### 이 프로젝트의 이름

**Hint System** (힌트 시스템)

---

## 2. 프로젝트 구조 한눈에 보기

### 폴더 구조를 집에 비유하면...

```
5th-project_mvp/          ← 우리 집 (전체 프로젝트)
│
├── frontend/             ← 거실 (사용자가 보는 화면)
│   └── src/              ← 거실 가구들 (버튼, 입력창 등)
│
├── backend/              ← 주방 (데이터를 요리하는 곳)
│   └── apps/             ← 주방 도구들 (기능별 코드)
│
├── nginx/                ← 현관문 (외부 요청을 안내)
│
├── docker-compose.yml    ← 집 설계도 (모든 것을 한번에 실행)
│
└── docs/                 ← 설명서 보관함
```

### 더 자세히 보면...

```
5th-project_mvp/
│
├── frontend/                    # 프론트엔드 (React)
│   ├── src/
│   │   ├── pages/              # 웹사이트의 각 페이지
│   │   │   ├── MainPage/       # 첫 화면
│   │   │   ├── Login/          # 로그인 화면
│   │   │   ├── Signup/         # 회원가입 화면
│   │   │   ├── Problems/       # 문제 목록 화면
│   │   │   ├── CodingTest/     # 코딩하는 화면
│   │   │   ├── Chatbot/        # 챗봇 화면
│   │   │   ├── MyPage/         # 내 정보 화면
│   │   │   └── AdminPanel/     # 관리자 화면
│   │   │
│   │   ├── components/         # 재사용하는 부품들
│   │   ├── services/           # 백엔드와 통신하는 코드
│   │   ├── store/              # 데이터 저장소 (Redux)
│   │   └── utils/              # 도우미 함수들
│   │
│   ├── package.json            # 필요한 도구 목록
│   └── vite.config.js          # 설정 파일
│
├── backend/                     # 백엔드 (Django)
│   ├── config/                 # 설정 파일들
│   │   ├── settings.py         # 주요 설정
│   │   └── urls.py             # 주소 연결
│   │
│   ├── apps/                   # 기능별 앱들
│   │   ├── authentication/     # 로그인/회원가입
│   │   ├── coding_test/        # 코딩 테스트 (메인 기능)
│   │   ├── chatbot/            # 챗봇
│   │   ├── mypage/             # 마이페이지
│   │   └── admin_panel/        # 관리자
│   │
│   ├── common/                 # 공통으로 쓰는 도구들
│   ├── vectordb/               # AI 벡터 데이터베이스
│   │
│   ├── requirements.txt        # 필요한 도구 목록
│   └── Dockerfile              # 도커 설정
│
├── nginx/                       # 웹서버 설정
├── docker-compose.yml           # 전체 실행 설정
└── .env                         # 비밀 설정 (비밀번호 등)
```

---

## 3. Docker 완전 정복하기

### Docker란 무엇인가요?

**Docker**는 프로그램을 실행하기 위한 **"이동식 컴퓨터"**라고 생각하면 됩니다!

#### 왜 Docker가 필요한가요?

원래 이 프로젝트를 실행하려면 이렇게 해야 해요:

```
1. Python 3.10 설치
2. Node.js 18 설치
3. MySQL 8.0 설치
4. 각종 라이브러리 설치
5. 환경 변수 설정
6. ... (계속)
```

**문제점:**
- 내 컴퓨터에서는 되는데 친구 컴퓨터에서는 안 됨
- Windows에서는 되는데 Mac에서는 안 됨
- 설치하다가 버전이 맞지 않아서 에러 남

**Docker가 해결해 줍니다!**

Docker를 사용하면:
```
1. Docker 설치
2. docker-compose up
3. 끝!
```

모든 설정이 **자동으로** 되고, **어떤 컴퓨터에서든 똑같이** 작동합니다!

### Docker를 쉽게 이해하는 비유

#### 비유 1: 도시락

| 일반 방식 | Docker 방식 |
|-----------|-------------|
| 식재료를 각자 사서 요리 | 완성된 도시락을 배달 |
| 재료가 다르면 맛이 다름 | 항상 같은 맛 |
| 조리 도구가 필요함 | 그냥 먹으면 됨 |

#### 비유 2: 이사

| 일반 방식 | Docker 방식 |
|-----------|-------------|
| 가구를 분해해서 이사 | 집 전체를 통째로 이사 |
| 다시 조립해야 함 | 그대로 사용 |
| 부품이 없으면 문제 | 항상 완벽 |

### Docker의 핵심 개념

#### 1. 이미지 (Image)

**이미지**는 **설계도**예요.

```
"Python 3.10이 설치된 컴퓨터" → 이미지
"Node.js 18이 설치된 컴퓨터" → 이미지
"MySQL 8.0이 설치된 컴퓨터" → 이미지
```

이미지 자체는 실행되지 않아요. 설계도일 뿐이에요.

#### 2. 컨테이너 (Container)

**컨테이너**는 **실제로 실행되는 것**이에요.

```
이미지(설계도) → 컨테이너(실제 실행)

Python 이미지 → Python 컨테이너 (실행 중!)
MySQL 이미지 → MySQL 컨테이너 (실행 중!)
```

마치:
- 이미지 = 자동차 설계도
- 컨테이너 = 실제 자동차

#### 3. Dockerfile

**Dockerfile**은 **이미지를 만드는 레시피**예요.

```dockerfile
# "이렇게 생긴 이미지를 만들어줘!"

FROM python:3.10        # Python 3.10 기반으로
COPY . /app             # 내 코드를 복사하고
RUN pip install -r requirements.txt  # 라이브러리 설치
CMD ["python", "app.py"]  # 이 명령어로 실행해줘
```

#### 4. docker-compose.yml

**docker-compose.yml**은 **여러 컨테이너를 한번에 관리하는 설정**이에요.

```
"MySQL도 실행하고, Django도 실행하고, React도 실행해줘!"
```

---

### 현재 프로젝트의 Docker 구조

이 프로젝트는 **4개의 컨테이너**를 사용합니다:

```
┌─────────────────────────────────────────────────────┐
│                  Docker Network                      │
│                 (hint_network)                       │
│                                                      │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────┐ │
│  │   db     │  │ backend  │  │ frontend │  │nginx │ │
│  │ (MySQL)  │  │ (Django) │  │ (React)  │  │      │ │
│  │ :3306    │  │ :8000    │  │ :3000    │  │ :80  │ │
│  └──────────┘  └──────────┘  └──────────┘  └──────┘ │
│       ↑              ↑             ↑          ↓     │
│       │              │             │          │     │
│       └──────────────┴─────────────┴──────────┘     │
│                      요청 흐름                       │
└─────────────────────────────────────────────────────┘
```

### 각 컨테이너 상세 설명

---

#### 🗄️ 컨테이너 1: db (MySQL 데이터베이스)

**역할**: 모든 데이터를 저장하는 창고

##### docker-compose.yml에서의 설정

```yaml
db:
  image: mysql:8.0                    # MySQL 8.0 이미지 사용
  container_name: hint_system_db      # 컨테이너 이름
  environment:                        # 환경 변수 설정
    MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}  # 루트 비밀번호
    MYSQL_DATABASE: ${DB_NAME}           # 데이터베이스 이름
    MYSQL_USER: ${DB_USER}               # 사용자 이름
    MYSQL_PASSWORD: ${DB_PASSWORD}       # 비밀번호
  volumes:
    - mysql_data:/var/lib/mysql       # 데이터 영구 저장
  ports:
    - "3307:3306"                     # 외부 3307 → 내부 3306
  healthcheck:                        # 건강 체크
    test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
    timeout: 20s
    retries: 10
```

##### 쉽게 설명하면

| 설정 | 의미 |
|------|------|
| `image: mysql:8.0` | MySQL 8.0 버전을 사용해줘 |
| `environment` | 데이터베이스 비밀번호 등 설정 |
| `volumes` | 컴퓨터를 꺼도 데이터 유지 |
| `ports: "3307:3306"` | 컴퓨터의 3307번 포트로 접속 가능 |
| `healthcheck` | 데이터베이스가 준비됐는지 확인 |

##### 저장되는 데이터

- 사용자 정보 (이메일, 비밀번호, 점수)
- 문제 정보
- 제출 기록
- 힌트 기록
- 배지 정보

---

#### 🐍 컨테이너 2: backend (Django 백엔드)

**역할**: 데이터를 처리하고 API를 제공

##### Dockerfile 분석

```dockerfile
FROM python:3.10-slim              # Python 3.10 경량 버전 사용

WORKDIR /app                       # 작업 폴더 설정

# 시스템 도구 설치
RUN apt-get update && apt-get install -y \
    gcc \                          # C 컴파일러
    default-libmysqlclient-dev \   # MySQL 연결 도구
    pkg-config \
    && rm -rf /var/lib/apt/lists/*

# Python 패키지 설치
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 코드 복사
COPY . .

# 로그 폴더 생성
RUN mkdir -p logs

# 서버 실행
CMD ["gunicorn", "config.wsgi:application", "--bind", "0.0.0.0:8000", "--workers", "4"]
```

##### docker-compose.yml에서의 설정

```yaml
backend:
  build:
    context: ./backend              # backend 폴더에서 빌드
    dockerfile: Dockerfile
  container_name: hint_system_backend
  command: gunicorn config.wsgi:application --bind 0.0.0.0:8000 --workers 4 --reload
  volumes:
    - ./backend:/app                # 코드 실시간 반영
    - static_volume:/app/staticfiles
    - media_volume:/app/media
    - ./hint-system:/app/hint-system  # AI 힌트 시스템
  ports:
    - "8000:8000"                   # 8000번 포트
  env_file:
    - .env                          # 환경 변수 파일
  depends_on:
    db:
      condition: service_healthy    # DB가 준비된 후 시작
```

##### 쉽게 설명하면

| 설정 | 의미 |
|------|------|
| `build: context: ./backend` | backend 폴더의 Dockerfile로 이미지 생성 |
| `command: gunicorn ...` | 이 명령어로 서버 실행 |
| `volumes: - ./backend:/app` | 코드 수정하면 바로 반영 (개발용) |
| `ports: "8000:8000"` | 8000번 포트로 접속 |
| `depends_on: db` | DB가 먼저 켜진 후에 시작 |

##### Gunicorn이란?

**Gunicorn**은 Django를 실행하는 **웹 서버**예요.

```
--workers 4  →  4개의 일꾼이 동시에 일함
--reload     →  코드 수정하면 자동으로 재시작
```

---

#### ⚛️ 컨테이너 3: frontend (React 프론트엔드)

**역할**: 사용자가 보는 화면 제공

##### Dockerfile 분석

```dockerfile
FROM node:18-alpine               # Node.js 18 경량 버전

WORKDIR /app

# 패키지 설치
COPY package*.json ./
RUN npm install

# 코드 복사
COPY . .

# 개발 서버 실행
EXPOSE 3000
CMD ["npm", "run", "dev", "--", "--host"]
```

##### docker-compose.yml에서의 설정

```yaml
frontend:
  build:
    context: ./frontend
    dockerfile: Dockerfile
  container_name: hint_system_frontend
  volumes:
    - ./frontend:/app              # 코드 실시간 반영
    - /app/node_modules            # node_modules는 컨테이너 것 사용
  ports:
    - "3000:3000"
  environment:
    - VITE_API_BASE_URL=http://localhost:8000/api/v1
  depends_on:
    - backend                      # 백엔드가 먼저 시작
```

##### 쉽게 설명하면

| 설정 | 의미 |
|------|------|
| `FROM node:18-alpine` | Node.js 18 버전 사용 |
| `npm run dev` | 개발 모드로 실행 (코드 변경 시 자동 새로고침) |
| `- /app/node_modules` | node_modules는 컨테이너 안의 것 사용 |
| `VITE_API_BASE_URL` | 백엔드 주소 설정 |

##### 왜 `/app/node_modules`를 따로 설정하나요?

```
volumes:
  - ./frontend:/app          # 1. 내 코드를 컨테이너에 연결
  - /app/node_modules        # 2. 하지만 node_modules는 제외!
```

이유:
1. node_modules는 용량이 매우 큼 (수백 MB)
2. Windows와 Linux의 node_modules가 다름
3. 컨테이너 안에서 설치한 것을 사용하는 게 더 빠름

---

#### 🌐 컨테이너 4: nginx (웹 서버/프록시)

**역할**: 외부 요청을 받아서 적절한 곳으로 안내

##### Dockerfile 분석

```dockerfile
FROM nginx:alpine

# 설정 파일 복사
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

##### nginx.conf 분석

```nginx
# 백엔드와 프론트엔드 주소 정의
upstream backend {
    server backend:8000;
}

upstream frontend {
    server frontend:3000;
}

server {
    listen 80;                    # 80번 포트에서 듣기

    # "/" 요청 → 프론트엔드로
    location / {
        proxy_pass http://frontend;
    }

    # "/api/" 요청 → 백엔드로
    location /api/ {
        proxy_pass http://backend;
    }

    # "/admin/" 요청 → 백엔드로
    location /admin/ {
        proxy_pass http://backend;
    }

    # 정적 파일
    location /static/ {
        alias /app/backend/staticfiles/;
    }
}
```

##### 쉽게 설명하면: 교통 경찰

Nginx는 **교통 경찰**과 같아요!

```
사용자 요청                    Nginx가 안내
─────────────────────────────────────────
http://localhost/           →  프론트엔드 (React)
http://localhost/api/login  →  백엔드 (Django)
http://localhost/admin      →  백엔드 (Django 관리자)
http://localhost/static/    →  정적 파일 (CSS, JS)
```

##### 왜 Nginx가 필요한가요?

1. **하나의 주소**로 통일
   - Nginx 없이: 프론트엔드 3000번, 백엔드 8000번 따로 접속
   - Nginx 있으면: 80번 하나로 모든 것 접속

2. **보안 강화**
   - 직접 백엔드에 접속하지 않음
   - CORS 헤더 자동 추가

3. **성능 향상**
   - 정적 파일을 빠르게 제공
   - 로드 밸런싱 가능

---

### docker-compose.yml 완전 분석

#### 전체 구조

```yaml
services:        # 실행할 컨테이너들
  db:            # MySQL
  backend:       # Django
  frontend:      # React
  nginx:         # 웹서버

volumes:         # 저장소
  mysql_data:    # MySQL 데이터
  static_volume: # 정적 파일
  media_volume:  # 미디어 파일

networks:        # 네트워크
  hint_network:  # 컨테이너들이 통신하는 네트워크
```

#### volumes (저장소) 설명

```yaml
volumes:
  mysql_data:      # MySQL 데이터 영구 저장
  static_volume:   # CSS, JS 등 정적 파일
  media_volume:    # 사용자 업로드 파일
```

**왜 필요한가요?**

Docker 컨테이너는 **종료하면 내부 데이터가 삭제**됩니다!

```
컨테이너 종료 → 데이터 삭제됨 😱

Volume 사용 → 데이터 영구 보존 ✅
```

#### networks (네트워크) 설명

```yaml
networks:
  hint_network:
    driver: bridge
```

**왜 필요한가요?**

컨테이너들이 서로 대화하려면 **같은 네트워크**에 있어야 해요!

```
같은 네트워크 안에서:
- backend 컨테이너가 "db"라고 하면 MySQL 컨테이너를 찾음
- frontend 컨테이너가 "backend"라고 하면 Django 컨테이너를 찾음
```

#### depends_on (의존성) 설명

```yaml
backend:
  depends_on:
    db:
      condition: service_healthy  # DB가 건강해야 시작

frontend:
  depends_on:
    - backend                     # 백엔드가 먼저 시작

nginx:
  depends_on:
    - backend
    - frontend                    # 둘 다 시작된 후
```

**시작 순서:**

```
1. db (MySQL) 시작
   ↓
   건강 체크 통과?
   ↓
2. backend (Django) 시작
   ↓
3. frontend (React) 시작
   ↓
4. nginx 시작
```

---

### 자주 사용하는 Docker 명령어

#### 기본 명령어

```bash
# 모든 컨테이너 시작 (처음 또는 Dockerfile 변경 시)
docker-compose up --build

# 모든 컨테이너 시작 (이미 빌드된 경우)
docker-compose up

# 백그라운드에서 실행
docker-compose up -d

# 모든 컨테이너 중지
docker-compose down

# 컨테이너와 볼륨 모두 삭제 (데이터 삭제!)
docker-compose down -v
```

#### 로그 보기

```bash
# 모든 로그 보기
docker-compose logs

# 특정 컨테이너 로그
docker-compose logs backend
docker-compose logs frontend
docker-compose logs db

# 실시간 로그 보기
docker-compose logs -f backend
```

#### 컨테이너 관리

```bash
# 실행 중인 컨테이너 보기
docker-compose ps

# 컨테이너 재시작
docker-compose restart backend

# 특정 컨테이너만 실행
docker-compose up backend

# 컨테이너 안에 들어가기
docker-compose exec backend bash
docker-compose exec db mysql -u hint_user -p
```

#### 개발 중 유용한 명령어

```bash
# Django 마이그레이션 실행
docker-compose exec backend python manage.py migrate

# Django 관리자 계정 생성
docker-compose exec backend python manage.py createsuperuser

# 프론트엔드 패키지 설치
docker-compose exec frontend npm install 패키지이름
```

---

### 실행 흐름 상세 설명

#### 1단계: docker-compose up --build

```
1. docker-compose.yml 읽기
2. 각 서비스의 Dockerfile 찾기
3. 이미지 빌드
   - backend: Python + Django 설치
   - frontend: Node.js + React 설치
   - nginx: Nginx 설정 적용
4. 네트워크 생성 (hint_network)
5. 볼륨 생성 (mysql_data, static_volume, media_volume)
```

#### 2단계: 컨테이너 시작

```
1. db 컨테이너 시작
   - MySQL 8.0 실행
   - 데이터베이스 생성
   - 사용자 생성
   - healthcheck 시작

2. db 건강 체크 통과 후...

3. backend 컨테이너 시작
   - Django 앱 실행
   - DB 연결
   - 8000번 포트 리스닝

4. frontend 컨테이너 시작
   - React 개발 서버 실행
   - 3000번 포트 리스닝

5. nginx 컨테이너 시작
   - 80번 포트 리스닝
   - 요청 라우팅 시작
```

#### 3단계: 사용자 요청 처리

```
사용자: http://localhost/ 접속
         ↓
      Nginx (80번)
         ↓
    location / 매칭
         ↓
    frontend (3000번)
         ↓
    React 화면 전송
         ↓
      사용자에게 표시
```

```
사용자: 로그인 버튼 클릭
         ↓
    React가 /api/auth/login/ 요청
         ↓
      Nginx (80번)
         ↓
    location /api/ 매칭
         ↓
    backend (8000번)
         ↓
    Django가 처리
         ↓
    DB에서 사용자 확인
         ↓
    JWT 토큰 생성
         ↓
      응답 전송
```

---

### 개발 환경 vs 프로덕션 환경

#### 개발 환경 (현재 설정)

```yaml
# 코드 변경 시 자동 반영
volumes:
  - ./backend:/app      # 백엔드 코드 마운트
  - ./frontend:/app     # 프론트엔드 코드 마운트

# 자동 재시작
command: gunicorn ... --reload
```

**특징:**
- 코드 수정하면 바로 반영
- 에러 메시지 자세히 표시
- 디버깅 모드 활성화

#### 프로덕션 환경 (배포용)

```yaml
# 코드를 이미지에 포함
# volumes 마운트 없음

# 고정된 워커 수
command: gunicorn ... --workers 4
```

**특징:**
- 코드가 이미지에 고정
- 에러 메시지 간단히
- 성능 최적화

---

### 자주 발생하는 문제와 해결

#### 문제 1: "포트가 이미 사용 중"

```
Error: port is already allocated
```

**해결:**

```bash
# Windows에서 포트 사용 프로세스 찾기
netstat -ano | findstr :3000

# 프로세스 종료
taskkill /PID [프로세스번호] /F
```

#### 문제 2: "DB 연결 실패"

```
django.db.utils.OperationalError: (2002, "Can't connect to MySQL server")
```

**해결:**

```bash
# DB가 완전히 시작됐는지 확인
docker-compose logs db

# DB만 먼저 시작
docker-compose up -d db

# 잠시 후 나머지 시작
docker-compose up backend frontend nginx
```

#### 문제 3: "node_modules 에러"

```
Error: Cannot find module 'xxx'
```

**해결:**

```bash
# node_modules 다시 설치
docker-compose exec frontend npm install

# 또는 컨테이너 재빌드
docker-compose up --build frontend
```

#### 문제 4: "마이그레이션 에러"

```
django.db.utils.OperationalError: (1049, "Unknown database")
```

**해결:**

```bash
# 마이그레이션 실행
docker-compose exec backend python manage.py migrate
```

---

### Docker를 사용한 개발 워크플로우

#### 1. 처음 프로젝트 시작

```bash
# 1. 환경 변수 설정
copy .env.example .env
# .env 파일 편집 (비밀번호 등)

# 2. Docker 실행
docker-compose up --build

# 3. 마이그레이션
docker-compose exec backend python manage.py migrate

# 4. 관리자 계정 생성
docker-compose exec backend python manage.py createsuperuser

# 5. 브라우저에서 확인
# http://localhost:3000
```

#### 2. 일상적인 개발

```bash
# 아침: Docker 시작
docker-compose up

# 코드 수정 → 자동 반영됨!

# 새 패키지 설치 시
docker-compose exec frontend npm install 패키지이름
docker-compose exec backend pip install 패키지이름

# 저녁: Docker 종료
docker-compose down
```

#### 3. 모델 변경 시

```bash
# 1. models.py 수정
# 2. 마이그레이션 파일 생성
docker-compose exec backend python manage.py makemigrations

# 3. 마이그레이션 적용
docker-compose exec backend python manage.py migrate
```

---

### 요약

| 개념 | 설명 | 이 프로젝트에서 |
|------|------|-----------------|
| **Docker** | 프로그램 실행 환경을 패키징 | 4개 컨테이너 관리 |
| **이미지** | 설계도 | python:3.10, node:18, mysql:8.0, nginx:alpine |
| **컨테이너** | 실행되는 것 | db, backend, frontend, nginx |
| **Dockerfile** | 이미지 만드는 레시피 | 3개 (backend, frontend, nginx) |
| **docker-compose.yml** | 여러 컨테이너 관리 | 4개 서비스 정의 |
| **Volume** | 데이터 영구 저장 | mysql_data, static_volume, media_volume |
| **Network** | 컨테이너 간 통신 | hint_network |

**핵심 명령어:**

```bash
docker-compose up --build   # 시작 (빌드 포함)
docker-compose down         # 종료
docker-compose logs -f      # 로그 보기
docker-compose exec [서비스] [명령]  # 컨테이너 안에서 실행
```

---

## 4. 프론트엔드 완전 이해하기

### 프론트엔드란?

**프론트엔드**는 사용자가 직접 보고 만지는 부분입니다.

- 버튼을 누르면 반응하는 것
- 글자를 입력하는 칸
- 예쁜 색깔과 디자인
- 페이지 이동

마치 **자동차의 핸들, 버튼, 화면** 같은 거예요!

### 사용하는 기술

| 기술 | 설명 | 버전 |
|------|------|------|
| **React** | 화면을 만드는 도구 | 18.2.0 |
| **Vite** | 빠르게 개발하는 도구 | 5.0.11 |
| **Redux** | 데이터를 저장하는 도구 | 2.0.1 |
| **Axios** | 백엔드와 통신하는 도구 | 1.6.5 |
| **Monaco Editor** | 코드 편집기 (VS Code와 같음) | 4.6.0 |

### 각 페이지 설명

#### 📁 pages 폴더 안에 있는 것들

```
pages/
├── MainPage/        # 메인 페이지 (처음 보이는 화면)
├── Login/           # 로그인 페이지
├── Signup/          # 회원가입 페이지
├── Problems/        # 문제 목록 페이지
├── CodingTest/      # 코딩 테스트 페이지 (가장 중요!)
├── Chatbot/         # 챗봇 페이지
├── MyPage/          # 내 정보 페이지
├── AdminPanel/      # 관리자 페이지
├── Survey/          # 설문조사 페이지
├── Roadmap/         # 학습 로드맵 페이지
├── TestCaseProposal/    # 테스트케이스 제안
├── SolutionProposal/    # 해결책 제안
└── ProblemProposal/     # 문제 제안
```

### 프론트엔드 작동 원리

#### 1단계: 사용자가 웹사이트에 접속

```
사용자 → 브라우저에 주소 입력 → React 앱이 로드됨
```

#### 2단계: 페이지 이동 (React Router)

```javascript
// App.jsx에서 주소에 따라 페이지를 보여줌
<Routes>
  <Route path="/" element={<MainPage />} />
  <Route path="/login" element={<Login />} />
  <Route path="/problems" element={<Problems />} />
  <Route path="/coding-test" element={<CodingTest />} />
</Routes>
```

쉽게 말하면:
- `/` 주소 → 메인 페이지 보여줌
- `/login` 주소 → 로그인 페이지 보여줌
- `/problems` 주소 → 문제 목록 보여줌

#### 3단계: 데이터 저장 (Redux Store)

Redux는 **모든 페이지가 공유하는 저장소**입니다.

```javascript
// store/authSlice.js - 로그인 정보 저장
{
  user: {
    email: "student@example.com",
    name: "홍길동",
    role: "user"
  },
  isLoggedIn: true,
  token: "abc123..."
}

// store/codingTestSlice.js - 코딩 테스트 정보 저장
{
  currentProblem: { ... },
  code: "print('hello')",
  result: "성공"
}
```

#### 4단계: 백엔드와 통신 (Axios)

```javascript
// services/api.js

// 로그인 요청
const response = await api.post('/auth/login/', {
  email: 'student@example.com',
  password: '1234'
});

// 문제 목록 가져오기
const problems = await api.get('/coding-test/problems/');
```

### 프론트엔드 파일 상세 설명

#### 📄 src/services/api.js

이 파일은 **백엔드와 대화하는 방법**을 정의합니다.

```javascript
import axios from 'axios';

// 백엔드 주소 설정
const api = axios.create({
  baseURL: 'http://192.168.0.4:8000/api/v1'
});

// 모든 요청에 자동으로 토큰 추가
api.interceptors.request.use((config) => {
  const token = localStorage.getItem('access_token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});
```

**쉽게 설명하면:**
1. 백엔드 주소를 설정해요
2. 로그인하면 받는 토큰(비밀번호 같은 것)을 자동으로 붙여요
3. 토큰이 만료되면 자동으로 새로 받아요

#### 📄 src/store/authSlice.js

로그인 상태를 관리하는 파일입니다.

```javascript
// 저장되는 정보
{
  user: null,           // 사용자 정보
  isAuthenticated: false,  // 로그인 했는지
  loading: false,       // 로딩 중인지
  error: null          // 에러가 있는지
}
```

#### 📄 vite.config.js

개발 환경 설정 파일입니다.

```javascript
export default defineConfig({
  plugins: [react()],

  // 경로 별명 설정 (짧게 쓸 수 있음)
  resolve: {
    alias: {
      '@': '/src',
      '@pages': '/src/pages',
      '@services': '/src/services'
    }
  },

  // 개발 서버 설정
  server: {
    port: 3000,  // 3000번 포트 사용
    proxy: {
      '/api': 'http://backend:8000'  // /api 요청은 백엔드로
    }
  }
});
```

---

## 5. 백엔드 완전 이해하기

### 백엔드란?

**백엔드**는 보이지 않는 곳에서 일하는 부분입니다.

- 로그인이 맞는지 확인하기
- 데이터베이스에서 정보 가져오기
- 점수 계산하기
- AI로 힌트 만들기

마치 **자동차의 엔진, 변속기, 연료 시스템** 같은 거예요!

### 사용하는 기술

| 기술 | 설명 | 버전 |
|------|------|------|
| **Django** | 웹 서버를 만드는 도구 | 5.0.1 |
| **Django REST Framework** | API를 만드는 도구 | 3.14.0 |
| **MySQL** | 데이터를 저장하는 곳 | 8.0 |
| **JWT** | 로그인 토큰 | - |
| **ChromaDB** | AI 벡터 데이터베이스 | 0.4.22 |

### Django 앱 구조 이해하기

Django에서는 기능별로 **"앱"**을 만들어요.

```
apps/
├── authentication/     # 인증 앱 (로그인, 회원가입)
├── coding_test/        # 코딩 테스트 앱 (메인!)
├── chatbot/            # 챗봇 앱
├── mypage/             # 마이페이지 앱
└── admin_panel/        # 관리자 앱
```

각 앱은 이런 파일들을 가지고 있어요:

```
authentication/
├── models.py       # 데이터 모양 정의
├── views.py        # 요청 처리 로직
├── serializers.py  # 데이터 변환
├── urls.py         # 주소 연결
└── migrations/     # 데이터베이스 변경 기록
```

### 각 파일의 역할

#### 📄 models.py - 데이터의 모양을 정의

```python
# apps/authentication/models.py

class User(AbstractUser):
    """사용자 정보"""
    email = models.EmailField(unique=True)      # 이메일 (중복 안됨)
    name = models.CharField(max_length=50)       # 이름
    role = models.CharField(default='user')      # 역할 (user/admin)
    rating = models.IntegerField(default=0)      # 점수
    skill_score = models.FloatField(default=0)   # 실력 점수
    hint_level = models.IntegerField(default=1)  # 힌트 레벨
```

**쉽게 설명하면:**
- 회원 가입할 때 어떤 정보를 저장할지 정해요
- 이메일, 이름, 점수 등을 저장해요

#### 📄 views.py - 요청을 처리하는 로직

```python
# apps/authentication/views.py

class LoginView(APIView):
    """로그인 처리"""

    def post(self, request):
        # 1. 이메일과 비밀번호 받기
        email = request.data.get('email')
        password = request.data.get('password')

        # 2. 사용자 찾기
        user = User.objects.get(email=email)

        # 3. 비밀번호 확인
        if user.check_password(password):
            # 4. 토큰 만들어서 보내기
            token = create_token(user)
            return Response({'token': token})
        else:
            return Response({'error': '비밀번호 틀림'})
```

**쉽게 설명하면:**
- 프론트엔드에서 요청이 오면 처리해요
- 로그인이면 비밀번호 확인하고 토큰을 줘요

#### 📄 serializers.py - 데이터 변환

```python
# apps/authentication/serializers.py

class UserSerializer(serializers.ModelSerializer):
    """User 모델을 JSON으로 변환"""

    class Meta:
        model = User
        fields = ['id', 'email', 'name', 'rating']
```

**쉽게 설명하면:**
- 데이터베이스의 정보를 JSON으로 바꿔요
- 프론트엔드가 이해할 수 있는 형식이에요

#### 📄 urls.py - 주소 연결

```python
# apps/authentication/urls.py

urlpatterns = [
    path('signup/', SignupView.as_view()),    # /auth/signup/
    path('login/', LoginView.as_view()),      # /auth/login/
    path('logout/', LogoutView.as_view()),    # /auth/logout/
    path('user/', UserView.as_view()),        # /auth/user/
]
```

**쉽게 설명하면:**
- 어떤 주소로 요청이 오면 어떤 함수가 처리할지 정해요

### 핵심 앱: coding_test 상세 설명

이 앱이 **가장 중요한 메인 기능**입니다!

#### 📄 models.py의 주요 모델들

```python
# 1. 문제 (Problem)
class Problem(models.Model):
    problem_id = models.IntegerField()          # 문제 번호
    title = models.CharField(max_length=200)     # 제목
    level = models.IntegerField()                # 난이도 (1-5)
    description = models.TextField()             # 문제 설명
    input_description = models.TextField()       # 입력 설명
    output_description = models.TextField()      # 출력 설명
    examples = models.JSONField()                # 예제
    solutions = models.JSONField()               # 정답 코드들

# 2. 제출 (Submission)
class Submission(models.Model):
    user = models.ForeignKey(User)              # 누가 제출했는지
    problem = models.ForeignKey(Problem)        # 어떤 문제인지
    code = models.TextField()                   # 제출한 코드
    result = models.CharField()                 # 결과 (성공/실패)
    execution_time = models.FloatField()        # 실행 시간
    rating_earned = models.IntegerField()       # 얻은 점수

# 3. 힌트 요청 (HintRequest)
class HintRequest(models.Model):
    user = models.ForeignKey(User)              # 누가 요청했는지
    problem = models.ForeignKey(Problem)        # 어떤 문제인지
    hint_level = models.IntegerField()          # 힌트 레벨 (1-3)
    user_code = models.TextField()              # 사용자 코드
    hint_response = models.TextField()          # AI가 준 힌트

# 4. 북마크 (Bookmark)
class Bookmark(models.Model):
    user = models.ForeignKey(User)
    problem = models.ForeignKey(Problem)

# 5. 배지 (Badge)
class Badge(models.Model):
    badge_type = models.CharField()             # 배지 종류
    name = models.CharField()                   # 배지 이름
    description = models.TextField()            # 설명
    condition_type = models.CharField()         # 획득 조건
```

#### 📄 code_executor.py - 코드 실행기

이 파일은 **사용자가 작성한 코드를 실행**합니다.

```python
# apps/coding_test/code_executor.py

import subprocess
import tempfile

def execute_code(code, test_input):
    """
    코드를 실행하고 결과를 반환

    1. 임시 파일에 코드 저장
    2. Python으로 실행
    3. 결과 반환
    """

    # 임시 파일 만들기
    with tempfile.NamedTemporaryFile(suffix='.py', delete=False) as f:
        f.write(code.encode())
        temp_file = f.name

    # 코드 실행 (5초 제한)
    result = subprocess.run(
        ['python', temp_file],
        input=test_input,
        capture_output=True,
        timeout=5  # 5초 넘으면 중지
    )

    return {
        'output': result.stdout.decode(),
        'error': result.stderr.decode(),
        'success': result.returncode == 0
    }
```

**쉽게 설명하면:**
1. 사용자 코드를 임시 파일로 저장해요
2. Python으로 실행해요
3. 결과를 돌려줘요
4. 5초 넘으면 자동으로 멈춰요 (무한 루프 방지)

#### 📄 hint_api.py - 힌트 생성

AI를 사용해서 힌트를 만들어요.

```python
# apps/coding_test/hint_api.py

def generate_hint(problem, user_code, hint_level):
    """
    AI를 사용해서 힌트 생성

    hint_level:
    - 1: 작은 힌트 (방향만 알려줌)
    - 2: 중간 힌트 (구체적인 조언)
    - 3: 큰 힌트 (거의 답에 가까움)
    """

    if hint_level == 1:
        prompt = "간단한 방향만 알려주세요"
    elif hint_level == 2:
        prompt = "구체적인 조언을 해주세요"
    else:
        prompt = "자세한 설명과 예시를 주세요"

    # AI 모델 호출
    hint = call_ai_model(prompt, problem, user_code)

    return hint
```

### config 폴더 설명

#### 📄 settings.py - Django 설정

```python
# config/settings.py

# 설치된 앱들
INSTALLED_APPS = [
    'django.contrib.admin',
    'rest_framework',
    'corsheaders',
    'apps.authentication',
    'apps.coding_test',
    'apps.chatbot',
    'apps.mypage',
    'apps.admin_panel',
]

# 데이터베이스 설정
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'hint_system',
        'USER': 'hint_user',
        'PASSWORD': '비밀번호',
        'HOST': 'db',
        'PORT': '3306',
    }
}

# JWT 토큰 설정
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(hours=1),   # 1시간
    'REFRESH_TOKEN_LIFETIME': timedelta(days=7),   # 7일
}
```

#### 📄 urls.py - 전체 주소 연결

```python
# config/urls.py

urlpatterns = [
    path('admin/', admin.site.urls),           # 관리자 페이지
    path('api/v1/auth/', include('apps.authentication.urls')),
    path('api/v1/coding-test/', include('apps.coding_test.urls')),
    path('api/v1/chatbot/', include('apps.chatbot.urls')),
    path('api/v1/mypage/', include('apps.mypage.urls')),
]
```

---

## 6. 프론트엔드와 백엔드는 어떻게 대화할까요?

### API란?

**API**는 프론트엔드와 백엔드가 대화하는 방법입니다.

마치 **식당에서 주문하는 것**과 같아요:

1. 손님(프론트엔드)이 메뉴를 주문 (요청)
2. 웨이터(API)가 주방에 전달
3. 주방(백엔드)이 요리를 만듦
4. 웨이터가 손님에게 가져다 줌 (응답)

### HTTP 메서드 이해하기

| 메서드 | 의미 | 예시 |
|--------|------|------|
| **GET** | 가져와 줘! | 문제 목록 보기 |
| **POST** | 새로 만들어 줘! | 회원가입, 코드 제출 |
| **PUT/PATCH** | 수정해 줘! | 프로필 수정 |
| **DELETE** | 삭제해 줘! | 계정 삭제 |

### 실제 API 예시

#### 1. 로그인 API

```
프론트엔드 → 백엔드
-------------------
POST /api/v1/auth/login/
{
  "email": "student@example.com",
  "password": "1234"
}

백엔드 → 프론트엔드
-------------------
{
  "success": true,
  "data": {
    "access": "eyJ...(토큰)...",
    "refresh": "eyK...(토큰)...",
    "user": {
      "id": 1,
      "email": "student@example.com",
      "name": "홍길동"
    }
  }
}
```

#### 2. 문제 목록 가져오기 API

```
프론트엔드 → 백엔드
-------------------
GET /api/v1/coding-test/problems/
Authorization: Bearer eyJ...(토큰)...

백엔드 → 프론트엔드
-------------------
{
  "success": true,
  "data": [
    {
      "id": 1,
      "title": "두 수의 합",
      "level": 1,
      "description": "두 수를 더하세요"
    },
    {
      "id": 2,
      "title": "배열의 최대값",
      "level": 2,
      "description": "배열에서 가장 큰 수를 찾으세요"
    }
  ]
}
```

#### 3. 코드 실행 API

```
프론트엔드 → 백엔드
-------------------
POST /api/v1/coding-test/execute/
{
  "problem_id": 1,
  "code": "a, b = map(int, input().split())\nprint(a + b)"
}

백엔드 → 프론트엔드
-------------------
{
  "success": true,
  "data": {
    "results": [
      {
        "test_case": 1,
        "input": "1 2",
        "expected": "3",
        "actual": "3",
        "passed": true
      },
      {
        "test_case": 2,
        "input": "5 7",
        "expected": "12",
        "actual": "12",
        "passed": true
      }
    ],
    "all_passed": true
  }
}
```

#### 4. 힌트 요청 API

```
프론트엔드 → 백엔드
-------------------
POST /api/v1/coding-test/hints/
{
  "problem_id": 1,
  "code": "print(a + b)",  // 사용자가 쓴 코드
  "hint_level": 1          // 1=작은힌트, 2=중간, 3=큰힌트
}

백엔드 → 프론트엔드
-------------------
{
  "success": true,
  "data": {
    "hint": "입력을 받는 부분이 빠져있어요. input() 함수를 사용해보세요.",
    "hint_level": 1
  }
}
```

### 전체 API 목록

#### 인증 (Authentication) API

| 메서드 | 주소 | 설명 |
|--------|------|------|
| POST | `/api/v1/auth/signup/` | 회원가입 |
| POST | `/api/v1/auth/login/` | 로그인 |
| POST | `/api/v1/auth/logout/` | 로그아웃 |
| POST | `/api/v1/auth/refresh/` | 토큰 갱신 |
| GET | `/api/v1/auth/user/` | 내 정보 보기 |
| PUT | `/api/v1/auth/user/update/` | 정보 수정 |
| POST | `/api/v1/auth/user/password/` | 비밀번호 변경 |
| DELETE | `/api/v1/auth/user/delete/` | 계정 삭제 |

#### 코딩 테스트 API

| 메서드 | 주소 | 설명 |
|--------|------|------|
| GET | `/api/v1/coding-test/problems/` | 문제 목록 |
| GET | `/api/v1/coding-test/problems/{id}/` | 문제 상세 |
| POST | `/api/v1/coding-test/execute/` | 코드 실행 |
| POST | `/api/v1/coding-test/submit/` | 코드 제출 |
| POST | `/api/v1/coding-test/hints/` | 힌트 요청 |
| GET | `/api/v1/coding-test/bookmarks/` | 북마크 목록 |
| POST | `/api/v1/coding-test/bookmarks/toggle/` | 북마크 추가/제거 |
| GET | `/api/v1/coding-test/submissions/` | 제출 기록 |
| GET | `/api/v1/coding-test/badges/` | 배지 목록 |
| GET | `/api/v1/coding-test/user-badges/` | 내 배지 |

### JWT 토큰 이해하기

**JWT**는 **로그인 증명서** 같은 거예요.

```
1. 로그인 성공
   → 백엔드가 토큰 2개를 줌
   → access 토큰 (1시간)
   → refresh 토큰 (7일)

2. API 요청할 때
   → access 토큰을 같이 보냄
   → 백엔드가 "아, 로그인한 사람이구나" 확인

3. access 토큰 만료
   → refresh 토큰으로 새 access 토큰 받음
   → 자동으로 처리됨
```

---

## 7. 데이터베이스 이해하기

### 데이터베이스란?

**데이터베이스**는 정보를 저장하는 창고예요.

- 회원 정보
- 문제 정보
- 제출 기록
- 점수

### 사용하는 데이터베이스

- **MySQL 8.0** - 주로 사용
- **SQLite** - 개발할 때 간단히 사용

### 테이블 (모델) 목록

| 테이블 | 설명 | 주요 필드 |
|--------|------|-----------|
| **User** | 사용자 | email, name, role, rating |
| **Problem** | 문제 | title, level, description |
| **Submission** | 제출 기록 | user, problem, code, result |
| **HintRequest** | 힌트 기록 | user, problem, hint_level |
| **Bookmark** | 북마크 | user, problem |
| **Badge** | 배지 정의 | name, description, condition |
| **UserBadge** | 획득한 배지 | user, badge, earned_at |
| **ProblemSession** | 문제 풀이 세션 | user, problem, time_spent |

### 관계 이해하기

```
User (사용자)
  │
  ├── Submission (제출) ─── Problem (문제)
  │
  ├── Bookmark (북마크) ─── Problem
  │
  ├── HintRequest (힌트) ── Problem
  │
  └── UserBadge (배지) ──── Badge
```

**쉽게 설명하면:**
- 한 사용자가 여러 문제를 풀 수 있어요
- 한 문제를 여러 사용자가 풀 수 있어요
- 사용자는 여러 배지를 가질 수 있어요

---

## 8. 프로젝트 처음부터 설치하기

### 필요한 것들

1. **Docker Desktop** - 모든 것을 한번에 실행
2. **Git** - 코드 받기
3. **VS Code** (선택) - 코드 편집

### 설치 순서 (초간단!)

#### 1단계: Docker 설치

1. [Docker Desktop](https://www.docker.com/products/docker-desktop/) 다운로드
2. 설치 후 실행
3. 컴퓨터 재시작

#### 2단계: 프로젝트 받기

```bash
# 프로젝트 폴더로 이동
cd C:\Users\playdata2\Desktop\playdata\Workspace\팀프로젝트5

# 이미 있다면 건너뛰기
# 없다면 git clone으로 받기
```

#### 3단계: 환경 변수 설정

```bash
# .env.example을 복사해서 .env 만들기
copy 5th-project_mvp\.env.example 5th-project_mvp\.env
```

`.env` 파일을 열어서 비밀번호 설정:

```env
# Django 설정
DJANGO_SECRET_KEY=아무거나-긴-문자열-적기
DEBUG=True

# 데이터베이스 설정
DB_NAME=hint_system
DB_USER=hint_user
DB_PASSWORD=여기에비밀번호
DB_HOST=db
DB_PORT=3306
```

#### 4단계: Docker로 실행

```bash
# 프로젝트 폴더로 이동
cd 5th-project_mvp

# Docker 실행 (처음에는 5-10분 걸림)
docker-compose up --build
```

**성공하면 이런 메시지가 보여요:**
```
backend_1   | Starting development server at http://0.0.0.0:8000/
frontend_1  |   VITE v5.0.11  ready in 500 ms
frontend_1  |   ➜  Local:   http://localhost:3000/
```

#### 5단계: 웹사이트 열기

브라우저에서:
- **프론트엔드**: http://localhost:3000
- **백엔드 API**: http://localhost:8000/api/v1/
- **관리자 페이지**: http://localhost:8000/admin/

### 개발 환경 설정 (Docker 없이)

Docker 없이 직접 실행하고 싶다면:

#### 백엔드 설정

```bash
# 1. 백엔드 폴더로 이동
cd 5th-project_mvp/backend

# 2. 가상환경 만들기
python -m venv venv

# 3. 가상환경 활성화 (Windows)
venv\Scripts\activate

# 4. 필요한 도구 설치
pip install -r requirements.txt

# 5. 데이터베이스 설정
python manage.py migrate

# 6. 관리자 계정 만들기
python manage.py createsuperuser

# 7. 서버 실행
python manage.py runserver
```

#### 프론트엔드 설정

```bash
# 1. 프론트엔드 폴더로 이동
cd 5th-project_mvp/frontend

# 2. 필요한 도구 설치
npm install

# 3. 개발 서버 실행
npm run dev
```

### 문제 해결

#### "포트가 이미 사용 중"이라고 나오면

```bash
# Windows에서 포트 사용 중인 프로세스 찾기
netstat -ano | findstr :3000
netstat -ano | findstr :8000

# 해당 프로세스 종료
taskkill /PID [프로세스번호] /F
```

#### Docker가 안 되면

1. Docker Desktop이 실행 중인지 확인
2. 컴퓨터 재시작
3. `docker-compose down` 후 다시 `docker-compose up --build`

---

## 9. 각 기능별 상세 설명

### 1. 회원가입/로그인 기능

#### 작동 순서

```
[회원가입]
1. 사용자가 이메일, 비밀번호, 이름 입력
2. 프론트엔드가 백엔드에 POST 요청
3. 백엔드가 이메일 중복 확인
4. 이메일 인증 코드 발송
5. 사용자가 코드 입력
6. 회원가입 완료!

[로그인]
1. 사용자가 이메일, 비밀번호 입력
2. 백엔드가 확인
3. 맞으면 JWT 토큰 발급
4. 프론트엔드가 토큰 저장
5. 로그인 상태 유지!
```

#### 관련 파일

- 프론트엔드: `pages/Login/`, `pages/Signup/`
- 백엔드: `apps/authentication/`

### 2. 문제 풀기 기능

#### 작동 순서

```
1. 문제 목록 보기
   - GET /problems/ → 문제 리스트 받음

2. 문제 선택
   - GET /problems/{id}/ → 문제 상세 정보

3. 코드 작성
   - Monaco Editor에서 코드 작성

4. 코드 실행
   - POST /execute/ → 테스트 케이스로 실행
   - 결과: 성공/실패, 출력값

5. 코드 제출
   - POST /submit/ → 최종 제출
   - 점수 획득!
```

#### 관련 파일

- 프론트엔드: `pages/Problems/`, `pages/CodingTest/`
- 백엔드: `apps/coding_test/views.py`, `code_executor.py`

### 3. 힌트 기능

#### 힌트 레벨

| 레벨 | 이름 | 설명 |
|------|------|------|
| 1 | 작은 힌트 | 방향만 알려줌 |
| 2 | 중간 힌트 | 구체적인 조언 |
| 3 | 큰 힌트 | 거의 답에 가까움 |

#### 작동 순서

```
1. 사용자가 힌트 버튼 클릭
2. 현재 코드와 힌트 레벨을 백엔드에 전송
3. AI 모델이 코드 분석
4. 적절한 힌트 생성
5. 힌트를 화면에 표시
```

#### 관련 파일

- 백엔드: `apps/coding_test/hint_api.py`

### 4. 배지 시스템

#### 배지 종류 예시

| 배지 | 조건 |
|------|------|
| 첫 발자국 | 첫 문제 풀기 |
| 성실왕 | 연속 7일 문제 풀기 |
| 레벨업 | 레벨 2 문제 5개 풀기 |
| 만점왕 | 문제 10개 만점 |
| 힌트 마스터 | 힌트 없이 10문제 |

#### 관련 파일

- 백엔드: `apps/coding_test/badge_logic.py`

### 5. 마이페이지

#### 볼 수 있는 정보

- 내 점수
- 푼 문제 수
- 획득한 배지
- 제출 기록
- 북마크한 문제

#### 관련 파일

- 프론트엔드: `pages/MyPage/`
- 백엔드: `apps/mypage/views.py`

---

## 10. 자주 묻는 질문 (FAQ)

### Q1: React와 Django가 뭐예요?

**React**는 화면을 만드는 도구예요. 버튼, 입력창, 예쁜 디자인을 만들어요.

**Django**는 데이터를 처리하는 도구예요. 로그인 확인, 점수 계산, 데이터 저장을 해요.

### Q2: API가 뭐예요?

**API**는 프론트엔드와 백엔드가 대화하는 방법이에요.

마치 식당에서 메뉴 주문하는 것처럼:
- 손님이 주문 (요청)
- 주방이 요리 (처리)
- 음식 나옴 (응답)

### Q3: JWT 토큰이 뭐예요?

**JWT 토큰**은 로그인 증명서예요.

신분증처럼, 이걸 보여주면 "아, 로그인한 사람이구나" 하고 알 수 있어요.

### Q4: Docker가 뭐예요?

**Docker**는 프로젝트를 쉽게 실행하는 도구예요.

원래는 Python, MySQL, Node.js 등을 각각 설치해야 하는데,
Docker가 있으면 한 번에 다 설치하고 실행해요!

### Q5: 왜 프론트엔드와 백엔드를 나눠요?

**역할 분담** 때문이에요!

- 프론트엔드 개발자: 디자인, 버튼, 화면
- 백엔드 개발자: 데이터, 보안, 로직

이렇게 나누면 각자 전문 분야에 집중할 수 있어요.

### Q6: 데이터베이스는 왜 필요해요?

컴퓨터를 끄면 모든 정보가 사라지잖아요?

**데이터베이스**는 정보를 영구적으로 저장해요.
회원 정보, 점수, 문제 등을 안전하게 보관해요.

### Q7: 프로젝트를 수정하려면 어디를 고쳐야 해요?

| 수정하고 싶은 것 | 수정할 위치 |
|------------------|-------------|
| 화면 디자인 | `frontend/src/pages/` |
| 버튼 동작 | `frontend/src/pages/` (해당 페이지) |
| API 추가 | `backend/apps/` (해당 앱) |
| 데이터 구조 | `backend/apps/*/models.py` |
| 주소 변경 | `backend/apps/*/urls.py` |

### Q8: 에러가 나면 어떻게 해요?

1. **에러 메시지 읽기** - 어디서 문제인지 알려줘요
2. **콘솔 확인** - 브라우저 F12 → Console
3. **서버 로그 확인** - Docker 로그 보기
4. **구글 검색** - 에러 메시지 복사해서 검색

---

## 마무리

축하합니다! 이 문서를 다 읽었다면 이 프로젝트의 구조를 완전히 이해한 거예요!

### 요약

1. **프론트엔드** (React) - 사용자가 보는 화면
2. **백엔드** (Django) - 데이터 처리
3. **API** - 둘 사이의 대화 방법
4. **데이터베이스** (MySQL) - 정보 저장
5. **Docker** - 모든 것을 한번에 실행

### 다음 단계

1. Docker로 프로젝트 실행해보기
2. 각 페이지 둘러보기
3. 간단한 수정 시도해보기
4. 새로운 기능 추가해보기

화이팅! 🚀

---

*이 문서는 5th-project_mvp 프로젝트를 위해 작성되었습니다.*
*질문이 있으면 팀원들에게 물어보세요!*
